<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>::<a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">MultiblockGriddingAlgorithm</a></div>
<h1>SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::mesh::MultiblockGriddingAlgorithm" --><!-- doxytag: inherits="SAMRAI::mesh::BaseGriddingAlgorithm" -->Class MultiblockGriddingAlgorithm&lt;DIM&gt; manages gridding operations in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> for problems on multiblock domains. Specifically, it provides AMR patch hierarchy generation and regridding routines that may be used with a variety of AMR solution algorithms and application-specific numerical routines.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/mesh/multiblock/MultiblockGriddingAlgorithm.h&gt;</code>
<p>
Inheritance diagram for SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt;:<p><center><img src="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm__inherit__graph.png" border="0" usemap="#SAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm_3_01DIM_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="SAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm_3_01DIM_01_4__inherit__map">
<area href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html" shape="rect" coords="22,157,326,181" alt="">
<area href="classSAMRAI_1_1tbox_1_1Serializable.html" shape="rect" coords="83,83,264,107" alt="">
<area href="classtbox_1_1DescribedClass.html" shape="rect" coords="116,8,231,32" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#cbccc01ce67760f1262885a2500bce9e">MultiblockGriddingAlgorithm</a> (const std::string &amp;object_name, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; input_db, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockPatchHierarchy.html">hier::MultiblockPatchHierarchy</a>&lt; DIM &gt; &gt; multiblock, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">mesh::TagAndInitializeStrategy</a>&lt; DIM &gt; &gt; level_strategy, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1BoxGeneratorStrategy.html">mesh::BoxGeneratorStrategy</a>&lt; DIM &gt; &gt; generator, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">mesh::LoadBalanceStrategy</a>&lt; DIM &gt; &gt; balancer, <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingTagger.html">MultiblockGriddingTagger</a>&lt; DIM &gt; *mb_tagger_strategy=(<a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingTagger.html">MultiblockGriddingTagger</a>&lt; DIM &gt; *)(0), bool register_for_restart=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct the multiblock gridding algorithm.  <a href="#cbccc01ce67760f1262885a2500bce9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#6a227da578f66a7b81f456b9719a588b">~MultiblockGriddingAlgorithm</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#0982d392d7673380d0486ec955279e7d">makeCoarsestLevel</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; multiblock, const double level_time, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;override_boxes=0, const <a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;override_mapping=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create level 0 for a hierarchy.  <a href="#0982d392d7673380d0486ec955279e7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#adab6c6ad06ba6006087ff024606e1b8">makeFinerLevel</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; multiblock, const double level_time, const bool initial_time, const int tag_buffer, const double regrid_start_time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create new finer level in hierarchy.  <a href="#adab6c6ad06ba6006087ff024606e1b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#bd7930b5c836bc43bd0628c586419552">regridAllFinerLevels</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; multiblock, const int level_number, const double regrid_time, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; int &gt; &amp;tag_buffer, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt; regrid_start_time=<a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt;(), const bool level_is_coarsest_to_sync=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Regrid all levels finer that a specified level.  <a href="#bd7930b5c836bc43bd0628c586419552"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#a15cb0fbd0a44312306d482871335089">errorEstimationUsesTimeIntegration</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if error estimation process uses time integration; otherwise, return false.  <a href="#a15cb0fbd0a44312306d482871335089"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#2e47e19f09e210655bcf9dbaadd019cc">getErrorCoarsenRatio</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the error coarsen ratio.  <a href="#2e47e19f09e210655bcf9dbaadd019cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#a100eb14da651d3d39476bbc6eb8b89d">levelCanBeRefined</a> (const int level_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if level associated with the specified level number can * be refined; i.e., the level number is less than that of the finest level allowed in the hierarchy. Otherwise, false is returned.  <a href="#a100eb14da651d3d39476bbc6eb8b89d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">mesh::TagAndInitializeStrategy</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#96a6e57d1c5dbb3fe4a27612a02d72b3">getTagAndInitializeStrategy</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return pointer to level gridding strategy data member.  <a href="#96a6e57d1c5dbb3fe4a27612a02d72b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#b0dcd4f2cc74c411c605be9e24a44a0a">getMaxLevels</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum number of levels allowed in hierarchy.  <a href="#b0dcd4f2cc74c411c605be9e24a44a0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;<br>
 DIM &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#f535f3c9819d8dfb6e7f9c7e31cc3218">getRatioToCoarserLevel</a> (int level_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return const reference to ratio between specified level and next coarser.  <a href="#f535f3c9819d8dfb6e7f9c7e31cc3218"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#cce894dbad4f8372816dafadbaa9b63a">getEfficiencyTolerance</a> (int level_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return efficiency tolerance for clustering tags on level.  <a href="#cce894dbad4f8372816dafadbaa9b63a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#1ca17f262ecd3aaaa5973c70c882038c">getCombineEfficiency</a> (int level_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return combine efficiency for clustering tags on level.  <a href="#1ca17f262ecd3aaaa5973c70c882038c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#349f11f113f26130c4a718794dd69742">getProperNestingBuffer</a> (int level_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return proper nesting buffer width for level.  <a href="#349f11f113f26130c4a718794dd69742"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;<br>
 DIM &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#ea2335f7be21120b8890c11993958fe2">getSmallestPatchSize</a> (const int level_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return const reference to smallest patch size for level.  <a href="#ea2335f7be21120b8890c11993958fe2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;<br>
 DIM &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#81905dbfe732e389cd4ada2f9dae77c6">getLargestPatchSize</a> (const int level_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return const reference to largest patch size for level.  <a href="#81905dbfe732e389cd4ada2f9dae77c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#502dc58d8b870cf424f82fa678e70b66">putToDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; db)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write object state out to the given database.  <a href="#502dc58d8b870cf424f82fa678e70b66"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt;</h3>

Class MultiblockGriddingAlgorithm&lt;DIM&gt; manages gridding operations in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> for problems on multiblock domains. Specifically, it provides AMR patch hierarchy generation and regridding routines that may be used with a variety of AMR solution algorithms and application-specific numerical routines. 
<p>
The three main functions provided by this class are:<ul>
<li><b><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#0982d392d7673380d0486ec955279e7d">makeCoarsestLevel()</a></b> This routine constructs or repartitions the coarsest hierarchy level (level 0).</li></ul>
<p>
<ul>
<li><b><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#adab6c6ad06ba6006087ff024606e1b8">makeFinerLevel()</a></b> This routine will attempt to add a new finest level to the hierarchy if the maximum number of levels allows it and cells on the current finest level are selected for refinement.</li></ul>
<p>
<ul>
<li><b><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#bd7930b5c836bc43bd0628c586419552">regridAllFinerLevels()</a></b> This routine will regrid all levels finer than some specified level based on cells that are selected for refinement on each level finer than and including the given level. This routine may add a new finest hierarchy level if the maximum number of levels allows it and cells on the current finest level are selected for refinement. Levels may also be removed from the hierarchy if no cells are tagged.</li></ul>
<p>
These basic AMR operations are used to generate of individual levels in the AMR patch hierarchy at the beginning of a simulation, and regridding collections of levels during an adaptive calculation. More details are found in the comments accompanying each member function below.<p>
The operations that identify cells for refinement on a single level and initialize data and solution algorithm-specific information that depend on the AMR hierarchy configuration are provided by the data member of type mesh::TagAndInitializeStrategy&lt;DIM&gt;. Operations that cluster tagged cells into a collection of box regions are provided by the mesh::BoxGeneratorStrategy&lt;DIM&gt; data member. Routines that load balancing patches on each level are provided by the mesh::LoadBalanceStrategy&lt;DIM&gt; data member. The collaboration between this class and each of those objects follows the Strategy design pattern. Each instantiation of this gridding algorithm class is configured with concrete implementations of those routines by passing appropriate objects into this constructor.<p>
Initialization of an MultiblockGriddingAlgorithm&lt;DIM&gt; object is performed via a combination of default parameters and values read from input. Data read from input is summarized as follows:<p>
Required input keys and data types:<p>
<ul>
<li><b>max_levels</b> Integer value specifying maximum number of levels allowed in the AMR patch hierarchy.</li></ul>
<p>
<ul>
<li><b>largest_patch_size</b> An array of integer vectors (each has length = DIM) that specify the dimensions of largest patch allowed on each level in the hierarchy. The index of the vector in the array corresponds to the number of the level to which it applies. If more values are given than the maximum number of levels, extra entries will be ignored. If fewer values are given, then the last element in the array will be used on each level without a specified input value. For example, if only a single value is specified, then that value will be used on all levels. See sample input below for more information.</li></ul>
<p>
<ul>
<li><b>ratio_to_coarser</b> Set of max_levels - 1 integer vectors, each of which indicates the ratio of the index space of a patch level to that of the next coarser level. The input for each level must correspond to the format ``level_n = vector'', where n is the level number and each vector must have length DIM. See sample input below.</li></ul>
<p>
Optional input keys, data types, and defaults:<p>
<ul>
<li><b>efficiency_tolerance</b> An array of double values, each of which specifies the minimum percentage of tagged cells in each box used to construct patches on a finer level. If the ratio of the number of tagged cells in a box to total cells in the box is below the tolerance value, the box may be split into smaller boxes and pieces removed until the ratio becomes greater than or equal to the the tolerance. The index of the value in the array corresponds to the number of the level to which the tolerance value applies. If more values are given than max_levels - 1 , extra entries will be ignored. If fewer values are given, then the last element in the array will be used on each level without a specified input value. For example, if only a single value is specified, then that value will be used on all levels. If no input values are given, a default of 0.8 is used. See sample input below for input file format.</li></ul>
<p>
<ul>
<li><b>combine_efficiency</b> An array of double values, each of which serves as a threshold for the ratio of the total number of cells in two boxes into which a box may be split and the number of cells in the original box. If that ratio is greater than combine efficiency, the box will not be split. This avoids splitting up portions of the domain into potentially more costly smaller pieces if there appears to be little to be gained by splitting up the boxes. The index of the value in the array corresponds to the number of the level to which the efficiency value applies. If more values are given than max_levels - 1 , extra entries will be ignored. If fewer values are given, then the last element in the array will be used on each level without a specified input value. For example, if only a single value is specified, then that value will be used on all levels. If no input values are given, a default of 0.8 is used. See sample input below for input file format.</li></ul>
<p>
<ul>
<li><b>smallest_patch_size</b> An array of integer vectors (each has length = DIM) that specify the dimensions of smallest patch allowed on each level in the hierarchy. The smallest patch allowed must be at least as great as the maximum ghost cell width for all variables in the problem. If some smaller patch size is given in input, then it will be overridden with a value consistent with the maximum ghost width. The index of the vector in the array corresponds to the number of the level to which it applies. If more values are given than the maximum number of levels, extra entries will be ignored. If fewer values are given, then the last element in the array will be used on each level without a specified input value. For example, if only a single value is specified, then that value will be used on all levels. If no input is given, a default of the maximum ghost cell width over all variables is used. See sample input below for input file format.</li></ul>
<p>
<ul>
<li><b>proper_nesting_buffer</b> An integer array specifying the number of coarse cells by which the next finer level is nested within the interior of the domain of the next coarser level when creating a new level. If more values are given than max_levels - 1 , extra entries will be ignored. If fewer values are given, then the last element in the array will be used on each level without a specified input value. For example, if only a single value is specified, then that value will be used on all levels. If no values are given, a default of 1 is used for each nesting buffer value. See sample input below for input file format.</li></ul>
<p>
<ul>
<li><b>allow_patches_smaller_than_ghostwidth</b> In order to enforce minimum patch size restrictions, boxes may be grown in gridding operations. This may in turn lead to overlaps created between boxes. If overlaps are undesirable and you are willing to relax the minimum size constraints, set this parameter true. By default, it is false.</li></ul>
<p>
<ul>
<li><b>write_regrid_boxes</b> Output sequence of refine boxes to file.</li></ul>
<p>
<ul>
<li><b>read_regrid_boxes</b> Read sequence of refine boxes from file.</li></ul>
<p>
<ul>
<li><b>regrid_boxes_filename</b> Filename used for writing or reading refine boxes. The read and write boxes option is usable only under very specific circumstances. Please contact the <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> developers at samrai@llnl.gov) for more information.</li></ul>
<p>
Note that when continuing from restart, the input values in the input file override all values read in from the restart database.<p>
The following represents sample input data for a three-dimensional problem:<p>
<div class="fragment"><pre class="fragment">
 *
 *    // Required input: maximum bumber of levels in patch hierarchy
 *    max_levels = 4
 *
 *    // Required input: vector ratio between each finer level and next coarser
 *    ratio_to_coarser {
 *       level_1 = 2, 2, 2
 *       level_2 = 2, 2, 2
 *       level_3 = 4, 4, 4
 *    }
 *
 *    // Required input: int vector for largest patch size on each level.
 *    largest_patch_size {
 *       level_0 = 40, 40, 40
 *       level_1 = 30, 30, 30
 *       // all finer levels will use same values as level_1...
 *    }
 *
 *    // Optional input:  buffer of one cell used on each level
 *    proper_nesting_buffer = 1
 *    grow_after_nesting = FALSE
 *
 *    // Optional input: int vector for smallest patch size on each level.
 *    smallest_patch_size {
 *       level_0 = 16, 16, 16
 *       // all finer levels will use same values as level_0...
 *    }
 *
 *    // Optional input: different efficiency tolerance for each coarser level
 *    efficiency_tolerance = 0.80e0, 0.85e0, 0.90e0
 *
 *    // Optional input: combine efficiency is same for all levels.
 *    combine_efficiency = 0.95e0
 *
 *    write_regrid_boxes = TRUE
 *    regrid_boxes_filename = "regrid_boxes_32proc"
 *
 * </pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a> <p>
<a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">mesh::TagAndInitializeStrategy</a> <p>
<a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">mesh::LoadBalanceStrategy</a> <p>
<a class="el" href="classSAMRAI_1_1mesh_1_1BoxGeneratorStrategy.html">mesh::BoxGeneratorStrategy</a> <p>
<a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingTagger.html">mesh::MultiblockGriddingTagger</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="cbccc01ce67760f1262885a2500bce9e"></a><!-- doxytag: member="SAMRAI::mesh::MultiblockGriddingAlgorithm::MultiblockGriddingAlgorithm" ref="cbccc01ce67760f1262885a2500bce9e" args="(const std::string &amp;object_name, tbox::Pointer&lt; tbox::Database &gt; input_db, tbox::Pointer&lt; hier::MultiblockPatchHierarchy&lt; DIM &gt; &gt; multiblock, tbox::Pointer&lt; mesh::TagAndInitializeStrategy&lt; DIM &gt; &gt; level_strategy, tbox::Pointer&lt; mesh::BoxGeneratorStrategy&lt; DIM &gt; &gt; generator, tbox::Pointer&lt; mesh::LoadBalanceStrategy&lt; DIM &gt; &gt; balancer, MultiblockGriddingTagger&lt; DIM &gt; *mb_tagger_strategy=(MultiblockGriddingTagger&lt; DIM &gt; *)(0), bool register_for_restart=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">MultiblockGriddingAlgorithm</a>           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockPatchHierarchy.html">hier::MultiblockPatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>multiblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">mesh::TagAndInitializeStrategy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1BoxGeneratorStrategy.html">mesh::BoxGeneratorStrategy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">mesh::LoadBalanceStrategy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>balancer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingTagger.html">MultiblockGriddingTagger</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>mb_tagger_strategy</em> = <code>(<a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingTagger.html">MultiblockGriddingTagger</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>register_for_restart</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct the multiblock gridding algorithm. 
<p>
The constructor for MultiblockGriddingAlgorithm&lt;DIM&gt; configures the gridding algorithm with the concrete strategy objects in the argument list. Gridding parameters are initialized from values provided in the specified input and in the restart database corresponding to the specified object_name argument. The constructor also registers this object for restart using the specified object name when the boolean argument is true. Whether object will write its state to restart files during program execution is determined by this argument. Note that it has a default state of true.<p>
If assertion checking is turned on, an unrecoverable assertion will result if any of the input database, level strategy, box generator, or load balancer pointers is null. Exceptions may also be thrown if any checks for consistency among input parameters fail.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object_name</em>&nbsp;</td><td>Name of object, to be used by RestartManager </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_db</em>&nbsp;</td><td>Input database </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>multiblock</em>&nbsp;</td><td>Multiblock patch hierarchy for the application </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_strategy</em>&nbsp;</td><td>Pointer to object that manages cell tagging </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>generator</em>&nbsp;</td><td>Pointer to object that generates boxes for a level </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>balancer</em>&nbsp;</td><td>Pointer to load-balancing object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mb_tagger_strategy</em>&nbsp;</td><td>Optional pointer to multiblock tagging strategy used to communicate tags across block boundaries. If not provided, a default will be used. Should be NULL unless user has implemented a class inheriting from <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingTagger.html">MultiblockGriddingTagger</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>register_for_restart</em>&nbsp;</td><td>Optional boolean flag indicating whether object will be written to restart files. The default is true indicating that the object will be written to resatrt files. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6a227da578f66a7b81f456b9719a588b"></a><!-- doxytag: member="SAMRAI::mesh::MultiblockGriddingAlgorithm::~MultiblockGriddingAlgorithm" ref="6a227da578f66a7b81f456b9719a588b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">MultiblockGriddingAlgorithm</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual destructor for MultiblockGriddingAlgorithm&lt;DIM&gt;. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="0982d392d7673380d0486ec955279e7d"></a><!-- doxytag: member="SAMRAI::mesh::MultiblockGriddingAlgorithm::makeCoarsestLevel" ref="0982d392d7673380d0486ec955279e7d" args="(tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; multiblock, const double level_time, const hier::BoxArray&lt; DIM &gt; &amp;override_boxes=0, const hier::ProcessorMapping &amp;override_mapping=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm</a>&lt; DIM &gt;::makeCoarsestLevel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>multiblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>level_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>override_boxes</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>override_mapping</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create level 0 for a hierarchy. 
<p>
This routine will attempt to construct the coarsest level in an AMR multiblock patch hierarchy (i.e., level 0). If level 0 does not already exist, then the domain specification is checked against the constraints of the grid generation procedures. The level gridding strategy data member defines these constraints. Recall that the domain specification is maintained by the grid geometry object associated with the hierarchy. Generally, an unrecoverable exception will result if the constraints are not satisfied.<p>
If level 0 already exists in the hierarchy, then the routine will generate a new level by re-applying the load balancing procedure to the existing level. Data will be moved from the old level to the new level and the pre-existing level 0 will be discarded. Note that this routine is different than the routine <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#adab6c6ad06ba6006087ff024606e1b8">makeFinerLevel()</a> below, which is used to construct levels 1 and finer. In particular, this routine does not select cells for refinement, whereas the other routine does.<p>
Important note: If assertion checking is turned on, then an unrecoverable assertion will result if either the patch hierarchy or its grid geometry is NULL.<p>
The two optional arguments exist only for compatibility with the base class <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">BaseGriddingAlgorithm</a>. If they are used in this function, they will be ignored.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiblock</em>&nbsp;</td><td>Multiblock patch hierarchy on which level is created </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_time</em>&nbsp;</td><td>Simulation time for data on the new level </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>override_boxes</em>&nbsp;</td><td>optional argument that will be ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>override_mapping</em>&nbsp;</td><td>optional argument that will be ignored </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#38ea13b0d56ed4e0a80f37eb92957eff">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="adab6c6ad06ba6006087ff024606e1b8"></a><!-- doxytag: member="SAMRAI::mesh::MultiblockGriddingAlgorithm::makeFinerLevel" ref="adab6c6ad06ba6006087ff024606e1b8" args="(tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; multiblock, const double level_time, const bool initial_time, const int tag_buffer, const double regrid_start_time)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm</a>&lt; DIM &gt;::makeFinerLevel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>multiblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>level_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_start_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create new finer level in hierarchy. 
<p>
This routine attempts to create a new level in an AMR patch hierarchy finer than the finest level currently residing in the hierarchy. It will select cells for refinement on the finest level and construct a new finest level, if necessary. If no cells are selected for refinement, no new level will be added to the hierarchy. The boolean argument initial_time indicates whether the routine is called at the initial simulation time. If true, this routine is used to build individual levels during the construction of the AMR hierarchy at the initial simulation time. If false, the routine is being used to add new levels to the hierarchy at some later point. In either case, the time value is the current simulation time. Note that this routine cannot be used to construct the coarsest level in the hierarchy (i.e., level 0). The routine <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#0982d392d7673380d0486ec955279e7d">makeCoarsestLevel()</a> above must be used for that purpose.<p>
The tag buffer indicates the number of cells by which cells selected for refinement will be buffered before new finer level boxes are constructed. The buffer is important to keep phenomena of interest on refined regions of the mesh until adaptive regridding occurs next. Thus, the buffer size should take into account how the simulation may evolve before regridding occurs (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., number of timesteps taken).<p>
Important note: If assertion checking is activated, several checks are applied to the function arguments. If any check is violated, an unrecoverable assertion will result. In particular, the hierarchy pointer must be non-NULL and the given level number must match that of the finest level currently residing in the hierarchy. Also, the the tag buffer must be positive.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiblock</em>&nbsp;</td><td>Multiblock patch hierarchy on which level is created </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_time</em>&nbsp;</td><td>Simulation time at which this level is created </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>initial_time</em>&nbsp;</td><td>Boolean flag that should be true only if level_time is the initial time of the simulation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_buffer</em>&nbsp;</td><td>Number of cells to buffer cells tagged for refinement </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regrid_start_time</em>&nbsp;</td><td>Time of the previous regrid </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#6e2fd0ed01be50969e4451b39cf5a9c5">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="bd7930b5c836bc43bd0628c586419552"></a><!-- doxytag: member="SAMRAI::mesh::MultiblockGriddingAlgorithm::regridAllFinerLevels" ref="bd7930b5c836bc43bd0628c586419552" args="(tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; multiblock, const int level_number, const double regrid_time, const tbox::Array&lt; int &gt; &amp;tag_buffer, tbox::Array&lt; double &gt; regrid_start_time=tbox::Array&lt; double &gt;(), const bool level_is_coarsest_to_sync=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm</a>&lt; DIM &gt;::regridAllFinerLevels           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>multiblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tag_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt;&nbsp;</td>
          <td class="paramname"> <em>regrid_start_time</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt;&nbsp;double&nbsp;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>level_is_coarsest_to_sync</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Regrid all levels finer that a specified level. 
<p>
This routine attempts to reconfigure the patches on each level in an AMR patch hierarchy which is finer than the specified level. The given level number is that of the coarsest level on which cells will be will be selected for refinement. In other words, that level is the finest level that will not be subject to a change in its patch configuration during the regridding process. Generally, this routine should be used to alter a pre-existing AMR patch hierarchy based on the need to adapt the computational mesh around some phenomenon of interest. The routine <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#adab6c6ad06ba6006087ff024606e1b8">makeFinerLevel()</a> above should be used to construct an initial hierarchy configuration or to add more than one new level into the hierarchy. Also, this routine will not reconfigure the patches on level 0 (i.e., the coarsest in any hierarchy). The routine <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#0982d392d7673380d0486ec955279e7d">makeCoarsestLevel()</a> above is provided for that purpose.<p>
Note that the current algorithm permits at most one new finest level to be added to the hierarchy with each invocation of the regridding process. This constraint, though seemingly restrictive makes the process of maintaining properly nested levels much easier.<p>
The tag buffer array indicates the number of cells by which cells selected for refinement on a level will be buffered before new finer level boxes are constructed. The buffer is important to keep phenomena of interest on refined regions of the mesh until adaptive regridding occurs next. Thus, the buffer size should take into account how the simulation may evolve before regridding occurs (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., number of timesteps taken on each level).<p>
The boolean argument level_is_coarsest_to_sync is used for regridding in time-dependent problems. When true, it indicates that the specified level is the coarsest level to synchronize at the current regrid time before this regridding method is called. This is a pretty idiosyncratic argument but allows some flexibility in the way memory is managed during time-dependent regridding operations.<p>
Important note: If assertion checking is activated, several checks are applied to the functions arguments. If any check is violated, an unrecoverable assertion will result. In particular, the hierarchy pointer must be non-NULL and the given level number must match that of of some level in the hierarchy. Also, the tag buffer array must contain a positive value for each level in the hierarchy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiblock</em>&nbsp;</td><td>Multiblock patch hierarchy where the levels exist </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_number</em>&nbsp;</td><td>Level number of a coarse level for which all finer levels will be regridded </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regrid_time</em>&nbsp;</td><td>Simulation time when regridding occurs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_buffer</em>&nbsp;</td><td>Array that stores the tag buffer around tagged cells that will be applied at each level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regrid_start_time</em>&nbsp;</td><td>Array that stores the time that each level of the hierarchy was last regridded </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_is_coarsest_to_sync</em>&nbsp;</td><td>See comments above </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#27aa93c208000bfbb871c02f21b918ae">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="a15cb0fbd0a44312306d482871335089"></a><!-- doxytag: member="SAMRAI::mesh::MultiblockGriddingAlgorithm::errorEstimationUsesTimeIntegration" ref="a15cb0fbd0a44312306d482871335089" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm</a>&lt; DIM &gt;::errorEstimationUsesTimeIntegration           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if error estimation process uses time integration; otherwise, return false. 
<p>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#1a10894c9e4f96e2ac6d8b9cca1efcdd">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="2e47e19f09e210655bcf9dbaadd019cc"></a><!-- doxytag: member="SAMRAI::mesh::MultiblockGriddingAlgorithm::getErrorCoarsenRatio" ref="2e47e19f09e210655bcf9dbaadd019cc" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm</a>&lt; DIM &gt;::getErrorCoarsenRatio           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the error coarsen ratio. 
<p>
This is needed for cases where an error estimation schem uses time integration (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>. Richardson extrapolation) to determine how many time levels to maintain to properly apply the estimtion scheme. In general, an even refine ratio (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>. 2, 4, 8) will maintain two time levels, while an odd refine ratio (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>. 3) will maintain three. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#2467f4e8b80d42fabefda019eba8b6d9">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="a100eb14da651d3d39476bbc6eb8b89d"></a><!-- doxytag: member="SAMRAI::mesh::MultiblockGriddingAlgorithm::levelCanBeRefined" ref="a100eb14da651d3d39476bbc6eb8b89d" args="(const int level_number) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm</a>&lt; DIM &gt;::levelCanBeRefined           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if level associated with the specified level number can * be refined; i.e., the level number is less than that of the finest level allowed in the hierarchy. Otherwise, false is returned. 
<p>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#80593a645746dc9208810412a5880b18">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="96a6e57d1c5dbb3fe4a27612a02d72b3"></a><!-- doxytag: member="SAMRAI::mesh::MultiblockGriddingAlgorithm::getTagAndInitializeStrategy" ref="96a6e57d1c5dbb3fe4a27612a02d72b3" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">mesh::TagAndInitializeStrategy</a>&lt; DIM &gt; &gt; <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm</a>&lt; DIM &gt;::getTagAndInitializeStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return pointer to level gridding strategy data member. 
<p>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#edbd080e17757c682391a616454ba97c">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="b0dcd4f2cc74c411c605be9e24a44a0a"></a><!-- doxytag: member="SAMRAI::mesh::MultiblockGriddingAlgorithm::getMaxLevels" ref="b0dcd4f2cc74c411c605be9e24a44a0a" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm</a>&lt; DIM &gt;::getMaxLevels           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return maximum number of levels allowed in hierarchy. 
<p>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#680a6dc0520c476f4486ec04b2756c47">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="f535f3c9819d8dfb6e7f9c7e31cc3218"></a><!-- doxytag: member="SAMRAI::mesh::MultiblockGriddingAlgorithm::getRatioToCoarserLevel" ref="f535f3c9819d8dfb6e7f9c7e31cc3218" args="(int level_number) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp; <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm</a>&lt; DIM &gt;::getRatioToCoarserLevel           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return const reference to ratio between specified level and next coarser. 
<p>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#4816dd64af50c6cd594edadfc366bee0">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="cce894dbad4f8372816dafadbaa9b63a"></a><!-- doxytag: member="SAMRAI::mesh::MultiblockGriddingAlgorithm::getEfficiencyTolerance" ref="cce894dbad4f8372816dafadbaa9b63a" args="(int level_number) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm</a>&lt; DIM &gt;::getEfficiencyTolerance           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return efficiency tolerance for clustering tags on level. 
<p>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#78ed81ac7ddfe070acde1ee5c0c0d030">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="1ca17f262ecd3aaaa5973c70c882038c"></a><!-- doxytag: member="SAMRAI::mesh::MultiblockGriddingAlgorithm::getCombineEfficiency" ref="1ca17f262ecd3aaaa5973c70c882038c" args="(int level_number) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm</a>&lt; DIM &gt;::getCombineEfficiency           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return combine efficiency for clustering tags on level. 
<p>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#c4bdddcbf6701d0a220c66ac29751643">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="349f11f113f26130c4a718794dd69742"></a><!-- doxytag: member="SAMRAI::mesh::MultiblockGriddingAlgorithm::getProperNestingBuffer" ref="349f11f113f26130c4a718794dd69742" args="(int level_number) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm</a>&lt; DIM &gt;::getProperNestingBuffer           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return proper nesting buffer width for level. 
<p>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#b87a8fe4d49b5844ce23d11aa4891edd">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="ea2335f7be21120b8890c11993958fe2"></a><!-- doxytag: member="SAMRAI::mesh::MultiblockGriddingAlgorithm::getSmallestPatchSize" ref="ea2335f7be21120b8890c11993958fe2" args="(const int level_number) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp; <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm</a>&lt; DIM &gt;::getSmallestPatchSize           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return const reference to smallest patch size for level. 
<p>

</div>
</div><p>
<a class="anchor" name="81905dbfe732e389cd4ada2f9dae77c6"></a><!-- doxytag: member="SAMRAI::mesh::MultiblockGriddingAlgorithm::getLargestPatchSize" ref="81905dbfe732e389cd4ada2f9dae77c6" args="(const int level_number) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp; <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm</a>&lt; DIM &gt;::getLargestPatchSize           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return const reference to largest patch size for level. 
<p>

</div>
</div><p>
<a class="anchor" name="502dc58d8b870cf424f82fa678e70b66"></a><!-- doxytag: member="SAMRAI::mesh::MultiblockGriddingAlgorithm::putToDatabase" ref="502dc58d8b870cf424f82fa678e70b66" args="(tbox::Pointer&lt; tbox::Database &gt; db)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm</a>&lt; DIM &gt;::putToDatabase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write object state out to the given database. 
<p>
When assertion checking is active, the database pointer must be non-null. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#402d40aa6172a028f927af79440bd813">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/mesh/multiblock/<a class="el" href="MultiblockGriddingAlgorithm_8h.html">MultiblockGriddingAlgorithm.h</a><li>source/mesh/multiblock/<a class="el" href="MultiblockGriddingAlgorithm_8C.html">MultiblockGriddingAlgorithm.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:28:41 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
