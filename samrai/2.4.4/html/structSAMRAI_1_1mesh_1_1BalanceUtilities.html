<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::mesh::BalanceUtilities&lt; DIM &gt; Struct Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>::<a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">BalanceUtilities</a></div>
<h1>SAMRAI::mesh::BalanceUtilities&lt; DIM &gt; Struct Template Reference</h1><!-- doxytag: class="SAMRAI::mesh::BalanceUtilities" -->Utility class BalanceUtilities&lt;DIM&gt; provides several functions useful in various load balancing operations. These utilities include bin packing operations, box chopping by recursive bisection, and computation of effective processor layouts for boxes.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/mesh/load_balance/BalanceUtilities.h&gt;</code>
<p>
<a href="structSAMRAI_1_1mesh_1_1BalanceUtilities-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#1ba2cb7b4c108c1c2578345cd5cff871">binPack</a> (<a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;mapping, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt; &amp;weights, int nproc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#f096e740c769d2b8e8c5fa10df161b90">spatialBinPack</a> (<a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;mapping, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt; &amp;weights, <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;boxes, const int nproc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#286a68be85449bf17e8d19d705e6ea8a">recursiveBisectionUniform</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;out_boxes, <a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a>&lt; double &gt; &amp;out_workloads, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;in_boxes, double ideal_workload, const double workload_tolerance, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;cut_factor, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;bad_interval, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;physical_domain)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#7097a7f3d2895421773e120c6d1393f0">recursiveBisectionNonuniform</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;out_boxes, <a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a>&lt; double &gt; &amp;out_workloads, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; &amp;in_level, int work_id, double ideal_workload, const double workload_tolerance, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;cut_factor, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;bad_interval, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;physical_domain)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#09984cf1b557f22b2a8a476dff5b4a49">computeDomainDependentProcessorLayout</a> (<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;proc_dist, int num_procs, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#edce5f87b864f985cb031b20d439e212">computeDomainIndependentProcessorLayout</a> (<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;proc_dist, int num_procs, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#c594bf463b9b61e8f1ef32a318fbec8b">sortDescendingBoxWorkloads</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;boxes, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt; &amp;workload)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#6c206378665e75c01c22378a5ef871af">computeNonUniformWorkload</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &gt; patch, int wrk_indx, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#c7ed1ab82b3048caa0803bab284c3a67">computeLoadBalanceEfficiency</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; &amp;level, std::ostream &amp;os, int workload_data_id=-1)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 struct SAMRAI::mesh::BalanceUtilities&lt; DIM &gt;</h3>

Utility class BalanceUtilities&lt;DIM&gt; provides several functions useful in various load balancing operations. These utilities include bin packing operations, box chopping by recursive bisection, and computation of effective processor layouts for boxes. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="1ba2cb7b4c108c1c2578345cd5cff871"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::binPack" ref="1ba2cb7b4c108c1c2578345cd5cff871" args="(hier::ProcessorMapping &amp;mapping, tbox::Array&lt; double &gt; &amp;weights, int nproc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::binPack           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nproc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign workloads to processors using a greedy algorithm that attempts to distribute the sum of weights on each processor evenly across the given number of processors.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>double-valued estimate of the load balance efficiency (ranges from zero to one hundred percent)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mapping</em>&nbsp;</td><td>Output processor mapping. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weights</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of double-valued weights to distribute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nproc</em>&nbsp;</td><td>Integer number of processors, must be &gt; 0. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f096e740c769d2b8e8c5fa10df161b90"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::spatialBinPack" ref="f096e740c769d2b8e8c5fa10df161b90" args="(hier::ProcessorMapping &amp;mapping, tbox::Array&lt; double &gt; &amp;weights, hier::BoxArray&lt; DIM &gt; &amp;boxes, const int nproc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::spatialBinPack           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nproc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign boxes to processors so that boxes spatially near each other are likely to be assigned to processors near each other (assuming that processor ordering is reflected in processor rank) and so that the workload is approximately evenly distributed among the processors. The routine uses a Morton space-filling curve algorithm.<p>
Note that this routine potentially reorders the boxes passed in to achieve the first goal.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Double-valued estimate of the load balance efficiency (ranges from zero to one hundred percent)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mapping</em>&nbsp;</td><td>Output processor mapping. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weights</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of double-valued box weights to distribute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boxes</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of boxes to distribute to processors. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nproc</em>&nbsp;</td><td>Integer number of processors, must be &gt; 0.</td></tr>
  </table>
</dl>
Note that the wight and box arrrays must be the same size. 
</div>
</div><p>
<a class="anchor" name="286a68be85449bf17e8d19d705e6ea8a"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::recursiveBisectionUniform" ref="286a68be85449bf17e8d19d705e6ea8a" args="(hier::BoxList&lt; DIM &gt; &amp;out_boxes, tbox::List&lt; double &gt; &amp;out_workloads, const hier::BoxList&lt; DIM &gt; &amp;in_boxes, double ideal_workload, const double workload_tolerance, const hier::IntVector&lt; DIM &gt; &amp;min_size, const hier::IntVector&lt; DIM &gt; &amp;cut_factor, const hier::IntVector&lt; DIM &gt; &amp;bad_interval, const hier::BoxArray&lt; DIM &gt; &amp;physical_domain)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::recursiveBisectionUniform           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out_workloads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>in_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ideal_workload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>workload_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>physical_domain</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursively chop chops boxes in input boxlist until each box has a workload less than the prescribed ideal workload or no more more chopping is allowed by the given constraints. A spatially-uniform workload is assumed; i.e., all cells are weighted equally. This routine attempts to create as many boxes as possible with loads equal to or slightly less than the ideal workload value so that they can be mapped to processors effectively.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out_boxes</em>&nbsp;</td><td>Output box list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out_workloads</em>&nbsp;</td><td>Output list of box workloads. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>in_boxes</em>&nbsp;</td><td>Input boxlist for chopping. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ideal_workload</em>&nbsp;</td><td>Input double ideal box workload, must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>workload_tolerance</em>&nbsp;</td><td>Input double workload tolerance, must be &gt;= 0 and &lt; 1.0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_size</em>&nbsp;</td><td>Input integer vector of minimum dimensions for output boxes. All entries must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cut_factor</em>&nbsp;</td><td>Input integer vector used to create boxes with correct dimensions. The length of each box dimension will be an integer multiple of the corresponding cut factor vector entry. All vector entries must be &gt; 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bad_interval</em>&nbsp;</td><td>Input integer vector used to create boxes near physical domain boundary with sufficient number of cells. No box face will be closer to the boundary than the corresponding interval of cells to the boundary (the corresponding value is given by the normal direction of the box face) unless the face coincides with the boundary itself. The point of this argument is to have no patch live within a certain ghost cell width of the boundary if its boundary does not coincide with that boundary . That is, all ghost cells along a face will be either in the domain interior or outside the domain. All entries must be &gt;= 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>physical_domain</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of boxes describing the physical extent of the index space associated with the in_boxes. This box array cannot be empty. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7097a7f3d2895421773e120c6d1393f0"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::recursiveBisectionNonuniform" ref="7097a7f3d2895421773e120c6d1393f0" args="(hier::BoxList&lt; DIM &gt; &amp;out_boxes, tbox::List&lt; double &gt; &amp;out_workloads, const tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; &amp;in_level, int work_id, double ideal_workload, const double workload_tolerance, const hier::IntVector&lt; DIM &gt; &amp;min_size, const hier::IntVector&lt; DIM &gt; &amp;cut_factor, const hier::IntVector&lt; DIM &gt; &amp;bad_interval, const hier::BoxArray&lt; DIM &gt; &amp;physical_domain)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::recursiveBisectionNonuniform           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out_workloads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>in_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>work_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ideal_workload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>workload_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>physical_domain</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursively chops boxes given by patches on input patch level until each box has a workload less than the prescribed ideal workload or no more more chopping is allowed by the given constraints. A spatially-nonuniform workload is assumed. Cell weights must be given bydata defined by the given patch data id on the given patch level. This routine attempts to create as many boxes as possible with loads equal to or slightly less than the ideal workload value so that they can be mapped to processors effectively.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out_boxes</em>&nbsp;</td><td>Output box list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out_workloads</em>&nbsp;</td><td>Output list of box workloads. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>in_level</em>&nbsp;</td><td>Input patch level whose patches describe input box regions and whose patch data contain workload estimate for each cell. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>work_id</em>&nbsp;</td><td>Input integer patch data id for cell-centered double work estimate for each cell. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ideal_workload</em>&nbsp;</td><td>Input double ideal box workload, must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>workload_tolerance</em>&nbsp;</td><td>Input double workload tolerance, must be &gt;= 0 and &lt; 1.0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_size</em>&nbsp;</td><td>Input integer vector of minimum dimensions for output boxes. All entries must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cut_factor</em>&nbsp;</td><td>Input integer vector used to create boxes with correct dimensions. The length of each box dimension will be an integer multiple of the corresponding cut factor vector entry. All vector entries must be &gt; 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bad_interval</em>&nbsp;</td><td>Input integer vector used to create boxes near physical domain boundary with sufficient number of cells. No box face will be closer to the boundary than the corresponding interval of cells to the boundary (the corresponding value is given by the normal direction of the box face) unless the face coincides with the boundary itself. The point of this argument is to have no patch live within a certain ghost cell width of the boundary if its boundary does not coincide with that boundary . That is, all ghost cells along a face will be either in the domain interior or outside the domain. All entries must be &gt;= 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>physical_domain</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of boxes describing the physical extent of the index space associated with the in_boxes. This box array cannot be empty. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="09984cf1b557f22b2a8a476dff5b4a49"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::computeDomainDependentProcessorLayout" ref="09984cf1b557f22b2a8a476dff5b4a49" args="(hier::IntVector&lt; DIM &gt; &amp;proc_dist, int num_procs, const hier::Box&lt; DIM &gt; &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::computeDomainDependentProcessorLayout           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proc_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_procs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute factorization of processors corresponding to dimensions of given box.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proc_dist</em>&nbsp;</td><td>Output number of processors for each coordinate direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_procs</em>&nbsp;</td><td>Input integer number of processors, must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Input box to be distributed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="edce5f87b864f985cb031b20d439e212"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::computeDomainIndependentProcessorLayout" ref="edce5f87b864f985cb031b20d439e212" args="(hier::IntVector&lt; DIM &gt; &amp;proc_dist, int num_procs, const hier::Box&lt; DIM &gt; &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::computeDomainIndependentProcessorLayout           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proc_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_procs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute a factorization of processors that does NOT necessarily correspond to the dimensions of the supplied box. For example, the processor distribution in each direction may simply be a square root (cube root in 3D) of the number of processors. The box information is used simply to determine a maximum number of processors in each coordinate direction.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proc_dist</em>&nbsp;</td><td>Output number of processors for each coordinate direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_procs</em>&nbsp;</td><td>Input integer number of processors, must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Input box to be distributed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c594bf463b9b61e8f1ef32a318fbec8b"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::sortDescendingBoxWorkloads" ref="c594bf463b9b61e8f1ef32a318fbec8b" args="(hier::BoxArray&lt; DIM &gt; &amp;boxes, tbox::Array&lt; double &gt; &amp;workload)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::sortDescendingBoxWorkloads           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>workload</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sort box array in descending order of workload according to the workload array. Both the box array and the work array will be sorted on return.<p>
Note that if you simply want to sort boxes based on their size, see <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>boxes</em>&nbsp;</td><td>Boxes to be sorted based on workload array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>workload</em>&nbsp;</td><td>Workloads to use for sorting boxes.</td></tr>
  </table>
</dl>
Note that both arrays must be the same size. 
</div>
</div><p>
<a class="anchor" name="6c206378665e75c01c22378a5ef871af"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::computeNonUniformWorkload" ref="6c206378665e75c01c22378a5ef871af" args="(tbox::Pointer&lt; hier::Patch&lt; DIM &gt; &gt; patch, int wrk_indx, const hier::Box&lt; DIM &gt; &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::computeNonUniformWorkload           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>wrk_indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute total workload in region of argument box based on patch data defined by given integer index. The sum is computed on the intersection of argument box and box over which data associated with workload is defined.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Double-valued sum of workload values in box region.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td>Input patch on which workload data is defined. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wrk_indx</em>&nbsp;</td><td>Input integer patch data identifier for work data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Input box region</td></tr>
  </table>
</dl>
Note that wrk_indx must refer to a valid cell-centered patch data entry. 
</div>
</div><p>
<a class="anchor" name="c7ed1ab82b3048caa0803bab284c3a67"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::computeLoadBalanceEfficiency" ref="c7ed1ab82b3048caa0803bab284c3a67" args="(const tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; &amp;level, std::ostream &amp;os, int workload_data_id=-1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::computeLoadBalanceEfficiency           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>workload_data_id</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute and return load balance efficiency for a level.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Double-valued estimate of the load balance efficiency (ranges from zero to one hundred percent)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>Input patch level to consider, can't be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>Output stream for reporting load balance details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>workload_data_id</em>&nbsp;</td><td>(Optional) Input integer id for workload data on level. If no value is given, the calculation assumes spatially-uniform load. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following files:<ul>
<li>source/mesh/load_balance/<a class="el" href="BalanceUtilities_8h.html">BalanceUtilities.h</a><li>source/mesh/load_balance/<a class="el" href="BalanceUtilities_8C.html">BalanceUtilities.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:28:41 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
