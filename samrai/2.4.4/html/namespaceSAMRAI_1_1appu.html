<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::appu Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="namespaces.html"><span>Namespace List</span></a></li>
    <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1appu.html">appu</a></div>
<h1>SAMRAI::appu Namespace Reference</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1BoundaryUtilityStrategy.html">BoundaryUtilityStrategy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class <a class="el" href="classSAMRAI_1_1appu_1_1BoundaryUtilityStrategy.html">BoundaryUtilityStrategy</a> is an abstract base class that declares an interface that allows application code to read problem-specific boundary data when using the <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> boundary utilities. Currently, there are two virtual member functions defined. One allows users to read problem-specific DIRICHLET boundary values from an input database; the other does the same for NEUMANN boundary values. More virtual functions may be added in the future as additional boundary conditions are supported.  <a href="classSAMRAI_1_1appu_1_1BoundaryUtilityStrategy.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1BoundaryNode.html">BoundaryNode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classSAMRAI_1_1appu_1_1BoundaryNode.html">BoundaryNode</a> struct holds data and methods to define a boundary node (i.e. the first node inside the boundary) on an irregular boundary. An array of boundary nodes is maintained by each "CutCell" object, if the appropriate functions are called to enable boundary node storage. For more information, see the <a class="el" href="classSAMRAI_1_1appu_1_1CutCell.html">CutCell</a> class documentation.  <a href="classSAMRAI_1_1appu_1_1BoundaryNode.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1CubesPatchInterface.html">CubesPatchInterface</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1CutCell.html">CutCell</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classSAMRAI_1_1appu_1_1CutCell.html">CutCell</a> struct holds data and methods to define a cut-cell on an irregular boundary.  <a href="classSAMRAI_1_1appu_1_1CutCell.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1ElevenPatchInterface.html">ElevenPatchInterface</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class provides an interface to the Eleven geometry library by Kyle Chand in CASC. The shapes over which the embedded boundary is cut is defined through an XML database, the name of which is specified in the input file.  <a href="classSAMRAI_1_1appu_1_1ElevenPatchInterface.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryDefines.html">EmbeddedBoundaryDefines</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryDefines.html">EmbeddedBoundaryDefines</a> sets the enumerated types used to define cells and nodes on the embedded boundary level.  <a href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryDefines.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">EmbeddedBoundaryGeometry</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">EmbeddedBoundaryGeometry</a> provides embedded boundary mesh construction, storage, and management on an AMR hierarchy.  <a href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShape.html">EmbeddedBoundaryShape</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An abstract base class from which the different embedded boundary analytic shapes used in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> are derived. It specifies virtual implementations of several functions used to define an analytic embedded boundary shape.  <a href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShape.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShapePolygon.html">EmbeddedBoundaryShapePolygon</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides an analytic description of a convex polygon. It inherets from the <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShape.html">EmbeddedBoundaryShape</a> base class and provides a concrete implementation of the "isInside()" method, which specifies whether a cell is INSIDE the convex poly.  <a href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShapePolygon.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShapeSphere.html">EmbeddedBoundaryShapeSphere</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides an analytic description of a sphere. It inherets from the <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShape.html">EmbeddedBoundaryShape</a> base class and provides a concrete implementation of the "isInside()" method, which specifies whether a cell is INSIDE the sphere.  <a href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShapeSphere.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1CartesianVizamraiDataWriter.html">CartesianVizamraiDataWriter</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">VisDerivedDataStrategy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class VisDerivedDataStrategy&lt;DIM&gt; is an abstract base class that defines an interface allowing an VisItDataWriter&lt;DIM&gt; object and/or an CartesianVizamraiDataWriter&lt;DIM&gt; object to generate plot files that contain "derived" quantities; that is, data that does not reside on the hierarchy, but which is derived from data that does reside on the hierarchy. The derived data may be scalar, vector, or tensor (VisIt only), and cell-centered or node-centered (VisIt only). A concrete object of this type must be registered with the data writer if any derived variable is registered with the data writer. The registration of the concrete strategy object may be done independently using the method setDerivedDataWriter() (Vizamrai only) or setDefaultDerivedDataWriter() (VisIt only) from the relevant DataWriter class, or the concrete strategy object may be registered concurrently with the derived variable using the method registerDerivedPlotScalar/Vector/Tensor().  <a href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">VisItDataWriter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class VisItDataWriter&lt;DIM&gt; is used by SAMRAI-based application codes to generate VisIt data files. VisIt provides a wide range of visualization and post-processing capabilities. This class supports both cell-centered and node-centered 2D and 3D AMR data where the underlying data type is either double, float, or int. Scalar, vector and 2nd-order tensor variables are supported. This class may be used when the mesh geometry is managed by a geom::CartesianGridGeometry&lt;DIM&gt; object, or when the mesh itself is stored in a state variable to allow moving deformed grids.  <a href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisMaterialsDataStrategy.html">VisMaterialsDataStrategy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class VisMaterialsDataStrategy&lt;DIM&gt; is an abstract base class that defines an interface allowing an VisItDataWriter&lt;DIM&gt; object to generate plot files that contain material and species fractions, as well as state variables for individual materials. A concrete object of this type must be registered with the data writer in order to use materials or species with the data writer. The registration of the concrete object is done using the method setMaterialsDataWriter() from the <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">VisItDataWriter</a> class. VisIt requires that material fractions, species fractions, and material state variables be cell-centered. If they are not cell-centered in the simulation, it is the job of the relevant packing method to convert them to a cell-centered basis before packing them into the buffer.  <a href="classSAMRAI_1_1appu_1_1VisMaterialsDataStrategy.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html">CartesianBoundaryUtilities2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class <a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html">CartesianBoundaryUtilities2</a> is a utility class that simplifies the implementation of simple physical boundary data in 2 spatial dimensions. It contains routines for reading boundary data information from input files, applying those boundary conditions, and error checking boundary data. These routines apply to the case of cell-centered double data only. One may use all of these capabilities, or use the input reading, boundary setting, and error checking routines independently.  <a href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities3.html">CartesianBoundaryUtilities3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class <a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html">CartesianBoundaryUtilities2</a> is a utility class that simplifies the implementation of simple physical boundary data in 3 spatial dimensions. It contains routines for reading boundary data information from input files, applying those boundary conditions, and error checking boundary data. These routines apply to the case of cell-centered double data only. One may use all of these capabilities, or use the input reading, boundary setting, and error checking routines independently.  <a href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities3.html#_details">More...</a><br></td></tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:28:21 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
