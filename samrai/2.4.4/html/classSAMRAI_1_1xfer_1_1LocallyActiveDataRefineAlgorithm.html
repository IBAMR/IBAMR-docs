<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::xfer::LocallyActiveDataRefineAlgorithm&lt; DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1xfer.html">xfer</a>::<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html">LocallyActiveDataRefineAlgorithm</a></div>
<h1>SAMRAI::xfer::LocallyActiveDataRefineAlgorithm&lt; DIM &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::xfer::LocallyActiveDataRefineAlgorithm" -->Class LocallyActiveDataRefineAlgorithm&lt;DIM&gt; encapsulates the AMR communication pattern to refine data to, copy data to, or fill physical boundary data on a destination patch level, where the data may be defined only on some patches (i.e., the patch data is "locally-active"). The basic procedure for moving data follows three steps:<ol type=1>
<li>spatially interpolate data from coarser levels</li><li>copy data from the same level of refinement</li><li>fill physical boundary conditions regions. </li></ol>
 
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/transfer/datamovers/locally_active/LocallyActiveDataRefineAlgorithm.h&gt;</code>
<p>
<a href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html#ec1a55a236ed93822a3347648e62daea">LocallyActiveDataRefineAlgorithm</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html#e5677b0fbaf8791483ceef4884d6f18e">~LocallyActiveDataRefineAlgorithm</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html#2d32e2afe5d9820f8b79ec7d90161013">registerRefine</a> (const int dst, const int src, const int scratch, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">xfer::RefineOperator</a>&lt; DIM &gt; &gt; oprefine)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html#e412bd628e0a8d1210cc48aa7b2bba42">registerRefine</a> (const int dst, const int src, const int src_told, const int src_tnew, const int scratch, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">RefineOperator</a>&lt; DIM &gt; &gt; oprefine, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1TimeInterpolateOperator.html">TimeInterpolateOperator</a>&lt; DIM &gt; &gt; optime)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineSchedule.html">xfer::LocallyActiveDataRefineSchedule</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html#9abeb7483cba9517cd165273c98c6609">createSchedule</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveDataPatchLevelManager.html">hier::LocallyActiveDataPatchLevelManager</a>&lt; DIM &gt; &gt; level_mgr, <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">xfer::LocallyActiveDataRefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">xfer::LocallyActiveDataRefinePatchStrategy</a>&lt; DIM &gt; *)(0)), <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineTransactionFactory.html">xfer::LocallyActiveDataRefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineTransactionFactory.html">xfer::LocallyActiveDataRefineTransactionFactory</a>&lt; DIM &gt; *)(0))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a communication schedule that moves data from the interiors of the source data components into the interior and boundary cells of the destination data components on the same level where those sources and destinations overlap.  <a href="#9abeb7483cba9517cd165273c98c6609"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineSchedule.html">xfer::LocallyActiveDataRefineSchedule</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html#3b7683de874ed37614d4d97ee980462d">createSchedule</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; dst_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveDataPatchLevelManager.html">hier::LocallyActiveDataPatchLevelManager</a>&lt; DIM &gt; &gt; dst_level_mgr, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; src_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveDataPatchLevelManager.html">hier::LocallyActiveDataPatchLevelManager</a>&lt; DIM &gt; &gt; src_level_mgr, <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">xfer::LocallyActiveDataRefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">xfer::LocallyActiveDataRefinePatchStrategy</a>&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineTransactionFactory.html">xfer::LocallyActiveDataRefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineTransactionFactory.html">xfer::LocallyActiveDataRefineTransactionFactory</a>&lt; DIM &gt; *)(0))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a communication schedule that moves data from the interiors of the source data components on a source level into the interior and boundary cells of the destination data components on a destination level where those sources and destinations overlap.  <a href="#3b7683de874ed37614d4d97ee980462d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineSchedule.html">xfer::LocallyActiveDataRefineSchedule</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html#fec3cd9364178118a9d9934c81f1af1c">createSchedule</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveDataPatchLevelManager.html">hier::LocallyActiveDataPatchLevelManager</a>&lt; DIM &gt; &gt; level_mgr, const int next_coarser_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">xfer::LocallyActiveDataRefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">xfer::LocallyActiveDataRefinePatchStrategy</a>&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineTransactionFactory.html">xfer::LocallyActiveDataRefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineTransactionFactory.html">xfer::LocallyActiveDataRefineTransactionFactory</a>&lt; DIM &gt; *)(0))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a communication schedule that moves data from the interiors of the source data components on the patch level and coarser levels in the patch hierarchy into the interior and boundary cells of the destination data components on the given patch level where those sources and destinations overlap. Data is time interpolated between old and new sources on coarser levels when and where time interpolation is needed and copied from the source components on the patch level into the destination components otherwise.  <a href="#fec3cd9364178118a9d9934c81f1af1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineSchedule.html">xfer::LocallyActiveDataRefineSchedule</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html#22c09c0da3788dd87b550b145b5e3796">createSchedule</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; dst_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveDataPatchLevelManager.html">hier::LocallyActiveDataPatchLevelManager</a>&lt; DIM &gt; &gt; dst_level_mgr, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; src_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveDataPatchLevelManager.html">hier::LocallyActiveDataPatchLevelManager</a>&lt; DIM &gt; &gt; src_level_mgr, const int next_coarser_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">xfer::LocallyActiveDataRefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">xfer::LocallyActiveDataRefinePatchStrategy</a>&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineTransactionFactory.html">xfer::LocallyActiveDataRefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineTransactionFactory.html">xfer::LocallyActiveDataRefineTransactionFactory</a>&lt; DIM &gt; *)(0))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a communication schedule that moves data from the interiors of the source data components on the source level and coarser levels in the hierarchy into the interior and boundary cells of the destination data components on the destination level where those sources and destinations overlap. Data is time interpolated between old and new sources on coarser levels when and where time interpolation is needed and from the source data components on the source level into the destination data components otherwise.  <a href="#22c09c0da3788dd87b550b145b5e3796"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html#68c5485bc265f82b51a53190352f5ab3">printClassData</a> (std::ostream &amp;stream) const </td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class SAMRAI::xfer::LocallyActiveDataRefineAlgorithm&lt; DIM &gt;</h3>

Class LocallyActiveDataRefineAlgorithm&lt;DIM&gt; encapsulates the AMR communication pattern to refine data to, copy data to, or fill physical boundary data on a destination patch level, where the data may be defined only on some patches (i.e., the patch data is "locally-active"). The basic procedure for moving data follows three steps:<ol type=1>
<li>spatially interpolate data from coarser levels</li><li>copy data from the same level of refinement</li><li>fill physical boundary conditions regions. </li></ol>

<p>
Note that this algorithm class is similar in functionality and usage to the RefineAlgorithm&lt;DIM&gt; class.<p>
Each data communication procedure generally consists of three parts: an algorithm, a schedule, and a patch strategy. The algorithm describes the patch data components and time and space interpolation operations, but is independent of the configuration of the patches in an AMR hierarchy. Patch data items and their associated spatial and time interpolation operators are registered with an instantiation of this algorithm class. To generate the communication dependencies for a particular patch hierarchy configuration, the algorithm creates a refine schedule based on the state of a given hierarchy and the information in the algorithm. The schedule can then perform the communication operations that move data to the destination patch level using the associated operators. User-defined operations (such as filling physical boundaries and special interpolation procedures) are provided through a refine patch strategy object.<p>
In general, source data is copied into the designated scratch data for temporary processing. The scratch space must contain sufficient ghost cells to accommodate the stencil width of the given interpolation operators and any physical boundary data that must be filled. The scratch storage is copied into the destination data space at the end of the communication process. Thus, copy operations between source, scratch, and destination patch data objects must be defined. In general, it is the user's responsibility to register valid operations with the refine algorithm so that the data communication can occur.<p>
In general, the destination and scratch data components may be the same (assuming that the scratch component has a sufficient ghost cells width). The source and scratch components SHOULD NOT be the same generally, since the interiors of the source space may be changed by the use of the scratch data as temporary work space.<p>
Note that each refine schedule created by a refine algorithm remains valid as long as the patches involved in the communication process do not change; thus, they can be used for multiple data communication cycles.<p>
Typical usage of a refine algorithm to perform inter-patch communication on an AMR hierarchy involves four steps:<p>
<ol type=1>
<li>Construct a refine algorithm object.</li><li>Register refine operations with the refine algorithm. Using the <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html#2d32e2afe5d9820f8b79ec7d90161013">registerRefine()</a> methods(s), one provides source and destination patch data information, as well as time and space interpolation operators as needed. Two <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html#2d32e2afe5d9820f8b79ec7d90161013">registerRefine()</a> methods appear in this class; one supports time interpolation, one does not.</li><li>After all operations are registered with the algorithm, one creates a communication schedule using one of the <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html#9abeb7483cba9517cd165273c98c6609">createSchedule()</a> methods. These methods are distinguished by the resulting data communication pattern (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., interpatch communication on a single level, between two different levels at the same grid resolution, interpolation of data between different AMR hierarchy levels, etc.) Note that when creating a communication schedule, a concrete instance of a LocallyActiveDataRefinePatchStrategy&lt;DIM&gt; object may be required to supply physical boundary conditions as well as user-defined spatial data interpolation operations.</li><li>Invoke the fillData() method in the communication schedule to perform the data transfers.</li></ol>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineSchedule.html">xfer::LocallyActiveDataRefineSchedule</a> <p>
<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">xfer::LocallyActiveDataRefinePatchStrategy</a> <p>
<a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">xfer::RefineClasses</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="ec1a55a236ed93822a3347648e62daea"></a><!-- doxytag: member="SAMRAI::xfer::LocallyActiveDataRefineAlgorithm::LocallyActiveDataRefineAlgorithm" ref="ec1a55a236ed93822a3347648e62daea" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html">SAMRAI::xfer::LocallyActiveDataRefineAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html">LocallyActiveDataRefineAlgorithm</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a refinement algorithm and initialize its basic state. Note that refinement operations must be registered with this algorithm before it can do anything useful. See the <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html#2d32e2afe5d9820f8b79ec7d90161013">registerRefine()</a> routines for details. 
</div>
</div><p>
<a class="anchor" name="e5677b0fbaf8791483ceef4884d6f18e"></a><!-- doxytag: member="SAMRAI::xfer::LocallyActiveDataRefineAlgorithm::~LocallyActiveDataRefineAlgorithm" ref="e5677b0fbaf8791483ceef4884d6f18e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html">SAMRAI::xfer::LocallyActiveDataRefineAlgorithm</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html">LocallyActiveDataRefineAlgorithm</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The virtual destructor for the algorithm releases all internal storage. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="2d32e2afe5d9820f8b79ec7d90161013"></a><!-- doxytag: member="SAMRAI::xfer::LocallyActiveDataRefineAlgorithm::registerRefine" ref="2d32e2afe5d9820f8b79ec7d90161013" args="(const int dst, const int src, const int scratch, tbox::Pointer&lt; xfer::RefineOperator&lt; DIM &gt; &gt; oprefine)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html">SAMRAI::xfer::LocallyActiveDataRefineAlgorithm</a>&lt; DIM &gt;::registerRefine           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">xfer::RefineOperator</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>oprefine</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a refine operation with the refine algorithm object. This routine does not support time interpolation. Data values will be moved from the source component to the destination component using scratch component as a temporary work space. The scratch component must have sufficient ghost cells to cover the required operator stencil width and any needed physical boundary ghost cells.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Integer destination patch data index to be filled on the destination level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Integer source patch data index on the source level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scratch</em>&nbsp;</td><td>Integer patch data index used as a temporary work space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oprefine</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refinement operator. This may be a null pointer. In this case, refinement must be handled by the refine patch strategy member functions. See the comments for the preprocessRefine() and postprocessRefine() functions in the LocallyActiveDataRefinePatchStrategy&lt;DIM&gt; class. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e412bd628e0a8d1210cc48aa7b2bba42"></a><!-- doxytag: member="SAMRAI::xfer::LocallyActiveDataRefineAlgorithm::registerRefine" ref="e412bd628e0a8d1210cc48aa7b2bba42" args="(const int dst, const int src, const int src_told, const int src_tnew, const int scratch, tbox::Pointer&lt; RefineOperator&lt; DIM &gt; &gt; oprefine, tbox::Pointer&lt; TimeInterpolateOperator&lt; DIM &gt; &gt; optime)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html">SAMRAI::xfer::LocallyActiveDataRefineAlgorithm</a>&lt; DIM &gt;::registerRefine           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>src_told</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>src_tnew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">RefineOperator</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>oprefine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1TimeInterpolateOperator.html">TimeInterpolateOperator</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>optime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a refine operation with the refine algorithm object. This routine supports time interpolation. Time interpolation will take place between the old and new source data components on coarser levels. On the destination level, data will be moved from the source component to the destination component using scratch component as a temporary work space. The scratch component must have sufficient ghost cells to cover the required operator stencil width and any needed physical boundary ghost cells. The time interpolation operator cannot be null. When assertion checking is active, passing in a null pointer will result in an unrecoverable exception.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Integer destination patch data index to be filled on the destination level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Integer source patch data index on the source level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_told</em>&nbsp;</td><td>Integer source patch data index for old data used in time interpolation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_tnew</em>&nbsp;</td><td>Integer source patch data index for new data used in time interpolation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scratch</em>&nbsp;</td><td>Integer patch data index used as a temporary work space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oprefine</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refinement operator. This may be a null pointer. In this case, refinement must be handled by the refine patch strategy member functions. See the comments for <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#4e647ae59b0d7b45ac8e3e3072f69912">RefinePatchStrategy&lt;DIM&gt;::preprocessRefine()</a> and <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a8630858c8464794242a469bbcd48672">RefinePatchStrategy&lt;DIM&gt;::postprocessRefine()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optime</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to time interpolation operator. This pointer may not be null. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9abeb7483cba9517cd165273c98c6609"></a><!-- doxytag: member="SAMRAI::xfer::LocallyActiveDataRefineAlgorithm::createSchedule" ref="9abeb7483cba9517cd165273c98c6609" args="(tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; level, tbox::Pointer&lt; hier::LocallyActiveDataPatchLevelManager&lt; DIM &gt; &gt; level_mgr, xfer::LocallyActiveDataRefinePatchStrategy&lt; DIM &gt; *patch_strategy=((xfer::LocallyActiveDataRefinePatchStrategy&lt; DIM &gt; *)(0)), tbox::Pointer&lt; xfer::LocallyActiveDataRefineTransactionFactory&lt; DIM &gt; &gt; transaction_factory=(xfer::LocallyActiveDataRefineTransactionFactory&lt; DIM &gt; *)(0))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineSchedule.html">xfer::LocallyActiveDataRefineSchedule</a>&lt; DIM &gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html">SAMRAI::xfer::LocallyActiveDataRefineAlgorithm</a>&lt; DIM &gt;::createSchedule           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveDataPatchLevelManager.html">hier::LocallyActiveDataPatchLevelManager</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level_mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">xfer::LocallyActiveDataRefinePatchStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">xfer::LocallyActiveDataRefinePatchStrategy</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineTransactionFactory.html">xfer::LocallyActiveDataRefineTransactionFactory</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineTransactionFactory.html">xfer::LocallyActiveDataRefineTransactionFactory</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a communication schedule that moves data from the interiors of the source data components into the interior and boundary cells of the destination data components on the same level where those sources and destinations overlap. 
<p>
No spatial interpolation is performed.<p>
Note that the schedule remains valid as long as the patches on the level do not change; thus, it can be used for multiple data communication cycles.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refine schedule that performs the data transfers.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to level on which interpatch transfers occur. This pointer cannot be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_mgr</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to destination level data manager; cannot be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine patch strategy that provides user-defined physical boundary filling operations. If this patch strategy is null (default state), then no physical boundary filling is performed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardLocallyActiveDataRefineTransactionFactory.html">StandardLocallyActiveDataRefineTransactionFactory</a> object will be used. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3b7683de874ed37614d4d97ee980462d"></a><!-- doxytag: member="SAMRAI::xfer::LocallyActiveDataRefineAlgorithm::createSchedule" ref="3b7683de874ed37614d4d97ee980462d" args="(tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; dst_level, tbox::Pointer&lt; hier::LocallyActiveDataPatchLevelManager&lt; DIM &gt; &gt; dst_level_mgr, tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; src_level, tbox::Pointer&lt; hier::LocallyActiveDataPatchLevelManager&lt; DIM &gt; &gt; src_level_mgr, xfer::LocallyActiveDataRefinePatchStrategy&lt; DIM &gt; *patch_strategy=((xfer::LocallyActiveDataRefinePatchStrategy&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, tbox::Pointer&lt; xfer::LocallyActiveDataRefineTransactionFactory&lt; DIM &gt; &gt; transaction_factory=(xfer::LocallyActiveDataRefineTransactionFactory&lt; DIM &gt; *)(0))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineSchedule.html">xfer::LocallyActiveDataRefineSchedule</a>&lt; DIM &gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html">SAMRAI::xfer::LocallyActiveDataRefineAlgorithm</a>&lt; DIM &gt;::createSchedule           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveDataPatchLevelManager.html">hier::LocallyActiveDataPatchLevelManager</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>dst_level_mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveDataPatchLevelManager.html">hier::LocallyActiveDataPatchLevelManager</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>src_level_mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">xfer::LocallyActiveDataRefinePatchStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">xfer::LocallyActiveDataRefinePatchStrategy</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineTransactionFactory.html">xfer::LocallyActiveDataRefineTransactionFactory</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineTransactionFactory.html">xfer::LocallyActiveDataRefineTransactionFactory</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a communication schedule that moves data from the interiors of the source data components on a source level into the interior and boundary cells of the destination data components on a destination level where those sources and destinations overlap. 
<p>
Note that both levels must reside in the same AMR hierarchy index space, or in index spaces that represent the same level of mesh refinement. No spatial interpolation is performed.<p>
Note that the schedule remains valid as long as the patches on the levels do not change; thus, it can be used for multiple data communication cycles.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refine schedule that performs the data transfers.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst_level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to destination level; cannot be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_level_mgr</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to destination level data manager; cannot be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to source level; cannot be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_level_mgr</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to source level data manager; cannot be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine patch strategy that provides user-defined physical boundary filling operations. If this patch strategy is null (default state), then no physical boundary filling is performed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_time_interpolation</em>&nbsp;</td><td>Optional boolean flag to create the schedule with the ability to perform time interpolation. Default is no time interpolation (false). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardLocallyActiveDataRefineTransactionFactory.html">StandardLocallyActiveDataRefineTransactionFactory</a> object will be used. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fec3cd9364178118a9d9934c81f1af1c"></a><!-- doxytag: member="SAMRAI::xfer::LocallyActiveDataRefineAlgorithm::createSchedule" ref="fec3cd9364178118a9d9934c81f1af1c" args="(tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; level, tbox::Pointer&lt; hier::LocallyActiveDataPatchLevelManager&lt; DIM &gt; &gt; level_mgr, const int next_coarser_level, tbox::Pointer&lt; hier::PatchHierarchy&lt; DIM &gt; &gt; hierarchy, xfer::LocallyActiveDataRefinePatchStrategy&lt; DIM &gt; *patch_strategy=((xfer::LocallyActiveDataRefinePatchStrategy&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, tbox::Pointer&lt; xfer::LocallyActiveDataRefineTransactionFactory&lt; DIM &gt; &gt; transaction_factory=(xfer::LocallyActiveDataRefineTransactionFactory&lt; DIM &gt; *)(0))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineSchedule.html">xfer::LocallyActiveDataRefineSchedule</a>&lt; DIM &gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html">SAMRAI::xfer::LocallyActiveDataRefineAlgorithm</a>&lt; DIM &gt;::createSchedule           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveDataPatchLevelManager.html">hier::LocallyActiveDataPatchLevelManager</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level_mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>next_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">xfer::LocallyActiveDataRefinePatchStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">xfer::LocallyActiveDataRefinePatchStrategy</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineTransactionFactory.html">xfer::LocallyActiveDataRefineTransactionFactory</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineTransactionFactory.html">xfer::LocallyActiveDataRefineTransactionFactory</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a communication schedule that moves data from the interiors of the source data components on the patch level and coarser levels in the patch hierarchy into the interior and boundary cells of the destination data components on the given patch level where those sources and destinations overlap. Data is time interpolated between old and new sources on coarser levels when and where time interpolation is needed and copied from the source components on the patch level into the destination components otherwise. 
<p>
In certain rare cases in may be necessary to perform time interpolation between old and new sources on the given patch level. In this case the optional argument use_time_interpolation should be set to true. Regardless of the value of this argument, time interpolation on coarser levels will always occur whenever needed.<p>
Note that the schedule remains valid as long as the patches on the levels involved in its creation do not change; thus, it can be used for multiple data communication cycles.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to refine schedule that performs the data transfers.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to destination level; cannot be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_mgr</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to destination level data manager; cannot be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>next_coarser_level</em>&nbsp;</td><td>Integer number of next coarser patch level in the patch hierarchy relative to the destination level. Note that when the destination level has number zero (i.e., the coarsest level), this value should be &lt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to patch hierarchy from which data to fill level should come. This pointer may be null only when the next_coarser_level is &lt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine patch strategy that provides user-defined physical boundary filling operations and user-defined spatial interpolation operations. If this patch strategy is null (default state), then no physical boundary filling or user-defined interpolation is performed. Note that this may cause problems since interpolation of data from coarser levels to some finer level may require physical boundary data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_time_interpolation</em>&nbsp;</td><td>Optional boolean flag to create the schedule with the ability to perform time interpolation Default is no time interpolation (false). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardLocallyActiveDataRefineTransactionFactory.html">StandardLocallyActiveDataRefineTransactionFactory</a> object will be used. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="22c09c0da3788dd87b550b145b5e3796"></a><!-- doxytag: member="SAMRAI::xfer::LocallyActiveDataRefineAlgorithm::createSchedule" ref="22c09c0da3788dd87b550b145b5e3796" args="(tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; dst_level, tbox::Pointer&lt; hier::LocallyActiveDataPatchLevelManager&lt; DIM &gt; &gt; dst_level_mgr, tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; src_level, tbox::Pointer&lt; hier::LocallyActiveDataPatchLevelManager&lt; DIM &gt; &gt; src_level_mgr, const int next_coarser_level, tbox::Pointer&lt; hier::PatchHierarchy&lt; DIM &gt; &gt; hierarchy, xfer::LocallyActiveDataRefinePatchStrategy&lt; DIM &gt; *patch_strategy=((xfer::LocallyActiveDataRefinePatchStrategy&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, tbox::Pointer&lt; xfer::LocallyActiveDataRefineTransactionFactory&lt; DIM &gt; &gt; transaction_factory=(xfer::LocallyActiveDataRefineTransactionFactory&lt; DIM &gt; *)(0))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineSchedule.html">xfer::LocallyActiveDataRefineSchedule</a>&lt; DIM &gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html">SAMRAI::xfer::LocallyActiveDataRefineAlgorithm</a>&lt; DIM &gt;::createSchedule           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveDataPatchLevelManager.html">hier::LocallyActiveDataPatchLevelManager</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>dst_level_mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveDataPatchLevelManager.html">hier::LocallyActiveDataPatchLevelManager</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>src_level_mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>next_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">xfer::LocallyActiveDataRefinePatchStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">xfer::LocallyActiveDataRefinePatchStrategy</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineTransactionFactory.html">xfer::LocallyActiveDataRefineTransactionFactory</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineTransactionFactory.html">xfer::LocallyActiveDataRefineTransactionFactory</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a communication schedule that moves data from the interiors of the source data components on the source level and coarser levels in the hierarchy into the interior and boundary cells of the destination data components on the destination level where those sources and destinations overlap. Data is time interpolated between old and new sources on coarser levels when and where time interpolation is needed and from the source data components on the source level into the destination data components otherwise. 
<p>
This form of schedule construction is typically used after regridding (where the source level is the patch level being replaced by the destination level in the patch hierarchy) or when the data on destination patch level is to be overwritten by data interpolated from coarser levels in the patch hierarchy. In the first case, data on the destination level will be copied from the source level in regions where those two levels overlap and filled with interpolated values from the hierarchy elsewhere. In the latter case, the source level pointer may be null. Then, data on the destination level will be filled using interpolated data from coarser hierarchy levels.<p>
In certain cases it may be necessary to perform time interpolation between old and new sources onto the destination level. In this case the optional argument use_time_interpolation should be set to true. Regardless of the value of this argument, time interpolation on coarser levels will always occur whenever needed.<p>
Note that when the source level pointer is non-null, the source and destination levels must correspond to the same index space.<p>
Note that the schedule remains valid as long as the patches on the levels involved in its creation do not change; thus, it can be used for multiple data communication cycles.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to refine schedule that performs the data transfers.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst_level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to destination level; cannot be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_level_mgr</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to destination level data manager; cannot be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to source level. This pointer may be null. In this case, data on the destination level will be filled only using interpolated data from coarser hierarchy levels. When this pointer is not null, the source level must live in the same AMR hierarchy index space as the destination level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_level_mgr</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to source level data mgr; cannot be null if src_level pointer is non-null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>next_coarser_level</em>&nbsp;</td><td>Integer number of next coarser patch level in a patch hierarchy relative to the destination level. Note that when the destination level has number zero (i.e., the coarsest level), this value should be &lt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to patch hierarchy from which data to fill level should come. This pointer may be null only when the next_coarser_level is &lt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td>Pointer to a refine patch strategy that provides user-defined physical boundary filling operations and user-defined spatial interpolation operations. If this patch strategy is null (default state), then no physical boundary filling or user-defined interpolation is performed. Note that this may cause problems since interpolation of data from coarser levels to some finer level may require physical boundary data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_time_interpolation</em>&nbsp;</td><td>Optional boolean flag to create the schedule with the ability to perform time interpolation Default is no time interpolation (false). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardLocallyActiveDataRefineTransactionFactory.html">StandardLocallyActiveDataRefineTransactionFactory</a> object will be used. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="68c5485bc265f82b51a53190352f5ab3"></a><!-- doxytag: member="SAMRAI::xfer::LocallyActiveDataRefineAlgorithm::printClassData" ref="68c5485bc265f82b51a53190352f5ab3" args="(std::ostream &amp;stream) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html">SAMRAI::xfer::LocallyActiveDataRefineAlgorithm</a>&lt; DIM &gt;::printClassData           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the refine algorithm state to the specified data stream.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Output data stream. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/transfer/datamovers/locally_active/<a class="el" href="LocallyActiveDataRefineAlgorithm_8h.html">LocallyActiveDataRefineAlgorithm.h</a><li>source/transfer/datamovers/locally_active/<a class="el" href="LocallyActiveDataRefineAlgorithm_8C.html">LocallyActiveDataRefineAlgorithm.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:29:09 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
