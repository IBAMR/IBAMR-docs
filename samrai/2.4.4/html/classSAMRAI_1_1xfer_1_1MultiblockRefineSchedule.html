<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::xfer::MultiblockRefineSchedule&lt; DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1xfer.html">xfer</a>::<a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html">MultiblockRefineSchedule</a></div>
<h1>SAMRAI::xfer::MultiblockRefineSchedule&lt; DIM &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::xfer::MultiblockRefineSchedule" --><code>#include &lt;source/transfer/multiblock/MultiblockRefineSchedule.h&gt;</code>
<p>
<a href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html#c71f9c3c7a00a5f4631988b081901602">MultiblockRefineSchedule</a> (const std::string &amp;fill_pattern, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockPatchLevel.html">hier::MultiblockPatchLevel</a>&lt; DIM &gt; &gt; dst_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockPatchLevel.html">hier::MultiblockPatchLevel</a>&lt; DIM &gt; &gt; src_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockPatchHierarchy.html">hier::MultiblockPatchHierarchy</a>&lt; DIM &gt; &gt; multiblock, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">xfer::RefineAlgorithm</a>&lt; DIM &gt; &gt; refine_alg, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory, <a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefinePatchStrategy.html">MultiblockRefinePatchStrategy</a>&lt; DIM &gt; *strategy, bool use_time_refinement=false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html#0829e76686ab6b33a664c15e1cb3f1a0">MultiblockRefineSchedule</a> (const std::string &amp;fill_pattern, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockPatchLevel.html">hier::MultiblockPatchLevel</a>&lt; DIM &gt; &gt; dst_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockPatchLevel.html">hier::MultiblockPatchLevel</a>&lt; DIM &gt; &gt; src_level, const int next_coarser_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockPatchHierarchy.html">hier::MultiblockPatchHierarchy</a>&lt; DIM &gt; &gt; multiblock, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">xfer::RefineAlgorithm</a>&lt; DIM &gt; &gt; refine_alg, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory, <a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefinePatchStrategy.html">MultiblockRefinePatchStrategy</a>&lt; DIM &gt; *strategy, bool use_time_refinement=false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html#b8508545f8b95e68c90148858ad40462">~MultiblockRefineSchedule</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html#61a21a4b4c0fe38e307d2843d47e0524">fillData</a> (double fill_time, bool do_physical_boundary_fill=true) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute the stored communication schedule and perform the data movement.  <a href="#61a21a4b4c0fe38e307d2843d47e0524"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html#303be10347de28aba8e1a9e566aab5bd">initializeSourceVector</a> (<a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">hier::ComponentSelector</a> &amp;allocate_vector) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a vector to contain source data components.  <a href="#303be10347de28aba8e1a9e566aab5bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">xfer::RefineClasses</a>&lt;<br>
 DIM &gt; &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html#f95c6a489b947bad5bdf5ccc6741d5b1">getEquivalenceClasses</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the equivalence classes associated with the algorithm that created this schedule.  <a href="#f95c6a489b947bad5bdf5ccc6741d5b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html#dceb9916bea3322f9ff0911885a695ab">allocateScratchSpace</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level, double fill_time, <a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">hier::ComponentSelector</a> &amp;allocate_vector) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate scratch space on the specified level and return the allocated patch data indices in the component selector for later deallocation.  <a href="#dceb9916bea3322f9ff0911885a695ab"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1xfer_1_1MultiblockRefineSchedule_1_1SingularityPatch.html">SingularityPatch</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">struct <a class="el" href="structSAMRAI_1_1xfer_1_1MultiblockRefineSchedule_1_1SingularityPatch.html">SingularityPatch</a> allows a temporary patch that contains data near a singularity to be paired with a block id number.  <a href="structSAMRAI_1_1xfer_1_1MultiblockRefineSchedule_1_1SingularityPatch.html#_details">More...</a><br></td></tr>
</table>
<h3>template&lt;int DIM&gt;<br>
 class SAMRAI::xfer::MultiblockRefineSchedule&lt; DIM &gt;</h3>

<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="c71f9c3c7a00a5f4631988b081901602"></a><!-- doxytag: member="SAMRAI::xfer::MultiblockRefineSchedule::MultiblockRefineSchedule" ref="c71f9c3c7a00a5f4631988b081901602" args="(const std::string &amp;fill_pattern, tbox::Pointer&lt; hier::MultiblockPatchLevel&lt; DIM &gt; &gt; dst_level, tbox::Pointer&lt; hier::MultiblockPatchLevel&lt; DIM &gt; &gt; src_level, tbox::Pointer&lt; hier::MultiblockPatchHierarchy&lt; DIM &gt; &gt; multiblock, tbox::Pointer&lt; xfer::RefineAlgorithm&lt; DIM &gt; &gt; refine_alg, tbox::Pointer&lt; xfer::RefineTransactionFactory&lt; DIM &gt; &gt; transaction_factory, MultiblockRefinePatchStrategy&lt; DIM &gt; *strategy, bool use_time_refinement=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html">SAMRAI::xfer::MultiblockRefineSchedule</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html">MultiblockRefineSchedule</a>           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>fill_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockPatchLevel.html">hier::MultiblockPatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockPatchLevel.html">hier::MultiblockPatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockPatchHierarchy.html">hier::MultiblockPatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>multiblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">xfer::RefineAlgorithm</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>refine_alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefinePatchStrategy.html">MultiblockRefinePatchStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_refinement</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor to create a <a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html">MultiblockRefineSchedule</a> that copies data from the interiors of source patch data components on the source level into the interiors and ghost cells of destination patch data components on the destination level. Only data on the intersection of the source and destination patch components will be copied. The source and destination patch levels must reside in the same Multiblock domain. In general, this constructor is called by a MultiblockRefineAlgorithm&lt;DIM&gt; object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fill_pattern</em>&nbsp;</td><td>Indicates which parts of the destination level to fill. See <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> for valid values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_level</em>&nbsp;</td><td>Pointer to destination level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_level</em>&nbsp;</td><td>Pointer to source level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>multiblock</em>&nbsp;</td><td>Multiblock patch hierarchy object containing all of the levels that hold the data being communicated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refine_alg</em>&nbsp;</td><td>Pointer to an xfer::RefineAlgorithm&lt;DIM&gt; that will be used to create refine schedules that will do the data transfers and communication. In general, this is a data member of the calling MultiblockRefineAlgorithm&lt;DIM&gt; object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>Transaction factory. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>strategy</em>&nbsp;</td><td>Pointer to a multiblock patch strategy object that provides user-defined boundary filling operations for patch boundaries that touch a multiblock singularity point, as well as user- defined physical boundary filling operations. This pointer may be null, in which case no boundary filling operations will occur. case no boundary filling operations will occur. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_time_refinement</em>&nbsp;</td><td>Let the destination level be filled using time refinement operations. This defaults to false because it should only be used in recursive calls within this class </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0829e76686ab6b33a664c15e1cb3f1a0"></a><!-- doxytag: member="SAMRAI::xfer::MultiblockRefineSchedule::MultiblockRefineSchedule" ref="0829e76686ab6b33a664c15e1cb3f1a0" args="(const std::string &amp;fill_pattern, tbox::Pointer&lt; hier::MultiblockPatchLevel&lt; DIM &gt; &gt; dst_level, tbox::Pointer&lt; hier::MultiblockPatchLevel&lt; DIM &gt; &gt; src_level, const int next_coarser_level, tbox::Pointer&lt; hier::MultiblockPatchHierarchy&lt; DIM &gt; &gt; multiblock, tbox::Pointer&lt; xfer::RefineAlgorithm&lt; DIM &gt; &gt; refine_alg, tbox::Pointer&lt; xfer::RefineTransactionFactory&lt; DIM &gt; &gt; transaction_factory, MultiblockRefinePatchStrategy&lt; DIM &gt; *strategy, bool use_time_refinement=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html">SAMRAI::xfer::MultiblockRefineSchedule</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html">MultiblockRefineSchedule</a>           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>fill_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockPatchLevel.html">hier::MultiblockPatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockPatchLevel.html">hier::MultiblockPatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>next_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockPatchHierarchy.html">hier::MultiblockPatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>multiblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">xfer::RefineAlgorithm</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>refine_alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefinePatchStrategy.html">MultiblockRefinePatchStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_refinement</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor to create a MultiblockRefineShedule that moves data from the interiors of source patch data components on the source level and coarser levels in the patch hierarchy into the interiors and ghost cells of destination patch data components on the destination level. Only data on the intersection of the source and destination patch components will be copied. If portions of the destination level remain unfilled, then the algorithm recursively fills those unfilled portions from coarser levels in the AMR hierarchy. The source and destination patch levels must reside in the same index space. However, the levels do not have to be in the same AMR patch hierarchy. In general, this constructor is called by a MultiblockRefineAlgorithm&lt;DIM&gt; object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fill_pattern</em>&nbsp;</td><td>Indicates which parts of the destination level to fill. See <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> for valid values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_level</em>&nbsp;</td><td>Pointer to destination level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_level</em>&nbsp;</td><td>Pointer to source level. This pointer may be null, in which case the destination level will be filled only using data interpolated from coarser levels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>next_coarser_level</em>&nbsp;</td><td>Integer number of next coarser level in relative to the destination level. Note that when the destination level has number zero (i.e., the coarsest level), this value should be &lt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>multiblock</em>&nbsp;</td><td>Multiblock object containing all of the levels that hold the data being communicated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refine_alg</em>&nbsp;</td><td>Pointer to an xfer::RefineAlgorithm&lt;DIM&gt; that will be used to create refine schedules that will do the data transfers and communication. In general, this is a data member of the calling MultiblockRefineAlgorithm&lt;DIM&gt; object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>Transaction factory. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>strategy</em>&nbsp;</td><td>Pointer to a multiblock patch strategy object that provides user-defined boundary filling operations for patch boundaries that touch a multiblock singularity point, as well as user- defined physical boundary filling operations. This pointer may be null, in which case no boundary filling operations will occur. case no boundary filling operations will occur. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_time_refinement</em>&nbsp;</td><td>Let the destination level be filled using time refinement operations. This defaults to false because it should only be used in recursive calls within this class </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b8508545f8b95e68c90148858ad40462"></a><!-- doxytag: member="SAMRAI::xfer::MultiblockRefineSchedule::~MultiblockRefineSchedule" ref="b8508545f8b95e68c90148858ad40462" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html">SAMRAI::xfer::MultiblockRefineSchedule</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html">MultiblockRefineSchedule</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual destructor 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="61a21a4b4c0fe38e307d2843d47e0524"></a><!-- doxytag: member="SAMRAI::xfer::MultiblockRefineSchedule::fillData" ref="61a21a4b4c0fe38e307d2843d47e0524" args="(double fill_time, bool do_physical_boundary_fill=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html">SAMRAI::xfer::MultiblockRefineSchedule</a>&lt; DIM &gt;::fillData           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_physical_boundary_fill</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute the stored communication schedule and perform the data movement. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fill_time</em>&nbsp;</td><td>Double simulation time when the fill take place. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>do_physical_boundary_fill</em>&nbsp;</td><td>Boolean flag used to bypass the physical boundary data filling operations on the destination level. The default value is true indicating that boundary data will be filled (assuming a non-null refine patch strategy pointer was passed to the createSchedule() function. Note that even when the value is false, boundary routines may be called on levels coarser than the destination level if such data is needed for proper interpolation. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="303be10347de28aba8e1a9e566aab5bd"></a><!-- doxytag: member="SAMRAI::xfer::MultiblockRefineSchedule::initializeSourceVector" ref="303be10347de28aba8e1a9e566aab5bd" args="(hier::ComponentSelector &amp;allocate_vector) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html">SAMRAI::xfer::MultiblockRefineSchedule</a>&lt; DIM &gt;::initializeSourceVector           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">hier::ComponentSelector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>allocate_vector</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a vector to contain source data components. 
<p>
The component selector argument will be filled with the data component id's that have been registered as source items for the algorithm that created this schedule 
</div>
</div><p>
<a class="anchor" name="f95c6a489b947bad5bdf5ccc6741d5b1"></a><!-- doxytag: member="SAMRAI::xfer::MultiblockRefineSchedule::getEquivalenceClasses" ref="f95c6a489b947bad5bdf5ccc6741d5b1" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">xfer::RefineClasses</a>&lt; DIM &gt; &gt; &amp; <a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html">SAMRAI::xfer::MultiblockRefineSchedule</a>&lt; DIM &gt;::getEquivalenceClasses           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the equivalence classes associated with the algorithm that created this schedule. 
<p>

</div>
</div><p>
<a class="anchor" name="dceb9916bea3322f9ff0911885a695ab"></a><!-- doxytag: member="SAMRAI::xfer::MultiblockRefineSchedule::allocateScratchSpace" ref="dceb9916bea3322f9ff0911885a695ab" args="(tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; level, double fill_time, hier::ComponentSelector &amp;allocate_vector) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html">SAMRAI::xfer::MultiblockRefineSchedule</a>&lt; DIM &gt;::allocateScratchSpace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">hier::ComponentSelector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>allocate_vector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate scratch space on the specified level and return the allocated patch data indices in the component selector for later deallocation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>Level on which to allocate scratch space </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fill_time</em>&nbsp;</td><td>Simulation time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>allocate_vector</em>&nbsp;</td><td>The patch data indices associated with scratch space will be stored here to be used later for deallocation </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/transfer/multiblock/<a class="el" href="MultiblockRefineSchedule_8h.html">MultiblockRefineSchedule.h</a><li>source/transfer/multiblock/<a class="el" href="MultiblockRefineSchedule_8C.html">MultiblockRefineSchedule.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:29:11 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
