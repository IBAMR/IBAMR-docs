<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::hier::LayerEdgeSet&lt; DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1hier.html">hier</a>::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a></div>
<h1>SAMRAI::hier::LayerEdgeSet&lt; DIM &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::hier::LayerEdgeSet" -->Encapsulates a set of DLBG edges that connect two <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a> objects.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/hierarchy/dlbg/LayerEdgeSet.h&gt;</code>
<p>
<a href="classSAMRAI_1_1hier_1_1LayerEdgeSet-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Algorithms for computing edge data</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#4920ba061b955a5ab6fa49133397fd50">findEdges</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discover and add edges between self and partner.  <a href="#4920ba061b955a5ab6fa49133397fd50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#cadc62d54f9ffc29446af95d0cf34714">bridge</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;edge_to_head, const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;edge_to_base)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the layer edge data by bridging the heads of two layer edges whose base nodes are identical to each other.  <a href="#cadc62d54f9ffc29446af95d0cf34714"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#e93466b9b9c1cfa51e16733dd1205c5b">replaceNodes</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;map)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace some nodes with others.  <a href="#e93466b9b9c1cfa51e16733dd1205c5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ed196aafeafca7e2fd608531714204dc">findEdges</a> (<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#453a82a7a55a9a28e2c19962f1abf6fa">a</a>, <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#e621b6d97e8da0c5028d78a69a4452bf">b</a>)</td></tr>

<tr><td colspan="2"><br><h2>For outputs, error checking and debugging.</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#6a74f870c9c4d255c34c32133458f6f5">printClassData</a> (std::ostream &amp;co, int debase_depth=0) const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#1da61184d137e2ba54a91b2a76254350">printEdgeStats</a> (std::ostream &amp;co) const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#e53c6f3fa7718a0ca96697b7ea1a9b66">checkNodeNabrCorrespondance</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that the node and neighbor containers have a one-to-one correspondance.  <a href="#e53c6f3fa7718a0ca96697b7ea1a9b66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#099ddfaa536ecbb2c12be9e88189f03b">checkNodeConsistency</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that the node referenced by connectivity match those in the partner's base <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>.  <a href="#099ddfaa536ecbb2c12be9e88189f03b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#2e233296f2152e5a8c906e737cdf2c56">checkConnectivity</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;head) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#893b915ed06131ec8722e419e830ae99">checkNodeConsistency</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a> &amp;local_nodes, const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> &amp;cnect, const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;head_layer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that nodes referenced by a given connectivity object match nodes in the given node containers.  <a href="#893b915ed06131ec8722e419e830ae99"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#16c7a3e816245aac62eda5fa36354ce4">ParallelState</a> { <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#16c7a3e816245aac62eda5fa36354ce4df2cc0623667ffde880ac3dc86f3021e">DISTRIBUTED</a>, 
<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#16c7a3e816245aac62eda5fa36354ce412c9c038f8596fbf43346a8a45541c3b">GLOBALIZED</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Names of parallel states.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#16c7a3e816245aac62eda5fa36354ce4">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1hier_1_1LayerNode.html">LayerNode</a>&lt; DIM &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#9c27bde9bfa42a11c1e9467be03fc9b4">Node</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1hier_1_1LayerNode.html#7119fea22553e2e6a399f862fcd83606">Node::LocalIndex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#585fead0a5477f20a132c56d64f8d371">LocalIndex</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM <br>
&gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Container for nodes.  <a href="#4e9c7ecdb5c4e0da6faa38807252324a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM <br>
&gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#c7bff8b71e87a5ece283b9ecb18064d9">NabrContainer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Container for neighbors.  <a href="#c7bff8b71e87a5ece283b9ecb18064d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#585fead0a5477f20a132c56d64f8d371">LocalIndex</a>,<br>
 <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#c7bff8b71e87a5ece283b9ecb18064d9">NabrContainer</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connectivity data between two node layers.  <a href="#92056ee8a1bfc452f200b7793f71e4bb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#eb90c4d886792bf0b2879cf975c7a633">LayerEdgeSet</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#eb90c4d886792bf0b2879cf975c7a633"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#c43e84fb7d1875692b1a44e5e1934a1a">~LayerEdgeSet</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#c43e84fb7d1875692b1a44e5e1934a1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#3b0ef31951c4d55e7e9f25ed0a5b1b71">getNodeContainer</a> (const int rank=-1) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#3b78364b1abc01207afe44eadd65501a">getConnectivity</a> (const int rank=-1) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#c0c3040ea3a04dc0aebce8064b206329">getBaseRefinementRatio</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#acb6cfeda2d9021ca394b8ddd5d9d789">getHeadRefinementRatio</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#5926ce17da6c6f571c200f60b5d81bd8">attachPartner</a> (<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;partner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutually attach to another layer-edge object to create a bi-directional set of edges.  <a href="#5926ce17da6c6f571c200f60b5d81bd8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#3a9ec3fd4fdc490d910aebc5483252cc">createPartner</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;partner_base, const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> *partner_connectivity=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a8b92291247111fcf50f4c969da064b8">getPartner</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the attached partner.  <a href="#a8b92291247111fcf50f4c969da064b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#e21a8d920e7086eefa8ec73e65582a39">getPartner</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the attached partner.  <a href="#e21a8d920e7086eefa8ec73e65582a39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#d2759591af37611b264a535126585eed">initialize</a> (<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#16c7a3e816245aac62eda5fa36354ce4">ParallelState</a> parallel_state, const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;base_layer, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;head_refinement_ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;gcw=<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt;(1), const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> *connectivity=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set data defining the edge set.  <a href="#d2759591af37611b264a535126585eed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#d93b7d29375ac737b46eabe9c915499e">operator=</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator duplicates edge data and reference to layer node set and sets up a similar partner relationship and parallel mode.  <a href="#d93b7d29375ac737b46eabe9c915499e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#82333be5c13f66297d2a69a161eab592">setParallelState</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#16c7a3e816245aac62eda5fa36354ce4">ParallelState</a> parallel_state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the parallel distribution state.  <a href="#82333be5c13f66297d2a69a161eab592"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#16c7a3e816245aac62eda5fa36354ce4">ParallelState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#f3a829e7487614cc0c89c2681110f299">getParallelState</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#eb4f16febdef841a55c17fef1b6f9a13">deallocateData</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate internal data on nodes and neighbors.  <a href="#eb4f16febdef841a55c17fef1b6f9a13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#4ff4abf0f084c7727f47cb362fde4bc3">setMaxGhostCellWidth</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;gcw)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the max ghost cell width used to check for box intersections.  <a href="#4ff4abf0f084c7727f47cb362fde4bc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#c9fa2f8f06def86a351a6489d0b1e8e0">getMaxGhostCellWidth</a> () const</td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1LayerEdgeSet_1_1CommunicationStruct.html">CommunicationStruct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data sorted by a hash.  <a href="structSAMRAI_1_1hier_1_1LayerEdgeSet_1_1CommunicationStruct.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class SAMRAI::hier::LayerEdgeSet&lt; DIM &gt;</h3>

Encapsulates a set of DLBG edges that connect two <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a> objects. 
<p>
<b>Distributed</b> <b>Layered</b> <b>Box-graph</b> (DLBG):<p>
A box-graph is a graph where the <b>nodes</b> correspond to boxes and <b>edges</b> connect neighboring nodes. Two nodes are <b>neighbors</b> if their boxes <b>overlap</b> when one is grown by some nominal <b>ghost-cell-width</b>. Each edge is defined by the two nodes it connects. The box-graph is useful in SAMR because it shows which boxes directly interact with each other.<p>
We can organize nodes of a box-graph into groups of boxes defined on the same index space. When sorted from coarsest to finest index spaces, the nodes fall into distinct <b>layers</b>. A "layer" is similar to a level in the hierarchy in that patches in a level share the same index space. We use layer instead of level to differentiate the graph from the hierarchy and because a layer does not necessarily have a one-to-one association with a level.<p>
For convenience, we define<ul>
<li><b>layer-node</b>: A set of nodes in same layer (defined on the same index space). This is encapsulated in the class <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>.</li><li><b>layer-edge</b>: Set of edges incident from a layer-node. This is encapsulated in the class <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>.</li></ul>
<p>
An edge is directional, like an arrow, starting at a <b>base</b> node and ending at a <b>head</b> node. Each pair of neighboring nodes has two edges, pointing in opposite directions. This goes also for <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a> and <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> objects. A single <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> object represents a set of directed edges incident from one base <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a> to one head <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>. The edges pointing in the oposite direction are stored in a separate <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> object.<p>
An object of this class can be <em>partnered</em> with another object that represents the directed edges in the opposite direction. The head of one partner is the base of the other. The partner does not provide additional information but it does organize the information differently. If the edge data is represented as a matrix, then one partner is the transpose of the other. A partnership allows both objects to be modified simultaneously so that their data is consistent. This avoids having to modify one after the other, which is problematic because the second modification begins with inconsistent data.<p>
Two layers may contain edges in opposite directions and not be attached; but they would not be automatically coordinated in that case.<p>
In parallel, a <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a> can also be in distributed or globalized (see <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>). A locally-owned node is called a local node. Nodes owned by other processors are remote notes. Remote nodes are stilled called remote nodes when the <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a> is globalized. Local knowledge of a remote node does not make it local.<p>
In parallel, we may partition the layer-edge and store it across many processors. The edge are classified as follows:<ul>
<li><b>Local</b> <b>edges</b> are incident from a local base and incident to two local head.</li><li><b>Semi-local</b> <b>edges</b> are incident from a local base and incident to a remote head.</li><li><b>Remote</b> <b>edges</b> connect two remote nodes.</li></ul>
<p>
The <b>parallel</b> <b>state</b> of a <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> object can be:<ol type=1>
<li><b>DISTRIBUTED:</b> An object in this state stores only edges incident from local nodes.</li><li><b>GLOBALIZED:</b> In this state, the edges are globally duplicated on all processors.</li></ol>
<p>
The distribution state is changed by <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#82333be5c13f66297d2a69a161eab592">setParallelState()</a>. Going to a more distributed state primarily means deallocating data, but going to a more serial state requires sharing of data (communicating). Currently, collected state for <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> objects seems to be unneeded.<p>
The general attributes of a <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> are:<ul>
<li>the base <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a> (a reference to an external object).</li><li>the ghost cell width to grow the base nodes when checking overlaps.</li><li>the connectivity (table of neighbors for nodes in the base <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>).</li><li>the attached partner, if any.</li><li>the parallel state.</li></ul>
<p>
The connectivity depends on the base <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a> and the ghost-cell-width, so it is discarded when either of these is manually changed. 
<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="9c27bde9bfa42a11c1e9467be03fc9b4"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::Node" ref="9c27bde9bfa42a11c1e9467be03fc9b4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1hier_1_1LayerNode.html">LayerNode</a>&lt;DIM&gt; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerNode.html">Node</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="585fead0a5477f20a132c56d64f8d371"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::LocalIndex" ref="585fead0a5477f20a132c56d64f8d371" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1hier_1_1LayerNode.html#7119fea22553e2e6a399f862fcd83606">Node::LocalIndex</a> <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#585fead0a5477f20a132c56d64f8d371">LocalIndex</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4e9c7ecdb5c4e0da6faa38807252324a"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::NodeContainer" ref="4e9c7ecdb5c4e0da6faa38807252324a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt;DIM&gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a> <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Container for nodes. 
<p>
This is a sorted container so that it can be compared without expensive searches. A node can be removed or added without changing the indices of existing nodes. 
</div>
</div><p>
<a class="anchor" name="c7bff8b71e87a5ece283b9ecb18064d9"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::NabrContainer" ref="c7bff8b71e87a5ece283b9ecb18064d9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt;DIM&gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a> <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#c7bff8b71e87a5ece283b9ecb18064d9">NabrContainer</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Container for neighbors. 
<p>

</div>
</div><p>
<a class="anchor" name="92056ee8a1bfc452f200b7793f71e4bb"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::Connectivity" ref="92056ee8a1bfc452f200b7793f71e4bb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#585fead0a5477f20a132c56d64f8d371">LocalIndex</a>,<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#c7bff8b71e87a5ece283b9ecb18064d9">NabrContainer</a>&gt; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connectivity data between two node layers. 
<p>
The connectivity <code>m</code> maps a node with index <code>i</code> to a set of nodes <code>m</code>[i], usually its neighbors. (The neighbors data is a container of nodes.)<p>
Because Connectivity is indexed by the LocalIndex instead of a combined owner and LocalIndex, each Connectivity object is implicitly associated with just one owner process. 
</div>
</div><p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="16c7a3e816245aac62eda5fa36354ce4"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::ParallelState" ref="16c7a3e816245aac62eda5fa36354ce4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#16c7a3e816245aac62eda5fa36354ce4">SAMRAI::hier::LayerEdgeSet::ParallelState</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Names of parallel states. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="16c7a3e816245aac62eda5fa36354ce4df2cc0623667ffde880ac3dc86f3021e"></a><!-- doxytag: member="DISTRIBUTED" ref="16c7a3e816245aac62eda5fa36354ce4df2cc0623667ffde880ac3dc86f3021e" args="" -->DISTRIBUTED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="16c7a3e816245aac62eda5fa36354ce412c9c038f8596fbf43346a8a45541c3b"></a><!-- doxytag: member="GLOBALIZED" ref="16c7a3e816245aac62eda5fa36354ce412c9c038f8596fbf43346a8a45541c3b" args="" -->GLOBALIZED</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="eb90c4d886792bf0b2879cf975c7a633"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::LayerEdgeSet" ref="eb90c4d886792bf0b2879cf975c7a633" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
The default constructor creates empty object in distributed state. 
</div>
</div><p>
<a class="anchor" name="c43e84fb7d1875692b1a44e5e1934a1a"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::~LayerEdgeSet" ref="c43e84fb7d1875692b1a44e5e1934a1a" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
Deallocate internal data. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="3b0ef31951c4d55e7e9f25ed0a5b1b71"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::getNodeContainer" ref="3b0ef31951c4d55e7e9f25ed0a5b1b71" args="(const int rank=-1) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a> &amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getNodeContainer           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rank</em> = <code>-1</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3b78364b1abc01207afe44eadd65501a"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::getConnectivity" ref="3b78364b1abc01207afe44eadd65501a" args="(const int rank=-1) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> &amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getConnectivity           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rank</em> = <code>-1</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c0c3040ea3a04dc0aebce8064b206329"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::getBaseRefinementRatio" ref="c0c3040ea3a04dc0aebce8064b206329" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getBaseRefinementRatio           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="acb6cfeda2d9021ca394b8ddd5d9d789"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::getHeadRefinementRatio" ref="acb6cfeda2d9021ca394b8ddd5d9d789" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getHeadRefinementRatio           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="5926ce17da6c6f571c200f60b5d81bd8"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::attachPartner" ref="5926ce17da6c6f571c200f60b5d81bd8" args="(LayerEdgeSet &amp;partner)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::attachPartner           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>partner</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mutually attach to another layer-edge object to create a bi-directional set of edges. 
<p>
<b>Preconditions</b> on the partner and this object:<ol type=1>
<li>The base refinement ratio of one partner and the head ratio of the other must be equal, and vice versa.</li><li>The product of the base refinement ratio and the ghost-cell-width musb be the same for the partners. This ensures that the overlap check gives the same result regardless of the layer whose boxes are grown for the overlap check. For the extent of the partnership, this requirement must be met. Resetting the ghost-cell-width of one partner forces the ghost-cell-width of the partner to change to meet this requirement.</li></ol>
<p>
Both objects must be in the same parallel state. Their parallel states will change together for the the duration of the partnership.<p>
Both objects are modified to reference each other as mutual partners. Both objects must be unpartnered. Multiple partners are not allowed. Once two layer edges objects are attached, they are synchronized when either calls a synchronizing method. Synchronizing means making all edges between them seen by both objects. (This does not mean that remote edges are seen in DISTRIBUTED modes though.)<p>
The relationship between two attached objects is symmetric, that is, <code>a.attach(b)</code> has the same effect as <code>b.attach(a)</code>. It is permissible to pass *this in for partner, which is how peer edges are set up.<p>
Since the partner is not created internally, it is NOT explicitly deleted when this object goes out of scope. It will simply be detached. This is in contrast to <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#3a9ec3fd4fdc490d910aebc5483252cc">createPartner()</a>. 
</div>
</div><p>
<a class="anchor" name="3a9ec3fd4fdc490d910aebc5483252cc"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::createPartner" ref="3a9ec3fd4fdc490d910aebc5483252cc" args="(const LayerNodeSet&lt; DIM &gt; &amp;partner_base, const Connectivity *partner_connectivity=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::createPartner           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>partner_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> *&nbsp;</td>
          <td class="paramname"> <em>partner_connectivity</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a8b92291247111fcf50f4c969da064b8"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::getPartner" ref="a8b92291247111fcf50f4c969da064b8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getPartner           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access the attached partner. 
<p>
Error if no partner is attached. 
</div>
</div><p>
<a class="anchor" name="e21a8d920e7086eefa8ec73e65582a39"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::getPartner" ref="e21a8d920e7086eefa8ec73e65582a39" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getPartner           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access the attached partner. 
<p>
Error if no partner is attached. 
</div>
</div><p>
<a class="anchor" name="d2759591af37611b264a535126585eed"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::initialize" ref="d2759591af37611b264a535126585eed" args="(ParallelState parallel_state, const LayerNodeSet&lt; DIM &gt; &amp;base_layer, const hier::IntVector&lt; DIM &gt; &amp;head_refinement_ratio, const hier::IntVector&lt; DIM &gt; &amp;gcw=hier::IntVector&lt; DIM &gt;(1), const Connectivity *connectivity=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::initialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#16c7a3e816245aac62eda5fa36354ce4">ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>base_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>head_refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gcw</em> = <code><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;&nbsp;DIM&nbsp;&gt;(1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> *&nbsp;</td>
          <td class="paramname"> <em>connectivity</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set data defining the edge set. 
<p>
The object must not be attached to a partner. This method resets enough data to make coordination with partners irrelevant. You must detach the partner (if any) before calling this method. There should be no reason to use this method while attached.<p>
A reference is made to the given <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>. The ghost cell width is copied. If <code>connectivity</code> is given, a copy is made from it. This is meant for use when you have an external means for computing the connectivity data. (The accuracy and consistency of the connectivity is not checked!) If <code>connectivity</code> is not given, it should be created using <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#4920ba061b955a5ab6fa49133397fd50">findEdges()</a> before calling a method that uses it.<p>
The parallel state is initialized to the given <code>parallel_state</code>. If state is GLOBALIZED:<ul>
<li><code>base_layer</code> must be in GLOBALIZED mode.</li><li>connectivity (if given) must be an array the length of the number of processes, describing the local and semi-local edges for each process.</li></ul>
<p>
A reference is made to the given <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>, replacing the current node reference.<p>
When debug is enabled, some checks are made to assert that base_layer and connectivity are consistent with each other. 
</div>
</div><p>
<a class="anchor" name="d93b7d29375ac737b46eabe9c915499e"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::operator=" ref="d93b7d29375ac737b46eabe9c915499e" args="(const LayerEdgeSet &amp;r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator duplicates edge data and reference to layer node set and sets up a similar partner relationship and parallel mode. 
<p>
If <code>r</code> is attached to itself, self-attach. If <code>r</code> is attached but not to itself, create a duplicate partner and attach to it.<p>
All other data is directly copied. 
</div>
</div><p>
<a class="anchor" name="4920ba061b955a5ab6fa49133397fd50"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::findEdges" ref="4920ba061b955a5ab6fa49133397fd50" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::findEdges           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Discover and add edges between self and partner. 
<p>
Obviously, a partner must be attached. Neighbor information on both the object and its partner is modified. The effect is the same as if <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#4920ba061b955a5ab6fa49133397fd50">findEdges()</a> were called for the partner.<p>
This method simply calls <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ed196aafeafca7e2fd608531714204dc">findEdges(LayerEdgeSet &amp;a, LayerEdgeSet &amp;b)</a> with the partner in the argument. See that method for communication implications.<p>
If the partner is the same object (finding peer edges), edges between a node and itself will be ignored. 
</div>
</div><p>
<a class="anchor" name="ed196aafeafca7e2fd608531714204dc"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::findEdges" ref="ed196aafeafca7e2fd608531714204dc" args="(LayerEdgeSet &amp;a, LayerEdgeSet &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::findEdges           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cadc62d54f9ffc29446af95d0cf34714"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::bridge" ref="cadc62d54f9ffc29446af95d0cf34714" args="(const LayerEdgeSet &amp;edge_to_head, const LayerEdgeSet &amp;edge_to_base)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::bridge           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>edge_to_head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>edge_to_base</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create the layer edge data by bridging the heads of two layer edges whose base nodes are identical to each other. 
<p>
<div class="fragment"><pre class="fragment">

        (bridge base)  ------------bridge-------------&gt;  (bridge head)
                       &lt;-------reverse bridge----------        
              ^                                                ^
              |                                                |
              |                                                |
              |                                                |
              +--edge to base-- (middle layer) --edge to head--+

     </pre></div><p>
The bases of the two given layers are known as the middle layer. For each node in this layer, the two given layers give the sets of neighboring nodes at the head and base layers of the current object. These two sets are checked against each other for node intersections.<p>
Conditions:<ol type=1>
<li><code>edge_to_head</code> and <code>edge_to_base</code> must be incident from identical sets of nodes.</li><li><code>edge_to_head</code> and <code>edge_to_base</code> must have attached partners.</li><li>Any parallel state is allowed, but states must be consistent between all <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> objects.</li><li>At least one of the head or base layers must be completely nested in the middle layer. If neither is nested, some edges may be missed.</li></ol>
<p>
To find peer edges, use identical layer-edges for the leg to head and leg to base.<p>
A partner must be attached. 
</div>
</div><p>
<a class="anchor" name="e93466b9b9c1cfa51e16733dd1205c5b"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::replaceNodes" ref="e93466b9b9c1cfa51e16733dd1205c5b" args="(const LayerEdgeSet &amp;map)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::replaceNodes           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace some nodes with others. 
<p>
Given the <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> object <code>map</code>, which maps some nodes in the head of the current <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> to new nodes (also in the head), replace each given node in the head layer by its neighbors in the tail of <code>map</code>.<p>
<div class="fragment"><pre class="fragment">
                               map
                 (old head) ---------&gt; (new head)
                          ^            ^
                           \          /
     edge before mapping -&gt; \        / &lt;- edge after mapping
                             \      /
                              \    /
                              (base)
     </pre></div><p>
Representing the map by a <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> implicitly requires that any set of nodes replacing an old node must overlap the old ones they replace. A special algorithm taking advantage of this restriction is used to update this object. If you want to manipulate the edge data generally, <em>DO</em> <em>NOT</em> use this method.<p>
<code>map</code> is a layer edge from nodes to be removed to nodes to be in its place. If any edges in <code>map</code> references nodes not locally owned, communication with the owner is triggered. In these cases, it is <em>CRITICAL</em> that the same mapping is introduced on the owner processes.<p>
We could do the same with a <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#cadc62d54f9ffc29446af95d0cf34714">bridge()</a> operation centered at the tail of the map. but that requires that <code>map</code> maps the unchanged nodes in the tail to itself, and it also requires doing work to map unchanged nodes to themselves. This is a lot of extra overhead when map is very small. If <code>map</code> maps each unchanged node to itself, <code>a.replaceNodes(map)</code> is equivalent to <code>a.bridge</code>(map,a.getPartner()).<p>
The partner's base will be replaced by the new head.<p>
Conditions:<ol type=1>
<li><code>map</code> must be based at the head of the current object.</li><li><code>map</code> and the current object must have attached partners.</li><li>Any parallel state is allowed, but states must be consistent between all <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> objects.</li><li><code>map</code> must not map any node outside the range of the node's current box.</li></ol>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>Mapping between old head and new head. A partner must be attached. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="82333be5c13f66297d2a69a161eab592"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::setParallelState" ref="82333be5c13f66297d2a69a161eab592" args="(const ParallelState parallel_state)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::setParallelState           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#16c7a3e816245aac62eda5fa36354ce4">ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the parallel distribution state. 
<p>
Before putting a <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> in a GLOBALIZED state, The <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a> given in <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#d2759591af37611b264a535126585eed">initialize()</a> must already be in GLOBALIZED mode. The layer-node set must always be in GLOBALIZED mode as long as the layer-edge set is.<p>
In GLOBALIZED state, the entire layer is independently duplicated on every process. (For consistency, it is imperative that the layer is operated on uniformly across all processes.) All edges (not just local and semilocal) are found when operations to find them are executed.<p>
This method is not necessarily trivial. More memory is required to store additional parts of the graph.<p>
If a partner is attached, the parallel state of the partner is affected the same way.<p>
Changing parallel state preserves existing neighbor information used by the new parallel state. Neighbor information not used by the new parallel state gets deallocated.<p>
For efficiency reasons, this method NEVER implicitly discovers new neighbor information after going to a GLOBALIZED state. To get this data, call <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#4920ba061b955a5ab6fa49133397fd50">findEdges()</a> explicitly.<p>
For serial (one processor) runs, there is no difference between the parallel states (except for the names), and there is no real cost for switching parallel states. 
</div>
</div><p>
<a class="anchor" name="f3a829e7487614cc0c89c2681110f299"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::getParallelState" ref="f3a829e7487614cc0c89c2681110f299" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#16c7a3e816245aac62eda5fa36354ce4">ParallelState</a> <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getParallelState           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="eb4f16febdef841a55c17fef1b6f9a13"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::deallocateData" ref="eb4f16febdef841a55c17fef1b6f9a13" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::deallocateData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deallocate internal data on nodes and neighbors. 
<p>
If a partner exists, its internal data is deallocated also. This method does <em>NOT</em> detach the partner. 
</div>
</div><p>
<a class="anchor" name="4ff4abf0f084c7727f47cb362fde4bc3"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::setMaxGhostCellWidth" ref="4ff4abf0f084c7727f47cb362fde4bc3" args="(const hier::IntVector&lt; DIM &gt; &amp;gcw)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::setMaxGhostCellWidth           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gcw</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the max ghost cell width used to check for box intersections. 
<p>
The default max ghost cell width is 1. The max ghost cell width affects the overlap comparison, so the old edge data is no longer valid. The old data is discarded. For efficiency reasons, new edge data is not automatically generated. To get this data, call <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#4920ba061b955a5ab6fa49133397fd50">findEdges()</a> explicitly.<p>
For attached <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> objects, the ratio of the ghost-cell-width of the two partners must be equal to the inverse ratio of their base layer refinement ratios. This ensures that the overlap check gives the same result regardless of the layer whose boxes are grown for the overlap check. If a partner is attached, the partner's ghost-cell-width is automatically changed to satisfy this requirement. 
</div>
</div><p>
<a class="anchor" name="c9fa2f8f06def86a351a6489d0b1e8e0"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::getMaxGhostCellWidth" ref="c9fa2f8f06def86a351a6489d0b1e8e0" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getMaxGhostCellWidth           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6a74f870c9c4d255c34c32133458f6f5"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::printClassData" ref="6a74f870c9c4d255c34c32133458f6f5" args="(std::ostream &amp;co, int debase_depth=0) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::printClassData           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>co</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>debase_depth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1da61184d137e2ba54a91b2a76254350"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::printEdgeStats" ref="1da61184d137e2ba54a91b2a76254350" args="(std::ostream &amp;co) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::printEdgeStats           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>co</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e53c6f3fa7718a0ca96697b7ea1a9b66"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::checkNodeNabrCorrespondance" ref="e53c6f3fa7718a0ca96697b7ea1a9b66" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::checkNodeNabrCorrespondance           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that the node and neighbor containers have a one-to-one correspondance. 
<p>

</div>
</div><p>
<a class="anchor" name="099ddfaa536ecbb2c12be9e88189f03b"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::checkNodeConsistency" ref="099ddfaa536ecbb2c12be9e88189f03b" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::checkNodeConsistency           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that the node referenced by connectivity match those in the partner's base <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>. 
<p>
Obviously, the object must have a partner. If the partner's base is not GLOBALIZED, a temporary copy is made and globalized for checking, triggering communication. 
</div>
</div><p>
<a class="anchor" name="893b915ed06131ec8722e419e830ae99"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::checkNodeConsistency" ref="893b915ed06131ec8722e419e830ae99" args="(const NodeContainer &amp;local_nodes, const Connectivity &amp;cnect, const LayerNodeSet&lt; DIM &gt; &amp;head_layer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::checkNodeConsistency           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>local_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cnect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>head_layer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that nodes referenced by a given connectivity object match nodes in the given node containers. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>local_nodes</em>&nbsp;</td><td>A node container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cnect</em>&nbsp;</td><td>Connectivity data for <code>nodes</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>head_layer</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a> describing the head with respect to the given connectivity. This object must be in GLOBALIZED state. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2e233296f2152e5a8c906e737cdf2c56"></a><!-- doxytag: member="SAMRAI::hier::LayerEdgeSet::checkConnectivity" ref="2e233296f2152e5a8c906e737cdf2c56" args="(const LayerNodeSet&lt; DIM &gt; &amp;head) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::checkConnectivity           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>head</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assert that connectivity data is correct for the base and head (partner's base).<p>
This is an expensive operation and should only be used for debugging. It creates a globalized version of the layer-node data (if this data is not already globalized), uses the data to compute the edges and compares the result to the current edges.<p>
The object must be partnered and be in hybrid mode for checking to work.<p>
Checking is done as follows:<ul>
<li>Rebuild the edge containers by finding edges in hybrid mode.</li><li>Check that the rebuilt containers match the existing containers.</li></ul>
<p>
Currently, the rebuilt edges are rebuilt using <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#4920ba061b955a5ab6fa49133397fd50">findEdges()</a>. Thus, it may be pointless to use this method as a check for that method. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/hierarchy/dlbg/<a class="el" href="LayerEdgeSet_8h.html">LayerEdgeSet.h</a><li>source/hierarchy/dlbg/<a class="el" href="LayerEdgeSet_8C.html">LayerEdgeSet.C</a><li>source/hierarchy/dlbg/<a class="el" href="LayerEdgeSet_8I.html">LayerEdgeSet.I</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:28:28 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
