<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::algs::TimeRefinementLevelStrategy&lt; DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1algs.html">algs</a>::<a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">TimeRefinementLevelStrategy</a></div>
<h1>SAMRAI::algs::TimeRefinementLevelStrategy&lt; DIM &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::algs::TimeRefinementLevelStrategy" --><code>#include &lt;source/algorithm/time_refinement/TimeRefinementLevelStrategy.h&gt;</code>
<p>
Inheritance diagram for SAMRAI::algs::TimeRefinementLevelStrategy&lt; DIM &gt;:<p><center><img src="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy__inherit__graph.png" border="0" usemap="#SAMRAI_1_1algs_1_1TimeRefinementLevelStrategy_3_01DIM_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="SAMRAI_1_1algs_1_1TimeRefinementLevelStrategy_3_01DIM_01_4__inherit__map">
<area href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html" shape="rect" coords="20,83,332,107" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#2047624bbe5207ce693f1d84f9d84e24">TimeRefinementLevelStrategy</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#d01eabd060bb195c3b7ddf07076d3017">~TimeRefinementLevelStrategy</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#cb88d5246caafc99aa7fef43226632c0">initializeLevelIntegrator</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt; &gt; gridding_alg)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#f5544ec884f172aabead44feb9f764db">getLevelDt</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt; level, const double dt_time, const bool initial_time)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#e6950b81e4dc879fcc73cd2afb08a46a">getMaxFinerLevelDt</a> (const int finer_level_number, const double coarse_dt, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ratio)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#25ebe8ba35f779028d36e16125b8548c">advanceLevel</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt; level, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const double current_time, const double new_time, const bool first_step, const bool last_step, const bool regrid_advance=false)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#3d9e05288798d49b0000d9737abfa8bf">standardLevelSynchronization</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const int coarsest_level, const int finest_level, const double sync_time, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt; &amp;old_times)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#60a7d60226275e8e8001a0b4c08f9ade">standardLevelSynchronization</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const int coarsest_level, const int finest_level, const double sync_time, const double old_time)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#ab60d668b4eb7dc4fd9cf76f29741c35">synchronizeNewLevels</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const int coarsest_level, const int finest_level, const double sync_time, const bool initial_time)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#0066b6a5d5ab832cde700334b026f34d">resetTimeDependentData</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt; level, const double new_time, const bool can_be_refined)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#b1fa8864fdce4073cc0ad8d4066635f6">resetDataToPreadvanceState</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt; level)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#ccf94f247f5e6388b93d101d73c93850">usingRefinedTimestepping</a> () const=0</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class SAMRAI::algs::TimeRefinementLevelStrategy&lt; DIM &gt;</h3>

Class TimeRefinementLevelStrategy&lt;DIM&gt; is an abstract base class that defines the interface to level integration and synchronization routines needed by the hierarchy integration class TimeRefinementIntegrator&lt;DIM&gt;. In particular, this class insulates the hierarchy integrator from the routines that manipulate data on the hierarchy levels in a problem-specific fashion. When the AMR hierarchy integration and regridding sequence provided by the class TimeRefinementIntegrator&lt;DIM&gt; are appropriate for some computational problem, a subclass of this base class can be used to provide the necessary operations to the hierarchy integrator. That is, a TimeRefinementIntegrator&lt;DIM&gt; object may be configured with a concrete implementation of this base class by passing the concrete object into the to the time refinement integrator constructor.<p>
Three functions in this class are defined as virtual rather than pure virtual, and default implementations are provided. This is done to allow for an implementation of this strategy class that is used by the time refinement integrator only for refined timestepping or only for synchronized timestepping. If an implementation is only used for refined timestepping, getMaxLevelDt() and one version of <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#3d9e05288798d49b0000d9737abfa8bf">standardLevelSynchronization()</a> must be overloaded in the concrete class. If an implementation is only used for synchronized timestepping, the other version of standardLevelSynchronization must be overloaded. If an implementation supports both refined and synchronized timestepping, all three virtual functions must be overloaded.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementIntegrator.html">algs::TimeRefinementIntegrator</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="2047624bbe5207ce693f1d84f9d84e24"></a><!-- doxytag: member="SAMRAI::algs::TimeRefinementLevelStrategy::TimeRefinementLevelStrategy" ref="2047624bbe5207ce693f1d84f9d84e24" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">SAMRAI::algs::TimeRefinementLevelStrategy</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">TimeRefinementLevelStrategy</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor for TimeRefinementLevelStrategy&lt;DIM&gt;. 
</div>
</div><p>
<a class="anchor" name="d01eabd060bb195c3b7ddf07076d3017"></a><!-- doxytag: member="SAMRAI::algs::TimeRefinementLevelStrategy::~TimeRefinementLevelStrategy" ref="d01eabd060bb195c3b7ddf07076d3017" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">SAMRAI::algs::TimeRefinementLevelStrategy</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">TimeRefinementLevelStrategy</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual destructor for TimeRefinementLevelStrategy&lt;DIM&gt;. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="cb88d5246caafc99aa7fef43226632c0"></a><!-- doxytag: member="SAMRAI::algs::TimeRefinementLevelStrategy::initializeLevelIntegrator" ref="cb88d5246caafc99aa7fef43226632c0" args="(tbox::Pointer&lt; mesh::BaseGriddingAlgorithm&lt; DIM &gt; &gt; gridding_alg)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">SAMRAI::algs::TimeRefinementLevelStrategy</a>&lt; DIM &gt;::initializeLevelIntegrator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>gridding_alg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the state of the integrator that performs time advances on the levels of the hierarchy. Typically, this involves setting up information, such as communication algorithms, to manage variable storage. The pointer to the gridding algorithm is provided so that the integrator may access information about regridding procedures or the structure the hierarchy, which is not yet created. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#f8815a27a04280aa73e23cc7a6da84f1">SAMRAI::algs::HyperbolicLevelIntegrator&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="f5544ec884f172aabead44feb9f764db"></a><!-- doxytag: member="SAMRAI::algs::TimeRefinementLevelStrategy::getLevelDt" ref="f5544ec884f172aabead44feb9f764db" args="(const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level, const double dt_time, const bool initial_time)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">SAMRAI::algs::TimeRefinementLevelStrategy</a>&lt; DIM &gt;::getLevelDt           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>dt_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return appropriate time increment for given level in the patch hierarchy. This routine is called during the initial generation of the AMR patch hierarchy and possibly during regridding if time regridding uses a time advance. It should be assumed that the only data that exists on the level when this routine is called is that which is needed to initialize the level. The initial_time boolean flag is true if this routine is called at the initial simulation time (i.e., when hierarchy is generated for first time); otherwise (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., at an advance step) it is false.<p>
The recompute_dt option specifies whether to compute the timestep using the current level data or to return the value stored by the time integrator. The default true setting means the timestep will be computed if no value is supplied. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#034e077581c3b102ac0862a9ea2d1fb1">SAMRAI::algs::HyperbolicLevelIntegrator&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="e6950b81e4dc879fcc73cd2afb08a46a"></a><!-- doxytag: member="SAMRAI::algs::TimeRefinementLevelStrategy::getMaxFinerLevelDt" ref="e6950b81e4dc879fcc73cd2afb08a46a" args="(const int finer_level_number, const double coarse_dt, const hier::IntVector&lt; DIM &gt; &amp;ratio)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">SAMRAI::algs::TimeRefinementLevelStrategy</a>&lt; DIM &gt;::getMaxFinerLevelDt           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finer_level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>coarse_dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the maximum allowable time increment for level in the hierarchy with the given level number. The point of this routine is to determine the increment for that level based on the current time increment used on the next coarser level. The coarse dt is the current time step size for the next coarser level. The ratio is the mesh refinement ratio between the two levels.<p>
This is defined as a virtual function, and it is only used by the time refinement integrator for refined timestepping. It should be overloaded in any concrete implementation of this class that is used for refined timestepping, but need not be overloaded in an implementation that is used only for synchronized timestepping. 
<p>
Reimplemented in <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#766ef40c910dffa6b9e01d58ad8aec17">SAMRAI::algs::HyperbolicLevelIntegrator&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="25ebe8ba35f779028d36e16125b8548c"></a><!-- doxytag: member="SAMRAI::algs::TimeRefinementLevelStrategy::advanceLevel" ref="25ebe8ba35f779028d36e16125b8548c" args="(const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level, const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const double current_time, const double new_time, const bool first_step, const bool last_step, const bool regrid_advance=false)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">SAMRAI::algs::TimeRefinementLevelStrategy</a>&lt; DIM &gt;::advanceLevel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>first_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>last_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>regrid_advance</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Advance data on all patches on specified patch level from current time (current_time) to new time (new_time). The boolean value first_step indicates whether the advance step is the first in a time sequence on the level. The boolean value last_step indicates whether the advance step is the last in a time sequence on the level. Usually, the timestep sequence refers to the steps taken to advance the solution through the time interval of the most recent advance on the next coarser level, if such a level exists. The boolean regrid_advance is false when the advance is part of the actual hierarchy integration process and true when the advance is called during time-dependent regridding (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., when using Richardson extrapolation). The default value is false. The last boolean argument is true when the level is in the hierarchy, and false otherwise. The default value is true. Usually, this value is false only during time-dependent regridding operations performed on some temporary level; thus, a schedule must be generated for the level before the advance can occur, for example.<p>
When this function is called, the level data required to begin the advance must be allocated and be defined appropriately. Typically, this is equivalent to what is needed to initialize a new level after regridding. Upon exiting this routine, both current and new data may exist on the level. This data is needed until level synchronization occurs, in general. Current and new data may be reset by calling the member function <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#0066b6a5d5ab832cde700334b026f34d">resetTimeDependentData()</a>.<p>
This routine is called from two different points within the TimeRefinementIntegrator&lt;DIM&gt; class: during the regular time advance sequence, and at the initial simulation time. The second call is made to advance the solution on a coarser level ahead in time to provide time-dependent boundary values for some finer level when time-dependent regridding is used. In the first case, the values of the boolean flags are:<p>
<ul>
<li><b>first_step</b> = true for first step in level time step sequence; else, false.</li><li><b>last_step</b> = true for last step in level time step sequence; else, false.</li><li><b>regrid_advance</b> = false.</li></ul>
<p>
In the second case, the values of the boolean flags are:<p>
<ul>
<li><b>first_step</b> = true.</li><li><b>last_step</b> = false.</li><li><b>regrid_advance</b> = true. </li></ul>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#f840fc060932579da438cbc700c1be8c">SAMRAI::algs::HyperbolicLevelIntegrator&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="3d9e05288798d49b0000d9737abfa8bf"></a><!-- doxytag: member="SAMRAI::algs::TimeRefinementLevelStrategy::standardLevelSynchronization" ref="3d9e05288798d49b0000d9737abfa8bf" args="(const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const int coarsest_level, const int finest_level, const double sync_time, const tbox::Array&lt; double &gt; &amp;old_times)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">SAMRAI::algs::TimeRefinementLevelStrategy</a>&lt; DIM &gt;::standardLevelSynchronization           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>sync_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>old_times</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Synchronize data on specified patch levels in AMR hierarchy at the given synchronization time. The array of time values provides the previous integration time for each level involved in the synchronization. In other words, (sync_time - old_times[ln]) is the most recent time increment used to advance data on level ln. These times are used when the synchronization process requires re-integration of the data. Note that other synchronization routines are defined below for other points in the hierarchy integration sequence.<p>
When this routine is called, both current and new data may exist on each level involved in the synchronization. The new data on each level corresponds to the synchronization time. Each entry in the array of time values specifies the time to which the current data on each level corresponds. It is assumed that this routine will reset the synchronized data on each level so that only the current data will exist on each level when done.<p>
Note that this routine is distinct from the <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#ab60d668b4eb7dc4fd9cf76f29741c35">synchronizeNewLevels()</a> function below. This routine is used to synchronize levels during the time integration process. The other routine is used to synchronize new levels in the hierarchy, either at initialization time or after regridding.<p>
This function must be overloaded in a concrete implementation that is used by the time refinement integrator for refined timestepping 
<p>
Reimplemented in <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#72f8e04b48aaaaa47f4bf27eab538c1a">SAMRAI::algs::HyperbolicLevelIntegrator&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="60a7d60226275e8e8001a0b4c08f9ade"></a><!-- doxytag: member="SAMRAI::algs::TimeRefinementLevelStrategy::standardLevelSynchronization" ref="60a7d60226275e8e8001a0b4c08f9ade" args="(const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const int coarsest_level, const int finest_level, const double sync_time, const double old_time)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">SAMRAI::algs::TimeRefinementLevelStrategy</a>&lt; DIM &gt;::standardLevelSynchronization           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>sync_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>old_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This version of standardLevelSynchronization must be overloaded for implementations that support synchronized timestepping. The interface is the same as the other version of this function, except for the old_time argument. In synchronized timestepping all levels advance the same timestep, so only a single old time is required, rather than an array. 
<p>
Reimplemented in <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#5a23fe7f0333fca7e0813e5eabdccbde">SAMRAI::algs::HyperbolicLevelIntegrator&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="ab60d668b4eb7dc4fd9cf76f29741c35"></a><!-- doxytag: member="SAMRAI::algs::TimeRefinementLevelStrategy::synchronizeNewLevels" ref="ab60d668b4eb7dc4fd9cf76f29741c35" args="(const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const int coarsest_level, const int finest_level, const double sync_time, const bool initial_time)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">SAMRAI::algs::TimeRefinementLevelStrategy</a>&lt; DIM &gt;::synchronizeNewLevels           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>sync_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Synchronize specified levels after regridding has occurred or during initial construction of the AMR patch hierarchy. Note that this synchronization may be different than the standard time-dependent synchronization (above in <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#3d9e05288798d49b0000d9737abfa8bf">standardLevelSynchronization()</a>) depending on the level integration algorithm.<p>
Before this routine is called, all time-dependent data on all levels involved in the synchronization has been reset. Thus, this routine must only synchronize the current data on each level. On return from this function, only the current data on each level must be present. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#d4e62168bcfa5f9d5ac3a4edc19db5aa">SAMRAI::algs::HyperbolicLevelIntegrator&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="0066b6a5d5ab832cde700334b026f34d"></a><!-- doxytag: member="SAMRAI::algs::TimeRefinementLevelStrategy::resetTimeDependentData" ref="0066b6a5d5ab832cde700334b026f34d" args="(const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level, const double new_time, const bool can_be_refined)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">SAMRAI::algs::TimeRefinementLevelStrategy</a>&lt; DIM &gt;::resetTimeDependentData           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>can_be_refined</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset time-dependent data storage for the specified patch level. This routine is called when the current level data is no longer needed and it is appropriate to replace the current data with the new data on the level, if such data exists. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#f122f695b1437366789773511f51c286">SAMRAI::algs::HyperbolicLevelIntegrator&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="b1fa8864fdce4073cc0ad8d4066635f6"></a><!-- doxytag: member="SAMRAI::algs::TimeRefinementLevelStrategy::resetDataToPreadvanceState" ref="b1fa8864fdce4073cc0ad8d4066635f6" args="(const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">SAMRAI::algs::TimeRefinementLevelStrategy</a>&lt; DIM &gt;::resetDataToPreadvanceState           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset data on the patch level to state before time advance. This is needed whenever the solution on a level is advanced beyond the new time on a level. For example, during time-dependent regridding (Richardson extrapolation) or initialization, it is necessary to do such an advance. This routine is called to discard the new solution data so that subsequent calls to advance are provided proper data at the correct time. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#806914590210104f371eb193f514ad24">SAMRAI::algs::HyperbolicLevelIntegrator&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="ccf94f247f5e6388b93d101d73c93850"></a><!-- doxytag: member="SAMRAI::algs::TimeRefinementLevelStrategy::usingRefinedTimestepping" ref="ccf94f247f5e6388b93d101d73c93850" args="() const=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">SAMRAI::algs::TimeRefinementLevelStrategy</a>&lt; DIM &gt;::usingRefinedTimestepping           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if the implementation of this class is constructed to use refined timestepping, and false otherwise. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#56018b02e4c08f473ef8d5acf41a6a9c">SAMRAI::algs::HyperbolicLevelIntegrator&lt; DIM &gt;</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/algorithm/time_refinement/<a class="el" href="TimeRefinementLevelStrategy_8h.html">TimeRefinementLevelStrategy.h</a><li>source/algorithm/time_refinement/<a class="el" href="TimeRefinementLevelStrategy_8C.html">TimeRefinementLevelStrategy.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:28:21 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
