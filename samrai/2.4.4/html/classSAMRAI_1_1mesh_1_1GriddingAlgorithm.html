<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>::<a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a></div>
<h1>SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::mesh::GriddingAlgorithm" --><!-- doxytag: inherits="SAMRAI::mesh::BaseGriddingAlgorithm" -->Class GriddingAlgorithm&lt;DIM&gt; manages gridding operations in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>. Specifically, it provides AMR patch hierarchy generation and regridding routines that may be used with a variety of AMR solution algorithms and application-specific numerical routines.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/mesh/gridding/GriddingAlgorithm.h&gt;</code>
<p>
Inheritance diagram for SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;:<p><center><img src="classSAMRAI_1_1mesh_1_1GriddingAlgorithm__inherit__graph.png" border="0" usemap="#SAMRAI_1_1mesh_1_1GriddingAlgorithm_3_01DIM_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="SAMRAI_1_1mesh_1_1GriddingAlgorithm_3_01DIM_01_4__inherit__map">
<area href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html" shape="rect" coords="7,157,311,181" alt="">
<area href="classSAMRAI_1_1tbox_1_1Serializable.html" shape="rect" coords="68,83,249,107" alt="">
<area href="classtbox_1_1DescribedClass.html" shape="rect" coords="101,8,216,32" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#26cefc54fb9405abc128f29c8304680c">GriddingAlgorithm</a> (const std::string &amp;object_name, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; input_db, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a>&lt; DIM &gt; &gt; level_strategy, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1BoxGeneratorStrategy.html">BoxGeneratorStrategy</a>&lt; DIM &gt; &gt; generator, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a>&lt; DIM &gt; &gt; balancer, bool register_for_restart=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#fe9603996d26be5b228f1e68693c3c25">~GriddingAlgorithm</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#c6ac68fc94d09e89645bb976b41dbc70">makeCoarsestLevel</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const double level_time, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;override_boxes=0, const <a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;override_mapping=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#0731d3541c79f65abe798e9e5b70767b">makeFinerLevel</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const double level_time, const bool initial_time, const int tag_buffer, const double regrid_start_time=0.)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#4dd69a9bf65bfe13b4cd6712e868c607">regridAllFinerLevels</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const int level_number, const double regrid_time, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; int &gt; &amp;tag_buffer, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt; regrid_start_time=<a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt;(), const bool level_is_coarsest_to_sync=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#6e436b44a8afebdb436be4f76df0d349">errorEstimationUsesTimeIntegration</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#6deb51b6fc4f6229d03a403b28827b40">getErrorCoarsenRatio</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#ce77e7e1519d0b6357f13daa6b118ee6">levelCanBeRefined</a> (const int level_number) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#340373f4871526a19b62bdcf245cf50d">getTagAndInitializeStrategy</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#061e5d0a9026ecff642c740ce3d600f5">getLoadBalanceStrategy</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#5254b158aadf1011585f42bfcc2bbfed">getMaxLevels</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;<br>
 DIM &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#4dc2972c564039b5e163ff00831c9265">getRatioToCoarserLevel</a> (const int level_number) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#8d961a041e7aa22eab1111e04da9fcbd">getEfficiencyTolerance</a> (const int level_number) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#78e143eed354b8d9939be76112a1462f">getCombineEfficiency</a> (const int level_number) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#b79bf3443fbd5bec9b495314a2990b63">getProperNestingBuffer</a> (const int level_number) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;<br>
 DIM &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#a8b3ab9939e8e63a4e4c8a7e7c9c463c">getSmallestPatchSize</a> (const int level_number) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;<br>
 DIM &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#18ee5b292a3f14c6ae27b2d9f5a680ec">getLargestPatchSize</a> (const int level_number) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#48e29daf1ddbad51c710002f331060cd">printClassData</a> (std::ostream &amp;os) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#bc891b565bc13bdc5b85afb2d1cdaf6b">putToDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; db)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</h3>

Class GriddingAlgorithm&lt;DIM&gt; manages gridding operations in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>. Specifically, it provides AMR patch hierarchy generation and regridding routines that may be used with a variety of AMR solution algorithms and application-specific numerical routines. 
<p>
The three main functions provided by this class are:<ul>
<li><b><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#c6ac68fc94d09e89645bb976b41dbc70">makeCoarsestLevel()</a></b> This routine constructs or repartitions the coarsest hierarchy level (level 0).</li></ul>
<p>
<ul>
<li><b><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#0731d3541c79f65abe798e9e5b70767b">makeFinerLevel()</a></b> This routine will attempt to add a new finest level to the hierarchy if the maximum number of levels allows it and cells on the current finest level are selected for refinement.</li></ul>
<p>
<ul>
<li><b><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#4dd69a9bf65bfe13b4cd6712e868c607">regridAllFinerLevels()</a></b> This routine will regrid all levels finer than some specified level based on cells that are selected for refinement on each level finer than and including the given level. This routine may add a new finest hierarchy level if the maximum number of levels allows it and cells on the current finest level are selected for refinement. Levels may also be removed from the hierarchy if no cells are tagged.</li></ul>
<p>
These basic AMR operations are used to generate of individual levels in the AMR patch hierarchy at the beginning of a simulation, and regridding collections of levels during an adaptive calculation. More details are found in the comments accompanying each member function below.<p>
The operations that identify cells for refinement on a single level and initialize data and solution algorithm-specific information that depend on the AMR hierarchy configuration are provided by the data member of type TagAndInitializeStrategy&lt;DIM&gt;. Operations that cluster tagged cells into a collection of box regions are provided by the BoxGeneratorStrategy&lt;DIM&gt; data member. Routines that load balancing patches on each level are provided by the LoadBalanceStrategy&lt;DIM&gt; data member. The collaboration between this class and each of those objects follows the Strategy design pattern. Each instantiation of this gridding algorithm class is configured with concrete implementations of those routines by passing appropriate objects into this constructor.<p>
Initialization of an GriddingAlgorithm&lt;DIM&gt; object is performed via a combination of default parameters and values read from input. Data read from input is summarized as follows:<p>
Required input keys and data types:<p>
<ul>
<li><b>max_levels</b> Integer value specifying maximum number of levels allowed in the AMR patch hierarchy.</li></ul>
<p>
<ul>
<li><b>largest_patch_size</b> An array of integer vectors (each has length = DIM) that specify the dimensions of largest patch allowed on each level in the hierarchy. The index of the vector in the array corresponds to the number of the level to which it applies. If more values are given than the maximum number of levels, extra entries will be ignored. If fewer values are given, then the last element in the array will be used on each level without a specified input value. For example, if only a single value is specified, then that value will be used on all levels. See sample input below for more information.</li></ul>
<p>
<ul>
<li><b>ratio_to_coarser</b> Set of max_levels - 1 integer vectors, each of which indicates the ratio of the index space of a patch level to that of the next coarser level. The input for each level must correspond to the format ``level_n = vector'', where n is the level number and each vector must have length DIM. If more values are given than max_levels - 1 , extra entries will be ignored. If fewer values are given, then the last element in the array will be used for finer levels.</li></ul>
<p>
Optional input keys, data types, and defaults:<p>
<ul>
<li><b>efficiency_tolerance</b> An array of double values, each of which specifies the minimum percentage of tagged cells in each box used to construct patches on a finer level. If the ratio of the number of tagged cells in a box to total cells in the box is below the tolerance value, the box may be split into smaller boxes and pieces removed until the ratio becomes greater than or equal to the the tolerance. The index of the value in the array corresponds to the number of the level to which the tolerance value applies. If more values are given than max_levels - 1 , extra entries will be ignored. If fewer values are given, then the last element in the array will be used on each level without a specified input value. For example, if only a single value is specified, then that value will be used on all levels. If no input values are given, a default of 0.8 is used. See sample input below for input file format.</li></ul>
<p>
<ul>
<li><b>combine_efficiency</b> An array of double values, each of which serves as a threshold for the ratio of the total number of cells in two boxes into which a box may be split and the number of cells in the original box. If that ratio is greater than combine efficiency, the box will not be split. This avoids splitting up portions of the domain into potentially more costly smaller pieces if there appears to be little to be gained by splitting up the boxes. The index of the value in the array corresponds to the number of the level to which the efficiency value applies. If more values are given than max_levels - 1 , extra entries will be ignored. If fewer values are given, then the last element in the array will be used on each level without a specified input value. For example, if only a single value is specified, then that value will be used on all levels. If no input values are given, a default of 0.8 is used. See sample input below for input file format.</li></ul>
<p>
<ul>
<li><b>smallest_patch_size</b> An array of integer vectors (each has length = DIM) that specify the dimensions of smallest patch allowed on each level in the hierarchy. The smallest patch allowed must be at least as great as the maximum ghost cell width for all variables in the problem. If some smaller patch size is given in input, then it will be overridden with a value consistent with the maximum ghost width. The index of the vector in the array corresponds to the number of the level to which it applies. If more values are given than the maximum number of levels, extra entries will be ignored. If fewer values are given, then the last element in the array will be used on each level without a specified input value. For example, if only a single value is specified, then that value will be used on all levels. If no input is given, a default of the maximum ghost cell width over all variables is used. See sample input below for input file format.</li></ul>
<p>
<ul>
<li><b>proper_nesting_buffer</b> An integer array specifying the number of coarse cells by which the next finer level is nested within the interior of the domain of the next coarser level when creating a new level. If more values are given than max_levels - 1 , extra entries will be ignored. If fewer values are given, then the last element in the array will be used on each level without a specified input value. For example, if only a single value is specified, then that value will be used on all levels. If no values are given, a default of 1 is used for each nesting buffer value. See sample input below for input file format.</li></ul>
<p>
<ul>
<li><b>allow_patches_smaller_than_ghostwidth</b> If the smallest patch size provided in the input file is smaller than the maximum ghost width of all the registered variables, then by default the smallest patch size will be grown to the maximum ghost width. Set this flag to true to override this default behavior and to allow the smallest patch size given in the input to remain in effect. The default value is false.</li></ul>
<p>
<ul>
<li><b>allow_patches_smaller_than_minimum_size_to_prevent_overlaps</b> In order to enforce minimum patch size restrictions, boxes may be grown in gridding operations. This may in turn lead to overlaps created between boxes. If overlaps are undesirable and you are willing to relax the minimum size constraints, set this parameter true. By default, it is false.</li></ul>
<p>
<ul>
<li><b>check_nonrefined_tags</b> How to resolve user-specified tags that violates proper nesting. Such tags will not be refined when creating a finer level. This flag gives options for how to handle these tags. Set to one of these characters: <b>'i'</b> for ignore (there is no check for violating tags, and they will be quietly disregarded). <b>'w'</b> for warn (violating tags will cause a warning and be disregarded). <b>'e'</b> for error (violating tags will cause an unrecoverable exception). The default is 'w'. Ignoring is the most efficient because no checks are required (but this puts the burden of dealing with unrefined tagged cells on the user.</li></ul>
<p>
<ul>
<li><b>check_overlapping</b> patches Specify whether to check for overlapping patches on a newly created level, and what to do if any are found. Set to one of these characters: <b>'i'</b> for ignore (there is no check for overlapping patches, and they will be quietly disregarded). <b>'w'</b> for warn (overlapping patches will cause a warning and be disregarded). <b>'e'</b> for error (violating tags will cause an unrecoverable exception). The default is 'i'. The check for overlapping patches may be expensive, so the use of 'w' and 'e' is recommended only for debugging purposes. To prevent the creation of any levels with overlapping patches, see the input flag "allow_patches_smaller_than_minimum_size_to_prevent_overlaps"</li></ul>
<p>
<ul>
<li><b>write_regrid_boxes</b> Output sequence of refine boxes to file.</li></ul>
<p>
<ul>
<li><b>read_regrid_boxes</b> Read sequence of refine boxes from file.</li></ul>
<p>
<ul>
<li><b>regrid_boxes_filename</b> Filename used for writing or reading refine boxes. The read and write boxes option is usable only under very specific circumstances. Please contact the <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> developers at samrai@llnl.gov) for more information.</li></ul>
<p>
<ul>
<li><b>coalesce_boxes</b> Whether to coalesce boxes so that load balancer gives better results. Coalescing can be very expensive. If regridding cost fails to scale, this is probably the first option you should consider disabling.</li></ul>
<p>
Note that when continuing from restart, the input values in the input file override all values read in from the restart database.<p>
The following represents sample input data for a three-dimensional problem:<p>
<div class="fragment"><pre class="fragment">
 *
 *    // Required input: maximum bumber of levels in patch hierarchy
 *    max_levels = 4
 *
 *    // Required input: vector ratio between each finer level and next coarser
 *    ratio_to_coarser {
 *       level_1 = 2, 2, 2
 *       level_2 = 2, 2, 2
 *       level_3 = 4, 4, 4
 *    }
 *
 *    // Required input: int vector for largest patch size on each level.
 *    largest_patch_size {
 *       level_0 = 40, 40, 40
 *       level_1 = 30, 30, 30
 *       // all finer levels will use same values as level_1...
 *    }
 *
 *    // Optional input:  buffer of one cell used on each level
 *    proper_nesting_buffer = 1
 *    grow_after_nesting = FALSE
 *
 *    // Optional input: int vector for smallest patch size on each level.
 *    smallest_patch_size {
 *       level_0 = 16, 16, 16
 *       // all finer levels will use same values as level_0...
 *    }
 *
 *    // Optional input: different efficiency tolerance for each coarser level
 *    efficiency_tolerance = 0.80e0, 0.85e0, 0.90e0
 *
 *    // Optional input: combine efficiency is same for all levels.
 *    combine_efficiency = 0.95e0
 *
 *    write_regrid_boxes = TRUE
 *    regrid_boxes_filename = "regrid_boxes_32proc"
 *
 *    coalesce_boxes = TRUE
 *
 * </pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">mesh::TagAndInitializeStrategy</a> <p>
<a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">mesh::LoadBalanceStrategy</a> <p>
<a class="el" href="classSAMRAI_1_1mesh_1_1BoxGeneratorStrategy.html">mesh::BoxGeneratorStrategy</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="26cefc54fb9405abc128f29c8304680c"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::GriddingAlgorithm" ref="26cefc54fb9405abc128f29c8304680c" args="(const std::string &amp;object_name, tbox::Pointer&lt; tbox::Database &gt; input_db, tbox::Pointer&lt; TagAndInitializeStrategy&lt; DIM &gt; &gt; level_strategy, tbox::Pointer&lt; BoxGeneratorStrategy&lt; DIM &gt; &gt; generator, tbox::Pointer&lt; LoadBalanceStrategy&lt; DIM &gt; &gt; balancer, bool register_for_restart=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a>           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1BoxGeneratorStrategy.html">BoxGeneratorStrategy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>balancer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>register_for_restart</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The constructor for GriddingAlgorithm&lt;DIM&gt; configures the gridding algorithm with the concrete strategy objects in the argument list. Gridding parameters are initialized from values provided in the specified input and in the restart database corresponding to the specified object_name argument. The constructor also registers this object for restart using the specified object name when the boolean argument is true. Whether object will write its state to restart files during program execution is determined by this argument. Note that it has a default state of true.<p>
If assertion checking is turned on, an unrecoverable assertion will result if any of the input database, level strategy, box generator, or load balancer pointers is null. Exceptions may also be thrown if any checks for consistency among input parameters fail. 
</div>
</div><p>
<a class="anchor" name="fe9603996d26be5b228f1e68693c3c25"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::~GriddingAlgorithm" ref="fe9603996d26be5b228f1e68693c3c25" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual destructor for GriddingAlgorithm&lt;DIM&gt;. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="c6ac68fc94d09e89645bb976b41dbc70"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::makeCoarsestLevel" ref="c6ac68fc94d09e89645bb976b41dbc70" args="(tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const double level_time, const hier::BoxArray&lt; DIM &gt; &amp;override_boxes=0, const hier::ProcessorMapping &amp;override_mapping=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::makeCoarsestLevel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>level_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>override_boxes</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>override_mapping</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine will attempt to construct the coarsest level in an AMR patch hierarchy (i.e., level 0). If level 0 does not already exist, then the domain specification is checked against the constraints of the grid generation procedures. The level gridding strategy data member defines these constraints. Recall that the domain specification is maintained by the grid geometry object associated with the hierarchy. Generally, an unrecoverable exception will result if the constraints are not satisfied.<p>
If level 0 already exists in the hierarchy, then the routine will generate a new level by re-applying the load balancing procedure to the existing level. Data will be moved from the old level to the new level and the pre-existing level 0 will be discarded. Note that this routine is different than the routine <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#0731d3541c79f65abe798e9e5b70767b">makeFinerLevel()</a> below, which is used to construct levels 1 and finer. In particular, this routine does not select cells for refinement, whereas the other routine does.<p>
Important note: If assertion checking is turned on, then an unrecoverable assertion will result if either the patch hierarchy or its grid geometry is NULL.<p>
The two optional arguments are only to be used for a special case where the user wishes to manually specify a box decomposition and load balance for the coarsest level of the hierarchy. The BoxArray argument must be a decomposition of the the coarsest level, and must exactly fill the index space of the physical domain of the hierarchy. The ProcessorMapping must be constructed to map each box in the BoxArray to a processor. The size of the mapping must be equal to the length of the box array, or an assertion failure will result.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The hierarchy on which coarse level is constructed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_time</em>&nbsp;</td><td>Simulation time when level is constructed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>override_boxes</em>&nbsp;</td><td>box array representing a decomposition of level zero of the hierarchy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>override_mapping</em>&nbsp;</td><td>processor mapping that maps each box in the above array to a processor. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#38ea13b0d56ed4e0a80f37eb92957eff">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="0731d3541c79f65abe798e9e5b70767b"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::makeFinerLevel" ref="0731d3541c79f65abe798e9e5b70767b" args="(tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const double level_time, const bool initial_time, const int tag_buffer, const double regrid_start_time=0.)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::makeFinerLevel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>level_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_start_time</em> = <code>0.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine attempts to create a new level in an AMR patch hierarchy finer than the finest level currently residing in the hierarchy. It will select cells for refinement on the finest level and construct a new finest level, if necessary. If no cells are selected for refinement, no new level will be added to the hierarchy. The boolean argument initial_time indicates whether the routine is called at the initial simulation time. If true, this routine is used to build individual levels during the construction of the AMR hierarchy at the initial simulation time. If false, the routine is being used to add new levels to the hierarchy at some later point. In either case, the time value is the current simulation time. Note that this routine cannot be used to construct the coarsest level in the hierarchy (i.e., level 0). The routine <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#c6ac68fc94d09e89645bb976b41dbc70">makeCoarsestLevel()</a> above must be used for that purpose.<p>
The tag buffer indicates the number of cells by which cells selected for refinement will be buffered before new finer level boxes are constructed. The buffer is important to keep phenomena of interest on refined regions of the mesh until adaptive regridding occurs next. Thus, the buffer size should take into account how the simulation may evolve before regridding occurs (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., number of timesteps taken).<p>
Important note: If assertion checking is activated, several checks are applied to the functions arguments. If any check is violated, an unrecoverable assertion will result. In particular, the hierarchy pointer must be non-NULL and the given level number must match that of the finest level currently residing in the hierarchy. Also, the the tag buffer must be positive. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#6e2fd0ed01be50969e4451b39cf5a9c5">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="4dd69a9bf65bfe13b4cd6712e868c607"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::regridAllFinerLevels" ref="4dd69a9bf65bfe13b4cd6712e868c607" args="(tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const int level_number, const double regrid_time, const tbox::Array&lt; int &gt; &amp;tag_buffer, tbox::Array&lt; double &gt; regrid_start_time=tbox::Array&lt; double &gt;(), const bool level_is_coarsest_to_sync=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::regridAllFinerLevels           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tag_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt;&nbsp;</td>
          <td class="paramname"> <em>regrid_start_time</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt;&nbsp;double&nbsp;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>level_is_coarsest_to_sync</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine attempts to reconfigure the patches on each level in an AMR patch hierarchy which is finer than the specified level. The given level number is that of the coarsest level on which cells will be will be selected for refinement. In other words, that level is the finest level that will not be subject to a change in its patch configuration during the regridding process. Generally, this routine should be used to alter a pre-existing AMR patch hierarchy based on the need to adapt the computational mesh around some phenomenon of interest. The routine <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#0731d3541c79f65abe798e9e5b70767b">makeFinerLevel()</a> above should be used to construct an initial hierarchy configuration or to add more than one new level into the hierarchy. Also, this routine will not reconfigure the patches on level 0 (i.e., the coarsest in any hierarchy). The routine <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#c6ac68fc94d09e89645bb976b41dbc70">makeCoarsestLevel()</a> above is provided for that purpose.<p>
Note that the current algorithm permits at most one new finest level to be added to the hierarchy with each invocation of the regridding process. This constraint, though seemingly restrictive makes the process of maintaining properly nested levels much easier.<p>
The tag buffer array indicates the number of cells by which cells selected for refinement on a level will be buffered before new finer level boxes are constructed. The buffer is important to keep phenomena of interest on refined regions of the mesh until adaptive regridding occurs next. Thus, the buffer size should take into account how the simulation may evolve before regridding occurs (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., number of timesteps taken on each level).<p>
The boolean argument is used for regridding in time-dependent problems. When true, it indicates that the specified level is the coarsest level to synchronize at the current regrid time before this regridding method is called. This is a pretty idiosyncratic argument but allows some flexibility in the way memory is managed during time-dependent regridding operations.<p>
Important note: If assertion checking is activated, several checks are applied to the functions arguments. If any check is violated, an unrecoverable assertion will result. In particular, the hierarchy pointer must be non-NULL and the given level number must match that of of some level in the hierarchy. Also, the tag buffer array must contain a positive value for each level in the hierarchy. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#27aa93c208000bfbb871c02f21b918ae">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="6e436b44a8afebdb436be4f76df0d349"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::errorEstimationUsesTimeIntegration" ref="6e436b44a8afebdb436be4f76df0d349" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::errorEstimationUsesTimeIntegration           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if error estimation process uses time integration; otherwise, return false. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#1a10894c9e4f96e2ac6d8b9cca1efcdd">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="6deb51b6fc4f6229d03a403b28827b40"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getErrorCoarsenRatio" ref="6deb51b6fc4f6229d03a403b28827b40" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::getErrorCoarsenRatio           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the error coarsen ratio. This is needed for cases where an error estimation scheme uses time integration (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>. Richardson extrapolation) to determine how many time levels to maintain to properly apply the estimtion scheme. In general, an even refine ratio (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>. 2, 4, 8) will maintain two time levels, while an odd refine ratio (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>. 3) will maintain three. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#2467f4e8b80d42fabefda019eba8b6d9">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="ce77e7e1519d0b6357f13daa6b118ee6"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::levelCanBeRefined" ref="ce77e7e1519d0b6357f13daa6b118ee6" args="(const int level_number) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::levelCanBeRefined           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if level associated with the specified level number can be refined; i.e., the level number is less than that of the finest level allowed in the hierarchy. Otherwise, false is returned. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#80593a645746dc9208810412a5880b18">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="340373f4871526a19b62bdcf245cf50d"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getTagAndInitializeStrategy" ref="340373f4871526a19b62bdcf245cf50d" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a>&lt; DIM &gt; &gt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::getTagAndInitializeStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return pointer to level gridding strategy data member. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#edbd080e17757c682391a616454ba97c">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="061e5d0a9026ecff642c740ce3d600f5"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getLoadBalanceStrategy" ref="061e5d0a9026ecff642c740ce3d600f5" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a>&lt; DIM &gt; &gt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::getLoadBalanceStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return pointer to load balance strategy data member. 
</div>
</div><p>
<a class="anchor" name="5254b158aadf1011585f42bfcc2bbfed"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getMaxLevels" ref="5254b158aadf1011585f42bfcc2bbfed" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::getMaxLevels           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return maximum number of levels allowed in hierarchy. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#680a6dc0520c476f4486ec04b2756c47">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="4dc2972c564039b5e163ff00831c9265"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getRatioToCoarserLevel" ref="4dc2972c564039b5e163ff00831c9265" args="(const int level_number) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::getRatioToCoarserLevel           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return const reference to ratio between specified level and next coarser. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#4816dd64af50c6cd594edadfc366bee0">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="8d961a041e7aa22eab1111e04da9fcbd"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getEfficiencyTolerance" ref="8d961a041e7aa22eab1111e04da9fcbd" args="(const int level_number) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::getEfficiencyTolerance           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return efficiency tolerance for clustering tags on level. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#78ed81ac7ddfe070acde1ee5c0c0d030">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="78e143eed354b8d9939be76112a1462f"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getCombineEfficiency" ref="78e143eed354b8d9939be76112a1462f" args="(const int level_number) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::getCombineEfficiency           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return combine efficiency for clustering tags on level. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#c4bdddcbf6701d0a220c66ac29751643">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="b79bf3443fbd5bec9b495314a2990b63"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getProperNestingBuffer" ref="b79bf3443fbd5bec9b495314a2990b63" args="(const int level_number) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::getProperNestingBuffer           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return proper nesting buffer width for level. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#b87a8fe4d49b5844ce23d11aa4891edd">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="a8b3ab9939e8e63a4e4c8a7e7c9c463c"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getSmallestPatchSize" ref="a8b3ab9939e8e63a4e4c8a7e7c9c463c" args="(const int level_number) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::getSmallestPatchSize           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return const reference to smallest patch size for level. 
</div>
</div><p>
<a class="anchor" name="18ee5b292a3f14c6ae27b2d9f5a680ec"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getLargestPatchSize" ref="18ee5b292a3f14c6ae27b2d9f5a680ec" args="(const int level_number) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::getLargestPatchSize           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return const reference to largest patch size for level. 
</div>
</div><p>
<a class="anchor" name="48e29daf1ddbad51c710002f331060cd"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::printClassData" ref="48e29daf1ddbad51c710002f331060cd" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::printClassData           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print out all members of the class instance to given output stream. 
</div>
</div><p>
<a class="anchor" name="bc891b565bc13bdc5b85afb2d1cdaf6b"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::putToDatabase" ref="bc891b565bc13bdc5b85afb2d1cdaf6b" args="(tbox::Pointer&lt; tbox::Database &gt; db)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; DIM &gt;::putToDatabase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write object state out to the given database.<p>
When assertion checking is active, the database pointer must be non-null. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#402d40aa6172a028f927af79440bd813">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/mesh/gridding/<a class="el" href="GriddingAlgorithm_8h.html">GriddingAlgorithm.h</a><li>source/mesh/gridding/<a class="el" href="GriddingAlgorithm_8C.html">GriddingAlgorithm.C</a><li>source/mesh/gridding/<a class="el" href="GriddingAlgorithm_8I.html">GriddingAlgorithm.I</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:28:40 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
