<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::appu::EmbeddedBoundaryGeometry&lt; DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1appu.html">appu</a>::<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">EmbeddedBoundaryGeometry</a></div>
<h1>SAMRAI::appu::EmbeddedBoundaryGeometry&lt; DIM &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::appu::EmbeddedBoundaryGeometry" --><!-- doxytag: inherits="SAMRAI::appu::VisMaterialsDataStrategy,SAMRAI::xfer::RefinePatchStrategy,SAMRAI::tbox::Serializable" -->Class <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">EmbeddedBoundaryGeometry</a> provides embedded boundary mesh construction, storage, and management on an AMR hierarchy.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/apputils/embedded_boundary/EmbeddedBoundaryGeometry.h&gt;</code>
<p>
Inheritance diagram for SAMRAI::appu::EmbeddedBoundaryGeometry&lt; DIM &gt;:<p><center><img src="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry__inherit__graph.png" border="0" usemap="#SAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry_3_01DIM_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="SAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry_3_01DIM_01_4__inherit__map">
<area href="classSAMRAI_1_1appu_1_1VisMaterialsDataStrategy.html" shape="rect" coords="7,83,321,107" alt="">
<area href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" shape="rect" coords="345,83,625,107" alt="">
<area href="classSAMRAI_1_1tbox_1_1Serializable.html" shape="rect" coords="649,83,831,107" alt="">
<area href="classtbox_1_1DescribedClass.html" shape="rect" coords="683,8,797,32" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#2aa7906385f93b18d8655c26d76953d2">CELL_TYPE</a> { <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#2aa7906385f93b18d8655c26d76953d26627701c15fbb0c38a34547bca055498">SOLID</a> =  EmbeddedBoundaryDefines::SOLID, 
<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#2aa7906385f93b18d8655c26d76953d28d4619ec53a2918c2cec635bba9896c5">CUT</a> =  EmbeddedBoundaryDefines::CUT, 
<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#2aa7906385f93b18d8655c26d76953d27c03cedcf54a8d6783f1d5e49654b4ca">BORDER</a> =  EmbeddedBoundaryDefines::BORDER, 
<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#2aa7906385f93b18d8655c26d76953d23fc63eef7554c080b52e2ad4784f0295">FLOW</a> =  EmbeddedBoundaryDefines::FLOW
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#b021888e318c696d9deca59ec102eac6">NODE_TYPE</a> { <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#b021888e318c696d9deca59ec102eac68fc2fcc7da0974e653f732636acd9081">OUTSIDE</a> =  EmbeddedBoundaryDefines::OUTSIDE, 
<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#b021888e318c696d9deca59ec102eac6e98475b75c5a47050058cc16731d206e">INSIDE</a> =  EmbeddedBoundaryDefines::INSIDE, 
<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#b021888e318c696d9deca59ec102eac6546d882ae355e404570e5f289d905edd">BOUNDARY</a> =  EmbeddedBoundaryDefines::BOUNDARY, 
<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#b021888e318c696d9deca59ec102eac6879e120323d9a65ea8b19db765c5eab2">ONBOUNDARY</a> =  EmbeddedBoundaryDefines::ONBOUNDARY
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#f4e186b68dc9340f20a7d1e00b48c928">EmbeddedBoundaryGeometry</a> (const std::string &amp;object_name, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; input_db=(0), const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html">geom::CartesianGridGeometry</a>&lt; DIM &gt; &gt; grid_geom=(0), const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;nghosts=<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt;(0))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#8614951e7ceedde3136473fd2e4e72e6">~EmbeddedBoundaryGeometry</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#9da61ab7bec24509c179d72262dbe099">buildEmbeddedBoundaryOnLevel</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy=(0), const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; old_level=(0))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#f9abccec36502c7e16587a66fc06c016">tagInsideOutsideNodesOnLevel</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#932261231d32e71fc96375abeda6b464">registerVisItDataWriter</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">appu::VisItDataWriter</a>&lt; DIM &gt; &gt; visit_writer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#123f9bf04a607e5b24b42ac20f563160">getCellFlagDataId</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#29b6c35ccb0463ddc765d613e538a9aa">getCellVolumeDataId</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#3d5e65bb0a5fe3df196f2d12c03ecc6d">getIndexCutCellDataId</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#f5aba8a96c0d809e48a418914d1ca002">getNodeInsideOutsideDataId</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#6b758a31d48f2064c27f44434e8b51bc">computeTotalVolumeOnLevel</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#76107f4ce5c93f1ceedba95e981fdba4">setGridGeometry</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html">geom::CartesianGridGeometry</a>&lt; DIM &gt; &gt; grid_geom)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#84b84b2d51dd03df999418d5c535e953">writeLevelEmbeddedBoundaryDataToFile</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level, const std::string &amp;dirname) const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#1525418ea2fa1b48b9e230e1cba70314">packMaterialFractionsIntoDoubleBuffer</a> (double *dbuffer, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;patch, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;region, const std::string &amp;material_name) const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#72e373bfbbe992c5018900b2665d8297">setPhysicalBoundaryConditions</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;patch, const double fill_time, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ghost_width_to_fill)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#f9ffb617043dbf3d5a96b2e4c83b00ee">preprocessRefine</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;fine_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ratio)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#7e2fd329650a78873098692cb06ac6ae">postprocessRefine</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;fine_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ratio)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#9f0784673718e92267b9003a2e8d6eeb">getRefineOpStencilWidth</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#b21db5a935dbef4d1505d1bf2d7744d2">putToDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; db)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class SAMRAI::appu::EmbeddedBoundaryGeometry&lt; DIM &gt;</h3>

Class <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">EmbeddedBoundaryGeometry</a> provides embedded boundary mesh construction, storage, and management on an AMR hierarchy. 
<p>
The embedded boundary may be constructed from a set of analytic shapes supplied through input. The following outlines the steps required:<p>
1. Construct an <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">EmbeddedBoundaryGeometry</a> object, supplying the input file that contains the shape entries, a pointer to the Cartesian grid geometry, and the desired number of ghosts to be used in defining the embedded boundary:<p>
<div class="fragment"><pre class="fragment">
 *    EmbeddedBoundaryGeometry* eb_geom = 
 *       new EmbeddedBoundaryGeometry("EmbeddedBoundaryGeometry",
 *                                     input_db-&gt;getDatabase("EBdryGeometry"),
 *                                     grid_geometry,
 *                                     nghosts);
 *    </pre></div><p>
Note: The cart_grid_geometry argument is optional and may be supplied later using the "setGridGeometry()" method. However, it must be set before the "buildEmbeddedBoundaryOnLevel()" is called. The nghosts argument is also optional and is set to zero by default.<p>
2. Build the embedded boundary on the levels of the hierarchy:<p>
<div class="fragment"><pre class="fragment">
 *    Pointer&lt;PatchLevel&lt;DIM&gt; &gt; level = hierarchy-&gt;getPatchLevel(ln);
 *    eb_geom-&gt;buildEmbeddedBoundaryOnLevel(level);
 *    </pre></div><p>
Note: It is also possible to pass in a hierarchy and an old level as arguments. If supplied, this information can be used to accelerate construction of the boundary on the supplied level.<p>
3. Access information about the embedded boundary from patches:<p>
<ul>
<li>The "cell flag" identifies whether a cell is cut, solid, or flow</li><li>The "node flag" identifies nodes as inside, outside, boundary (first node just inside solid boundary), or on-boundary (within a specified distance from the solid boundary).</li><li>The "volume fraction" will be 0.0 for solid cells, 1.0 for flow cells, and somewhere in-between for cut cells</li><li>The list of "cut cells" holds information about the normal, face areas, etc. on specific cells that are cut.</li></ul>
<p>
<div class="fragment"><pre class="fragment">
 *    int cell_flag_index = eb_geom-&gt;getCellFlagDataId();  
 *    int node_flag_index = eb_geom-&gt;getNodeInsideOutsideDataId();  
 *    int vol_frac_index = eb_geom-&gt;getCellVolumeDataId();  
 *    int cut_cell_index = eb_geom-&gt;getIndexCutCellDataId();
 *
 *    tbox::Pointer&lt;CellData&lt;DIM,int&gt; &gt; cell_flag_data = 
 *        patch-&gt;getPatchData(cell_flag_index); 
 *    tbox::Pointer&lt;NodeData&lt;DIM,int&gt; &gt; node_flag_data = 
 *        patch-&gt;getPatchData(node_flag_index); 
 *    tbox::Pointer&lt;CellData&lt;DIM,double&gt; &gt; vol_frac_data = 
 *        patch-&gt;getPatchData(vol_frac_index); 
 *    tbox::Pointer&lt;IndexData&lt;DIM,CutCell&gt; &gt; cut_cell_data = 
 *        patch-&gt;getPatchData(cut_cell_index); 
 *    </pre></div><p>
Input parameters specify the list of shapes to be used to construct the boundary, the desired accuracy of the volume and area fraction computation, and information about whether write constructed embedded boundary information to file, or read from file.<p>
Required input keys and data types: NONE<p>
Optional input keys, data types, and defaults:<p>
-<b>verbose</b> boolean specifying whether to output information about the embedded boundary, such as the number of cut cells, the error in the volume calculation, etc. to the log file. If no value is supplied in input, the default is TRUE.<p>
-<b>max_subdivides</b> integer specifying the number of cell subdivides when computing the volume and area fractions. The larger the number of subdivides, the more accurate the fraction calculation will be, but the calculation will also be more expensive. If no value is supplied in input, a default of 0 is used.<p>
-<b>read_from_file</b> bool specifying whether to read the embedded boundary from file. If true, it will read flag, volume fraction, and cut cell information describing the embedded boundary from the specified HDF "dirname" (specified below). If no value is supplied, the default is FALSE.<p>
-<b>write_to_file</b> bool specifying whether to write the embedded boundary to the specified HDF "dirname" (specified below). If true, it will write flag, volume fraction, and cut cell information computed while building the embedded boundary to the specified HDF "dirname" (specified below). If no value is supplied, the default is FALSE.<p>
-<b>dirname</b> string specifying the name of the HDF directory to read/write embedded boundary information. Used with the "read_from_file" and "write_to_file" options.<p>
-<b>compute_areas_and_normal</b> bool specifying whether to compute areas and normal information. Some applications only need the volume fraction so it is not necessary to invoke the extra cost of computing the areas and normal. If no value is supplied, the default is TRUE.<p>
-<b>compute_cutcell_index_data</b> bool specifying whether to compute a list of cut cells. If false, it will compute the cell flag and volume fraction information but will not create and store the list of <a class="el" href="classSAMRAI_1_1appu_1_1CutCell.html">CutCell</a> data structs. If no value is supplied, the default is TRUE.<p>
-<b>compute_boundary_node_data</b> bool specifying whether to mark nodes that are just inside the geometry as BOUNDARY nodes, and to compute the centroid of the wetted cut area (i.e. the "front area") of the cut cells. This information may be needed for node-based finite difference or finite element computations of the embedded boundary. If no value is supplied, the default is TRUE.<p>
-<b>use_recursive_algs</b> bool specifying whether to use a recursive algorithm to compute volume and area fractions. If true, it volume and area fractions are computed by recursively subdividing the cell until the max number of subdivides is reached. If false, it will apply the max subdivides to divide the cell into a (potentially large) array of subcells. Algorithmically, the recursive algorithm has fewer operations but the non-recursive algorithm may be more computationally efficient because it can do array-based operations. If no value is supplied, the default is TRUE.<p>
-<b>Shapes</b> sub-database that specifies information about the analytic shapes used to construct an embedded boundary. See the <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShapeSphere.html">EmbeddedBoundaryShapeSphere</a> and <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShapePolygon.html">EmbeddedBoundaryShapePolygon</a> class headers for information on the inputs required.<p>
-<b><a class="el" href="classSAMRAI_1_1appu_1_1CubesPatchInterface.html">CubesPatchInterface</a></b> sub-database for the Cubes interface, a cut-cell mesh generator from NASA Ames. See the <a class="el" href="classSAMRAI_1_1appu_1_1CubesPatchInterface.html">CubesPatchInterface</a> class header for information about the required inputs.<p>
The following represents a sample input entry:<p>
<div class="fragment"><pre class="fragment">
 *  EmbeddedBoundaryGeometry{
 *     max_subdivides = 2
 *     read_from_file  = FALSE 
 *     write_to_file   = FALSE
 *     dirname         = "eb_grid"
 *     compute_areas_and_normal   = TRUE 
 *     compute_boundary_node_data = FALSE
 *     use_recursive_algs         = FALSE 
 *
 *     Shapes {
 *        Shape1 {
 *           type = "POLYGON"    
 *           vertices {
 *              v1 = 1.0 , 1.0
 *              v2 = 1.5 , .5 
 *              v3 = 2.0 , 1.75 
 *              v4 = 1.5 , 4.5
 *              v5 = .5 , 2.0 
 *           }
 *           height = 5.0 // only used for 3D 
 *        }
 *        Shape2 {
 *           type = "SPHERE"    
 *           center = 65., 50.
 *           radius = 20.     
 *        }
 *     }
 *  }
 *  </pre></div><p>
Note: Each shape has its own specific set of inputs. See the individual shapes for information about input requirements.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShapeSphere.html">appu::EmbeddedBoundaryShapeSphere</a> <p>
<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShapePolygon.html">appu::EmbeddedBoundaryShapePolygon</a> <p>
<a class="el" href="classSAMRAI_1_1appu_1_1CubesPatchInterface.html">appu::CubesPatchInterface</a> <p>
<a class="el" href="classSAMRAI_1_1appu_1_1ElevenPatchInterface.html">appu::ElevenPatchInterface</a> <p>
<a class="el" href="classSAMRAI_1_1appu_1_1CutCell.html">appu::CutCell</a> </dd></dl>

<p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="2aa7906385f93b18d8655c26d76953d2"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::CELL_TYPE" ref="2aa7906385f93b18d8655c26d76953d2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#2aa7906385f93b18d8655c26d76953d2">SAMRAI::appu::EmbeddedBoundaryGeometry::CELL_TYPE</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumerated type for the different cell classifications.<p>
<ul>
<li><b>SOLID</b> {Cell is located in the "solid" region.}</li><li><b>CUT</b> {Cell is cut, meaning a <a class="el" href="classSAMRAI_1_1appu_1_1CutCell.html">CutCell</a> data structure will be maintained at this cell.}</li><li><b>BORDER</b> {Cell neighbors a cut cell, in the "flow" region.}</li><li><b>FLOW</b> {Cell is located in the "flow" region.} </li></ul>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="2aa7906385f93b18d8655c26d76953d26627701c15fbb0c38a34547bca055498"></a><!-- doxytag: member="SOLID" ref="2aa7906385f93b18d8655c26d76953d26627701c15fbb0c38a34547bca055498" args="" -->SOLID</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="2aa7906385f93b18d8655c26d76953d28d4619ec53a2918c2cec635bba9896c5"></a><!-- doxytag: member="CUT" ref="2aa7906385f93b18d8655c26d76953d28d4619ec53a2918c2cec635bba9896c5" args="" -->CUT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="2aa7906385f93b18d8655c26d76953d27c03cedcf54a8d6783f1d5e49654b4ca"></a><!-- doxytag: member="BORDER" ref="2aa7906385f93b18d8655c26d76953d27c03cedcf54a8d6783f1d5e49654b4ca" args="" -->BORDER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="2aa7906385f93b18d8655c26d76953d23fc63eef7554c080b52e2ad4784f0295"></a><!-- doxytag: member="FLOW" ref="2aa7906385f93b18d8655c26d76953d23fc63eef7554c080b52e2ad4784f0295" args="" -->FLOW</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="b021888e318c696d9deca59ec102eac6"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::NODE_TYPE" ref="b021888e318c696d9deca59ec102eac6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#b021888e318c696d9deca59ec102eac6">SAMRAI::appu::EmbeddedBoundaryGeometry::NODE_TYPE</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumerated type for inside/outside node classification.<p>
<ul>
<li><b>INSIDE</b> {Node is located "inside" the prescribed geometry.}</li><li><b>OUTSIDE</b> {Node is outside the geometry.}</li><li><b>BOUNDARY</b> {Node is on the boundary of the geometry. That is it is the first one "inside" the geometry.}</li><li><b>ONBOUNDARY</b> {Node is located exactly on the boundary of the geometry (used to avoid divide-by-zero problems) in numerical operations at embedded boundary.} </li></ul>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="b021888e318c696d9deca59ec102eac68fc2fcc7da0974e653f732636acd9081"></a><!-- doxytag: member="OUTSIDE" ref="b021888e318c696d9deca59ec102eac68fc2fcc7da0974e653f732636acd9081" args="" -->OUTSIDE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="b021888e318c696d9deca59ec102eac6e98475b75c5a47050058cc16731d206e"></a><!-- doxytag: member="INSIDE" ref="b021888e318c696d9deca59ec102eac6e98475b75c5a47050058cc16731d206e" args="" -->INSIDE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="b021888e318c696d9deca59ec102eac6546d882ae355e404570e5f289d905edd"></a><!-- doxytag: member="BOUNDARY" ref="b021888e318c696d9deca59ec102eac6546d882ae355e404570e5f289d905edd" args="" -->BOUNDARY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="b021888e318c696d9deca59ec102eac6879e120323d9a65ea8b19db765c5eab2"></a><!-- doxytag: member="ONBOUNDARY" ref="b021888e318c696d9deca59ec102eac6879e120323d9a65ea8b19db765c5eab2" args="" -->ONBOUNDARY</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="f4e186b68dc9340f20a7d1e00b48c928"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::EmbeddedBoundaryGeometry" ref="f4e186b68dc9340f20a7d1e00b48c928" args="(const std::string &amp;object_name, tbox::Pointer&lt; tbox::Database &gt; input_db=(0), const tbox::Pointer&lt; geom::CartesianGridGeometry&lt; DIM &gt; &gt; grid_geom=(0), const hier::IntVector&lt; DIM &gt; &amp;nghosts=hier::IntVector&lt; DIM &gt;(0))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">EmbeddedBoundaryGeometry</a>           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>input_db</em> = <code>(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html">geom::CartesianGridGeometry</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>grid_geom</em> = <code>(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nghosts</em> = <code><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;&nbsp;DIM&nbsp;&gt;(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor sets default values and reads data from input.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object_name</em>&nbsp;</td><td>Name of object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_db</em>&nbsp;</td><td>Input database. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>grid_geom</em>&nbsp;</td><td>The grid geometry (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>. cartesian) used in the problem. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nghosts</em>&nbsp;</td><td>Number of ghosts used to hold the embedded boundary. If not supplied, defaults to 0.</td></tr>
  </table>
</dl>
The grid_geom and nghosts may be NULL if the embedded boundary information is to be supplied by a file, either by restart or by other input such as CART3D. If the embedded boundary is to be constructed using analytic shapes in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>, the input_db and and grid_geom arguments must be supplied and may not be NULL. 
</div>
</div><p>
<a class="anchor" name="8614951e7ceedde3136473fd2e4e72e6"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::~EmbeddedBoundaryGeometry" ref="8614951e7ceedde3136473fd2e4e72e6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">EmbeddedBoundaryGeometry</a>&lt; DIM &gt;           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor deallocates data describing and unregisters the object with the restart manager if previously registered. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="9da61ab7bec24509c179d72262dbe099"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::buildEmbeddedBoundaryOnLevel" ref="9da61ab7bec24509c179d72262dbe099" args="(const tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; level, const tbox::Pointer&lt; hier::PatchHierarchy&lt; DIM &gt; &gt; hierarchy=(0), const tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; old_level=(0))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::buildEmbeddedBoundaryOnLevel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em> = <code>(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>old_level</em> = <code>(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build an embedded boundary by forming the set of cut cells, extend them to appropriately apply the physical boundary conditions, and lastly compute the surrounding volumes for mass correction.<p>
Depending on the arguments supplied, this method may be used in one of two ways. The first, taking only the level as an argument, performs an exhaustive search of all cells on the level to find the cut cells and classify the cells as inside or outside. The second, taking as additional arguments a hierarchy, coarser_level, and possibly old_level, performs the same function but uses the information on the coarser and old levels to narrow the search for cut cells, making it considerably faster. Generally, the first method is used for the coarsest level only and the second is used for all subsequent finer levels.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>Patch level on which embedded boundary is to be constructed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>Patch hierarchy of the level. Required if the level supplied in the first argument is in the hierarchy and is not the coarsest level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>old_level</em>&nbsp;</td><td>Patch level which holds "old" embedded boundary data (not required). Use this if regridding and you have an embedded boundary at the old level to speed construction of the boundary on the new level. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f9abccec36502c7e16587a66fc06c016"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::tagInsideOutsideNodesOnLevel" ref="f9abccec36502c7e16587a66fc06c016" args="(const tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; level)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::tagInsideOutsideNodesOnLevel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tag nodes as being inside or outside the geometry. Some applications only require this knowledge and do not use need the volume/area fraction information for cut cells.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>Patch level where tagging takes place. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="932261231d32e71fc96375abeda6b464"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::registerVisItDataWriter" ref="932261231d32e71fc96375abeda6b464" args="(tbox::Pointer&lt; appu::VisItDataWriter&lt; DIM &gt; &gt; visit_writer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::registerVisItDataWriter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">appu::VisItDataWriter</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>visit_writer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a VisIt data writer so this class will write plot files that may be postprocessed with the VisIt visualization tool.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>visit_writer</em>&nbsp;</td><td>VisIt data writer </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="123f9bf04a607e5b24b42ac20f563160"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::getCellFlagDataId" ref="123f9bf04a607e5b24b42ac20f563160" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::getCellFlagDataId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the descriptor index for the CellData&lt;DIM,int&gt; patch data that holds the integer flag at each cell, identifying it as being solid, cut, boundary, or flow. 
</div>
</div><p>
<a class="anchor" name="29b6c35ccb0463ddc765d613e538a9aa"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::getCellVolumeDataId" ref="29b6c35ccb0463ddc765d613e538a9aa" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::getCellVolumeDataId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the descriptor index for the CellData&lt;DIM,double&gt; patch data that holds the cell volume fraction. 
</div>
</div><p>
<a class="anchor" name="3d5e65bb0a5fe3df196f2d12c03ecc6d"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::getIndexCutCellDataId" ref="3d5e65bb0a5fe3df196f2d12c03ecc6d" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::getIndexCutCellDataId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the descriptor index for the IndexData&lt;DIM,CutCell&gt; patch data that holds the list of embedded boundary cells on the patch. 
</div>
</div><p>
<a class="anchor" name="f5aba8a96c0d809e48a418914d1ca002"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::getNodeInsideOutsideDataId" ref="f5aba8a96c0d809e48a418914d1ca002" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::getNodeInsideOutsideDataId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the descriptor index for the NodeData&lt;DIM,int&gt; patch data that specifies a cell as being inside or outside the geometry. 
</div>
</div><p>
<a class="anchor" name="6b758a31d48f2064c27f44434e8b51bc"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::computeTotalVolumeOnLevel" ref="6b758a31d48f2064c27f44434e8b51bc" args="(const tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; level)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::computeTotalVolumeOnLevel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the total volume, which is the sum of the volume fractions, on the supplied level. 
</div>
</div><p>
<a class="anchor" name="76107f4ce5c93f1ceedba95e981fdba4"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::setGridGeometry" ref="76107f4ce5c93f1ceedba95e981fdba4" args="(const tbox::Pointer&lt; geom::CartesianGridGeometry&lt; DIM &gt; &gt; grid_geom)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::setGridGeometry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html">geom::CartesianGridGeometry</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>grid_geom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the grid geometry, if it was not supplied when the object was constructed. 
</div>
</div><p>
<a class="anchor" name="84b84b2d51dd03df999418d5c535e953"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::writeLevelEmbeddedBoundaryDataToFile" ref="84b84b2d51dd03df999418d5c535e953" args="(const tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; level, const std::string &amp;dirname) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::writeLevelEmbeddedBoundaryDataToFile           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>dirname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write embedded boundary information - cell flag and cut cell information - to supplied directory. Files of the form "ebmesh-l&lt;ln&gt;-p&lt;pid&gt;.hdf", where ln is the level number and pid is the processor number, will be written to the directory. 
</div>
</div><p>
<a class="anchor" name="1525418ea2fa1b48b9e230e1cba70314"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::packMaterialFractionsIntoDoubleBuffer" ref="1525418ea2fa1b48b9e230e1cba70314" args="(double *dbuffer, const hier::Patch&lt; DIM &gt; &amp;patch, const hier::Box&lt; DIM &gt; &amp;region, const std::string &amp;material_name) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::packMaterialFractionsIntoDoubleBuffer           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>dbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>material_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Put volume data located on the patch into the double buffer over the specified region.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dbuffer</em>&nbsp;</td><td>double buffer into which materials data is packed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td>supplied patch on which materials data is defined </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>region over which data is packed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>material_name</em>&nbsp;</td><td>name of the material </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="classSAMRAI_1_1appu_1_1VisMaterialsDataStrategy.html#ba909a18bb8141275e9438aece4816d4">SAMRAI::appu::VisMaterialsDataStrategy&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="72e373bfbbe992c5018900b2665d8297"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::setPhysicalBoundaryConditions" ref="72e373bfbbe992c5018900b2665d8297" args="(hier::Patch&lt; DIM &gt; &amp;patch, const double fill_time, const hier::IntVector&lt; DIM &gt; &amp;ghost_width_to_fill)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::setPhysicalBoundaryConditions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ghost_width_to_fill</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the data in ghost cells corresponding to physical boundary conditions. Specific boundary conditions are determined by information specified in input file and numerical routines. 
<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#ece784dfaef6ec58bfbf678e68d2d2d3">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="f9ffb617043dbf3d5a96b2e4c83b00ee"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::preprocessRefine" ref="f9ffb617043dbf3d5a96b2e4c83b00ee" args="(hier::Patch&lt; DIM &gt; &amp;fine, const hier::Patch&lt; DIM &gt; &amp;coarse, const hier::Box&lt; DIM &gt; &amp;fine_box, const hier::IntVector&lt; DIM &gt; &amp;ratio)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::preprocessRefine           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fine_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform user-defined refining operations. This member function is called before the other refining operators. For this class, no preprocessing is needed for the refine operators so it is setup to do nothing. 
<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#4e647ae59b0d7b45ac8e3e3072f69912">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="7e2fd329650a78873098692cb06ac6ae"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::postprocessRefine" ref="7e2fd329650a78873098692cb06ac6ae" args="(hier::Patch&lt; DIM &gt; &amp;fine, const hier::Patch&lt; DIM &gt; &amp;coarse, const hier::Box&lt; DIM &gt; &amp;fine_box, const hier::IntVector&lt; DIM &gt; &amp;ratio)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::postprocessRefine           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fine_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Postprocess data after the refinement operator is applied. For the embedded boundary data, refining involves two steps; First, refine the "flag" data, which will designate on the fine level where the boundary exists; Second, on each fine cell that is flagged to possibly contain the boundary, go through and determine whether the cell is indeed cut by the boundary and adjust the volume, flag, and boundary cell data on the fine level as necessary. This method invokes step 2 of this refine operation. 
<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a8630858c8464794242a469bbcd48672">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="9f0784673718e92267b9003a2e8d6eeb"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::getRefineOpStencilWidth" ref="9f0784673718e92267b9003a2e8d6eeb" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::getRefineOpStencilWidth           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return maximum stencil width needed for user-defined data interpolation operations. Default is to return zero, assuming no user-defined operations provided. 
<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#33e5040ce18b9e81c3ae8009df17de7c">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="b21db5a935dbef4d1505d1bf2d7744d2"></a><!-- doxytag: member="SAMRAI::appu::EmbeddedBoundaryGeometry::putToDatabase" ref="b21db5a935dbef4d1505d1bf2d7744d2" args="(tbox::Pointer&lt; tbox::Database &gt; db)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::putToDatabase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The following routine:<p>
<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#b21db5a935dbef4d1505d1bf2d7744d2">putToDatabase()</a><p>
is a concrete implementation of a function declared in the <a class="el" href="classSAMRAI_1_1tbox_1_1Serializable.html">tbox::Serializable</a> abstract base class. 
<p>
Implements <a class="el" href="classSAMRAI_1_1tbox_1_1Serializable.html#d90b74ae3fd7af9a7bb9cbf7f3ebc08a">SAMRAI::tbox::Serializable</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/apputils/embedded_boundary/<a class="el" href="EmbeddedBoundaryGeometry_8h.html">EmbeddedBoundaryGeometry.h</a><li>source/apputils/embedded_boundary/<a class="el" href="EmbeddedBoundaryGeometry_8C.html">EmbeddedBoundaryGeometry.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:28:21 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
