<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum&lt; DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1algs.html">algs</a>::<a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">LocallyActiveDataPatchBoundaryNodeSum</a></div>
<h1>SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum&lt; DIM &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum" -->Class <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">LocallyActiveDataPatchBoundaryNodeSum</a> provides operations for summing locally-active node data values at nodes shared by multiple patches on a single level or across multiple hierarchy levels.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/algorithm/femutils/locally_active/LocallyActiveDataPatchBoundaryNodeSum.h&gt;</code>
<p>
<a href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html#f22f23325c60f607c19305aac573f351">LocallyActiveDataPatchBoundaryNodeSum</a> (const std::string &amp;object_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor initializes object to default (mostly undefined) state.  <a href="#f22f23325c60f607c19305aac573f351"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html#56ca072e6d453e82261eb8daa49a6aa5">~LocallyActiveDataPatchBoundaryNodeSum</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor for the schedule releases all internal storage.  <a href="#56ca072e6d453e82261eb8daa49a6aa5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html#83fcdcfa980bcbebd3dee4df5cee3430">registerSum</a> (int node_data_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register node data with given patch data identifier for summing.  <a href="#83fcdcfa980bcbebd3dee4df5cee3430"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html#552cd4147f18626716a3d070d3a41a56">setupSum</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveDataPatchLevelManager.html">hier::LocallyActiveDataPatchLevelManager</a>&lt; DIM &gt; &gt; level_mgr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up summation operations for node data across shared nodes on a single level.  <a href="#552cd4147f18626716a3d070d3a41a56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html#7735f68d74b3a97c2eca5da8fdaaae3e">setupSum</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const int coarsest_level, const int finest_level)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up for summation operations for node data at shared nodes across a range of hierarchy levels. The active patches for each node quantity on each level is accumed to be defined by the corresponding hier::LocallyActiveDataPatchLevelManager&lt;DIM&gt; objects held by the hier::LocallyActiveVariableDatabase&lt;DIM&gt; Singleton object.  <a href="#7735f68d74b3a97c2eca5da8fdaaae3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html#23320a30a8ae2a499c79fe84fba8af42">computeSum</a> (const bool fill_hanging_nodes=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute sum of node values at each shared node and replace each such node value with the corresponding sum.  <a href="#23320a30a8ae2a499c79fe84fba8af42"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html#72fe2e7afb7dd49815dbbadeaca92ce8">getNumSharedPatchDataSlots</a> (int max_variables_to_register)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Static function used to predetermine number of patch data slots ahared among all <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">LocallyActiveDataPatchBoundaryNodeSum</a> objects (i.e., static members). To get a correct count, this routine should only be called once.  <a href="#72fe2e7afb7dd49815dbbadeaca92ce8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html#97f2028ef24446e2b0dbd40156580e07">getNumUniquePatchDataSlots</a> (int max_variables_to_register)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Static function used to predetermine number of patch data slots unique to each <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">LocallyActiveDataPatchBoundaryNodeSum</a> object (i.e., non-static members). To get a correct count, this routine should only be called exactly once for each object that will be constructed.  <a href="#97f2028ef24446e2b0dbd40156580e07"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum&lt; DIM &gt;</h3>

Class <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">LocallyActiveDataPatchBoundaryNodeSum</a> provides operations for summing locally-active node data values at nodes shared by multiple patches on a single level or across multiple hierarchy levels. 
<p>
NOTE: Currently, the functionality to sum data across multiple hierarchy levels is unavailable.<p>
Usage of a patch boundry node sum involves the following sequence of steps:<p>
<ol type=1>
<li>Construct a patch boundry node sum object. For example, <div class="fragment"><pre class="fragment">
 *         LocallyActiveDataPatchBoundaryNodeSum&lt;DIM&gt; my_node_sum("My Node Sum");
 *     </pre></div></li><li>Register node data quantities to sum. For example, <div class="fragment"><pre class="fragment">
 *         my_node_sum.registerSum(node_data_id1);
 *         my_node_sum.registerSum(node_data_id2);
 *         etc...
 *     </pre></div></li><li>Setup the sum operations for either single level or a range of levels in a patch hierarchy. For example, <div class="fragment"><pre class="fragment">
 *         my_node_sum.setupSum(level, level_mgr);    // single level
 *         -- or --
 *         my_node_sum.setupSum(hierarchy, coarsest_ln, finest_ln);  // multiple levels
 *     </pre></div></li><li>Execute the sum operation. For example, <div class="fragment"><pre class="fragment">
 *         my_node_sum.computeSum()
 *     </pre></div></li></ol>
<p>
The result of these operations is that each node patch data value associated with the registered ids at patch boundaries, on either the single level or range of hierarchy levels, is replaced by the sum of all data values at the node.<p>
Note that only one of the <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html#552cd4147f18626716a3d070d3a41a56">setupSum()</a> functions may be called once a LocallyActiveDataPatchBoundaryNodeSum&lt;DIM&gt; object is created. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="f22f23325c60f607c19305aac573f351"></a><!-- doxytag: member="SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum::LocallyActiveDataPatchBoundaryNodeSum" ref="f22f23325c60f607c19305aac573f351" args="(const std::string &amp;object_name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">LocallyActiveDataPatchBoundaryNodeSum</a>           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor initializes object to default (mostly undefined) state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object_name</em>&nbsp;</td><td>const std::string reference for name of object used in error reporting. When assertion checking is on, the string cannot be empty. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="56ca072e6d453e82261eb8daa49a6aa5"></a><!-- doxytag: member="SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum::~LocallyActiveDataPatchBoundaryNodeSum" ref="56ca072e6d453e82261eb8daa49a6aa5" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">LocallyActiveDataPatchBoundaryNodeSum</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor for the schedule releases all internal storage. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="72fe2e7afb7dd49815dbbadeaca92ce8"></a><!-- doxytag: member="SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum::getNumSharedPatchDataSlots" ref="72fe2e7afb7dd49815dbbadeaca92ce8" args="(int max_variables_to_register)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum</a>&lt; DIM &gt;::getNumSharedPatchDataSlots           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_variables_to_register</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Static function used to predetermine number of patch data slots ahared among all <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">LocallyActiveDataPatchBoundaryNodeSum</a> objects (i.e., static members). To get a correct count, this routine should only be called once. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>integer number of internal patch data slots required to perform sum. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>max_variables_to_register</em>&nbsp;</td><td>integer value indicating maximum number of patch data ids that will be registered with node sum objects. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="97f2028ef24446e2b0dbd40156580e07"></a><!-- doxytag: member="SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum::getNumUniquePatchDataSlots" ref="97f2028ef24446e2b0dbd40156580e07" args="(int max_variables_to_register)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum</a>&lt; DIM &gt;::getNumUniquePatchDataSlots           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_variables_to_register</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Static function used to predetermine number of patch data slots unique to each <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">LocallyActiveDataPatchBoundaryNodeSum</a> object (i.e., non-static members). To get a correct count, this routine should only be called exactly once for each object that will be constructed. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>integer number of internal patch data slots required to perform sum. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>max_variables_to_register</em>&nbsp;</td><td>integer value indicating maximum number of patch data ids that will be registered with node sum objects. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="83fcdcfa980bcbebd3dee4df5cee3430"></a><!-- doxytag: member="SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum::registerSum" ref="83fcdcfa980bcbebd3dee4df5cee3430" args="(int node_data_id)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum</a>&lt; DIM &gt;::registerSum           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node_data_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register node data with given patch data identifier for summing. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node_data_id</em>&nbsp;</td><td>integer patch data index for node data to sum</td></tr>
  </table>
</dl>
The node data id must be a valid patch data id (&gt;=0) and must correspond to node-centered double data. If not, an error will result. 
</div>
</div><p>
<a class="anchor" name="552cd4147f18626716a3d070d3a41a56"></a><!-- doxytag: member="SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum::setupSum" ref="552cd4147f18626716a3d070d3a41a56" args="(tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; level, tbox::Pointer&lt; hier::LocallyActiveDataPatchLevelManager&lt; DIM &gt; &gt; level_mgr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum</a>&lt; DIM &gt;::setupSum           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveDataPatchLevelManager.html">hier::LocallyActiveDataPatchLevelManager</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level_mgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set up summation operations for node data across shared nodes on a single level. 
<p>
If the other <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html#552cd4147f18626716a3d070d3a41a56">setupSum()</a> function for a range of hierarchy levels has been called previously for this object, an error will result.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>pointer to level on which to perform node sum </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_mgr</em>&nbsp;</td><td>pointer to level mgr defining active patches for node data registered with the node sum object</td></tr>
  </table>
</dl>
When assertion checking is active, the level pointer cannot be null. 
</div>
</div><p>
<a class="anchor" name="7735f68d74b3a97c2eca5da8fdaaae3e"></a><!-- doxytag: member="SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum::setupSum" ref="7735f68d74b3a97c2eca5da8fdaaae3e" args="(tbox::Pointer&lt; hier::PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const int coarsest_level, const int finest_level)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum</a>&lt; DIM &gt;::setupSum           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finest_level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set up for summation operations for node data at shared nodes across a range of hierarchy levels. The active patches for each node quantity on each level is accumed to be defined by the corresponding hier::LocallyActiveDataPatchLevelManager&lt;DIM&gt; objects held by the hier::LocallyActiveVariableDatabase&lt;DIM&gt; Singleton object. 
<p>
If the other <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html#552cd4147f18626716a3d070d3a41a56">setupSum()</a> function for a single level has been called previously for this object, an error will result.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>pointer to hierarchy on which to perform node sum </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarsest_level</em>&nbsp;</td><td>coarsest level number for node sum </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>finest_level</em>&nbsp;</td><td>finest level number for node sum</td></tr>
  </table>
</dl>
When assertion checking is active, the hierarchy pointer cannot be null, and the range of levels must be valid. 
</div>
</div><p>
<a class="anchor" name="23320a30a8ae2a499c79fe84fba8af42"></a><!-- doxytag: member="SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum::computeSum" ref="23320a30a8ae2a499c79fe84fba8af42" args="(const bool fill_hanging_nodes=false) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum</a>&lt; DIM &gt;::computeSum           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>fill_hanging_nodes</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute sum of node values at each shared node and replace each such node value with the corresponding sum. 
<p>
At the end of this method, all values at shared node locations on patch boundaries (on levels indicated by the call to one of the <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html#552cd4147f18626716a3d070d3a41a56">setupSum()</a> routines) will have the same value.<p>
When the <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html#552cd4147f18626716a3d070d3a41a56">setupSum()</a> method taking a range of patch levels in a hierarchy is called, this method will compute the sum of nodal quantities at all the specified patch boundaries. For nodes at a coarse-fine boundary, nodal sums will only be performed where the coarse and fine nodes overlap. A node on a fine level that is not also a node on the next coarser level (a so-called "hanging node") will not be summed.<p>
The boolean "fill_hanging_nodes" argument specifies whether the the hanging nodes should be filled using linearly interpolated values from neighboring non-hanging nodes (i.e. those that overlap nodes on a coarse level). The correct steps required to deal with hanging nodes is algorithm dependent so, if left unspecified, values at the hanging nodes will not be adjusted. However, because many algorithms average hanging nodes we provide the capability to do it here. Note that the hanging node interpolation provided does not take into consideration the spatial location of the nodes. So the interpolation may not be correct for coordinate systems other than standard Cartesian grid geometry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fill_hanging_nodes</em>&nbsp;</td><td>Optional boolean value specifying whether hanging node values should be set to values interpolated from neighboring non-hanging node values. The default is false. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/algorithm/femutils/locally_active/<a class="el" href="LocallyActiveDataPatchBoundaryNodeSum_8h.html">LocallyActiveDataPatchBoundaryNodeSum.h</a><li>source/algorithm/femutils/locally_active/<a class="el" href="LocallyActiveDataPatchBoundaryNodeSum_8C.html">LocallyActiveDataPatchBoundaryNodeSum.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:28:19 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
