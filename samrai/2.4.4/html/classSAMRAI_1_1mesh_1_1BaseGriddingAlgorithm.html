<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>::<a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">BaseGriddingAlgorithm</a></div>
<h1>SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::mesh::BaseGriddingAlgorithm" --><!-- doxytag: inherits="SAMRAI::tbox::Serializable" -->Virtual base class providing interface for gridding algorithm.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/mesh/gridding/BaseGriddingAlgorithm.h&gt;</code>
<p>
Inheritance diagram for SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;:<p><center><img src="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm__inherit__graph.png" border="0" usemap="#SAMRAI_1_1mesh_1_1BaseGriddingAlgorithm_3_01DIM_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="SAMRAI_1_1mesh_1_1BaseGriddingAlgorithm_3_01DIM_01_4__inherit__map">
<area href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html" shape="rect" coords="7,232,281,256" alt="">
<area href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html" shape="rect" coords="305,232,639,256" alt="">
<area href="classSAMRAI_1_1tbox_1_1Serializable.html" shape="rect" coords="217,83,399,107" alt="">
<area href="classtbox_1_1DescribedClass.html" shape="rect" coords="251,8,365,32" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#7c9d131a13d6b1442dc0b9c034f31a5f">BaseGriddingAlgorithm</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#7c9d131a13d6b1442dc0b9c034f31a5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#86ec73f6146560a462a303f9aa4914c7">~BaseGriddingAlgorithm</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual destructor for BaseGriddingAlgorithm&lt;DIM&gt;.  <a href="#86ec73f6146560a462a303f9aa4914c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#38ea13b0d56ed4e0a80f37eb92957eff">makeCoarsestLevel</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const double level_time, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;override_boxes=0, const <a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;override_mapping=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct the coarsest level in a hierarchy (i.e., level 0).  <a href="#38ea13b0d56ed4e0a80f37eb92957eff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#6e2fd0ed01be50969e4451b39cf5a9c5">makeFinerLevel</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const double level_time, const bool initial_time, const int tag_buffer, const double regrid_start_time=0.)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine attempts to create a new level in a hierarchy finer than the finest level currently residing in the hierarchy.  <a href="#6e2fd0ed01be50969e4451b39cf5a9c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#27aa93c208000bfbb871c02f21b918ae">regridAllFinerLevels</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const int level_number, const double regrid_time, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; int &gt; &amp;tag_buffer, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt; regrid_start_time=<a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt;(), const bool level_is_coarsest_to_sync=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine attempts to reconfigure the patches on each level in an AMR patch hierarchy which is finer than the specified level.  <a href="#27aa93c208000bfbb871c02f21b918ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#1a10894c9e4f96e2ac6d8b9cca1efcdd">errorEstimationUsesTimeIntegration</a> () const=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if error estimation process uses time integration; otherwise, return false.  <a href="#1a10894c9e4f96e2ac6d8b9cca1efcdd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#2467f4e8b80d42fabefda019eba8b6d9">getErrorCoarsenRatio</a> () const=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the error coarsen ratio.  <a href="#2467f4e8b80d42fabefda019eba8b6d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#80593a645746dc9208810412a5880b18">levelCanBeRefined</a> (const int level_number) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if level associated with the specified level number can be refined; i.e., the level number is less than that of the finest level allowed in the hierarchy. Otherwise, false is returned.  <a href="#80593a645746dc9208810412a5880b18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#edbd080e17757c682391a616454ba97c">getTagAndInitializeStrategy</a> () const=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return pointer to level gridding strategy data member.  <a href="#edbd080e17757c682391a616454ba97c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#680a6dc0520c476f4486ec04b2756c47">getMaxLevels</a> () const=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum number of levels allowed in hierarchy.  <a href="#680a6dc0520c476f4486ec04b2756c47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;<br>
 DIM &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#4816dd64af50c6cd594edadfc366bee0">getRatioToCoarserLevel</a> (const int level_number) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return const reference to ratio between specified level and next coarser.  <a href="#4816dd64af50c6cd594edadfc366bee0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#78ed81ac7ddfe070acde1ee5c0c0d030">getEfficiencyTolerance</a> (const int level_number) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return efficiency tolerance for clustering tags on level.  <a href="#78ed81ac7ddfe070acde1ee5c0c0d030"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#c4bdddcbf6701d0a220c66ac29751643">getCombineEfficiency</a> (const int level_number) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return combine efficiency for clustering tags on level.  <a href="#c4bdddcbf6701d0a220c66ac29751643"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#b87a8fe4d49b5844ce23d11aa4891edd">getProperNestingBuffer</a> (const int level_number) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return proper nesting buffer width for level.  <a href="#b87a8fe4d49b5844ce23d11aa4891edd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#402d40aa6172a028f927af79440bd813">putToDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; db)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write object state out to the given database.  <a href="#402d40aa6172a028f927af79440bd813"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</h3>

Virtual base class providing interface for gridding algorithm. 
<p>
Class <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">BaseGriddingAlgorithm</a> in a virtual base class that provides an abstract interface for a gridding algorithm. This allows higher-level classes in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> and in applications that use <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> to interface with a gridding algorithm in an abstract manner without knowing whether it is a <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a> that handles gridding operations on a rectangular domain or if it is an algorithm for gridding on, for example, a multiblock domain.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="7c9d131a13d6b1442dc0b9c034f31a5f"></a><!-- doxytag: member="SAMRAI::mesh::BaseGriddingAlgorithm::BaseGriddingAlgorithm" ref="7c9d131a13d6b1442dc0b9c034f31a5f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">BaseGriddingAlgorithm</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="86ec73f6146560a462a303f9aa4914c7"></a><!-- doxytag: member="SAMRAI::mesh::BaseGriddingAlgorithm::~BaseGriddingAlgorithm" ref="86ec73f6146560a462a303f9aa4914c7" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">BaseGriddingAlgorithm</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual destructor for BaseGriddingAlgorithm&lt;DIM&gt;. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="38ea13b0d56ed4e0a80f37eb92957eff"></a><!-- doxytag: member="SAMRAI::mesh::BaseGriddingAlgorithm::makeCoarsestLevel" ref="38ea13b0d56ed4e0a80f37eb92957eff" args="(tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const double level_time, const hier::BoxArray&lt; DIM &gt; &amp;override_boxes=0, const hier::ProcessorMapping &amp;override_mapping=0)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::makeCoarsestLevel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>level_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>override_boxes</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>override_mapping</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct the coarsest level in a hierarchy (i.e., level 0). 
<p>
If level 0 does not already exist, then the domain specification is checked against the constraints of the grid generation procedures. The level gridding strategy data member defines these constraints. Recall that the domain specification is maintained by the grid geometry associated with the hierarchy. Generally, an unrecoverable exception will result if the constraints are not satisfied.<p>
If level 0 already exists in the hierarchy, then the routine will generate a new level by re-applying the load balancing procedure to the existing level. Data will be moved from the old level to the new level and the pre-existing level 0 will be discarded. Note that this routine is different than the routine <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#6e2fd0ed01be50969e4451b39cf5a9c5">makeFinerLevel()</a> below, which is used to construct levels 1 and finer. In particular, this routine does not select cells for refinement, whereas the other routine does.<p>
Important note: If assertion checking is turned on, then an unrecoverable assertion will result if either the patch hierarchy or its grid geometry is NULL.<p>
The two optional arguments are only to be used for a special case where the user wishes to manually specify a box decomposition and load balance for the coarsest level of the hierarchy. The BoxArray argument must be a decomposition of the the coarsest level, and must exactly fill the index space of the physical domain of the hierarchy. The ProcessorMapping must be constructed to map each box in the BoxArray to a processor. The size of the mapping must be equal to the length of the box array, or an assertion failure will result.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The hierarchy on which coarse level is constructed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_time</em>&nbsp;</td><td>Simulation time when level is constructed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>override_boxes</em>&nbsp;</td><td>box array representing a decomposition of level zero of the hierarchy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>override_mapping</em>&nbsp;</td><td>processor mapping that maps each box in the above array to a processor. </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#c6ac68fc94d09e89645bb976b41dbc70">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#0982d392d7673380d0486ec955279e7d">SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="6e2fd0ed01be50969e4451b39cf5a9c5"></a><!-- doxytag: member="SAMRAI::mesh::BaseGriddingAlgorithm::makeFinerLevel" ref="6e2fd0ed01be50969e4451b39cf5a9c5" args="(tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const double level_time, const bool initial_time, const int tag_buffer, const double regrid_start_time=0.)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::makeFinerLevel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>level_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_start_time</em> = <code>0.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine attempts to create a new level in a hierarchy finer than the finest level currently residing in the hierarchy. 
<p>
It will select cells for refinement on the finest level and construct a new finest level, if necessary. If no cells are selected for refinement, no new level will be added to the hierarchy. The boolean argument initial_time indicates whether the routine is called at the initial simulation time. If true, this routine is used to build individual levels during the construction of the AMR hierarchy at the initial simulation time. If false, the routine is being used to add new levels to the hierarchy at some later point. In either case, the time value is the current simulation time. Note that this routine cannot be used to construct the coarsest level in the hierarchy (i.e., level 0). The routine <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#38ea13b0d56ed4e0a80f37eb92957eff">makeCoarsestLevel()</a> above must be used for that purpose.<p>
The tag buffer indicates the number of cells by which cells selected for refinement will be buffered before new finer level boxes are constructed. The buffer is important to keep phenomena of interest on refined regions of the mesh until adaptive regridding occurs next. Thus, the buffer size should take into account how the simulation may evolve before regridding occurs (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., number of timesteps taken).<p>
Important note: If assertion checking is activated, several checks are applied to the functions arguments. If any check is violated, an unrecoverable assertion will result. In particular, the hierarchy pointer must be non-NULL and the given level number must match that of the finest level currently residing in the hierarchy. Also, the the tag buffer must be positive.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The hierarchy on which coarse level is constructed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_time</em>&nbsp;</td><td>Simulation time when level is constructed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>initial_time</em>&nbsp;</td><td>Must be true if level_time is the initial time of the simulation, false otherwise </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_buffer</em>&nbsp;</td><td>Size of buffer around tagged cells that will be covered by the fine level </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regrid_start_time</em>&nbsp;</td><td>The simulation time when the regridding operation began (this parameter is ignored except when using Richardson extrapolation) </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#0731d3541c79f65abe798e9e5b70767b">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#adab6c6ad06ba6006087ff024606e1b8">SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="27aa93c208000bfbb871c02f21b918ae"></a><!-- doxytag: member="SAMRAI::mesh::BaseGriddingAlgorithm::regridAllFinerLevels" ref="27aa93c208000bfbb871c02f21b918ae" args="(tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const int level_number, const double regrid_time, const tbox::Array&lt; int &gt; &amp;tag_buffer, tbox::Array&lt; double &gt; regrid_start_time=tbox::Array&lt; double &gt;(), const bool level_is_coarsest_to_sync=true)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::regridAllFinerLevels           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tag_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt;&nbsp;</td>
          <td class="paramname"> <em>regrid_start_time</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt;&nbsp;double&nbsp;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>level_is_coarsest_to_sync</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine attempts to reconfigure the patches on each level in an AMR patch hierarchy which is finer than the specified level. 
<p>
The given level number is that of the coarsest level on which cells will be selected for refinement. In other words, that level is the finest level that will not be subject to a change in its patch configuration during the regridding process. Generally, this routine should be used to alter a pre-existing AMR patch hierarchy based on the need to adapt the computational mesh around some phenomenon of interest. The routine <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#6e2fd0ed01be50969e4451b39cf5a9c5">makeFinerLevel()</a> above should be used to construct an initial hierarchy configuration or to add more than one new level into the hierarchy. Also, this routine will not reconfigure the patches on level 0 (i.e., the coarsest in any hierarchy). The routine <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#38ea13b0d56ed4e0a80f37eb92957eff">makeCoarsestLevel()</a> above is provided for that purpose.<p>
Note that the current algorithm permits at most one new finest level to be added to the hierarchy with each invocation of the regridding process. This constraint, though seemingly restrictive makes the process of maintaining properly nested levels much easier.<p>
The tag buffer array indicates the number of cells by which cells selected for refinement on a level will be buffered before new finer level boxes are constructed. The buffer is important to keep phenomena of interest on refined regions of the mesh until adaptive regridding occurs next. Thus, the buffer size should take into account how the simulation may evolve before regridding occurs (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., number of timesteps taken on each level).<p>
The boolean argument is used for regridding in time-dependent problems. When true, it indicates that the specified level is the coarsest level to synchronize at the current regrid time before this regridding method is called. This is a pretty idiosyncratic argument but allows some flexibility in the way memory is managed during time-dependent regridding operations.<p>
Important note: If assertion checking is activated, several checks are applied to the functions arguments. If any check is violated, an unrecoverable assertion will result. In particular, the hierarchy pointer must be non-NULL and the given level number must match that of of some level in the hierarchy. Also, the tag buffer array must contain a positive value for each level in the hierarchy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The hierarchy on which coarse level is constructed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_number</em>&nbsp;</td><td>Coarsest level on which cells will be tagged for refinement </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regrid_time</em>&nbsp;</td><td>Simulaition time when regridding occurs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_buffer</em>&nbsp;</td><td>Size of buffer on each level around tagged cells that will be covered by the next finer level </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regrid_start_time</em>&nbsp;</td><td>The simulation time when the regridding operation began on each level (this parameter is ignored except when using Richardson extrapolation) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_is_coarsest_to_sync</em>&nbsp;</td><td>Level is the coarsest to sync </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#4dd69a9bf65bfe13b4cd6712e868c607">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#bd7930b5c836bc43bd0628c586419552">SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="1a10894c9e4f96e2ac6d8b9cca1efcdd"></a><!-- doxytag: member="SAMRAI::mesh::BaseGriddingAlgorithm::errorEstimationUsesTimeIntegration" ref="1a10894c9e4f96e2ac6d8b9cca1efcdd" args="() const=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::errorEstimationUsesTimeIntegration           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if error estimation process uses time integration; otherwise, return false. 
<p>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#6e436b44a8afebdb436be4f76df0d349">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#a15cb0fbd0a44312306d482871335089">SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="2467f4e8b80d42fabefda019eba8b6d9"></a><!-- doxytag: member="SAMRAI::mesh::BaseGriddingAlgorithm::getErrorCoarsenRatio" ref="2467f4e8b80d42fabefda019eba8b6d9" args="() const=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::getErrorCoarsenRatio           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the error coarsen ratio. 
<p>
This is needed for cases where an error estimation scheme uses time integration (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>. Richardson extrapolation) to determine how many time levels to maintain to properly apply the estimtion scheme. In general, an even refine ratio (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>. 2, 4, 8) will maintain two time levels, while while an odd refine ratio (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>. 3) will maintain three. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#6deb51b6fc4f6229d03a403b28827b40">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#2e47e19f09e210655bcf9dbaadd019cc">SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="80593a645746dc9208810412a5880b18"></a><!-- doxytag: member="SAMRAI::mesh::BaseGriddingAlgorithm::levelCanBeRefined" ref="80593a645746dc9208810412a5880b18" args="(const int level_number) const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::levelCanBeRefined           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if level associated with the specified level number can be refined; i.e., the level number is less than that of the finest level allowed in the hierarchy. Otherwise, false is returned. 
<p>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#ce77e7e1519d0b6357f13daa6b118ee6">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#a100eb14da651d3d39476bbc6eb8b89d">SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="edbd080e17757c682391a616454ba97c"></a><!-- doxytag: member="SAMRAI::mesh::BaseGriddingAlgorithm::getTagAndInitializeStrategy" ref="edbd080e17757c682391a616454ba97c" args="() const=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a>&lt;DIM&gt; &gt; <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::getTagAndInitializeStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return pointer to level gridding strategy data member. 
<p>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#340373f4871526a19b62bdcf245cf50d">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#96a6e57d1c5dbb3fe4a27612a02d72b3">SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="680a6dc0520c476f4486ec04b2756c47"></a><!-- doxytag: member="SAMRAI::mesh::BaseGriddingAlgorithm::getMaxLevels" ref="680a6dc0520c476f4486ec04b2756c47" args="() const=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::getMaxLevels           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return maximum number of levels allowed in hierarchy. 
<p>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#5254b158aadf1011585f42bfcc2bbfed">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#b0dcd4f2cc74c411c605be9e24a44a0a">SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="4816dd64af50c6cd594edadfc366bee0"></a><!-- doxytag: member="SAMRAI::mesh::BaseGriddingAlgorithm::getRatioToCoarserLevel" ref="4816dd64af50c6cd594edadfc366bee0" args="(const int level_number) const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;DIM&gt;&amp; <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::getRatioToCoarserLevel           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return const reference to ratio between specified level and next coarser. 
<p>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#4dc2972c564039b5e163ff00831c9265">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#f535f3c9819d8dfb6e7f9c7e31cc3218">SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="78ed81ac7ddfe070acde1ee5c0c0d030"></a><!-- doxytag: member="SAMRAI::mesh::BaseGriddingAlgorithm::getEfficiencyTolerance" ref="78ed81ac7ddfe070acde1ee5c0c0d030" args="(const int level_number) const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::getEfficiencyTolerance           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return efficiency tolerance for clustering tags on level. 
<p>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#8d961a041e7aa22eab1111e04da9fcbd">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#cce894dbad4f8372816dafadbaa9b63a">SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="c4bdddcbf6701d0a220c66ac29751643"></a><!-- doxytag: member="SAMRAI::mesh::BaseGriddingAlgorithm::getCombineEfficiency" ref="c4bdddcbf6701d0a220c66ac29751643" args="(const int level_number) const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::getCombineEfficiency           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return combine efficiency for clustering tags on level. 
<p>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#78e143eed354b8d9939be76112a1462f">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#1ca17f262ecd3aaaa5973c70c882038c">SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="b87a8fe4d49b5844ce23d11aa4891edd"></a><!-- doxytag: member="SAMRAI::mesh::BaseGriddingAlgorithm::getProperNestingBuffer" ref="b87a8fe4d49b5844ce23d11aa4891edd" args="(const int level_number) const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::getProperNestingBuffer           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return proper nesting buffer width for level. 
<p>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#b79bf3443fbd5bec9b495314a2990b63">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#349f11f113f26130c4a718794dd69742">SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="402d40aa6172a028f927af79440bd813"></a><!-- doxytag: member="SAMRAI::mesh::BaseGriddingAlgorithm::putToDatabase" ref="402d40aa6172a028f927af79440bd813" args="(tbox::Pointer&lt; tbox::Database &gt; db)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::putToDatabase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write object state out to the given database. 
<p>
When assertion checking is active, the database pointer must be non-null. 
<p>
Implements <a class="el" href="classSAMRAI_1_1tbox_1_1Serializable.html#d90b74ae3fd7af9a7bb9cbf7f3ebc08a">SAMRAI::tbox::Serializable</a>.
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#bc891b565bc13bdc5b85afb2d1cdaf6b">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html#502dc58d8b870cf424f82fa678e70b66">SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/mesh/gridding/<a class="el" href="BaseGriddingAlgorithm_8h.html">BaseGriddingAlgorithm.h</a><li>source/mesh/gridding/<a class="el" href="BaseGriddingAlgorithm_8C.html">BaseGriddingAlgorithm.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:28:40 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
