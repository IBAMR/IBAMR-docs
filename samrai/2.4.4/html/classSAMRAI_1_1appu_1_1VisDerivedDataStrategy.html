<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::appu::VisDerivedDataStrategy&lt; DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1appu.html">appu</a>::<a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">VisDerivedDataStrategy</a></div>
<h1>SAMRAI::appu::VisDerivedDataStrategy&lt; DIM &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::appu::VisDerivedDataStrategy" -->Class VisDerivedDataStrategy&lt;DIM&gt; is an abstract base class that defines an interface allowing an VisItDataWriter&lt;DIM&gt; object and/or an CartesianVizamraiDataWriter&lt;DIM&gt; object to generate plot files that contain "derived" quantities; that is, data that does not reside on the hierarchy, but which is derived from data that does reside on the hierarchy. The derived data may be scalar, vector, or tensor (VisIt only), and cell-centered or node-centered (VisIt only). A concrete object of this type must be registered with the data writer if any derived variable is registered with the data writer. The registration of the concrete strategy object may be done independently using the method setDerivedDataWriter() (Vizamrai only) or setDefaultDerivedDataWriter() (VisIt only) from the relevant DataWriter class, or the concrete strategy object may be registered concurrently with the derived variable using the method registerDerivedPlotScalar/Vector/Tensor().  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/apputils/plotting/VisDerivedDataStrategy.h&gt;</code>
<p>
Inheritance diagram for SAMRAI::appu::VisDerivedDataStrategy&lt; DIM &gt;:<p><center><img src="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy__inherit__graph.png" border="0" usemap="#SAMRAI_1_1appu_1_1VisDerivedDataStrategy_3_01DIM_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="SAMRAI_1_1appu_1_1VisDerivedDataStrategy_3_01DIM_01_4__inherit__map">
<area href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html" shape="rect" coords="7,99,364,123" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html#90f7dbdd7bdd19cc503569a5ede07262">VisDerivedDataStrategy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor for VisDerivedDataStrategy&lt;DIM&gt;.  <a href="#90f7dbdd7bdd19cc503569a5ede07262"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html#f1c45370a43034edbf0654103ca874ab">~VisDerivedDataStrategy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor for VisDerivedDataStrategy&lt;DIM&gt;.  <a href="#f1c45370a43034edbf0654103ca874ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html#225f37622023b009f915f21770de5a60">packDerivedDataIntoDoubleBuffer</a> (double *<a class="el" href="appu__cpdat2buf3d_8f.html#e3215fc943ca2137c64ec5948646fa5a">buffer</a>, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;patch, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;region, const std::string &amp;variable_name, int depth_index) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function calculates and packs derived cell-centered data to a 1D double precision buffer. In the case of the VisIt data writer, node-centered data may also be used. It is called once for each component of multicomponent data.  <a href="#225f37622023b009f915f21770de5a60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html#34a9f499ea4664a7fd96711bde914a40">packMixedDerivedDataIntoDoubleBuffer</a> (double *<a class="el" href="appu__cpdat2buf3d_8f.html#e3215fc943ca2137c64ec5948646fa5a">buffer</a>, std::vector&lt; double &gt; &amp;mixbuffer, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;patch, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;region, const std::string &amp;variable_name, int depth_index) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function calculates and packs derived cell-centered data to a 1D double precision buffer. It also packs material state varaibles for component materials in mixed zones for accurate visualization of mixed zones. In the case of the VisIt data writer, node-centered data may also be used. It is called once for each component of multicomponent data.  <a href="#34a9f499ea4664a7fd96711bde914a40"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class SAMRAI::appu::VisDerivedDataStrategy&lt; DIM &gt;</h3>

Class VisDerivedDataStrategy&lt;DIM&gt; is an abstract base class that defines an interface allowing an VisItDataWriter&lt;DIM&gt; object and/or an CartesianVizamraiDataWriter&lt;DIM&gt; object to generate plot files that contain "derived" quantities; that is, data that does not reside on the hierarchy, but which is derived from data that does reside on the hierarchy. The derived data may be scalar, vector, or tensor (VisIt only), and cell-centered or node-centered (VisIt only). A concrete object of this type must be registered with the data writer if any derived variable is registered with the data writer. The registration of the concrete strategy object may be done independently using the method setDerivedDataWriter() (Vizamrai only) or setDefaultDerivedDataWriter() (VisIt only) from the relevant DataWriter class, or the concrete strategy object may be registered concurrently with the derived variable using the method registerDerivedPlotScalar/Vector/Tensor(). 
<p>
The concrete strategy object is responsible for supplying an implementation of the function <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html#225f37622023b009f915f21770de5a60">packDerivedDataIntoDoubleBuffer()</a> which calculates the derived data and writes it into the double precision buffer passed in to it.<p>
This class is shared by both VisDataWriter&lt;DIM&gt; and CartesianVizamraiDataWriter&lt;DIM&gt;.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">appu::VisItDataWriter</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="90f7dbdd7bdd19cc503569a5ede07262"></a><!-- doxytag: member="SAMRAI::appu::VisDerivedDataStrategy::VisDerivedDataStrategy" ref="90f7dbdd7bdd19cc503569a5ede07262" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">SAMRAI::appu::VisDerivedDataStrategy</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">VisDerivedDataStrategy</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor for VisDerivedDataStrategy&lt;DIM&gt;. 
<p>

</div>
</div><p>
<a class="anchor" name="f1c45370a43034edbf0654103ca874ab"></a><!-- doxytag: member="SAMRAI::appu::VisDerivedDataStrategy::~VisDerivedDataStrategy" ref="f1c45370a43034edbf0654103ca874ab" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">SAMRAI::appu::VisDerivedDataStrategy</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">VisDerivedDataStrategy</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor for VisDerivedDataStrategy&lt;DIM&gt;. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="225f37622023b009f915f21770de5a60"></a><!-- doxytag: member="SAMRAI::appu::VisDerivedDataStrategy::packDerivedDataIntoDoubleBuffer" ref="225f37622023b009f915f21770de5a60" args="(double *buffer, const hier::Patch&lt; DIM &gt; &amp;patch, const hier::Box&lt; DIM &gt; &amp;region, const std::string &amp;variable_name, int depth_index) const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">SAMRAI::appu::VisDerivedDataStrategy</a>&lt; DIM &gt;::packDerivedDataIntoDoubleBuffer           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>variable_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function calculates and packs derived cell-centered data to a 1D double precision buffer. In the case of the VisIt data writer, node-centered data may also be used. It is called once for each component of multicomponent data. 
<p>
The buffer will be already allocated. This routine is needed to construct data values that are not stored on the hierarchy, but which may be important to visualize. The data to be packed corresponds to the plot variable that the user has registered with the data writer using registerDerivedPlotScalar/Vector/Tensor() with the string "variable_name". The data to be packed is derived from the data that lives on the given patch. The box describes the patch region over which to pack the data. It is assumed that all data needed to compute the derived quantity exists on the given patch.<p>
The method <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html#225f37622023b009f915f21770de5a60">packDerivedDataIntoDoubleBuffer()</a> will be called DIM times for vector data, and DIM*DIM times for tensor data, with the integer "depth_index" argument indicating the particular component of vector to be packed. For scalar values, the depth_index will be 0.<p>
This routine must include ghost data if the ghost_cell_width parameter was set when the derived data was registered. The data must be packed into the buffer in column major order, the ordering used by <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>, i.e. (f(x_0,y_0,z_0), f(x_1,y_0,z_0), f(x_2,y_0,z_0), ...). If the derived data was registered as node-centered, a buffer of node-centered data is expected. Derived data need not be defined on all patches. It is the responsibility of this routine to determine if data exists on the patch and set the return value of of this routine appropriately: true if the data exists on the patch, false otherwise.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Double precision array into which derived data is packed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> on which to calculate and pack derived data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> region over which to pack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>variable_name</em>&nbsp;</td><td>Name identifier for the derived variable as registered in registerDerivedPlotScalar/Vector/Tensor(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth_index</em>&nbsp;</td><td>For scalar quantities index will be zero. For vector data, index varies between 0 and DIM-1. For tensor data, index varies from 0 (DIM*DIM)-1. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Boolean value indicating if derived data defined on this patch. </dd></dl>

</div>
</div><p>
<a class="anchor" name="34a9f499ea4664a7fd96711bde914a40"></a><!-- doxytag: member="SAMRAI::appu::VisDerivedDataStrategy::packMixedDerivedDataIntoDoubleBuffer" ref="34a9f499ea4664a7fd96711bde914a40" args="(double *buffer, std::vector&lt; double &gt; &amp;mixbuffer, const hier::Patch&lt; DIM &gt; &amp;patch, const hier::Box&lt; DIM &gt; &amp;region, const std::string &amp;variable_name, int depth_index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">SAMRAI::appu::VisDerivedDataStrategy</a>&lt; DIM &gt;::packMixedDerivedDataIntoDoubleBuffer           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mixbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>variable_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function calculates and packs derived cell-centered data to a 1D double precision buffer. It also packs material state varaibles for component materials in mixed zones for accurate visualization of mixed zones. In the case of the VisIt data writer, node-centered data may also be used. It is called once for each component of multicomponent data. 
<p>
The buffer will be already allocated and an empty vector will be provided. This routine is needed to construct data values that are not stored on the hierarchy, but which may be important to visualize. The data to be packed corresponds to the plot variable that the user has registered with the data writer using registerDerivedPlotScalar/Vector/Tensor() with the string "variable_name". The data to be packed is derived from the data that lives on the given patch. The box describes the patch region over which&gt; * to pack the data. It is assumed that all data needed to compute the derived quantity exists on the given patch.<p>
The method <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html#34a9f499ea4664a7fd96711bde914a40">packMixedDerivedDataIntoDoubleBuffer()</a> will be called DIM times for vector data, and DIM*DIM times for tensor data, with the integer "depth_index" argument indicating the particular component of vector to be packed. For scalar values, the depth_index will be 0.<p>
This routine must include ghost data if the ghost_cell_width parameter was set when the derived data was registered. The data must be packed into the buffer in column major order, the ordering used by <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>, i.e. (f(x_0,y_0,z_0), f(x_1,y_0,z_0), f(x_2,y_0,z_0), ...). If the derived data was registered as node-centered, a buffer of node-centered data is expected. Derived data need not be defined on all patches. It is the responsibility of this routine to determine if data exists on the patch and set the return value of of this routine appropriately: true if the data exists on the patch, false otherwise.<p>
Mixed data should be packed in a sparse manner (i.e., only for cells that are mixed) in the same column major order and following the ordering of materials specified when registerMaterialNames() or registerSparseMaterialNames() was called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Double precision array into which derived data is packed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> on which to calculate and pack derived data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> region over which to pack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>variable_name</em>&nbsp;</td><td>Name identifier for the derived variable as registered in registerDerivedPlotScalar/Vector/Tensor(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth_index</em>&nbsp;</td><td>For scalar quantities index will be zero. For vector data, index varies between 0 and DIM-1. For tensor data, index varies from 0 (DIM*DIM)-1. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Boolean value indicating if derived data defined on this patch. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/apputils/plotting/<a class="el" href="VisDerivedDataStrategy_8h.html">VisDerivedDataStrategy.h</a><li>source/apputils/plotting/<a class="el" href="VisDerivedDataStrategy_8C.html">VisDerivedDataStrategy.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:28:22 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
