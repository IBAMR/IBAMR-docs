<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: Class List</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li id="current"><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>SAMRAI Class List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
  <tr><td class="indexkey"><a class="el" href="structarith__functions.html">arith_functions</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structKeyData.html">KeyData</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classMDA__Access.html">MDA_Access&lt; MDA_TYPE, MDA_DIM, OrderType &gt;</a></td><td class="indexvalue">Non-const multidimensional array access </td></tr>
  <tr><td class="indexkey"><a class="el" href="classMDA__AccessConst.html">MDA_AccessConst&lt; MDA_TYPE, MDA_DIM, OrderType &gt;</a></td><td class="indexvalue">Const data version of the multidimensional array access template class <a class="el" href="classMDA__Access.html">MDA_Access</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classMDA__IndexRange.html">MDA_IndexRange&lt; MDA_DIM &gt;</a></td><td class="indexvalue">Defines index ranges for multidimensional arrays </td></tr>
  <tr><td class="indexkey"><a class="el" href="classMDA__OrderColMajor.html">MDA_OrderColMajor&lt; MDA_DIM &gt;</a></td><td class="indexvalue">Performs computations based for column-major arrays </td></tr>
  <tr><td class="indexkey"><a class="el" href="classMDA__OrderRowMajor.html">MDA_OrderRowMajor&lt; MDA_DIM &gt;</a></td><td class="indexvalue">Performs computations based for row-major arrays </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">SAMRAI::algs::HyperbolicLevelIntegrator&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1ImplicitEquationStrategy.html">SAMRAI::algs::ImplicitEquationStrategy&lt; DIM &gt;</a></td><td class="indexvalue"><b>Abstract</b> base class defining the interface between ImplicitIntegrator&lt;DIM&gt; object and routines specific to the system of equations to be solved </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1ImplicitIntegrator.html">SAMRAI::algs::ImplicitIntegrator&lt; DIM &gt;</a></td><td class="indexvalue">Manage implicit time integration over an AMR patch hierarchy </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataOuteredgeSumTransactionFactory.html">SAMRAI::algs::LocallyActiveDataOuteredgeSumTransactionFactory&lt; DIM &gt;</a></td><td class="indexvalue">Concrete subclass of the xfer::LocallyActiveDataRefineTransactionFactory&lt;DIM&gt; base class that allocates outeredge sum transaction objects for a xfer::LocallyActiveDataRefineSchedule&lt;DIM&gt; object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataOuternodeSumTransactionFactory.html">SAMRAI::algs::LocallyActiveDataOuternodeSumTransactionFactory&lt; DIM &gt;</a></td><td class="indexvalue">Concrete subclass of the xfer::LocallyActiveDataRefineTransactionFactory&lt;DIM&gt; base class that allocates transaction outernode sum objects for a xfer::LocallyActiveDataRefineSchedule&lt;DIM&gt; object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryEdgeSum.html">SAMRAI::algs::LocallyActiveDataPatchBoundaryEdgeSum&lt; DIM &gt;</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryEdgeSum.html">LocallyActiveDataPatchBoundaryEdgeSum</a> provides operations summing locally-active edge data values at edges that are shared by multiple patches on a single level. Note that this utility only works on a SINGLE patch level, not on a multiple levels in an AMR patch hierarchy like the <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">LocallyActiveDataPatchBoundaryNodeSum</a> class. Unlike node data, edge data at coarse-fine boundaries are not co-located, so the sum operation across levels depends on application requirements </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">SAMRAI::algs::LocallyActiveDataPatchBoundaryNodeSum&lt; DIM &gt;</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1algs_1_1LocallyActiveDataPatchBoundaryNodeSum.html">LocallyActiveDataPatchBoundaryNodeSum</a> provides operations for summing locally-active node data values at nodes shared by multiple patches on a single level or across multiple hierarchy levels </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1MblkPatchBoundaryNodeSum.html">SAMRAI::algs::MblkPatchBoundaryNodeSum&lt; DIM &gt;</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1algs_1_1MblkPatchBoundaryNodeSum.html">MblkPatchBoundaryNodeSum</a> provides operations for summing node data values at nodes that are shared by multiple patches on a single level or across multiple hierarchy levels </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">SAMRAI::algs::MethodOfLinesIntegrator&lt; DIM &gt;</a></td><td class="indexvalue">Class MethodOfLinesIntegrator&lt;DIM&gt; implements a spatially adaptive version of the Strong Stability Preserving (SSP) Runge-Kutta time integration algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesPatchStrategy.html">SAMRAI::algs::MethodOfLinesPatchStrategy&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1OuteredgeSumTransaction.html">SAMRAI::algs::OuteredgeSumTransaction&lt; DIM &gt;</a></td><td class="indexvalue">Class OuteredgeSumTransaction&lt;DIM&gt; represents a single outeredge data sum communication transaction between two processors or a local data sum for refine schedules. Note that to there is an implicit hand-shaking between objects of this class and the xfer::RefineSchedule&lt;DIM&gt; object that constructs them. Following the refine schedule implementation, the source patch data index for a transaction always refers to the source data and the destination patch data index for a transaction is always the scratch data, all as defined in the xfer::RefineClasses&lt;DIM&gt; class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1OuteredgeSumTransactionFactory.html">SAMRAI::algs::OuteredgeSumTransactionFactory&lt; DIM &gt;</a></td><td class="indexvalue">Concrete subclass of the xfer::RefineTransactionFactory&lt;DIM&gt; base class that allocates outeredge sum transaction objects for a xfer::RefineSchedule&lt;DIM&gt; object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1OuternodeSumTransaction.html">SAMRAI::algs::OuternodeSumTransaction&lt; DIM &gt;</a></td><td class="indexvalue">Class OuternodeSumTransaction&lt;DIM&gt; represents a single outernode data sum communication transaction between two processors or a local data sum for refine schedules. Note that to there is an implicit hand-shaking between objects of this class and the xfer::RefineSchedule&lt;DIM&gt; object that constructs them. Following the refine schedule implementation, the source patch data index for a transaction always refers to the source data and the destination patch data index for a transaction is always the scratch data, all as defined in the xfer::RefineClasses&lt;DIM&gt; class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1OuternodeSumTransactionFactory.html">SAMRAI::algs::OuternodeSumTransactionFactory&lt; DIM &gt;</a></td><td class="indexvalue">Concrete subclass of the xfer::RefineTransactionFactory&lt;DIM&gt; base class that allocates transaction outernode sum objects for a xfer::RefineSchedule&lt;DIM&gt; object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1PatchBoundaryEdgeSum.html">SAMRAI::algs::PatchBoundaryEdgeSum&lt; DIM &gt;</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1algs_1_1PatchBoundaryEdgeSum.html">PatchBoundaryEdgeSum</a> provides operations summing edge data values at edges that are shared by multiple patches on a single level. Note that this utility only works on a SINGLE patch level, not on a multiple levels in an AMR patch hierarchy like the <a class="el" href="classSAMRAI_1_1algs_1_1PatchBoundaryNodeSum.html">PatchBoundaryNodeSum</a> class. Unlike node data, edge data at coarse-fine boundaries are not co-located, so the sum operation is not clearly defined </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1PatchBoundaryNodeSum.html">SAMRAI::algs::PatchBoundaryNodeSum&lt; DIM &gt;</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1algs_1_1PatchBoundaryNodeSum.html">PatchBoundaryNodeSum</a> provides operations for summing node data values at nodes that are shared by multiple patches on a single level or across multiple hierarchy levels </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementIntegrator.html">SAMRAI::algs::TimeRefinementIntegrator&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">SAMRAI::algs::TimeRefinementLevelStrategy&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1BoundaryNode.html">SAMRAI::appu::BoundaryNode&lt; DIM &gt;</a></td><td class="indexvalue">The <a class="el" href="classSAMRAI_1_1appu_1_1BoundaryNode.html">BoundaryNode</a> struct holds data and methods to define a boundary node (i.e. the first node inside the boundary) on an irregular boundary. An array of boundary nodes is maintained by each "CutCell" object, if the appropriate functions are called to enable boundary node storage. For more information, see the <a class="el" href="classSAMRAI_1_1appu_1_1CutCell.html">CutCell</a> class documentation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1BoundaryUtilityStrategy.html">SAMRAI::appu::BoundaryUtilityStrategy</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1appu_1_1BoundaryUtilityStrategy.html">BoundaryUtilityStrategy</a> is an abstract base class that declares an interface that allows application code to read problem-specific boundary data when using the <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> boundary utilities. Currently, there are two virtual member functions defined. One allows users to read problem-specific DIRICHLET boundary values from an input database; the other does the same for NEUMANN boundary values. More virtual functions may be added in the future as additional boundary conditions are supported </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html">SAMRAI::appu::CartesianBoundaryUtilities2</a></td><td class="indexvalue">Class <a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html">CartesianBoundaryUtilities2</a> is a utility class that simplifies the implementation of simple physical boundary data in 2 spatial dimensions. It contains routines for reading boundary data information from input files, applying those boundary conditions, and error checking boundary data. These routines apply to the case of cell-centered double data only. One may use all of these capabilities, or use the input reading, boundary setting, and error checking routines independently </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities3.html">SAMRAI::appu::CartesianBoundaryUtilities3</a></td><td class="indexvalue">Class <a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html">CartesianBoundaryUtilities2</a> is a utility class that simplifies the implementation of simple physical boundary data in 3 spatial dimensions. It contains routines for reading boundary data information from input files, applying those boundary conditions, and error checking boundary data. These routines apply to the case of cell-centered double data only. One may use all of these capabilities, or use the input reading, boundary setting, and error checking routines independently </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1CartesianVizamraiDataWriter.html">SAMRAI::appu::CartesianVizamraiDataWriter&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1CubesPatchInterface.html">SAMRAI::appu::CubesPatchInterface&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1CutCell.html">SAMRAI::appu::CutCell&lt; DIM &gt;</a></td><td class="indexvalue">The <a class="el" href="classSAMRAI_1_1appu_1_1CutCell.html">CutCell</a> struct holds data and methods to define a cut-cell on an irregular boundary </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1ElevenPatchInterface.html">SAMRAI::appu::ElevenPatchInterface&lt; DIM &gt;</a></td><td class="indexvalue">This class provides an interface to the Eleven geometry library by Kyle Chand in CASC. The shapes over which the embedded boundary is cut is defined through an XML database, the name of which is specified in the input file </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryDefines.html">SAMRAI::appu::EmbeddedBoundaryDefines</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryDefines.html">EmbeddedBoundaryDefines</a> sets the enumerated types used to define cells and nodes on the embedded boundary level </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry&lt; DIM &gt;</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">EmbeddedBoundaryGeometry</a> provides embedded boundary mesh construction, storage, and management on an AMR hierarchy </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShape.html">SAMRAI::appu::EmbeddedBoundaryShape&lt; DIM &gt;</a></td><td class="indexvalue">An abstract base class from which the different embedded boundary analytic shapes used in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> are derived. It specifies virtual implementations of several functions used to define an analytic embedded boundary shape </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShapePolygon.html">SAMRAI::appu::EmbeddedBoundaryShapePolygon&lt; DIM &gt;</a></td><td class="indexvalue">Provides an analytic description of a convex polygon. It inherets from the <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShape.html">EmbeddedBoundaryShape</a> base class and provides a concrete implementation of the "isInside()" method, which specifies whether a cell is INSIDE the convex poly </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShapeSphere.html">SAMRAI::appu::EmbeddedBoundaryShapeSphere&lt; DIM &gt;</a></td><td class="indexvalue">Provides an analytic description of a sphere. It inherets from the <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShape.html">EmbeddedBoundaryShape</a> base class and provides a concrete implementation of the "isInside()" method, which specifies whether a cell is INSIDE the sphere </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">SAMRAI::appu::VisDerivedDataStrategy&lt; DIM &gt;</a></td><td class="indexvalue">Class VisDerivedDataStrategy&lt;DIM&gt; is an abstract base class that defines an interface allowing an VisItDataWriter&lt;DIM&gt; object and/or an CartesianVizamraiDataWriter&lt;DIM&gt; object to generate plot files that contain "derived" quantities; that is, data that does not reside on the hierarchy, but which is derived from data that does reside on the hierarchy. The derived data may be scalar, vector, or tensor (VisIt only), and cell-centered or node-centered (VisIt only). A concrete object of this type must be registered with the data writer if any derived variable is registered with the data writer. The registration of the concrete strategy object may be done independently using the method setDerivedDataWriter() (Vizamrai only) or setDefaultDerivedDataWriter() (VisIt only) from the relevant DataWriter class, or the concrete strategy object may be registered concurrently with the derived variable using the method registerDerivedPlotScalar/Vector/Tensor() </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">SAMRAI::appu::VisItDataWriter&lt; DIM &gt;</a></td><td class="indexvalue">Class VisItDataWriter&lt;DIM&gt; is used by SAMRAI-based application codes to generate VisIt data files. VisIt provides a wide range of visualization and post-processing capabilities. This class supports both cell-centered and node-centered 2D and 3D AMR data where the underlying data type is either double, float, or int. Scalar, vector and 2nd-order tensor variables are supported. This class may be used when the mesh geometry is managed by a geom::CartesianGridGeometry&lt;DIM&gt; object, or when the mesh itself is stored in a state variable to allow moving deformed grids </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1VisMaterialsDataStrategy.html">SAMRAI::appu::VisMaterialsDataStrategy&lt; DIM &gt;</a></td><td class="indexvalue">Class VisMaterialsDataStrategy&lt;DIM&gt; is an abstract base class that defines an interface allowing an VisItDataWriter&lt;DIM&gt; object to generate plot files that contain material and species fractions, as well as state variables for individual materials. A concrete object of this type must be registered with the data writer in order to use materials or species with the data writer. The registration of the concrete object is done using the method setMaterialsDataWriter() from the <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">VisItDataWriter</a> class. VisIt requires that material fractions, species fractions, and material state variables be cell-centered. If they are not cell-centered in the simulation, it is the job of the relevant packing method to convert them to a cell-centered basis before packing them into the buffer </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1BlockGridGeometry.html">SAMRAI::geom::BlockGridGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1BlockPatchGeometry.html">SAMRAI::geom::BlockPatchGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellComplexConservativeLinearRefine.html">SAMRAI::geom::CartesianCellComplexConservativeLinearRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellComplexLinearRefine.html">SAMRAI::geom::CartesianCellComplexLinearRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellComplexWeightedAverage.html">SAMRAI::geom::CartesianCellComplexWeightedAverage&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellDoubleConservativeLinearRefine.html">SAMRAI::geom::CartesianCellDoubleConservativeLinearRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellDoubleLinearRefine.html">SAMRAI::geom::CartesianCellDoubleLinearRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellDoubleWeightedAverage.html">SAMRAI::geom::CartesianCellDoubleWeightedAverage&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellFloatConservativeLinearRefine.html">SAMRAI::geom::CartesianCellFloatConservativeLinearRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellFloatLinearRefine.html">SAMRAI::geom::CartesianCellFloatLinearRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellFloatWeightedAverage.html">SAMRAI::geom::CartesianCellFloatWeightedAverage&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianEdgeComplexWeightedAverage.html">SAMRAI::geom::CartesianEdgeComplexWeightedAverage&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianEdgeDoubleConservativeLinearRefine.html">SAMRAI::geom::CartesianEdgeDoubleConservativeLinearRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianEdgeDoubleWeightedAverage.html">SAMRAI::geom::CartesianEdgeDoubleWeightedAverage&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianEdgeFloatConservativeLinearRefine.html">SAMRAI::geom::CartesianEdgeFloatConservativeLinearRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianEdgeFloatWeightedAverage.html">SAMRAI::geom::CartesianEdgeFloatWeightedAverage&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianFaceComplexWeightedAverage.html">SAMRAI::geom::CartesianFaceComplexWeightedAverage&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianFaceDoubleConservativeLinearRefine.html">SAMRAI::geom::CartesianFaceDoubleConservativeLinearRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianFaceDoubleWeightedAverage.html">SAMRAI::geom::CartesianFaceDoubleWeightedAverage&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianFaceFloatConservativeLinearRefine.html">SAMRAI::geom::CartesianFaceFloatConservativeLinearRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianFaceFloatWeightedAverage.html">SAMRAI::geom::CartesianFaceFloatWeightedAverage&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html">SAMRAI::geom::CartesianGridGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianNodeComplexLinearRefine.html">SAMRAI::geom::CartesianNodeComplexLinearRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianNodeDoubleLinearRefine.html">SAMRAI::geom::CartesianNodeDoubleLinearRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianNodeFloatLinearRefine.html">SAMRAI::geom::CartesianNodeFloatLinearRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianOuterfaceComplexWeightedAverage.html">SAMRAI::geom::CartesianOuterfaceComplexWeightedAverage&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianOuterfaceDoubleWeightedAverage.html">SAMRAI::geom::CartesianOuterfaceDoubleWeightedAverage&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianOuterfaceFloatWeightedAverage.html">SAMRAI::geom::CartesianOuterfaceFloatWeightedAverage&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianOutersideDoubleWeightedAverage.html">SAMRAI::geom::CartesianOutersideDoubleWeightedAverage&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianPatchGeometry.html">SAMRAI::geom::CartesianPatchGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianSideComplexWeightedAverage.html">SAMRAI::geom::CartesianSideComplexWeightedAverage&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianSideDoubleConservativeLinearRefine.html">SAMRAI::geom::CartesianSideDoubleConservativeLinearRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianSideDoubleWeightedAverage.html">SAMRAI::geom::CartesianSideDoubleWeightedAverage&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianSideFloatConservativeLinearRefine.html">SAMRAI::geom::CartesianSideFloatConservativeLinearRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianSideFloatWeightedAverage.html">SAMRAI::geom::CartesianSideFloatWeightedAverage&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1SkeletonCoarsen.html">SAMRAI::geom::SkeletonCoarsen&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1SkeletonGridGeometry.html">SAMRAI::geom::SkeletonGridGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1SkeletonPatchGeometry.html">SAMRAI::geom::SkeletonPatchGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1SkeletonRefine.html">SAMRAI::geom::SkeletonRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BinaryTree.html">SAMRAI::hier::BinaryTree&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">SAMRAI::hier::BoundaryBox&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBoxUtils.html">SAMRAI::hier::BoundaryBoxUtils&lt; DIM &gt;</a></td><td class="indexvalue">Perform shifts, extensions, etc on a <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">BoundaryBox</a> using the box's location index and type </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoundaryLookupTable.html">SAMRAI::hier::BoundaryLookupTable&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">SAMRAI::hier::BoxArray&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1hier_1_1BoxComm.html">SAMRAI::hier::BoxComm&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxGeometry.html">SAMRAI::hier::BoxGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxGraph.html">SAMRAI::hier::BoxGraph&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1hier_1_1BoxGraphUtilities.html">SAMRAI::hier::BoxGraphUtilities&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxIOUtility.html">SAMRAI::hier::BoxIOUtility&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxIterator.html">SAMRAI::hier::BoxIterator&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">SAMRAI::hier::BoxList&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">SAMRAI::hier::BoxOverlap&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxTop.html">SAMRAI::hier::BoxTop&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxTree.html">SAMRAI::hier::BoxTree&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxTreeNode.html">SAMRAI::hier::BoxTreeNode&lt; DIM &gt;</a></td><td class="indexvalue">Building block used by BoxTree&lt;DIM&gt; </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1hier_1_1BoxTreeNode_1_1Triple.html">SAMRAI::hier::BoxTreeNode&lt; DIM &gt;::Triple</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">SAMRAI::hier::BoxUtilities&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html">SAMRAI::hier::CoarseFineBoundary&lt; DIM &gt;</a></td><td class="indexvalue">Utility class to construct and maintain a description of the coarse-fine boundary between a patch level and some coarser level </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">SAMRAI::hier::ComponentSelector</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">ComponentSelector</a> implements a simple bit vector of a fixed length and is typically used to apply operations on subsets of entries in the patch data array owned by a patch (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., allocate/deallocate). All <a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">ComponentSelector</a> objects have the same bit vector length that is established by the SAMRAIManager utility. See the documentation of the SAMRAIManager utility for information about changing this maximum value </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">SAMRAI::hier::GridGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1Index.html">SAMRAI::hier::Index&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet&lt; DIM &gt;</a></td><td class="indexvalue">Encapsulates a set of DLBG edges that connect two <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a> objects </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1hier_1_1LayerEdgeSet_1_1CommunicationStruct.html">SAMRAI::hier::LayerEdgeSet&lt; DIM &gt;::CommunicationStruct</a></td><td class="indexvalue">Data sorted by a hash </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1LayerHierarchy.html">SAMRAI::hier::LayerHierarchy&lt; DIM &gt;</a></td><td class="indexvalue">Distributed nested-level box graph for a patch hierarchy </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1LayerNode.html">SAMRAI::hier::LayerNode&lt; DIM &gt;</a></td><td class="indexvalue">Encapsulates the node on a DLBG </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">SAMRAI::hier::LayerNodeSet&lt; DIM &gt;</a></td><td class="indexvalue">Encapsulates a set of <a class="el" href="classSAMRAI_1_1hier_1_1LayerNode.html">LayerNode</a> objects on the same index space </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1hier_1_1LevelNumber.html">SAMRAI::hier::LevelNumber</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveDataPatchLevelIterator.html">SAMRAI::hier::LocallyActiveDataPatchLevelIterator&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveDataPatchLevelManager.html">SAMRAI::hier::LocallyActiveDataPatchLevelManager&lt; DIM &gt;</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveDataPatchLevelManager.html">LocallyActiveDataPatchLevelManager</a> is a utility class for managing data on a patch level where each data item may be defined on a different set of patches; i.e., the data is "locally-active". A separate object of this class is needed for each patch level on which locally-active data is defined. Typical usage involves constructing an instance of this class with a patch level and then defining the active patches for each patch data integer identifier. Then, this class supports various patch level operations asscociated with the locally-active data, such as allocation and deallocation of data and iteration over patches for which a particular data id is active </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveVariableDatabase.html">SAMRAI::hier::LocallyActiveVariableDatabase&lt; DIM &gt;</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1hier_1_1LocallyActiveVariableDatabase.html">LocallyActiveVariableDatabase</a> is a Singleton class that provides functionality for using the <a class="el" href="classSAMRAI_1_1hier_1_1VariableDatabase.html">VariableDatabase</a> to manage variables and data that live on different sets of patches in an AMR patch hierarchy, so-called "locally-active" data, can be managed </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1MBUtilities.html">SAMRAI::hier::MBUtilities&lt; DIM &gt;</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1hier_1_1MBUtilities.html">MBUtilities</a> contains utility functions related to multiblock functionality </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockDataTranslator.html">SAMRAI::hier::MultiblockDataTranslator&lt; DIM &gt;</a></td><td class="indexvalue">Class MultiblockDataTranslator&lt;DIM&gt; </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockGridGeometry.html">SAMRAI::hier::MultiblockGridGeometry&lt; DIM &gt;</a></td><td class="indexvalue">Class MultiblockGridGeometry&lt;DIM&gt; </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockPatchHierarchy.html">SAMRAI::hier::MultiblockPatchHierarchy&lt; DIM &gt;</a></td><td class="indexvalue">Class MultiblockPatchHierarchy&lt;DIM&gt; manages an array of patch hierarchies that represent a multiblock domain, and describes the relationship between these hierarchies </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1hier_1_1MultiblockPatchHierarchy_1_1Neighbor.html">SAMRAI::hier::MultiblockPatchHierarchy&lt; DIM &gt;::Neighbor</a></td><td class="indexvalue">Structure to represent the neighbor of a given block </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockPatchLevel.html">SAMRAI::hier::MultiblockPatchLevel&lt; DIM &gt;</a></td><td class="indexvalue">Class MultiblockPatchLevel&lt;DIM&gt; contains an array of hier::PatchLevel&lt;DIM&gt; that contains all of the patch levels that have the same level of refinement in a multiblock domain </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchConfigurationUtilities.html">SAMRAI::hier::PatchConfigurationUtilities&lt; DIM &gt;</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1hier_1_1PatchConfigurationUtilities.html">PatchConfigurationUtilities</a> contains routines that provide information about spatial relationships among patches on an AMR patch hierarchy. Such information is useful for building operations on patch data that must account for these relationships. Examples include knowing which patches are neighbors of a given patch on the same patch level and the positions of those neighbors with respect to the patch, and knowing which patches on a finer patch level overlap a given patch, etc </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1hier_1_1PatchConfigurationUtilities_1_1NeighborPatchInfo.html">SAMRAI::hier::PatchConfigurationUtilities&lt; DIM &gt;::NeighborPatchInfo</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">SAMRAI::hier::PatchData&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchDataFactory.html">SAMRAI::hier::PatchDataFactory&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1hier_1_1PatchDataId.html">SAMRAI::hier::PatchDataId</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchDescriptor.html">SAMRAI::hier::PatchDescriptor&lt; DIM &gt;</a></td><td class="indexvalue">Class PatchDescriptor&lt;DIM&gt; maintains a collection of patch data factories and associated names that describes how patch data entries are constructed on each patch in an AMR hierarchy. The factory mechanism is used to create new instances of concrete patch data objects without knowing their actual types. See the Design Patterns book by Gamma {<em>et</em> al.} for more details about the Abstract Factory pattern. Generally, a <a class="el" href="classSAMRAI_1_1hier_1_1PatchDescriptor.html">PatchDescriptor</a> object is intended to be shared among all patches (which are distributed across processors) so that they store patch data objects in the same way </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchFactory.html">SAMRAI::hier::PatchFactory&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry.html">SAMRAI::hier::PatchGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevelFactory.html">SAMRAI::hier::PatchLevelFactory&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevelIterator.html">SAMRAI::hier::PatchLevelIterator&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1hier_1_1PatchNumber.html">SAMRAI::hier::PatchNumber</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">SAMRAI::hier::ProcessorMapping</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">SAMRAI::hier::VariableContext</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1VariableDatabase.html">SAMRAI::hier::VariableDatabase&lt; DIM &gt;</a></td><td class="indexvalue">Class VariableDatabase&lt;DIM&gt; is a Singleton class that manages mapping information between variables and patch data objects in ways that are configurable to the needs of an application built using <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>. In <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>, a single patch descriptor object is shared by all patches in an SAMR hierarchy. This database generates and maintain mappings (for lookup) between integer patch data indices and either variable-context pairs or just variables when contexts are not used. Users define which variables are included in the database, which variable contexts are in the database, and which contexts are associated with which variables via registration operations described below </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataBasicOps.html">SAMRAI::math::ArrayDataBasicOps&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataNormOpsComplex.html">SAMRAI::math::ArrayDataNormOpsComplex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataNormOpsInteger.html">SAMRAI::math::ArrayDataNormOpsInteger&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataNormOpsReal.html">SAMRAI::math::ArrayDataNormOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyCellDataOpsComplex.html">SAMRAI::math::HierarchyCellDataOpsComplex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyCellDataOpsInteger.html">SAMRAI::math::HierarchyCellDataOpsInteger&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyCellDataOpsReal.html">SAMRAI::math::HierarchyCellDataOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsComplex.html">SAMRAI::math::HierarchyDataOpsComplex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsInteger.html">SAMRAI::math::HierarchyDataOpsInteger&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsManager.html">SAMRAI::math::HierarchyDataOpsManager&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsReal.html">SAMRAI::math::HierarchyDataOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyEdgeDataOpsComplex.html">SAMRAI::math::HierarchyEdgeDataOpsComplex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyEdgeDataOpsInteger.html">SAMRAI::math::HierarchyEdgeDataOpsInteger&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyEdgeDataOpsReal.html">SAMRAI::math::HierarchyEdgeDataOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyFaceDataOpsComplex.html">SAMRAI::math::HierarchyFaceDataOpsComplex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyFaceDataOpsInteger.html">SAMRAI::math::HierarchyFaceDataOpsInteger&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyFaceDataOpsReal.html">SAMRAI::math::HierarchyFaceDataOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyNodeDataOpsComplex.html">SAMRAI::math::HierarchyNodeDataOpsComplex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyNodeDataOpsInteger.html">SAMRAI::math::HierarchyNodeDataOpsInteger&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyNodeDataOpsReal.html">SAMRAI::math::HierarchyNodeDataOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchySideDataOpsComplex.html">SAMRAI::math::HierarchySideDataOpsComplex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchySideDataOpsInteger.html">SAMRAI::math::HierarchySideDataOpsInteger&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchySideDataOpsReal.html">SAMRAI::math::HierarchySideDataOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchCellDataBasicOps.html">SAMRAI::math::PatchCellDataBasicOps&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchCellDataMiscellaneousOpsReal.html">SAMRAI::math::PatchCellDataMiscellaneousOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchCellDataNormOpsComplex.html">SAMRAI::math::PatchCellDataNormOpsComplex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchCellDataNormOpsReal.html">SAMRAI::math::PatchCellDataNormOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchCellDataOpsComplex.html">SAMRAI::math::PatchCellDataOpsComplex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchCellDataOpsInteger.html">SAMRAI::math::PatchCellDataOpsInteger&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchCellDataOpsReal.html">SAMRAI::math::PatchCellDataOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchEdgeDataBasicOps.html">SAMRAI::math::PatchEdgeDataBasicOps&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchEdgeDataMiscellaneousOpsReal.html">SAMRAI::math::PatchEdgeDataMiscellaneousOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchEdgeDataNormOpsComplex.html">SAMRAI::math::PatchEdgeDataNormOpsComplex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchEdgeDataNormOpsReal.html">SAMRAI::math::PatchEdgeDataNormOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchEdgeDataOpsComplex.html">SAMRAI::math::PatchEdgeDataOpsComplex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchEdgeDataOpsInteger.html">SAMRAI::math::PatchEdgeDataOpsInteger&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchEdgeDataOpsReal.html">SAMRAI::math::PatchEdgeDataOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchFaceDataBasicOps.html">SAMRAI::math::PatchFaceDataBasicOps&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchFaceDataMiscellaneousOpsReal.html">SAMRAI::math::PatchFaceDataMiscellaneousOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchFaceDataNormOpsComplex.html">SAMRAI::math::PatchFaceDataNormOpsComplex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchFaceDataNormOpsReal.html">SAMRAI::math::PatchFaceDataNormOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchFaceDataOpsComplex.html">SAMRAI::math::PatchFaceDataOpsComplex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchFaceDataOpsInteger.html">SAMRAI::math::PatchFaceDataOpsInteger&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchFaceDataOpsReal.html">SAMRAI::math::PatchFaceDataOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchNodeDataBasicOps.html">SAMRAI::math::PatchNodeDataBasicOps&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchNodeDataMiscellaneousOpsReal.html">SAMRAI::math::PatchNodeDataMiscellaneousOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchNodeDataNormOpsComplex.html">SAMRAI::math::PatchNodeDataNormOpsComplex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchNodeDataNormOpsReal.html">SAMRAI::math::PatchNodeDataNormOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchNodeDataOpsComplex.html">SAMRAI::math::PatchNodeDataOpsComplex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchNodeDataOpsInteger.html">SAMRAI::math::PatchNodeDataOpsInteger&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchNodeDataOpsReal.html">SAMRAI::math::PatchNodeDataOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataBasicOps.html">SAMRAI::math::PatchSideDataBasicOps&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html">SAMRAI::math::PatchSideDataMiscellaneousOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataNormOpsComplex.html">SAMRAI::math::PatchSideDataNormOpsComplex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataNormOpsReal.html">SAMRAI::math::PatchSideDataNormOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataOpsComplex.html">SAMRAI::math::PatchSideDataOpsComplex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataOpsInteger.html">SAMRAI::math::PatchSideDataOpsInteger&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataOpsReal.html">SAMRAI::math::PatchSideDataOpsReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1AsyncBergerRigoutsos.html">SAMRAI::mesh::AsyncBergerRigoutsos&lt; DIM &gt;</a></td><td class="indexvalue">Asynchronous Berger-Rigoutsos implementation. This class is derived from the abstract base class mesh::BoxGeneratorStrategy&lt;DIM&gt;. Thus, it serves as a concrete implementation of the box generator Strategy pattern interface </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1AsyncBergerRigoutsosNode.html">SAMRAI::mesh::AsyncBergerRigoutsosNode&lt; DIM &gt;</a></td><td class="indexvalue">Node in the asynchronous Berger-Rigoutsos (BR) dendogram </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1mesh_1_1AsyncBergerRigoutsosNode_1_1CommonParams.html">SAMRAI::mesh::AsyncBergerRigoutsosNode&lt; DIM &gt;::CommonParams</a></td><td class="indexvalue">Parameters shared among all dendogram nodes in an dendogram and collectively managed by those nodes </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities&lt; DIM &gt;</a></td><td class="indexvalue">Utility class BalanceUtilities&lt;DIM&gt; provides several functions useful in various load balancing operations. These utilities include bin packing operations, box chopping by recursive bisection, and computation of effective processor layouts for boxes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</a></td><td class="indexvalue">Virtual base class providing interface for gridding algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1BergerRigoutsos.html">SAMRAI::mesh::BergerRigoutsos&lt; DIM &gt;</a></td><td class="indexvalue">BergerRigoutsos&lt;DIM&gt; provides operations that construct boxes to cover a collection of tagged cells on a single AMR hierarchy patch level. This class is derived from the abstract base class BoxGeneratorStrategy&lt;DIM&gt;. Thus, it serves as a concrete implementation of the box generator Strategy pattern interface </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1BoxGeneratorStrategy.html">SAMRAI::mesh::BoxGeneratorStrategy&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a></td><td class="indexvalue">Class GriddingAlgorithm&lt;DIM&gt; manages gridding operations in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>. Specifically, it provides AMR patch hierarchy generation and regridding routines that may be used with a variety of AMR solution algorithms and application-specific numerical routines </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1HistogramBox.html">SAMRAI::mesh::HistogramBox&lt; DIM &gt;</a></td><td class="indexvalue">Class HistogramBox&lt;DIM&gt; manages the histogram signature array for a region of index space contained within a single box. It is used during the regridding process to gather information about the distribution of tagged cells across a portion of a patch level </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalancer.html">SAMRAI::mesh::LoadBalancer&lt; DIM &gt;</a></td><td class="indexvalue">Class LoadBalancer&lt;DIM&gt; provides load balancing routines for AMR hierarchy levels based on either uniform or non-uniform workload estimates </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">SAMRAI::mesh::LoadBalanceStrategy&lt; DIM &gt;</a></td><td class="indexvalue">Class LoadBalanceStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface for operations that load balance patches on a single AMR patch hierarchy level. Typically, such operations are invoked after the domain of a new hierarchy level is determined (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., via some error estimation procedure) and is applied to the collection of boxes that describe the domain. The load balancing process produces a set of boxes from which patches on the new level are created and a processor mapping describing how the new patches are mapped to processors </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingAlgorithm.html">SAMRAI::mesh::MultiblockGriddingAlgorithm&lt; DIM &gt;</a></td><td class="indexvalue">Class MultiblockGriddingAlgorithm&lt;DIM&gt; manages gridding operations in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> for problems on multiblock domains. Specifically, it provides AMR patch hierarchy generation and regridding routines that may be used with a variety of AMR solution algorithms and application-specific numerical routines </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingTagger.html">SAMRAI::mesh::MultiblockGriddingTagger&lt; DIM &gt;</a></td><td class="indexvalue">Class MultiblockGriddingTagger&lt;DIM&gt; is a concrete implementation of MultiblockRefinePatchStrategy&lt;DIMI&gt; that is used for boundary filling of patch data representing cells tagged for refinement </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1SpatialKey.html">SAMRAI::mesh::SpatialKey</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html">SAMRAI::mesh::StandardTagAndInitialize&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">SAMRAI::mesh::TagAndInitializeStrategy&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData&lt; DIM, TYPE &gt;</a></td><td class="indexvalue">Class ArrayData&lt;DIM, TYPE&gt; is a basic templated array structure defined over the index space of a box (with a specified depth) that provides the support for the various standard array-based patch data subclasses </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataAccess.html">SAMRAI::pdat::ArrayDataAccess</a></td><td class="indexvalue">Utility for wrapping data from <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a> class in an <a class="el" href="classMDA__Access.html">MDA_Access</a> or <a class="el" href="classMDA__AccessConst.html">MDA_AccessConst</a> object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataIterator.html">SAMRAI::pdat::ArrayDataIterator&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataOperationUtilities.html">SAMRAI::pdat::ArrayDataOperationUtilities&lt; DIM, TYPE, OP &gt;</a></td><td class="indexvalue">Struct ArrayDataOperationUtilities&lt;DIM, TYPE, OP&gt; provides generic looping operations for all array-based patch data types. The operations are templated on spatial dimension, data type, and the operation that will be performed on individual array elements in the innermost loop </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellComplexConstantRefine.html">SAMRAI::pdat::CellComplexConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellComplexLinearTimeInterpolateOp.html">SAMRAI::pdat::CellComplexLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">SAMRAI::pdat::CellData&lt; DIM, TYPE &gt;</a></td><td class="indexvalue">Class CellData&lt;DIM&gt; provides an implementation for data defined at cell centers on AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, a cell data object represents data of some template TYPE and depth at the centers of the cells in the box. Here, depth indicates the number of data values at each cell index location. The <a class="el" href="classSAMRAI_1_1pdat_1_1CellGeometry.html">CellGeometry</a> class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and cell-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellDataFactory.html">SAMRAI::pdat::CellDataFactory&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellDoubleConstantRefine.html">SAMRAI::pdat::CellDoubleConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellDoubleLinearTimeInterpolateOp.html">SAMRAI::pdat::CellDoubleLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellFloatConstantRefine.html">SAMRAI::pdat::CellFloatConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellFloatLinearTimeInterpolateOp.html">SAMRAI::pdat::CellFloatLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellGeometry.html">SAMRAI::pdat::CellGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellIndex.html">SAMRAI::pdat::CellIndex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellIntegerConstantRefine.html">SAMRAI::pdat::CellIntegerConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellIterator.html">SAMRAI::pdat::CellIterator&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellOverlap.html">SAMRAI::pdat::CellOverlap&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CopyOperation.html">SAMRAI::pdat::CopyOperation&lt; TYPE &gt;</a></td><td class="indexvalue">Class CopyOperation&lt;TYPE&gt; encapsulates a copy operation into an object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeComplexConstantRefine.html">SAMRAI::pdat::EdgeComplexConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeComplexLinearTimeInterpolateOp.html">SAMRAI::pdat::EdgeComplexLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeData.html">SAMRAI::pdat::EdgeData&lt; DIM, TYPE &gt;</a></td><td class="indexvalue">Class EdgeData&lt;DIM&gt; provides an implementation for data defined at cell edges on AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, an edge data object represents data of some template TYPE and depth on the edges of the cells in the box. Here, depth indicates the number of data values at each edge index location. The <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeGeometry.html">EdgeGeometry</a> class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and edge-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeDataFactory.html">SAMRAI::pdat::EdgeDataFactory&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeDoubleConstantRefine.html">SAMRAI::pdat::EdgeDoubleConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeDoubleLinearTimeInterpolateOp.html">SAMRAI::pdat::EdgeDoubleLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeFloatConstantRefine.html">SAMRAI::pdat::EdgeFloatConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeFloatLinearTimeInterpolateOp.html">SAMRAI::pdat::EdgeFloatLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeGeometry.html">SAMRAI::pdat::EdgeGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeIndex.html">SAMRAI::pdat::EdgeIndex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeIntegerConstantRefine.html">SAMRAI::pdat::EdgeIntegerConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeIterator.html">SAMRAI::pdat::EdgeIterator&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeOverlap.html">SAMRAI::pdat::EdgeOverlap&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeVariable.html">SAMRAI::pdat::EdgeVariable&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceComplexConstantRefine.html">SAMRAI::pdat::FaceComplexConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceComplexLinearTimeInterpolateOp.html">SAMRAI::pdat::FaceComplexLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData&lt; DIM, TYPE &gt;</a></td><td class="indexvalue">Class FaceData&lt;DIM&gt; provides an implementation for data defined at cell faces on AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, a face data object represents data of some template TYPE and depth on the faces of the cells in the box. Here, depth indicates the number of data values at each face index location. The <a class="el" href="classSAMRAI_1_1pdat_1_1FaceGeometry.html">FaceGeometry</a> class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and face-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceDataFactory.html">SAMRAI::pdat::FaceDataFactory&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceDoubleConstantRefine.html">SAMRAI::pdat::FaceDoubleConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceDoubleLinearTimeInterpolateOp.html">SAMRAI::pdat::FaceDoubleLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceFloatConstantRefine.html">SAMRAI::pdat::FaceFloatConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceFloatLinearTimeInterpolateOp.html">SAMRAI::pdat::FaceFloatLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceGeometry.html">SAMRAI::pdat::FaceGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceIndex.html">SAMRAI::pdat::FaceIndex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceIntegerConstantRefine.html">SAMRAI::pdat::FaceIntegerConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceIterator.html">SAMRAI::pdat::FaceIterator&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceOverlap.html">SAMRAI::pdat::FaceOverlap&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceVariable.html">SAMRAI::pdat::FaceVariable&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FirstLayerCellFillPattern.html">SAMRAI::pdat::FirstLayerCellFillPattern&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FirstLayerCellNoCornersFillPattern.html">SAMRAI::pdat::FirstLayerCellNoCornersFillPattern&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FirstLayerNodeFillPattern.html">SAMRAI::pdat::FirstLayerNodeFillPattern&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData&lt; DIM, TYPE, BOX_GEOMETRY &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexDataFactory.html">SAMRAI::pdat::IndexDataFactory&lt; DIM, TYPE, BOX_GEOMETRY &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexDataNode.html">SAMRAI::pdat::IndexDataNode&lt; DIM, TYPE, BOX_GEOMETRY &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexIterator.html">SAMRAI::pdat::IndexIterator&lt; DIM, TYPE, BOX_GEOMETRY &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexVariable.html">SAMRAI::pdat::IndexVariable&lt; DIM, TYPE, BOX_GEOMETRY &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1MBDataUtilities.html">SAMRAI::pdat::MBDataUtilities&lt; DIM, TYPE &gt;</a></td><td class="indexvalue">Class MBDataUtilities&lt;DIM,TYPE&gt; is a templated utilitiy class that contains a set of static member functions that can be used to copy patch data between index spaces that are not necessarily aligned on the same axes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1MultiblockCellDataTranslator.html">SAMRAI::pdat::MultiblockCellDataTranslator&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1MultiblockEdgeDataTranslator.html">SAMRAI::pdat::MultiblockEdgeDataTranslator&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1MultiblockFaceDataTranslator.html">SAMRAI::pdat::MultiblockFaceDataTranslator&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1MultiblockNodeDataTranslator.html">SAMRAI::pdat::MultiblockNodeDataTranslator&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1MultiblockSideDataTranslator.html">SAMRAI::pdat::MultiblockSideDataTranslator&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeComplexInjection.html">SAMRAI::pdat::NodeComplexInjection&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeComplexLinearTimeInterpolateOp.html">SAMRAI::pdat::NodeComplexLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeData.html">SAMRAI::pdat::NodeData&lt; DIM, TYPE &gt;</a></td><td class="indexvalue">Class NodeData&lt;DIM&gt; provides an implementation for data defined at nodes on AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, a node data object represents data of some template TYPE and depth at the nodes of the cells in the box. Here, depth indicates the number of data values at each node index location. The <a class="el" href="classSAMRAI_1_1pdat_1_1NodeGeometry.html">NodeGeometry</a> class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and node-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeDataFactory.html">SAMRAI::pdat::NodeDataFactory&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeDoubleInjection.html">SAMRAI::pdat::NodeDoubleInjection&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeDoubleLinearTimeInterpolateOp.html">SAMRAI::pdat::NodeDoubleLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeFloatInjection.html">SAMRAI::pdat::NodeFloatInjection&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeFloatLinearTimeInterpolateOp.html">SAMRAI::pdat::NodeFloatLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeGeometry.html">SAMRAI::pdat::NodeGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeIndex.html">SAMRAI::pdat::NodeIndex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeIntegerInjection.html">SAMRAI::pdat::NodeIntegerInjection&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeIterator.html">SAMRAI::pdat::NodeIterator&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeOverlap.html">SAMRAI::pdat::NodeOverlap&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeVariable.html">SAMRAI::pdat::NodeVariable&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData&lt; DIM, TYPE &gt;</a></td><td class="indexvalue">Class OuteredgeData&lt;DIM&gt; provides an implementation for data defined at cell edges on the boundaries of AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, an outeredge data object represents data of some template TYPE and depth on the cell edges on the boundary of the box. Here, depth indicates the number of data values at each edge index location. The OuteredgedgeGeometry class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and outeredge-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeDataFactory.html">SAMRAI::pdat::OuteredgeDataFactory&lt; DIM, TYPE &gt;</a></td><td class="indexvalue">Class OuteredgeDataFactory&lt;DIM&gt; is a factory class used to allocate new instances of OuteredgeData&lt;DIM&gt; objects. It is a subclass of the patch data factory class and outeredge data is a subclass of patch data. Both the factory and data classes are templated on the type of the contained object (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., double or int) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeGeometry.html">SAMRAI::pdat::OuteredgeGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeVariable.html">SAMRAI::pdat::OuteredgeVariable&lt; DIM, TYPE &gt;</a></td><td class="indexvalue">Class OuteredgeVariable&lt;DIM&gt; is a templated variable class used to define edge-centered data quantities only on patch boundaries. It is a subclass of <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> and is templated on the type of the underlying data (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., double, int, bool, etc.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceComplexConstantRefine.html">SAMRAI::pdat::OuterfaceComplexConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceComplexLinearTimeInterpolateOp.html">SAMRAI::pdat::OuterfaceComplexLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceData.html">SAMRAI::pdat::OuterfaceData&lt; DIM, TYPE &gt;</a></td><td class="indexvalue">Class OuterfaceData&lt;DIM&gt; provides an implementation for data defined at cell faces on the boundaries of AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, an outerface data object represents data of some template TYPE and depth on the cell faces on the boundary of the box. Here, depth indicates the number of data values at each face index location. The OuteredgfaceGeometry class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and outerface-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceDataFactory.html">SAMRAI::pdat::OuterfaceDataFactory&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceDoubleConstantRefine.html">SAMRAI::pdat::OuterfaceDoubleConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceDoubleLinearTimeInterpolateOp.html">SAMRAI::pdat::OuterfaceDoubleLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceFloatConstantRefine.html">SAMRAI::pdat::OuterfaceFloatConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceFloatLinearTimeInterpolateOp.html">SAMRAI::pdat::OuterfaceFloatLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceGeometry.html">SAMRAI::pdat::OuterfaceGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceIntegerConstantRefine.html">SAMRAI::pdat::OuterfaceIntegerConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceVariable.html">SAMRAI::pdat::OuterfaceVariable&lt; DIM, TYPE &gt;</a></td><td class="indexvalue">Class OuterfaceVariable&lt;DIM&gt; is a templated variable class used to define face-centered data quantities only on patch boundaries. It is a subclass of <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> and is templated on the type of the underlying data (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., double, int, bool, etc.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuternodeData.html">SAMRAI::pdat::OuternodeData&lt; DIM, TYPE &gt;</a></td><td class="indexvalue">Class OuternodeData&lt;DIM&gt; provides an implementation for data defined at cell nodes on the boundaries of AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, an outernode data object represents data of some template TYPE and depth on the cell nodes on the boundary of the box. Here, depth indicates the number of data values at each node index location. The OuternodnodeGeometry class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and outernode-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuternodeDataFactory.html">SAMRAI::pdat::OuternodeDataFactory&lt; DIM, TYPE &gt;</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1pdat_1_1OuternodeDataFactory.html">OuternodeDataFactory</a> is a factory class used to allocate new instances of <a class="el" href="classSAMRAI_1_1pdat_1_1OuternodeData.html">OuternodeData</a> objects. It is a subclass of the patch data factory class and outernode data is a subclass of patch data. Both the factory and data classes are templated on the type of the contained object (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., double or int) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuternodeDoubleConstantCoarsen.html">SAMRAI::pdat::OuternodeDoubleConstantCoarsen&lt; DIM &gt;</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1pdat_1_1OuternodeDoubleConstantCoarsen.html">OuternodeDoubleConstantCoarsen</a> implements constant averaging (i.e., injection) for outernode-centered double patch data defined over a mesh </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuternodeGeometry.html">SAMRAI::pdat::OuternodeGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuternodeVariable.html">SAMRAI::pdat::OuternodeVariable&lt; DIM, TYPE &gt;</a></td><td class="indexvalue">Class OuternodeVariable&lt;DIM&gt; is a templated variable class used to define node-centered data quantities only on patch boundaries. It is a subclass of <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> and is templated on the type of the underlying data (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., double, int, bool, etc.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OutersideComplexLinearTimeInterpolateOp.html">SAMRAI::pdat::OutersideComplexLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OutersideData.html">SAMRAI::pdat::OutersideData&lt; DIM, TYPE &gt;</a></td><td class="indexvalue">Class OutersideData&lt;DIM&gt; provides an implementation for data defined at cell sides (faces) on the boundaries of AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, an outerside data object represents data of some template TYPE and depth on the cell sides (faces) on the boundary of the box. Here, depth indicates the number of data values at each face index location. The OuteredgsideGeometry class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and outerside-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OutersideDataFactory.html">SAMRAI::pdat::OutersideDataFactory&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OutersideDoubleLinearTimeInterpolateOp.html">SAMRAI::pdat::OutersideDoubleLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OutersideFloatLinearTimeInterpolateOp.html">SAMRAI::pdat::OutersideFloatLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OutersideGeometry.html">SAMRAI::pdat::OutersideGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OutersideVariable.html">SAMRAI::pdat::OutersideVariable&lt; DIM, TYPE &gt;</a></td><td class="indexvalue">Class OutersideVariable&lt;DIM&gt; is a templated variable class used to define side-centered data quantities only on patch boundaries. It is a subclass of <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> and is templated on the type of the underlying data (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., double, int, bool, etc.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SecondLayerNodeFillPattern.html">SAMRAI::pdat::SecondLayerNodeFillPattern&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SecondLayerNodeNoCornersFillPattern.html">SAMRAI::pdat::SecondLayerNodeNoCornersFillPattern&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideComplexConstantRefine.html">SAMRAI::pdat::SideComplexConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideComplexLinearTimeInterpolateOp.html">SAMRAI::pdat::SideComplexLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">SAMRAI::pdat::SideData&lt; DIM, TYPE &gt;</a></td><td class="indexvalue">Class SideData&lt;DIM&gt; provides an implementation for data defined at cell sides (faces) on AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, a side data object represents data of some template TYPE and depth on the sides (faces) of the cells in the box. Here, depth indicates the number of data values at each side index location. The <a class="el" href="classSAMRAI_1_1pdat_1_1SideGeometry.html">SideGeometry</a> class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and side-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideDataFactory.html">SAMRAI::pdat::SideDataFactory&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideDoubleConstantRefine.html">SAMRAI::pdat::SideDoubleConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideDoubleLinearTimeInterpolateOp.html">SAMRAI::pdat::SideDoubleLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideFloatConstantRefine.html">SAMRAI::pdat::SideFloatConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideFloatLinearTimeInterpolateOp.html">SAMRAI::pdat::SideFloatLinearTimeInterpolateOp&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideGeometry.html">SAMRAI::pdat::SideGeometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideIndex.html">SAMRAI::pdat::SideIndex&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideIntegerConstantRefine.html">SAMRAI::pdat::SideIntegerConstantRefine&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideIterator.html">SAMRAI::pdat::SideIterator&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideOverlap.html">SAMRAI::pdat::SideOverlap&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideVariable.html">SAMRAI::pdat::SideVariable&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SumOperation.html">SAMRAI::pdat::SumOperation&lt; TYPE &gt;</a></td><td class="indexvalue">Class SumOperation&lt;TYPE&gt; encapsulates a summation operation into an object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper&lt; DIM &gt;</a></td><td class="indexvalue">Helper utility for setting Robin boundary conditions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html">SAMRAI::solv::CellPoissonFACOps&lt; DIM &gt;</a></td><td class="indexvalue">FAC operator class to solve Poisson's equation on a SAMR grid, using cell-centered, second-order finite-volume method, with Robin boundary conditions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver&lt; DIM &gt;</a></td><td class="indexvalue">Class for solving scalar Poisson's equation on SAMR grid, wrapping up lower-level components (FAC cycling, Poisson equation operations and boundary conditions) in a single high-level interface </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html">SAMRAI::solv::CellPoissonHypreSolver&lt; DIM &gt;</a></td><td class="indexvalue">Use the HYPRE preconditioner library to solve (the cell-centered) Poisson's equation on a single level in a hierarchy </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1CVODEAbstractFunctions.html">SAMRAI::solv::CVODEAbstractFunctions</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html">SAMRAI::solv::CVODESolver</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html">CVODESolver</a> serves as a C++ wrapper for the CVODE ordinary differential equation solver package </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">SAMRAI::solv::FACOperatorStrategy&lt; DIM &gt;</a></td><td class="indexvalue">Defines a Strategy pattern interface to problem-specific operations needed to implement the FAC preconditioner algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html">SAMRAI::solv::FACPreconditioner&lt; DIM &gt;</a></td><td class="indexvalue">Implements the FAC iterative solution procedure for a linear system of equations, Au=f, defined on some subset of levels in an AMR patch hierarchy </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1GhostCellRobinBcCoefs.html">SAMRAI::solv::GhostCellRobinBcCoefs&lt; DIM &gt;</a></td><td class="indexvalue">A prefabricated Robin boundary condition coefficients for the case where cell-centered data is fixed at the first ghost-cell centers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1KINSOL__SAMRAIContext.html">SAMRAI::solv::KINSOL_SAMRAIContext&lt; DIM &gt;</a></td><td class="indexvalue">Wraps the <a class="el" href="classSAMRAI_1_1solv_1_1KINSOLSolver.html">KINSOLSolver</a> C++ wrapper class so that KINSOL may be used in applications that require a nonlinear solver </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1KINSOLAbstractFunctions.html">SAMRAI::solv::KINSOLAbstractFunctions</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1KINSOLSolver.html">SAMRAI::solv::KINSOLSolver</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1LocationIndexRobinBcCoefs.html">SAMRAI::solv::LocationIndexRobinBcCoefs&lt; DIM &gt;</a></td><td class="indexvalue">A prefabricated Robin boundary condition coefficients for coefficients that are entirely specified by the boundary box location index </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1NonlinearSolverStrategy.html">SAMRAI::solv::NonlinearSolverStrategy&lt; DIM &gt;</a></td><td class="indexvalue">Abstract base class defining interface between an <a class="el" href="classSAMRAI_1_1algs_1_1ImplicitIntegrator.html">algs::ImplicitIntegrator</a> object and a nonlinear solver used to advance the solution in time </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1PETSc__SAMRAIVectorReal.html">SAMRAI::solv::PETSc_SAMRAIVectorReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1PETScAbstractVectorReal.html">SAMRAI::solv::PETScAbstractVectorReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1PoissonSpecifications.html">SAMRAI::solv::PoissonSpecifications</a></td><td class="indexvalue">Light class holding specifications for cell-centered implementation of the scalar Poisson equation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy&lt; DIM &gt;</a></td><td class="indexvalue">Interface for specifying Robin boundary conditions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal&lt; DIM, TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1SimpleCellRobinBcCoefs.html">SAMRAI::solv::SimpleCellRobinBcCoefs&lt; DIM &gt;</a></td><td class="indexvalue">A prefabricated Robin boundary condition coefficients with an interface like the old Poisson solvers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1SNES__SAMRAIContext.html">SAMRAI::solv::SNES_SAMRAIContext&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1SNESAbstractFunctions.html">SAMRAI::solv::SNESAbstractFunctions</a></td><td class="indexvalue">Abstract base class that declares the functions to be used with the PETSc SNES nonlinear solver package </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1Sundials__SAMRAIVector.html">SAMRAI::solv::Sundials_SAMRAIVector&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1SundialsAbstractVector.html">SAMRAI::solv::SundialsAbstractVector</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1AbortAppender.html">SAMRAI::tbox::AbortAppender</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1AbstractStream.html">SAMRAI::tbox::AbstractStream</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Arena.html">SAMRAI::tbox::Arena</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1ArenaManager.html">SAMRAI::tbox::ArenaManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">SAMRAI::tbox::Array&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html">SAMRAI::tbox::AsyncCommGroup</a></td><td class="indexvalue">Supports many-to-one and one-to-many asynchronous communication operations within a given group of processes by sending messages along the branches of a conceptual tree </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">SAMRAI::tbox::AsyncCommStage</a></td><td class="indexvalue">Stage multiple asynchronous group communications so that the collective can advance asynchronously (as individual underlying MPI requests are completed) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1Clock.html">SAMRAI::tbox::Clock</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1ConstPointer.html">SAMRAI::tbox::ConstPointer&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1ConstPointerBase.html">SAMRAI::tbox::ConstPointerBase</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">Database</a> is an abstract base class for the input, restart, and visualization databases </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">SAMRAI::tbox::DatabaseBox</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1DatabaseBox__POD.html">SAMRAI::tbox::DatabaseBox_POD</a></td><td class="indexvalue">POD data for class <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">DatabaseBox</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseFactory.html">SAMRAI::tbox::DatabaseFactory</a></td><td class="indexvalue">Abstract base class factory used to build <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">Database</a> objects </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1DebugAppender.html">SAMRAI::tbox::DebugAppender</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1FileStream.html">SAMRAI::tbox::FileStream</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1FixedArena.html">SAMRAI::tbox::FixedArena</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1HDFDatabase.html">SAMRAI::tbox::HDFDatabase</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1HDFDatabaseFactory.html">SAMRAI::tbox::HDFDatabaseFactory</a></td><td class="indexvalue"><a class="el" href="classSAMRAI_1_1tbox_1_1HDFDatabase.html">HDFDatabase</a> factory </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1IEEE.html">SAMRAI::tbox::IEEE</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1InputManager.html">SAMRAI::tbox::InputManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1JobRelauncher.html">SAMRAI::tbox::JobRelauncher</a></td><td class="indexvalue">Manages an algorithm consisting of multiple relaunchable jobs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1List.html">SAMRAI::tbox::List&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1ListIterator.html">SAMRAI::tbox::ListIterator&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1ListNode.html">SAMRAI::tbox::ListNode&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Logger.html">SAMRAI::tbox::Logger</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Logger_1_1Appender.html">SAMRAI::tbox::Logger::Appender</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1MathUtilities.html">SAMRAI::tbox::MathUtilities&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1MemoryDatabase.html">SAMRAI::tbox::MemoryDatabase</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1MemoryDatabaseFactory.html">SAMRAI::tbox::MemoryDatabaseFactory</a></td><td class="indexvalue"><a class="el" href="classSAMRAI_1_1tbox_1_1MemoryDatabase.html">MemoryDatabase</a> factory </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1MemoryUtilities.html">SAMRAI::tbox::MemoryUtilities</a></td><td class="indexvalue">Class <a class="el" href="structSAMRAI_1_1tbox_1_1MemoryUtilities.html">MemoryUtilities</a> provides utility methods to access information about the memory characteristics of an application. Currently, there are only methods, one called "printMemoryInfo()" which does a simple dump of the current memory usage on a processor, and "recordMemoryInfo()" which records the memory for post-process analysis </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">SAMRAI::tbox::MessageStream</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1NullDatabase.html">SAMRAI::tbox::NullDatabase</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1ParallelBuffer.html">SAMRAI::tbox::ParallelBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Parser.html">SAMRAI::tbox::Parser</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1PIO.html">SAMRAI::tbox::PIO</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1PointerBase.html">SAMRAI::tbox::PointerBase</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1ReferenceCounter.html">SAMRAI::tbox::ReferenceCounter</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1RelaunchableJob.html">SAMRAI::tbox::RelaunchableJob</a></td><td class="indexvalue">Define interface for a relaunchable job managed by <a class="el" href="classSAMRAI_1_1tbox_1_1JobRelauncher.html">JobRelauncher</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1RestartManager.html">SAMRAI::tbox::RestartManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">SAMRAI::tbox::SAMRAI_MPI</a></td><td class="indexvalue">Provides C++ wrapper around MPI routines </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1SAMRAIManager.html">SAMRAI::tbox::SAMRAIManager</a></td><td class="indexvalue">Class <a class="el" href="structSAMRAI_1_1tbox_1_1SAMRAIManager.html">SAMRAIManager</a> is a utility for managing startup and shutdown for <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> applications and for changing the maximum number of patch data components supported by <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patches. All applications should call <a class="el" href="structSAMRAI_1_1tbox_1_1SAMRAIManager.html#6b3b7c0498bf43bdda64685daf7607da">SAMRAIManager::startup()</a> (or <a class="el" href="structSAMRAI_1_1tbox_1_1SAMRAIManager.html#6b3b7c0498bf43bdda64685daf7607da">SAMRAIManager::startup()</a>) at the beginning of the program. Startup should be called after initializing MPI but before any <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> objects are used. <a class="el" href="structSAMRAI_1_1tbox_1_1SAMRAIManager.html#abafb6ed941cf04cf0ef1e5c347b662b">SAMRAIManager::shutdown()</a> (or <a class="el" href="structSAMRAI_1_1tbox_1_1SAMRAIManager.html">SAMRAIManager</a>:<a class="el" href="structSAMRAI_1_1tbox_1_1SAMRAIManager.html#abafb6ed941cf04cf0ef1e5c347b662b">shutdown()</a>) should be called near the end of the program, but before shutting down MPI and calling exit(0). Note that the shutdown function does not exit the program; it merely shuts down certain packages and deallocates memory (mostly objects with static members) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Schedule.html">SAMRAI::tbox::Schedule</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1tbox_1_1Schedule.html">Schedule</a> is used to construct and execute a set of data communication transactions. Each transaction represents some data dependency and exchange between two processors, or locally involving a single processor. Once a communication schedule is constructed, transactions are provided to the schedule, using either the <a class="el" href="classSAMRAI_1_1tbox_1_1Schedule.html#0744ffbe1bf991d37184c0b1c2e75ba4">addTransaction()</a> method or the <a class="el" href="classSAMRAI_1_1tbox_1_1Schedule.html#cad74bbe19c26ebfc1da7360d8cfa423">appendTransaction()</a> method. The schedule is then executed forcing the communication, either interprocessor or local to occur. The basic idea behind the schedule is that it enables the cost of assembling communication dependencies and data transfers over many communication phases </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1Schedule_1_1ScheduleMessageStream.html">SAMRAI::tbox::Schedule::ScheduleMessageStream</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1ScratchArena.html">SAMRAI::tbox::ScratchArena</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Serializable.html">SAMRAI::tbox::Serializable</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1ShutdownRegistry.html">SAMRAI::tbox::ShutdownRegistry</a></td><td class="indexvalue">Class <a class="el" href="structSAMRAI_1_1tbox_1_1ShutdownRegistry.html">ShutdownRegistry</a> is a utility for managing callbacks at program completion </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1ShutdownRegistryItem.html">SAMRAI::tbox::ShutdownRegistryItem</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1SiloDatabaseFactory.html">SAMRAI::tbox::SiloDatabaseFactory</a></td><td class="indexvalue">SiloDatabase factory </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1StandardArena.html">SAMRAI::tbox::StandardArena</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Statistic.html">SAMRAI::tbox::Statistic</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1Statistic_1_1PatchStat.html">SAMRAI::tbox::Statistic::PatchStat</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1Statistic_1_1PatchStatRecord.html">SAMRAI::tbox::Statistic::PatchStatRecord</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1Statistic_1_1ProcStat.html">SAMRAI::tbox::Statistic::ProcStat</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Statistician.html">SAMRAI::tbox::Statistician</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1StatisticRestartDatabase.html">SAMRAI::tbox::StatisticRestartDatabase</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1StatTransaction.html">SAMRAI::tbox::StatTransaction</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Timer.html">SAMRAI::tbox::Timer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1TimerManager.html">SAMRAI::tbox::TimerManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Tracer.html">SAMRAI::tbox::Tracer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Transaction.html">SAMRAI::tbox::Transaction</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1Utilities.html">SAMRAI::tbox::Utilities</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1WarningAppender.html">SAMRAI::tbox::WarningAppender</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1XDRStream.html">SAMRAI::tbox::XDRStream</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1BoxGeometryFillPattern.html">SAMRAI::xfer::BoxGeometryFillPattern&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html">SAMRAI::xfer::CoarsenAlgorithm&lt; DIM &gt;</a></td><td class="indexvalue">Class CoarsenAlgorithm&lt;DIM&gt; encapsulates the AMR communication pattern to coarsen data from a finer level to any coarser level. Most often, data is coarsened from the interiors of source patch components on the source patch level into interiors of destination patch components on the destination level. See comments for the coarsen algorithm constructor for variations that are possible for (adventurous?) users. If the coarsening operators require ghost cells on a source component, then sufficient ghost cell storage must be provided by the source patch data component, and those ghost cells must be filled before calling the data coarsening routines </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenClasses.html">SAMRAI::xfer::CoarsenClasses&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1xfer_1_1CoarsenClasses_1_1Data.html">SAMRAI::xfer::CoarsenClasses&lt; DIM &gt;::Data</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenCopyTransaction.html">SAMRAI::xfer::CoarsenCopyTransaction&lt; DIM &gt;</a></td><td class="indexvalue">Class CoarsenCopyTransaction&lt;DIM&gt; represents a single copy communication transaction between two processors or a local data copy for coaren schedules. Note that to there is an implicit hand-shaking between objects of this class and the CoarsenSchedule&lt;DIM&gt; object that constructs them. Following the coarsen schedule implementation, the source patch data index for a copy transaction always refers to the source data, and the destination patch data index for a copy transaction is always the destination data, all as defined in the CoarsenClasses&lt;DIM&gt; class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenOperator.html">SAMRAI::xfer::CoarsenOperator&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html">SAMRAI::xfer::CoarsenPatchStrategy&lt; DIM &gt;</a></td><td class="indexvalue">Class CoarsenPatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface for operations that a user must supply for application-specific coarsening of data between two levels in an AMR patch hierarchy. A concrete subclass must define three member functions to perform the following tasks: </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule&lt; DIM &gt;</a></td><td class="indexvalue">Class CoarsenSchedule&lt;DIM&gt; performs the communication operations to coarsen data from a finer level to a coarser level </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenTransactionFactory.html">SAMRAI::xfer::CoarsenTransactionFactory&lt; DIM &gt;</a></td><td class="indexvalue">Abstract base class defining the interface for all concrete transaction factory objects that generate data transaction objects used with a CoarsenSchedule&lt;DIM&gt; object. A concrete subclass will allocate new transaction objects. This class is an example of the ``Abstract Factory'' method described in the Design Patterns book by Gamma, et al </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1FillBoxSet.html">SAMRAI::xfer::FillBoxSet&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1Geometry.html">SAMRAI::xfer::Geometry&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataCoarsenAlgorithm.html">SAMRAI::xfer::LocallyActiveDataCoarsenAlgorithm&lt; DIM &gt;</a></td><td class="indexvalue">Class LocallyActiveDataCoarsenAlgorithm&lt;DIM&gt; encapsulates the AMR communication pattern to coarsen locally-active data from a finer level to a coarser level where the data exists on both the coarse and fine levels. Most often, data is coarsened from the interiors of source patch components on the source patch level into interiors of destination patch components on the destination level. See comments for the coarsen algorithm constructor for variations that are possible for (adventurous?) users. If the coarsening operators require ghost cells on a source component, then sufficient ghost cell storage must be provided by the source patch data component, and those ghost cells must be filled before calling the data coarsening routines </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataCoarsenPatchStrategy.html">SAMRAI::xfer::LocallyActiveDataCoarsenPatchStrategy&lt; DIM &gt;</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataCoarsenPatchStrategy.html">LocallyActiveDataCoarsenPatchStrategy</a> is an abstract base class that defines a Strategy pattern interface for operations that a user may supply for application-specific coarsening of locally-active data between two levels in an AMR patch hierarchy. This interface class is similar to the <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html">CoarsenPatchStrategy</a> interface, except that it is used to treat locally-active patch data. A concrete subclass must define three member functions to perform the following tasks: </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataCoarsenSchedule.html">SAMRAI::xfer::LocallyActiveDataCoarsenSchedule&lt; DIM &gt;</a></td><td class="indexvalue">Class LocallyActiveDataCoarsenSchedule&lt;DIM&gt; performs the communication operations that coarsen locally-active data from a finer level to a coarser level </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataCoarsenTransactionFactory.html">SAMRAI::xfer::LocallyActiveDataCoarsenTransactionFactory&lt; DIM &gt;</a></td><td class="indexvalue">Abstract base class defining the interface for all concrete transaction factory objects that generate data transaction objects used with a LocallyActiveDataCoarsenSchedule&lt;DIM&gt; object. A concrete subclass will allocate new transaction objects. This class is an example of the ``Abstract Factory'' method described in the Design Patterns book by Gamma, et al </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataFillBox.html">SAMRAI::xfer::LocallyActiveDataFillBox&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataFillBoxSet.html">SAMRAI::xfer::LocallyActiveDataFillBoxSet&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineAlgorithm.html">SAMRAI::xfer::LocallyActiveDataRefineAlgorithm&lt; DIM &gt;</a></td><td class="indexvalue">Class LocallyActiveDataRefineAlgorithm&lt;DIM&gt; encapsulates the AMR communication pattern to refine data to, copy data to, or fill physical boundary data on a destination patch level, where the data may be defined only on some patches (i.e., the patch data is "locally-active"). The basic procedure for moving data follows three steps:<ol type=1>
<li>spatially interpolate data from coarser levels</li><li>copy data from the same level of refinement</li><li>fill physical boundary conditions regions </li></ol>
</td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">SAMRAI::xfer::LocallyActiveDataRefinePatchStrategy&lt; DIM &gt;</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefinePatchStrategy.html">LocallyActiveDataRefinePatchStrategy</a> is an abstract base class that defines a Strategy pattern interface for operations that a user may supply for application-specific refining of locally-active data between levels in an AMR patch hierarchy and filling of physical boundary values. A concrete subclass must define four member functions to perform the following tasks: </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineSchedule.html">SAMRAI::xfer::LocallyActiveDataRefineSchedule&lt; DIM &gt;</a></td><td class="indexvalue">Class LocallyActiveDataRefineSchedule&lt;DIM&gt; performs the communication operations that refine data to, copy data to, or fill physical boundary data on a destination patch level, where the data may be defined only on some patches (i.e., the patch data is "locally-active"). This class is based on the RefineSchedule&lt;DIM&gt; class. However, it has a reduced set of functionality since it treats locally-active data. For example, this class does not support time interpolation, and there is only one version of the constructor (vs. three for RefineSchedule&lt;DIM&gt;), the schedule cannot be reset, etc </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1LocallyActiveDataRefineTransactionFactory.html">SAMRAI::xfer::LocallyActiveDataRefineTransactionFactory&lt; DIM &gt;</a></td><td class="indexvalue">Abstract base class defining the interface for all concrete transaction factory objects that generate data transaction objects used with a LocallyActiveDataRefineSchedule&lt;DIM&gt; object. A concrete subclass will allocate new transaction objects. This class is an example of the ``Abstract Factory'' method described in the Design Patterns book by Gamma, et al </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockCoarsenAlgorithm.html">SAMRAI::xfer::MultiblockCoarsenAlgorithm&lt; DIM &gt;</a></td><td class="indexvalue">Class MultiblockCoarsenAlgorithm&lt;DIM&gt; encapsulates the AMR communication pattern to coarsen data from a finer level to any coarser level in a multiblock domain. Most often, data is coarsened from the interiors of source patch components on the source patch level into interiors of patch components on the destination level. If the coarsening operators require ghost cells on a source component, then sufficient ghost cell storage must be provided by the source patch data component, and those ghost cells must be filled before calling the data coarsening routines </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockCoarsenPatchStrategy.html">SAMRAI::xfer::MultiblockCoarsenPatchStrategy&lt; DIM &gt;</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockCoarsenPatchStrategy.html">MultiblockCoarsenPatchStrategy</a> is an abstract base class that provides interfaces between coarsen operations in the multiblock classes and user's problem specific routines. In general, it mimics the standard <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html">CoarsenPatchStrategy</a> class but implements some additional methods that supply information about the blocks </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockCoarsenSchedule.html">SAMRAI::xfer::MultiblockCoarsenSchedule&lt; DIM &gt;</a></td><td class="indexvalue">Class MultiblockCoarsenSchedule&lt;DIM&gt; encapsulates the AMR communication pattern to coarsen data from a finer level to a coarser level </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineAlgorithm.html">SAMRAI::xfer::MultiblockRefineAlgorithm&lt; DIM &gt;</a></td><td class="indexvalue">Class MultiblockRefineAlgorithm&lt;DIM&gt; is an extension of the concept of xfer::RefineAlgorithm&lt;DIM&gt; to be used in applications that require a multiblock domain </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefinePatchStrategy.html">SAMRAI::xfer::MultiblockRefinePatchStrategy&lt; DIM &gt;</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefinePatchStrategy.html">MultiblockRefinePatchStrategy</a> is a virtual base class that provides interfaces for users to problem-specific routines related to issues that arise in multiblock domains, particularly the filling of boundary conditions around a singularity </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1MultiblockRefineSchedule.html">SAMRAI::xfer::MultiblockRefineSchedule&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1xfer_1_1MultiblockRefineSchedule_1_1SingularityPatch.html">SAMRAI::xfer::MultiblockRefineSchedule&lt; DIM &gt;::SingularityPatch</a></td><td class="indexvalue">Struct <a class="el" href="structSAMRAI_1_1xfer_1_1MultiblockRefineSchedule_1_1SingularityPatch.html">SingularityPatch</a> allows a temporary patch that contains data near a singularity to be paired with a block id number </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm&lt; DIM &gt;</a></td><td class="indexvalue">Class RefineAlgorithm&lt;DIM&gt; encapsulates the AMR communication pattern to refine data to, copy data to, or fill physical boundary data on any destination patch level. The basic procedure for moving data follows three steps:<ol type=1>
<li>interpolate data (spatial and possibly temporal) from coarser levels</li><li>copy data from the same level of refinement</li><li>fill physical boundary conditions regions </li></ol>
</td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">SAMRAI::xfer::RefineClasses&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1xfer_1_1RefineClasses_1_1Data.html">SAMRAI::xfer::RefineClasses&lt; DIM &gt;::Data</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineCopyTransaction.html">SAMRAI::xfer::RefineCopyTransaction&lt; DIM &gt;</a></td><td class="indexvalue">Class RefineCopyTransaction&lt;DIM&gt; represents a single copy communication transaction between two processors or a local data copy for refine schedules. Note that to there is an implicit hand-shaking between objects of this class and the RefineSchedule&lt;DIM&gt; object that constructs them. Following the refine schedule implementation, the source patch data index for a copy transaction always refers to the source data and the destination patch data index for a copy transaction is always the scratch data, all as defined in the RefineClasses&lt;DIM&gt; class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">SAMRAI::xfer::RefineOperator&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a></td><td class="indexvalue">Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface for operations that a user must supply for application-specific refining of data between levels in an AMR patch hierarchy and filling of physical boundary values. A concrete subclass must define four member functions to perform the following tasks: </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule&lt; DIM &gt;</a></td><td class="indexvalue">Class RefineSchedule&lt;DIM&gt; performs the communication operations that refine data to, copy data to, or fill physical boundary data on a destination patch level </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineTimeTransaction.html">SAMRAI::xfer::RefineTimeTransaction&lt; DIM &gt;</a></td><td class="indexvalue">Class RefineTimeTransaction&lt;DIM&gt; represents a single time interpolation communication transaction between two processors or a local data copy or refine schedules. Note that to there is an implicit hand-shaking between objects of this class and the RefineSchedule&lt;DIM&gt; object that constructs them. Following the refine schedule implementation, the source patch data indices for a time transaction are always refer to the old and new source data and the destination patch data index for a time transaction is always the scratch data, all as defined in the RefineClasses&lt;DIM&gt; class. This transaction is used by the refine schedule </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">SAMRAI::xfer::RefineTransactionFactory&lt; DIM &gt;</a></td><td class="indexvalue">Abstract base class defining the interface for all concrete transaction factory objects that generate data transaction objects used with a RefineSchedule&lt;DIM&gt; object. A concrete subclass will allocate new transaction objects. This class is an example of the ``Abstract Factory'' method described in the Design Patterns book by Gamma, et al </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1StandardCoarsenTransactionFactory.html">SAMRAI::xfer::StandardCoarsenTransactionFactory&lt; DIM &gt;</a></td><td class="indexvalue">Concrete subclass of CoarsenTransactionFactory&lt;DIM&gt; base class that allocates CoarsenCopyTransaction&lt;DIM&gt; objects for a CoarsenSchedule&lt;DIM&gt; object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1StandardLocallyActiveDataCoarsenTransactionFactory.html">SAMRAI::xfer::StandardLocallyActiveDataCoarsenTransactionFactory&lt; DIM &gt;</a></td><td class="indexvalue">Concrete subclass of LocallyActiveDataCoarsenTransactionFactory&lt;DIM&gt; base class that allocates CoarsenCopyTransaction&lt;DIM&gt; objects for a LocallyActiveDataCoarsenSchedule&lt;DIM&gt; object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1StandardLocallyActiveDataRefineTransactionFactory.html">SAMRAI::xfer::StandardLocallyActiveDataRefineTransactionFactory&lt; DIM &gt;</a></td><td class="indexvalue">Concrete subclass of LocallyActiveDataRefineTransactionFactory&lt;DIM&gt; base class that allocates RefineCopyTransaction&lt;DIM&gt; and RefineTimeTransaction&lt;DIM&gt; objects for a LocallyActiveDataRefineSchedule&lt;DIM&gt; object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html">SAMRAI::xfer::StandardRefineTransactionFactory&lt; DIM &gt;</a></td><td class="indexvalue">Concrete subclass of RefineTransactionFactory&lt;DIM&gt; base class that allocates RefineCopyTransaction&lt;DIM&gt; and RefineTimeTransaction&lt;DIM&gt; objects for a RefineSchedule&lt;DIM&gt; object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1TimeInterpolateOperator.html">SAMRAI::xfer::TimeInterpolateOperator&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">SAMRAI::xfer::VariableFillPattern&lt; DIM &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classtbox_1_1DescribedClass.html">DescribedClass</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structXDR.html">XDR</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structyy__buffer__state.html">yy_buffer_state</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="unionyyalloc.html">yyalloc</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="unionYYSTYPE.html">YYSTYPE</a></td><td class="indexvalue"></td></tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:28:17 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
