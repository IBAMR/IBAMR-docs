<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::tbox::AsyncCommGroup Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1tbox.html">tbox</a>::<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html">AsyncCommGroup</a></div>
<h1>SAMRAI::tbox::AsyncCommGroup Class Reference</h1><!-- doxytag: class="SAMRAI::tbox::AsyncCommGroup" -->Supports many-to-one and one-to-many asynchronous communication operations within a given group of processes by sending messages along the branches of a conceptual tree.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/toolbox/parallel/AsyncCommGroup.h&gt;</code>
<p>
<a href="classSAMRAI_1_1tbox_1_1AsyncCommGroup-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#548e8ef8f25c86804e3fc30576e566b4">AsyncCommGroup</a> (const int nchild)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct communication group.  <a href="#548e8ef8f25c86804e3fc30576e566b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#450775f8009a1a5898477d071fb4f26c">~AsyncCommGroup</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#450775f8009a1a5898477d071fb4f26c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#f2aa4253bd569d04b31bb5b35a39142e">setMPITag</a> (const int mpi_tag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the MPI tag used for communication within the group.  <a href="#f2aa4253bd569d04b31bb5b35a39142e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#8473f4d8b4765634b5d193baa93fd9b7">setMPICommunicator</a> (<a class="el" href="structSAMRAI_1_1tbox_1_1SAMRAI__MPI.html#5fb40f9528afc8d4a0afb38e0f240ab1">SAMRAI_MPI::comm</a> &amp;mpi_communicator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the MPI communicator used for communication within the group.  <a href="#8473f4d8b4765634b5d193baa93fd9b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#c909116403ea9b4e86a194669224dbf7">setUseBlockingSendToParent</a> (const bool flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether sends to parents should be blocking.  <a href="#c909116403ea9b4e86a194669224dbf7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#f090fddfaa48c7eb91a860a9c4cc2c08">setUseBlockingSendToChildren</a> (const bool flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether sends to children should be blocking.  <a href="#f090fddfaa48c7eb91a860a9c4cc2c08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#c32c51edd05ad9c6e62838f32b313f44">getNumberOfChildren</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#3913a89e3b287dccd97c28218b4a552f">logCurrentState</a> (std::ostream &amp;co) const</td></tr>

<tr><td colspan="2"><div class="groupHeader">Define the communication group</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#3aa8c545ea1975a98a4079a0027cb1a5">setGroupAndRootIndex</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">Array</a>&lt; int &gt; &amp;group, const int root_index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup the tree for the given group of processes. The root process is specified by its index in the group array.  <a href="#3aa8c545ea1975a98a4079a0027cb1a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#2776a3efb70be8adb20d08c33cdd14b6">setGroupAndRootRank</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">Array</a>&lt; int &gt; &amp;group, const int root_rank)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup the group for the given group. The root process is specified by its rank.  <a href="#2776a3efb70be8adb20d08c33cdd14b6"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Communication methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#520f3cec0caea74a731b9102276eb83c">beginBcast</a> (int *<a class="el" href="appu__cpdat2buf3d_8f.html#e3215fc943ca2137c64ec5948646fa5a">buffer</a>, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin a broadcast communication.  <a href="#520f3cec0caea74a731b9102276eb83c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#69fd7c96bf69ca79b76a0ebf8c133fd9">checkBcast</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current broadcast communication and complete the broadcast if all MPI requests are fulfilled.  <a href="#69fd7c96bf69ca79b76a0ebf8c133fd9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#2179371efe6288654029b5796ac10fa2">beginGather</a> (int *<a class="el" href="appu__cpdat2buf3d_8f.html#e3215fc943ca2137c64ec5948646fa5a">buffer</a>, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin a gather communication.  <a href="#2179371efe6288654029b5796ac10fa2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#14b1c40af08d5be853ef33ccdde46489">checkGather</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current gather communication and complete the gather if all MPI requests are fulfilled.  <a href="#14b1c40af08d5be853ef33ccdde46489"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#8c793a5e0abe994ceb89d186dd21ff6c">beginSumReduce</a> (int *<a class="el" href="appu__cpdat2buf3d_8f.html#e3215fc943ca2137c64ec5948646fa5a">buffer</a>, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin a sum reduce communication.  <a href="#8c793a5e0abe994ceb89d186dd21ff6c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#724bbf61b605419c2ac4d43748cdabbe">checkSumReduce</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current sum reduce communication and complete the sum reduce if all MPI requests are fulfilled.  <a href="#724bbf61b605419c2ac4d43748cdabbe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#14aff2c877ce7573dc476d3f9e342048">checkOperation</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current communication and complete it if all MPI requests are fulfilled.  <a href="#14aff2c877ce7573dc476d3f9e342048"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#d2c4c885232ad191c33b73b32fca670d">waitOperation</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the current operation to complete.  <a href="#d2c4c885232ad191c33b73b32fca670d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#c5667c0977f09f956ec8170159b89b14">isDone</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether the last communication operation has finished.  <a href="#c5667c0977f09f956ec8170159b89b14"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Supports many-to-one and one-to-many asynchronous communication operations within a given group of processes by sending messages along the branches of a conceptual tree. 
<p>
This class was created to perform certain group communications without using MPI global communications, which require creating new MPI communicators (can be expensive) and does not support asynchronous operations.<p>
The supported communications are asynchronous in that you can start one and wait for it or check back on it occassionally until it completes. Asynchronous operations in conjunction with other groups can be done by using a <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> to allocate the groups and to check for completed communications.<p>
Supported operations are currently broadcast, gather and sum reduce. Only integer data is supported.<p>
A tree is an acyclic graph in which a node at position pos has nchild children, and the following positions for its<ul>
<li>parent: (pos-1)/nchild</li><li>first (oldest) child: pos*nchild+1</li><li>last (youngest) child: (pos+1)*nchild</li></ul>
<p>
For example, nchild=2 corresponds to a binary tree.<p>
Communication is done by sending messages toward the root (for all-to-one operations) or leaves (for one-to-all operations). For the former, we receive data from the children and send to the parent. For the latter, we receive from the parent and send to the children. Thus every communication involves a receive and a send (except at the root and leaf nodes of the tree).<p>
Using a tree generally gives better performance than having all processes in the the tree communicate directly with the root process. Using MPI communicators corresponding to the groups may faster than using this class, but the cost of creating MPI communicators MAY be expensive.<p>
This class supports communication and uses MPI for message passing. If MPI is disabled, the job of this class disappears and the class is effectively empty. The public interfaces still remain so the class can compile, but the implementations are trivial. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="548e8ef8f25c86804e3fc30576e566b4"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::AsyncCommGroup" ref="548e8ef8f25c86804e3fc30576e566b4" args="(const int nchild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::tbox::AsyncCommGroup::AsyncCommGroup           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nchild</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct communication group. 
<p>
The number of children per node is flexible.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nchild</em>&nbsp;</td><td>Number of children per node in the group, i.e., nchild=2 is a binary tree. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="450775f8009a1a5898477d071fb4f26c"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::~AsyncCommGroup" ref="450775f8009a1a5898477d071fb4f26c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::tbox::AsyncCommGroup::~AsyncCommGroup           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="3aa8c545ea1975a98a4079a0027cb1a5"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setGroupAndRootIndex" ref="3aa8c545ea1975a98a4079a0027cb1a5" args="(const Array&lt; int &gt; &amp;group, const int root_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::setGroupAndRootIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">Array</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>root_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setup the tree for the given group of processes. The root process is specified by its index in the group array. 
<p>
The root is specified by dereferencing <code>group</code> array with <code>root_index</code>. 
</div>
</div><p>
<a class="anchor" name="2776a3efb70be8adb20d08c33cdd14b6"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setGroupAndRootRank" ref="2776a3efb70be8adb20d08c33cdd14b6" args="(const Array&lt; int &gt; &amp;group, const int root_rank)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::setGroupAndRootRank           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">Array</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>root_rank</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setup the group for the given group. The root process is specified by its rank. 
<p>
The rank of the root is root_rank, which must be one of the ranks given in the group. 
</div>
</div><p>
<a class="anchor" name="f2aa4253bd569d04b31bb5b35a39142e"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setMPITag" ref="f2aa4253bd569d04b31bb5b35a39142e" args="(const int mpi_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::setMPITag           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>mpi_tag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the MPI tag used for communication within the group. 
<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>This class is NOT (and cannot be) responsible for ensuring that the MPI communicator and tag are sufficient to select the correct messages. Please specify appropriate values for the MPI communicator and tag. Very elusive bugs can occur if incorrect messages are received. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8473f4d8b4765634b5d193baa93fd9b7"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setMPICommunicator" ref="8473f4d8b4765634b5d193baa93fd9b7" args="(SAMRAI_MPI::comm &amp;mpi_communicator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::setMPICommunicator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSAMRAI_1_1tbox_1_1SAMRAI__MPI.html#5fb40f9528afc8d4a0afb38e0f240ab1">SAMRAI_MPI::comm</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi_communicator</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the MPI communicator used for communication within the group. 
<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>This class is NOT (and cannot be) responsible for ensuring that the MPI communicator and tag are sufficient to select the correct messages. Please specify appropriate values for the MPI communicator and tag. Very elusive bugs can occur if incorrect messages are received. To be safe, it is best to create a new communicator to avoid interference with other communications within <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c909116403ea9b4e86a194669224dbf7"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setUseBlockingSendToParent" ref="c909116403ea9b4e86a194669224dbf7" args="(const bool flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::setUseBlockingSendToParent           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>flag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set whether sends to parents should be blocking. 
<p>
The default is to use blocking send to parent. Because there is just one parent, short messages can be buffered by MPI to improve the performance of blocking sends. Blocking sends need not be checked for completion. 
</div>
</div><p>
<a class="anchor" name="f090fddfaa48c7eb91a860a9c4cc2c08"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setUseBlockingSendToChildren" ref="f090fddfaa48c7eb91a860a9c4cc2c08" args="(const bool flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::setUseBlockingSendToChildren           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>flag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set whether sends to children should be blocking. 
<p>
The default is to use nonblocking send to children. Nonblocking sends to children are generally appropriate as there are multiple children. 
</div>
</div><p>
<a class="anchor" name="520f3cec0caea74a731b9102276eb83c"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::beginBcast" ref="520f3cec0caea74a731b9102276eb83c" args="(int *buffer, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::beginBcast           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin a broadcast communication. 
<p>
Root process of broadcast may send less data (smaller size) than receivers of broadcast, in which case the missing data is considered irrelevant by the root.<p>
If this method returns false, <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#69fd7c96bf69ca79b76a0ebf8c133fd9">checkBcast()</a> must be called until it returns true before any change in object state is allowed.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="69fd7c96bf69ca79b76a0ebf8c133fd9"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::checkBcast" ref="69fd7c96bf69ca79b76a0ebf8c133fd9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::checkBcast           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check the current broadcast communication and complete the broadcast if all MPI requests are fulfilled. 
<p>
If no communication is in progress, this call does nothing.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2179371efe6288654029b5796ac10fa2"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::beginGather" ref="2179371efe6288654029b5796ac10fa2" args="(int *buffer, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::beginGather           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin a gather communication. 
<p>
Sending processes of gather may send less data (smaller size) than receivers of broadcast, in which case the missing data is considered irrelevant by the sender.<p>
If this method returns false, <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#14b1c40af08d5be853ef33ccdde46489">checkGather()</a> must be called until it returns true before any change in object state is allowed.<p>
On non-root processes, buffer should contain the data to be gathered. On the root process, it should have enough space for all the data from all the processes in the group.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Data to gather. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of data contributed by each process.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="14b1c40af08d5be853ef33ccdde46489"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::checkGather" ref="14b1c40af08d5be853ef33ccdde46489" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::checkGather           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check the current gather communication and complete the gather if all MPI requests are fulfilled. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8c793a5e0abe994ceb89d186dd21ff6c"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::beginSumReduce" ref="8c793a5e0abe994ceb89d186dd21ff6c" args="(int *buffer, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::beginSumReduce           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin a sum reduce communication. 
<p>
Assume all messages are the same size.<p>
If this method returns false, <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#724bbf61b605419c2ac4d43748cdabbe">checkSumReduce()</a> must be called until it returns true before any change in object state is allowed.<p>
Buffer should contain the data to be gathered.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="724bbf61b605419c2ac4d43748cdabbe"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::checkSumReduce" ref="724bbf61b605419c2ac4d43748cdabbe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::checkSumReduce           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check the current sum reduce communication and complete the sum reduce if all MPI requests are fulfilled. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="14aff2c877ce7573dc476d3f9e342048"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::checkOperation" ref="14aff2c877ce7573dc476d3f9e342048" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::checkOperation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check the current communication and complete it if all MPI requests are fulfilled. 
<p>

</div>
</div><p>
<a class="anchor" name="d2c4c885232ad191c33b73b32fca670d"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::waitOperation" ref="d2c4c885232ad191c33b73b32fca670d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::waitOperation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for the current operation to complete. 
<p>

</div>
</div><p>
<a class="anchor" name="c5667c0977f09f956ec8170159b89b14"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::isDone" ref="c5667c0977f09f956ec8170159b89b14" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::isDone           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether the last communication operation has finished. 
<p>

</div>
</div><p>
<a class="anchor" name="c32c51edd05ad9c6e62838f32b313f44"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::getNumberOfChildren" ref="c32c51edd05ad9c6e62838f32b313f44" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::tbox::AsyncCommGroup::getNumberOfChildren           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3913a89e3b287dccd97c28218b4a552f"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::logCurrentState" ref="3913a89e3b287dccd97c28218b4a552f" args="(std::ostream &amp;co) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::logCurrentState           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>co</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/toolbox/parallel/<a class="el" href="AsyncCommGroup_8h.html">AsyncCommGroup.h</a><li>source/toolbox/parallel/<a class="el" href="AsyncCommGroup_8C.html">AsyncCommGroup.C</a><li>source/toolbox/parallel/<a class="el" href="AsyncCommGroup_8I.html">AsyncCommGroup.I</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:29:06 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
