<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::algs::MethodOfLinesIntegrator&lt; DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1algs.html">algs</a>::<a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">MethodOfLinesIntegrator</a></div>
<h1>SAMRAI::algs::MethodOfLinesIntegrator&lt; DIM &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::algs::MethodOfLinesIntegrator" --><!-- doxytag: inherits="SAMRAI::tbox::Serializable,SAMRAI::mesh::StandardTagAndInitStrategy" -->Class MethodOfLinesIntegrator&lt;DIM&gt; implements a spatially adaptive version of the Strong Stability Preserving (SSP) Runge-Kutta time integration algorithm.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/algorithm/method_of_lines/MethodOfLinesIntegrator.h&gt;</code>
<p>
Inheritance diagram for SAMRAI::algs::MethodOfLinesIntegrator&lt; DIM &gt;:<p><center><img src="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator__inherit__graph.png" border="0" usemap="#SAMRAI_1_1algs_1_1MethodOfLinesIntegrator_3_01DIM_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="SAMRAI_1_1algs_1_1MethodOfLinesIntegrator_3_01DIM_01_4__inherit__map">
<area href="classSAMRAI_1_1tbox_1_1Serializable.html" shape="rect" coords="7,83,188,107" alt="">
<area href="classtbox_1_1DescribedClass.html" shape="rect" coords="40,8,155,32" alt="">
<area href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html" shape="rect" coords="212,83,548,107" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#25ed25ae080357a46aaac785496e1775">MOL_VAR_TYPE</a> { <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#25ed25ae080357a46aaac785496e1775453fe933d1b79c2350e4b00950d5863a">SOLN</a> =  0, 
<a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#25ed25ae080357a46aaac785496e1775314288ed3cd6b6856f1340b160fa3f98">RHS</a> =  1
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#4a8322e2e76ff308d99a98145824acac">MethodOfLinesIntegrator</a> (const std::string &amp;object_name, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; input_db, <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesPatchStrategy.html">MethodOfLinesPatchStrategy</a>&lt; DIM &gt; *patch_strategy, bool register_for_restart=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#9ce497a539e700ec7192c4960893f9ed">~MethodOfLinesIntegrator</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#5b961f9370f38e7abf50fc9d6b9d50c6">initializeIntegrator</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a>&lt; DIM &gt; &gt; gridding_alg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#cc87edd5e2fb332430faa75753ad966c">getTimestep</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const double time) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#99cbb10770f34a6ed86cc963bd89517c">advanceHierarchy</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const double time, const double dt)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#66ed77636f6fd100d13fba2ed6f3b03d">registerVariable</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a>&lt; DIM &gt; &gt; variable, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ghosts, const <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#25ed25ae080357a46aaac785496e1775">MOL_VAR_TYPE</a> m_v_type, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1Geometry.html">xfer::Geometry</a>&lt; DIM &gt; &gt; &amp;transfer_geom, const std::string &amp;coarsen_name=std::string(), const std::string &amp;refine_name=std::string())</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#984e321fb35830b0f1cbbe5b33b28b35">printClassData</a> (std::ostream &amp;os) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#38d3070ce81b09f49fa8ec7f3cbca547">initializeLevelData</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const int level_number, const double init_time, const bool can_be_refined, const bool initial_time, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt; old_level=<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;((0)), const bool allocate_data=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#cda6cac28daf90679252c93e1ab5ab70">resetHierarchyConfiguration</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const int coarsest_level, const int finest_level)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#03ce5f66938df051f28a714eaa12d1a6">applyGradientDetector</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const int level_number, const double time, const int tag_index, const bool initial_time, const bool uses_richardson_extrapolation_too)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#a838a96fa5b96234b8c0dcd027d5a99e">putToDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; db)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class SAMRAI::algs::MethodOfLinesIntegrator&lt; DIM &gt;</h3>

Class MethodOfLinesIntegrator&lt;DIM&gt; implements a spatially adaptive version of the Strong Stability Preserving (SSP) Runge-Kutta time integration algorithm. 
<p>
The original non-adaptive version of the algorithm is described in S. Gottlieb, C.W. Shu, E. Tadmor, SIAM Review, Vol. 43, No. 1, pp. 89-112. The <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#99cbb10770f34a6ed86cc963bd89517c">advanceHierarchy()</a> method integrates all levels of an AMR hierarchy through a specified timestep. See this method for details of the time-stepping process. Application-specific numerical routines that are necessary for these operations are provided by the MethodOfLinesPatchStrategy&lt;DIM&gt; data member. The collaboration between this class and the patch strategy follows the the Strategy design pattern. A concrete patch strategy object is derived from the base class to provide those routines for a specific problem.<p>
This class is derived from the mesh::StandardTagAndInitStrategy&lt;DIM&gt; abstract base class which defines an interface for routines required by the dynamic adaptive mesh refinement routines in the mesh::GriddingAlgorithm&lt;DIM&gt; class. This collaboration also follows the Strategy design pattern.<p>
Initialization of an MethodOfLinesIntegrator&lt;DIM&gt; object is performed by first setting default values, then reading from input. All input values may override values read from restart. Data read from input is summarized as follows:<p>
Required input keys and data types: NONE<p>
Optional input keys, data types, and defaults:<p>
<ul>
<li><b>order</b> integer value specifying order of Runge-Kutta scheme. If no input value is given, third order (i.e. order = 3) is used.</li></ul>
<p>
<ul>
<li><b>alpha_1</b> </li><li><b>alpha_2</b> </li><li><b>beta</b> arrays of double values (length = order) specifying the coeffients used in the multi-step Strong Stability Preserving (SSP) Runge-Kutta algorithm. If no input is supplied, the default alpha_1, alpha_2, and beta values are automatically set to correspond to the specified order.</li></ul>
<p>
The following represents a sample input entry:<p>
<div class="fragment"><pre class="fragment">
 *  MethodOfLinesIntegrator{
 *     order                 = 3         
 *     alpha_1               = 1., 0.75, 0.33333
 *     alpha_2               = 0., 0.25, 0.66666
 *     beta                  = 1., 0.25, 0.66666
 *  }
 *  </pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">mesh::StandardTagAndInitStrategy</a> </dd></dl>

<p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="25ed25ae080357a46aaac785496e1775"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::MOL_VAR_TYPE" ref="25ed25ae080357a46aaac785496e1775" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#25ed25ae080357a46aaac785496e1775">SAMRAI::algs::MethodOfLinesIntegrator::MOL_VAR_TYPE</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumerated type for the different categories of variable quantities allowed by the method of lines integration algorithm. See registerVariable(...) function for more details.<p>
<ul>
<li><b>SOLN</b> {Solution quantity for time-dependent ODE problem solved by RK time-stepping algorithm.}</li><li><b>RHS</b> {Right-hand-side of ODE problem solved; i.e., du/dt = RHS.} </li></ul>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="25ed25ae080357a46aaac785496e1775453fe933d1b79c2350e4b00950d5863a"></a><!-- doxytag: member="SOLN" ref="25ed25ae080357a46aaac785496e1775453fe933d1b79c2350e4b00950d5863a" args="" -->SOLN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="25ed25ae080357a46aaac785496e1775314288ed3cd6b6856f1340b160fa3f98"></a><!-- doxytag: member="RHS" ref="25ed25ae080357a46aaac785496e1775314288ed3cd6b6856f1340b160fa3f98" args="" -->RHS</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="4a8322e2e76ff308d99a98145824acac"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::MethodOfLinesIntegrator" ref="4a8322e2e76ff308d99a98145824acac" args="(const std::string &amp;object_name, tbox::Pointer&lt; tbox::Database &gt; input_db, MethodOfLinesPatchStrategy&lt; DIM &gt; *patch_strategy, bool register_for_restart=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">SAMRAI::algs::MethodOfLinesIntegrator</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">MethodOfLinesIntegrator</a>           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesPatchStrategy.html">MethodOfLinesPatchStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>register_for_restart</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The constructor for MethodOfLinesIntegrator&lt;DIM&gt; configures the method of lines integration algorithm with the concrete patch strategy object (containing problem-specific numerical routines) and initializes integration algorithm parameters provided in the specified input database and in the restart database corresponding to the specified object_name. The constructor also registers this object for restart using the specified object name when the boolean argument is true. Whether object will write its state to restart files during program execution is determined by this argument. Note that it has a default state of true.<p>
When assertion checking is active, passing in any null pointer or an empty string will result in an unrecoverable exception. 
</div>
</div><p>
<a class="anchor" name="9ce497a539e700ec7192c4960893f9ed"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::~MethodOfLinesIntegrator" ref="9ce497a539e700ec7192c4960893f9ed" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">SAMRAI::algs::MethodOfLinesIntegrator</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">MethodOfLinesIntegrator</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The destructor for MethodOfLinesIntegrator&lt;DIM&gt; unregisters the integrator object with the restart manager when so registered. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="5b961f9370f38e7abf50fc9d6b9d50c6"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::initializeIntegrator" ref="5b961f9370f38e7abf50fc9d6b9d50c6" args="(tbox::Pointer&lt; mesh::GriddingAlgorithm&lt; DIM &gt; &gt; gridding_alg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">SAMRAI::algs::MethodOfLinesIntegrator</a>&lt; DIM &gt;::initializeIntegrator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>gridding_alg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize integrator by setting the number of time levels of data needed based on specifications of the gridding algorithm.<p>
This routine also invokes variable registration in the patch strategy. 
</div>
</div><p>
<a class="anchor" name="cc87edd5e2fb332430faa75753ad966c"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::getTimestep" ref="cc87edd5e2fb332430faa75753ad966c" args="(const tbox::Pointer&lt; hier::PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const double time) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">SAMRAI::algs::MethodOfLinesIntegrator</a>&lt; DIM &gt;::getTimestep           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a suitable time increment over which to integrate the ODE problem. A minimum is taken over the increment computed on each patch in the hierarchy. 
</div>
</div><p>
<a class="anchor" name="99cbb10770f34a6ed86cc963bd89517c"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::advanceHierarchy" ref="99cbb10770f34a6ed86cc963bd89517c" args="(const tbox::Pointer&lt; hier::PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const double time, const double dt)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">SAMRAI::algs::MethodOfLinesIntegrator</a>&lt; DIM &gt;::advanceHierarchy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>dt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Advance the solution through the specified dt, which is assumed for the problem and state of the solution. Advances all patches in the hierarchy passed in. 
</div>
</div><p>
<a class="anchor" name="66ed77636f6fd100d13fba2ed6f3b03d"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::registerVariable" ref="66ed77636f6fd100d13fba2ed6f3b03d" args="(const tbox::Pointer&lt; hier::Variable&lt; DIM &gt; &gt; variable, const hier::IntVector&lt; DIM &gt; &amp;ghosts, const MOL_VAR_TYPE m_v_type, const tbox::Pointer&lt; xfer::Geometry&lt; DIM &gt; &gt; &amp;transfer_geom, const std::string &amp;coarsen_name=std::string(), const std::string &amp;refine_name=std::string())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">SAMRAI::algs::MethodOfLinesIntegrator</a>&lt; DIM &gt;::registerVariable           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#25ed25ae080357a46aaac785496e1775">MOL_VAR_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>m_v_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1Geometry.html">xfer::Geometry</a>&lt; DIM &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>transfer_geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>coarsen_name</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>refine_name</em> = <code>std::string()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register variable quantity defined in the patch strategy with the method of lines integrator which manipulates its storage. 
</div>
</div><p>
<a class="anchor" name="984e321fb35830b0f1cbbe5b33b28b35"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::printClassData" ref="984e321fb35830b0f1cbbe5b33b28b35" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">SAMRAI::algs::MethodOfLinesIntegrator</a>&lt; DIM &gt;::printClassData           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print all data members of MethodOfLinesIntegrator&lt;DIM&gt; object. 
</div>
</div><p>
<a class="anchor" name="38d3070ce81b09f49fa8ec7f3cbca547"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::initializeLevelData" ref="38d3070ce81b09f49fa8ec7f3cbca547" args="(const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const int level_number, const double init_time, const bool can_be_refined, const bool initial_time, const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; old_level=tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt;((0)), const bool allocate_data=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">SAMRAI::algs::MethodOfLinesIntegrator</a>&lt; DIM &gt;::initializeLevelData           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>init_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>can_be_refined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>old_level</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;&nbsp;<a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;&gt;((0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>allocate_data</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize data on a new level after it is inserted into an AMR patch hierarchy by the gridding algorithm. The level number indicates that of the new level. The old_level pointer corresponds to the level that resided in the hierarchy before the level with the specified number was introduced. If the pointer is NULL, there was no level in the hierarchy prior to the call and the level data is set based on the user routines and the simulation time. Otherwise, the specified level replaces the old level and the new level receives data from the old level appropriately before it is destroyed.<p>
Typically, when data is set, it is interpolated from coarser levels in the hierarchy. If the data is to be set, the level number must match that of the old level, if non-NULL. If the old level is non-NULL, then data is copied from the old level to the new level on regions of intersection between those levels before interpolation occurs. Then, user-supplied patch routines are called to further initialize the data if needed. The boolean argument after_regrid is passed into the user's routines.<p>
The boolean argument initial_time indicates whether the integration time corresponds to the initial simulation time. If true, the level should be initialized with initial simulation values. Otherwise, it should be assumed that the simulation time is at some point after the start of the simulation. This information is provided since the initialization of the data on a patch may be different in each of those circumstances. The can_be_refined boolean argument indicates whether the level is the finest allowable level in the hierarchy.<p>
Note: This function is overloaded from the base class mesh::StandardTagAndInitStrategy&lt;DIM&gt;. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#01feb177be312206e159858f33e6d332">SAMRAI::mesh::StandardTagAndInitStrategy&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="cda6cac28daf90679252c93e1ab5ab70"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::resetHierarchyConfiguration" ref="cda6cac28daf90679252c93e1ab5ab70" args="(const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const int coarsest_level, const int finest_level)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">SAMRAI::algs::MethodOfLinesIntegrator</a>&lt; DIM &gt;::resetHierarchyConfiguration           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finest_level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset cached communication schedules after the hierarchy has changed (due to regridding, for example) and the data has been initialized on the new levels. The intent is that the cost of data movement on the hierarchy will be amortized across multiple communication cycles, if possible. Note, that whenever this routine is called, communication schedules are updated for every level finer than and including that indexed by coarsest_level.<p>
Note: This function is overloaded from the base class mesh::StandardTagAndInitStrategy&lt;DIM&gt;. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#6f8d89482d4bdafc824307cc21c728c9">SAMRAI::mesh::StandardTagAndInitStrategy&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="03ce5f66938df051f28a714eaa12d1a6"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::applyGradientDetector" ref="03ce5f66938df051f28a714eaa12d1a6" args="(const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const int level_number, const double time, const int tag_index, const bool initial_time, const bool uses_richardson_extrapolation_too)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">SAMRAI::algs::MethodOfLinesIntegrator</a>&lt; DIM &gt;::applyGradientDetector           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>uses_richardson_extrapolation_too</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set integer tags to "one" on the given level where refinement of that level should occur using the user-supplied gradient detector. The boolean argument initial_time is true when the level is being subject to error estimation at initialization time. If it is false, the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. The boolean argument uses_richardson_extrapolation_too is true when Richardson extrapolation error estimation is used in addition to the gradient detector, and false otherwise. This argument helps the user to manage multiple regridding criteria. This information is passed along to the user's patch data tagging routines since the application of the error estimator may be different in each of those circumstances.<p>
Note: This function is overloaded from the base class mesh::StandardTagAndInitStrategy&lt;DIM&gt;. 
<p>
Reimplemented from <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#8aa67394970080b7c75d5f3a22dd9a82">SAMRAI::mesh::StandardTagAndInitStrategy&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="a838a96fa5b96234b8c0dcd027d5a99e"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::putToDatabase" ref="a838a96fa5b96234b8c0dcd027d5a99e" args="(tbox::Pointer&lt; tbox::Database &gt; db)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">SAMRAI::algs::MethodOfLinesIntegrator</a>&lt; DIM &gt;::putToDatabase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes object state out to the given database.<p>
When assertion checking is enabled, the database pointer must be non-null. 
<p>
Implements <a class="el" href="classSAMRAI_1_1tbox_1_1Serializable.html#d90b74ae3fd7af9a7bb9cbf7f3ebc08a">SAMRAI::tbox::Serializable</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/algorithm/method_of_lines/<a class="el" href="MethodOfLinesIntegrator_8h.html">MethodOfLinesIntegrator.h</a><li>source/algorithm/method_of_lines/<a class="el" href="MethodOfLinesIntegrator_8C.html">MethodOfLinesIntegrator.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:28:20 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
