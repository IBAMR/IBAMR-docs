<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::mesh::TagAndInitializeStrategy&lt; DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>::<a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a></div>
<h1>SAMRAI::mesh::TagAndInitializeStrategy&lt; DIM &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::mesh::TagAndInitializeStrategy" --><code>#include &lt;source/mesh/gridding/TagAndInitializeStrategy.h&gt;</code>
<p>
Inheritance diagram for SAMRAI::mesh::TagAndInitializeStrategy&lt; DIM &gt;:<p><center><img src="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy__inherit__graph.png" border="0" usemap="#SAMRAI_1_1mesh_1_1TagAndInitializeStrategy_3_01DIM_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="SAMRAI_1_1mesh_1_1TagAndInitializeStrategy_3_01DIM_01_4__inherit__map">
<area href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html" shape="rect" coords="7,83,321,107" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#4ed6b174c4c6646374bf0c68d3012d25">TagAndInitializeStrategy</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#e53ba63940196892f2f582562cad7ed0">~TagAndInitializeStrategy</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#e62741640519e4d9427d71554d8c35cc">getUserSuppliedRefineBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;refine_boxes, const int level_number, const double time)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#50ec5aff4cb72b294d6124069dba6d62">resetRefineBoxes</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;refine_boxes, const int level_number)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#6dce6747c72e4884f6d9d976e818b7c1">initializeLevelData</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const int level_number, const double init_data_time, const bool can_be_refined, const bool initial_time, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt; old_level=<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;(NULL), const bool allocate_data=true)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#18bef6d99c4419c34972af4f8f2e68cc">resetHierarchyConfiguration</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const int coarsest_level, const int finest_level)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#773d5cb94bff9c59e75b3c616ea372c1">tagCellsForRefinement</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const int level_number, const double error_data_time, const int tag_index, const bool initial_time, const bool coarsest_sync_level, const bool can_be_refined=true, const double regrid_start_time=0.)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#9ddc0e662b18076cce728796a9550840">preprocessErrorEstimation</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const int level_number, const double regrid_time, const double regrid_start_time, const bool initial_time)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#81b4ba32e0e8ea3e0bfcbc0a4197278f">usesTimeIntegration</a> () const=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#e3207f5258ae7fde42cf0e791f85ed78">coarsestLevelBoxesOK</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;boxes) const=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#7633efaf299fd532bc378aba8f6c5c9d">getErrorCoarsenRatio</a> () const=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#918000cdf7eafc303b2206e8d2627843">checkCoarsenRatios</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &gt; &amp;ratio_to_coarser)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#4086dd00d117f832bb6d942cc5c16c3b">refineUserBoxInputOnly</a> () const=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#62d05f66d2a0fe7357c436ad0f41b1a0">getFromInput</a> (const std::string &amp;object_name, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; db)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class SAMRAI::mesh::TagAndInitializeStrategy&lt; DIM &gt;</h3>

Class TagAndInitializeStrategy&lt;DIM&gt; is a base class that defines a Strategy pattern interface for level initialization and cell tagging routines that are needed by the adaptive meshing algorithms provided by the class GriddingAlgorithm&lt;DIM&gt;. The class maintains functionality to construct refined regions based on a user-supplied set of refine but its main role is to provide interfaces for level initialization and cell tagging operations.<p>
The operations that identify mesh cells for refinement or initialize data on a new hierarchy level are problem-specific and must be supplied by a concrete sub-class of this base class.<p>
If user supplied refine boxes are used, they may be supplied through input. Alternatively, they may be supplied through the "resetRefineBoxes()" method. If they are supplied through input, the format is as follows:<p>
<ul>
<li><b>RefineBoxes</b> input section describing the refine boxes for each level.<ul>
<li><b>level_0</b> input section providing the sequence of <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> arrays describing where user-specified refinement is to occur on Level 0.<ul>
<li><b>times</b> = double array specifying times at which a particular box seqence is to be used.</li><li><b>cycles</b> = integer array specifying regrid cycles at which a particular box seqence is to be used.</li><li><b>boxes_0</b> = box array specifying refine boxes for seq 0.</li><li><b>boxes_1</b> = box array specifying refine boxes for seq 1.</li><li><b>boxes_n</b> = box array specifying refine boxes for seq n.</li></ul>
</li><li><b>level_1</b> input section providing the sequence of <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> arrays describing where user-specified refinement is to occur on Level 1.</li><li><b>level_n</b> input section providing the sequence of <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> arrays describing where user-specified refinement is to occur on Level N.</li></ul>
</li></ul>
<p>
The <b>times</b> and <b>cycles</b> entries are optional. If neither is provided, a uniform set of refine boxes specified in the boxes_0 entry will be used over the entire calculation. If no boxes_0 entry is provided, no refinement will occur on that level.<p>
If both <b>times</b> or <b>cycles</b> entries are supplied, the times entry takes precedence so the cycles entry is ignored. The particular sequence chosen during regridding is determined by a ``greater-than'' convention. That is, if boxes are accessed at regridding time t, where t is greater-than the specified times[n] entry, then sequence n is used. Otherwise, the corresponding previous sequence that satisfies the criteria is used. The same convention is followed for regridding cycles. To avoid errant behavior, the times and cycles entries should always be supplied in increasing order.<p>
The <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a> entries for each sequence n of the level must be of the form ``boxes_n'' (where n is the sequence number) or the input parser will ignore the entry. Refinement will occur only when refinement boxes corresponding to a particular sequence number are specified. Otherwise, no refinement will occur during the sequence on the level.<p>
A sample input file entry might look like:<p>
<div class="fragment"><pre class="fragment">
 *
 *    RefineBoxes {
 *       level_0 {
 *          cycles = 0, 10
 *          boxes_0 = [(5,5),(9,9)],[(12,15),(18,19)]
 *          boxes_1 = [(7,7),(11,11)],[(14,17),(20,21)]
 *       }
 *       level_1 {
 *          times  = 0., 0.05, 0.10
 *          boxes_0 = [(25,30),(29,35)]    
 *          boxes_1 = [(30,35),(34,40)]    
 *          boxes_2 = [(35,40),(39,45)]    
 *       }
 *       level_2 {
 *          boxes_0 = [(60,70),(70,80)]    
 *       }
 *    }
 * </pre></div><p>
The virtual methods in this class may place constraints on the patch hierarchy by the particluar error estimation procedure in use. Those constraints and operations must be honored in the concrete subclass implementations of these methods. The constraints are discussed in the method descriptions below.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="4ed6b174c4c6646374bf0c68d3012d25"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::TagAndInitializeStrategy" ref="4ed6b174c4c6646374bf0c68d3012d25" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">SAMRAI::mesh::TagAndInitializeStrategy</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Empty constructor for TagAndInitializeStrategy&lt;DIM&gt;. 
</div>
</div><p>
<a class="anchor" name="e53ba63940196892f2f582562cad7ed0"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::~TagAndInitializeStrategy" ref="e53ba63940196892f2f582562cad7ed0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">SAMRAI::mesh::TagAndInitializeStrategy</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Empty destructor for TagAndInitializeStrategy&lt;DIM&gt;. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e62741640519e4d9427d71554d8c35cc"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::getUserSuppliedRefineBoxes" ref="e62741640519e4d9427d71554d8c35cc" args="(hier::BoxArray&lt; DIM &gt; &amp;refine_boxes, const int level_number, const double time)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">SAMRAI::mesh::TagAndInitializeStrategy</a>&lt; DIM &gt;::getUserSuppliedRefineBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>refine_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return user supplied set of refine boxes for specified level number and time. The boolean return value specifies whether the boxes have been reset from the last time this method was called. If they have been reset, it returns true. If they are unchanged, it returns false. 
</div>
</div><p>
<a class="anchor" name="50ec5aff4cb72b294d6124069dba6d62"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::resetRefineBoxes" ref="50ec5aff4cb72b294d6124069dba6d62" args="(const hier::BoxArray&lt; DIM &gt; &amp;refine_boxes, const int level_number)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">SAMRAI::mesh::TagAndInitializeStrategy</a>&lt; DIM &gt;::resetRefineBoxes           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>refine_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset the static refine boxes for the specified level number in the hierarchy. The level number must be greater than or equal to zero. 
</div>
</div><p>
<a class="anchor" name="6dce6747c72e4884f6d9d976e818b7c1"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::initializeLevelData" ref="6dce6747c72e4884f6d9d976e818b7c1" args="(const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const int level_number, const double init_data_time, const bool can_be_refined, const bool initial_time, const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; old_level=tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt;(NULL), const bool allocate_data=true)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">SAMRAI::mesh::TagAndInitializeStrategy</a>&lt; DIM &gt;::initializeLevelData           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>init_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>can_be_refined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>old_level</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;&nbsp;<a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;&gt;(NULL)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>allocate_data</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize data on a new level after it is inserted into an AMR patch hierarchy by the gridding algorithm. The level number indicates that of the new level. The old_level pointer corresponds to the level that resided in the hierarchy before the level with the specified number was introduced. If this pointer is null, there was no level in the hierarchy prior to the call and the data on the new level is set by interpolating data from coarser levels in the hierarchy. Otherwise, the the new level is initialized by interpolating data from coarser levels and copying data from the old level before it is destroyed.<p>
The boolean argument initial_time indicates whether the integration time corresponds to the initial simulation time. If true, the level should be initialized with initial simulation values. Otherwise, it should be assumed that the simulation time is at some point after the start of the simulation. This information is provided since the initialization of the data may be different in each of those circumstances. In any case, the double "time" value is the current simulation time for the level. The can_be_refined boolean argument indicates whether the level is the finest allowable level in the hierarchy. This flag is included since data management on the finest level may be different than other levels in the hierarchy in some cases.<p>
The last two (optional) arguments specify an old level from which the data may be used to initialize data on this level, and a flag that indicates whether data on the initialized level must first be allocated. The allocate_data argument is used in cases where one wishes to simply reset data to an initialized state on a level that has already been allocated. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#d449c271e65d3c678df17ecec892c0c4">SAMRAI::mesh::StandardTagAndInitialize&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="18bef6d99c4419c34972af4f8f2e68cc"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::resetHierarchyConfiguration" ref="18bef6d99c4419c34972af4f8f2e68cc" args="(const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const int coarsest_level, const int finest_level)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">SAMRAI::mesh::TagAndInitializeStrategy</a>&lt; DIM &gt;::resetHierarchyConfiguration           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finest_level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
After hierarchy levels have changed and data has been initialized on the new levels, this routine can be used to reset any information needed by the solution method that is particular to the hierarchy configuration. For example, the solution procedure may cache communication schedules to amortize the cost of data movement on the AMR patch hierarchy. This function will be called by the gridding algorithm after the initialization occurs so that the algorithm-specific subclass can reset such things. Also, if the solution method must make the solution consistent across multiple levels after the hierarchy is changed, this process may be invoked by this routine. Of course the details of these processes are determined by the particular solution methods in use.<p>
The level number arguments indicate the coarsest and finest levels in the current hierarchy configuration that have changed. It should be assumed that all intermediate levels have changed as well. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#2fcccc75d30f07ca360564e0ede8c86b">SAMRAI::mesh::StandardTagAndInitialize&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="773d5cb94bff9c59e75b3c616ea372c1"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::tagCellsForRefinement" ref="773d5cb94bff9c59e75b3c616ea372c1" args="(const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const int level_number, const double error_data_time, const int tag_index, const bool initial_time, const bool coarsest_sync_level, const bool can_be_refined=true, const double regrid_start_time=0.)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">SAMRAI::mesh::TagAndInitializeStrategy</a>&lt; DIM &gt;::tagCellsForRefinement           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>coarsest_sync_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>can_be_refined</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_start_time</em> = <code>0.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set integer tags to "one" on the given level to identify where refinement of that level should occur. The index is that of the cell-centered integer tag array on each patch. The boolean argument initial_time indicates whether cells are being tagged at initialization time, or at some later time during the calculation. If it is false, it should be assumed that the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. This information is provided since application of the error estimator may be different in each of those circumstances.<p>
The cell-tagging operation may use time advancement to determine tag regions. The argument coarsest_sync_level provides information for the tagging method to coordinate time advance with an integrator. When time integration is used during regridding, this value is true if the level is the coarsest level involved in level synchronization immediately preceeding the regrid process; otherwise it is false. If time advancement is not used, this argument are ignored.<p>
The boolean can_be_refined is used to coordinate data reset operations with the time integrator when time-dependent regridding is used. This is provided since data may be managed differently on the finest hierarchy level than on coarser levels. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#967a10cce35627ddc1a8bae9497d3166">SAMRAI::mesh::StandardTagAndInitialize&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="9ddc0e662b18076cce728796a9550840"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::preprocessErrorEstimation" ref="9ddc0e662b18076cce728796a9550840" args="(const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const int level_number, const double regrid_time, const double regrid_start_time, const bool initial_time)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">SAMRAI::mesh::TagAndInitializeStrategy</a>&lt; DIM &gt;::preprocessErrorEstimation           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_start_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Certain cases may require pre-processing of error estimation data before tagging cells, which is handled by this method. For example, Richardson extrapolation may require advances of data in time before the error estimation procedure is implemented.<p>
The level number indicates the level in which pre-process steps are applied, time is the time at which the operation is performed (generally the regrid time), and the boolean argument indicates whether the operation is performed at the initial time. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#ece0b079d95f2aa43572b70f168b5e41">SAMRAI::mesh::StandardTagAndInitialize&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="81b4ba32e0e8ea3e0bfcbc0a4197278f"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::usesTimeIntegration" ref="81b4ba32e0e8ea3e0bfcbc0a4197278f" args="() const=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">SAMRAI::mesh::TagAndInitializeStrategy</a>&lt; DIM &gt;::usesTimeIntegration           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if regridding process advances the data using some time integration procedure; otherwise, return false. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#b22cd3f57e97a0f388eb297b50912a62">SAMRAI::mesh::StandardTagAndInitialize&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="e3207f5258ae7fde42cf0e791f85ed78"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::coarsestLevelBoxesOK" ref="e3207f5258ae7fde42cf0e791f85ed78" args="(const hier::BoxArray&lt; DIM &gt; &amp;boxes) const=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">SAMRAI::mesh::TagAndInitializeStrategy</a>&lt; DIM &gt;::coarsestLevelBoxesOK           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if boxes for coarsest hierarchy level are not appropriate for gridding strategy. Otherwise, return false. If false is returned, it is useful to provide a detailed explanatory message describing the problems with the boxes. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#063369e2deba40e4f85cec1590b1ea5b">SAMRAI::mesh::StandardTagAndInitialize&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="7633efaf299fd532bc378aba8f6c5c9d"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::getErrorCoarsenRatio" ref="7633efaf299fd532bc378aba8f6c5c9d" args="() const=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">SAMRAI::mesh::TagAndInitializeStrategy</a>&lt; DIM &gt;::getErrorCoarsenRatio           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return ratio by which level may be coarsened during the error estimation process. Generally, this is needed by the gridding algorithm class so that the new patch levels that it constructs can be coarsened properly (if needed) during the error estimation process. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#c226d6a4b82575fc2a63450292307be1">SAMRAI::mesh::StandardTagAndInitialize&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="918000cdf7eafc303b2206e8d2627843"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::checkCoarsenRatios" ref="918000cdf7eafc303b2206e8d2627843" args="(const tbox::Array&lt; hier::IntVector&lt; DIM &gt; &gt; &amp;ratio_to_coarser)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">SAMRAI::mesh::TagAndInitializeStrategy</a>&lt; DIM &gt;::checkCoarsenRatios           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_coarser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check ratios between hierarchy levels against any constraints that may be required for the error estimation scheme. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#f081cea71978275cf7d7ef8c39857c5a">SAMRAI::mesh::StandardTagAndInitialize&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="4086dd00d117f832bb6d942cc5c16c3b"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::refineUserBoxInputOnly" ref="4086dd00d117f832bb6d942cc5c16c3b" args="() const=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">SAMRAI::mesh::TagAndInitializeStrategy</a>&lt; DIM &gt;::refineUserBoxInputOnly           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether refinement is being performed using ONLY user-supplied refine boxes. If any method is used that invokes tagging, this will return false. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#3d586750a2923ffe47d3ed27a6b24d04">SAMRAI::mesh::StandardTagAndInitialize&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="62d05f66d2a0fe7357c436ad0f41b1a0"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::getFromInput" ref="62d05f66d2a0fe7357c436ad0f41b1a0" args="(const std::string &amp;object_name, tbox::Pointer&lt; tbox::Database &gt; db)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">SAMRAI::mesh::TagAndInitializeStrategy</a>&lt; DIM &gt;::getFromInput           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>db</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read user supplied refine boxes from the provided database. The database must be non-null, or an unrecoverable exception will be thrown. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/mesh/gridding/<a class="el" href="TagAndInitializeStrategy_8h.html">TagAndInitializeStrategy.h</a><li>source/mesh/gridding/<a class="el" href="TagAndInitializeStrategy_8C.html">TagAndInitializeStrategy.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:28:41 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
