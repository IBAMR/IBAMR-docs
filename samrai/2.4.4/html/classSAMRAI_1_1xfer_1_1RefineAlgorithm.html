<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::xfer::RefineAlgorithm&lt; DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1xfer.html">xfer</a>::<a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a></div>
<h1>SAMRAI::xfer::RefineAlgorithm&lt; DIM &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::xfer::RefineAlgorithm" -->Class RefineAlgorithm&lt;DIM&gt; encapsulates the AMR communication pattern to refine data to, copy data to, or fill physical boundary data on any destination patch level. The basic procedure for moving data follows three steps:<ol type=1>
<li>interpolate data (spatial and possibly temporal) from coarser levels</li><li>copy data from the same level of refinement</li><li>fill physical boundary conditions regions. </li></ol>
 
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/transfer/datamovers/standard/RefineAlgorithm.h&gt;</code>
<p>
<a href="classSAMRAI_1_1xfer_1_1RefineAlgorithm-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#22b55cd1b9740ab82f472c1ef74354e9">RefineAlgorithm</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#ca496558267dcaa39b5cda09b9331238">~RefineAlgorithm</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#996d67ca0b591ea40755bb1bf754d9d6">registerRefine</a> (const int dst, const int src, const int scratch, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">RefineOperator</a>&lt; DIM &gt; &gt; oprefine, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a>&lt; DIM &gt; &gt; var_fill_pattern=<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1BoxGeometryFillPattern.html">BoxGeometryFillPattern</a>&lt; DIM &gt; &gt;())</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#25415f4113b009be6a8a252a5505b4ff">registerRefine</a> (const int dst, const int src, const int src_told, const int src_tnew, const int scratch, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">RefineOperator</a>&lt; DIM &gt; &gt; oprefine, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1TimeInterpolateOperator.html">TimeInterpolateOperator</a>&lt; DIM &gt; &gt; optime, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a>&lt; DIM &gt; &gt; var_fill_pattern=<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1BoxGeometryFillPattern.html">BoxGeometryFillPattern</a>&lt; DIM &gt; &gt;())</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#e8b8c234a73ec022fabed39314acbc66">createSchedule</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *)(0)), <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; *)(0))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a communication schedule that moves data from the interiors of the source data components into the interior and boundary cells of the destination data components on the same level where those sources and destinations overlap.  <a href="#e8b8c234a73ec022fabed39314acbc66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#0c182d09cfd5a922809040de23b166b7">createSchedule</a> (const std::string &amp;fill_pattern, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *)(0)), <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; *)(0))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#f43c19270e614c958f83b8d87e9ed64d">createSchedule</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; dst_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; src_level, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; *)(0))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a communication schedule that moves data from the interiors of the source data components on a source level into the interior and boundary cells of the destination data components on a destination level where those sources and destinations overlap.  <a href="#f43c19270e614c958f83b8d87e9ed64d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#307c4220330263d53106ccd5c57ab9db">createSchedule</a> (const std::string &amp;fill_pattern, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; dst_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; src_level, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; *)(0))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#6d6662b51eef6392f243444be1db031b">createSchedule</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level, const int next_coarser_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; *)(0))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a communication schedule that moves data from the interiors of the source data components on the patch level and coarser levels in the patch hierarchy into the interior and boundary cells of the destination data components on the given patch level where those sources and destinations overlap. Data is time interpolated between old and new sources on coarser levels when and where time interpolation is needed and copied from the source components on the patch level into the destination components otherwise.  <a href="#6d6662b51eef6392f243444be1db031b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#fce5e2bf765dee149f6759668d4ed867">createSchedule</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; dst_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; src_level, const int next_coarser_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; *)(0))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a communication schedule that moves data from the interiors of the source data components on the source level and coarser levels in the hierarchy into the interior and boundary cells of the destination data components on the destination level where those sources and destinations overlap. Data is time interpolated between old and new sources on coarser levels when and where time interpolation is needed and from the source data components on the source level into the destination data components otherwise.  <a href="#fce5e2bf765dee149f6759668d4ed867"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#e41fd8380aaefed028233d0e08a57f15">createSchedule</a> (const std::string &amp;fill_pattern, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level, const int next_coarser_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; *)(0))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to the version of createSchedule without the <code>fill_pattern</code> argument.  <a href="#e41fd8380aaefed028233d0e08a57f15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#7e6b00e2dca9ca7ae490178d5325a478">createSchedule</a> (const std::string &amp;fill_pattern, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; dst_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; src_level, const int next_coarser_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; *)(0))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to the version of createSchedule without the <code>fill_pattern</code> argument.  <a href="#7e6b00e2dca9ca7ae490178d5325a478"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#4b0a8e58a915d88924b1c6ed5d032021">checkConsistency</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt; schedule) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a previously-generated refine schedule, check for consistency with this refine algorithm object to see whether a call to <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#bdfec753c30902472e7e2291137aa0d6">resetSchedule()</a> is a valid operation.  <a href="#4b0a8e58a915d88924b1c6ed5d032021"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#bdfec753c30902472e7e2291137aa0d6">resetSchedule</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt; schedule) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a previously-generated refine schedule, reconfigure it to peform the communication operations registered with this refine algorithm object. That is, the schedule will be transformed so that it will funcions as though this refine algorithm created it. Note that the set of operations registered with this refine algorithm must be essentially the same as those registered with the refine algorithm that created the schedule originallyl. That is, the number of operations registered must be the same and the source, destination, scratch patch data items and operators for each operation must have identical characteristics (i.e., data centering, ghost cell widths, stencil requirements, etc.). However, However, the specific source, destination, scratch patch data ids and operators can be different. Detailed and fairly complete error checking is performed when this routine is called to prevent potential errors or unexpected behavior.  <a href="#bdfec753c30902472e7e2291137aa0d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a>&lt;<br>
 DIM &gt; &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#fcb325aa44cd3aec262dcf3ead5236d4">getEquivalenceClasses</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return const reference to the pointer to refine equivalence classes used in algorithm.  <a href="#fcb325aa44cd3aec262dcf3ead5236d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#4ed85f6233c367be9db2759e42bcc0fd">setEquivalenceClasses</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a>&lt; DIM &gt; &gt; refine_classes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the pointer to the refine equivalence classes to be equal to the given argument.  <a href="#4ed85f6233c367be9db2759e42bcc0fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#e596663bcd27d5fa87f8b62222a946a7">printClassData</a> (std::ostream &amp;stream) const </td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class SAMRAI::xfer::RefineAlgorithm&lt; DIM &gt;</h3>

Class RefineAlgorithm&lt;DIM&gt; encapsulates the AMR communication pattern to refine data to, copy data to, or fill physical boundary data on any destination patch level. The basic procedure for moving data follows three steps:<ol type=1>
<li>interpolate data (spatial and possibly temporal) from coarser levels</li><li>copy data from the same level of refinement</li><li>fill physical boundary conditions regions. </li></ol>

<p>
Each data communication procedure generally consists of three parts: an algorithm, a schedule, and a patch strategy. The algorithm describes the patch data components and time and space interpolation operations, but is independent of the configuration of the patches in an AMR hierarchy. Patch data items and their associated spatial and time interpolation operators are registered with an instantiation of this algorithm class. To generate the communication dependencies for a particular patch hierarchy configuration, the algorithm creates a refine schedule based on the state of a given hierarchy and the information in the algorithm. The schedule can then perform the communication operations that move data to the destination patch level using the associated operators. User-defined operations (such as filling physical boundaries and special interpolation procedures) are provided through a refine patch strategy object.<p>
In general, source data is copied into the designated scratch data for temporary processing. The scratch space must contain sufficient ghost cells to accommodate the stencil width of the given interpolation operators and any physical boundary data that must be filled. The scratch storage is copied into the destination data space at the end of the communication process. Thus, copy operations between source, scratch, and destination patch data objects must be defined. In general, it is the user's responsibility to register valid operations with the refine algorithm so that the data communication can occur.<p>
In general, the destination and scratch data components may be the same (assuming that the scratch component has a sufficient ghost cells width). The source and scratch components SHOULD NOT be the same, since the interiors of the source space would be changed by the use of the scratch data as temporary work space.<p>
Note that each refine schedule created by a refine algorithm remains valid as long as the patches involved in the communication process do not change; thus, they can be used for multiple data communication cycles.<p>
Typical usage of a refine algorithm to perform inter-patch communication on an AMR hierarchy involves four steps:<p>
<ol type=1>
<li>Construct a refine algorithm object.</li><li>Register refine operations with the refine algorithm. Using the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#996d67ca0b591ea40755bb1bf754d9d6">registerRefine()</a> methods(s), one provides source and destination patch data information, as well as time and space interpolation operators as needed. Two <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#996d67ca0b591ea40755bb1bf754d9d6">registerRefine()</a> methods appear in this class; one supports time interpolation, one does not.</li><li>After all operations are registered with the algorithm, one creates a communication schedule using one of the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#e8b8c234a73ec022fabed39314acbc66">createSchedule()</a> methods. These methods are distinguished by the resulting data communication pattern (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., interpatch communication on a single level, between two different levels at the same grid resolution, interpolation of data between different AMR hierarchy levels, etc.) Note that when creating a communication schedule, a concrete instance of a RefinePatchStrategy&lt;DIM&gt; object may be required to supply physical boundary conditions as well as user-defined spatial data interpolation operations.</li><li>Invoke the fillData() method in the communication schedule to perform the data transfers.</li></ol>
<p>
User-defined interpolation operations can be written using the interfaces in <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> for preprocessRefine() and postProcessRefine(). Users who use create these operations must note that all data that is to be used in such operations should be registered with the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a> using <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#996d67ca0b591ea40755bb1bf754d9d6">registerRefine()</a>, whether or not the data is to be refined.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a> <p>
<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a> <p>
<a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">xfer::RefineClasses</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="22b55cd1b9740ab82f472c1ef74354e9"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::RefineAlgorithm" ref="22b55cd1b9740ab82f472c1ef74354e9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a refinement algorithm and initialize its basic state. Note that refinement operations must be registered with this algorithm before it can do anything useful. See the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#996d67ca0b591ea40755bb1bf754d9d6">registerRefine()</a> routines for details. 
</div>
</div><p>
<a class="anchor" name="ca496558267dcaa39b5cda09b9331238"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::~RefineAlgorithm" ref="ca496558267dcaa39b5cda09b9331238" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The virtual destructor for the algorithm releases all internal storage. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="996d67ca0b591ea40755bb1bf754d9d6"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::registerRefine" ref="996d67ca0b591ea40755bb1bf754d9d6" args="(const int dst, const int src, const int scratch, tbox::Pointer&lt; RefineOperator&lt; DIM &gt; &gt; oprefine, tbox::Pointer&lt; VariableFillPattern&lt; DIM &gt; &gt; var_fill_pattern=tbox::Pointer&lt; BoxGeometryFillPattern&lt; DIM &gt; &gt;())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::registerRefine           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">RefineOperator</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>oprefine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>var_fill_pattern</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;&nbsp;<a class="el" href="classSAMRAI_1_1xfer_1_1BoxGeometryFillPattern.html">BoxGeometryFillPattern</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a refine operation with the refine algorithm object. This routine does not support time interpolation. Data values will be moved from the source component to the destination component using scratch component as a temporary work space. The scratch component must have sufficient ghost cells to cover the required operator stencil width and any needed physical boundary ghost cells.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Integer destination patch data index to be filled on the destination level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Integer source patch data index on the source level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scratch</em>&nbsp;</td><td>Integer patch data index used as a temporary work space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oprefine</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refinement operator. This may be a null pointer. In this case, refinement must be handled by the refine patch strategy member functions. See the comments for <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#4e647ae59b0d7b45ac8e3e3072f69912">RefinePatchStrategy&lt;DIM&gt;::preprocessRefine()</a> and <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a8630858c8464794242a469bbcd48672">RefinePatchStrategy&lt;DIM&gt;::postprocessRefine()</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="25415f4113b009be6a8a252a5505b4ff"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::registerRefine" ref="25415f4113b009be6a8a252a5505b4ff" args="(const int dst, const int src, const int src_told, const int src_tnew, const int scratch, tbox::Pointer&lt; RefineOperator&lt; DIM &gt; &gt; oprefine, tbox::Pointer&lt; TimeInterpolateOperator&lt; DIM &gt; &gt; optime, tbox::Pointer&lt; VariableFillPattern&lt; DIM &gt; &gt; var_fill_pattern=tbox::Pointer&lt; BoxGeometryFillPattern&lt; DIM &gt; &gt;())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::registerRefine           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>src_told</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>src_tnew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">RefineOperator</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>oprefine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1TimeInterpolateOperator.html">TimeInterpolateOperator</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>optime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>var_fill_pattern</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;&nbsp;<a class="el" href="classSAMRAI_1_1xfer_1_1BoxGeometryFillPattern.html">BoxGeometryFillPattern</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a refine operation with the refine algorithm object. This routine supports time interpolation. Time interpolation will take place between the old and new source data components on coarser levels. On the destination level, data will be moved from the source component to the destination component using scratch component as a temporary work space. The scratch component must have sufficient ghost cells to cover the required operator stencil width and any needed physical boundary ghost cells. The time interpolation operator cannot be null. When assertion checking is active, passing in a null pointer will result in an unrecoverable exception.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Integer destination patch data index to be filled on the destination level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Integer source patch data index on the source level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_told</em>&nbsp;</td><td>Integer source patch data index for old data used in time interpolation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_tnew</em>&nbsp;</td><td>Integer source patch data index for new data used in time interpolation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scratch</em>&nbsp;</td><td>Integer patch data index used as a temporary work space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oprefine</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refinement operator. This may be a null pointer. In this case, refinement must be handled by the refine patch strategy member functions. See the comments for <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#4e647ae59b0d7b45ac8e3e3072f69912">RefinePatchStrategy&lt;DIM&gt;::preprocessRefine()</a> and <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a8630858c8464794242a469bbcd48672">RefinePatchStrategy&lt;DIM&gt;::postprocessRefine()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optime</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to time interpolation operator. This pointer may not be null. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e8b8c234a73ec022fabed39314acbc66"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::createSchedule" ref="e8b8c234a73ec022fabed39314acbc66" args="(tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; level, xfer::RefinePatchStrategy&lt; DIM &gt; *patch_strategy=((xfer::RefinePatchStrategy&lt; DIM &gt; *)(0)), tbox::Pointer&lt; xfer::RefineTransactionFactory&lt; DIM &gt; &gt; transaction_factory=(xfer::RefineTransactionFactory&lt; DIM &gt; *)(0))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::createSchedule           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a communication schedule that moves data from the interiors of the source data components into the interior and boundary cells of the destination data components on the same level where those sources and destinations overlap. 
<p>
Neither time nor spatial interpolation is performed.<p>
Note that the schedule remains valid as long as the patches on the level do not change; thus, it can be used for multiple data communication cycles.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refine schedule that performs the data transfers.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to level on which interpatch transfers occur. This pointer cannot be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine patch strategy that provides user-defined physical boundary filling operations. If this patch strategy is null (default state), then no physical boundary filling is performed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html">StandardRefineTransactionFactory</a> object will be used. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0c182d09cfd5a922809040de23b166b7"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::createSchedule" ref="0c182d09cfd5a922809040de23b166b7" args="(const std::string &amp;fill_pattern, tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; level, xfer::RefinePatchStrategy&lt; DIM &gt; *patch_strategy=((xfer::RefinePatchStrategy&lt; DIM &gt; *)(0)), tbox::Pointer&lt; xfer::RefineTransactionFactory&lt; DIM &gt; &gt; transaction_factory=(xfer::RefineTransactionFactory&lt; DIM &gt; *)(0))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::createSchedule           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>fill_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f43c19270e614c958f83b8d87e9ed64d"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::createSchedule" ref="f43c19270e614c958f83b8d87e9ed64d" args="(tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; dst_level, tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; src_level, xfer::RefinePatchStrategy&lt; DIM &gt; *patch_strategy=((xfer::RefinePatchStrategy&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, tbox::Pointer&lt; xfer::RefineTransactionFactory&lt; DIM &gt; &gt; transaction_factory=(xfer::RefineTransactionFactory&lt; DIM &gt; *)(0))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::createSchedule           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a communication schedule that moves data from the interiors of the source data components on a source level into the interior and boundary cells of the destination data components on a destination level where those sources and destinations overlap. 
<p>
Note that both levels must reside in the same AMR hierarchy index space, or in index spaces that represent the same level of mesh refinement. No spatial interpolation is performed.<p>
In certain rare cases it may be desired to use this schedule to perform time interpolation, in which case the use_time_interpolation optional argument should be set to true.<p>
Note that the schedule remains valid as long as the patches on the levels do not change; thus, it can be used for multiple data communication cycles.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refine schedule that performs the data transfers.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst_level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to destination level; cannot be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to source level; cannot be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine patch strategy that provides user-defined physical boundary filling operations. If this patch strategy is null (default state), then no physical boundary filling is performed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_time_interpolation</em>&nbsp;</td><td>Optional boolean flag to create the schedule with the ability to perform time interpolation. Default is no time interpolation (false). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html">StandardRefineTransactionFactory</a> object will be used. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="307c4220330263d53106ccd5c57ab9db"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::createSchedule" ref="307c4220330263d53106ccd5c57ab9db" args="(const std::string &amp;fill_pattern, tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; dst_level, tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; src_level, xfer::RefinePatchStrategy&lt; DIM &gt; *patch_strategy=((xfer::RefinePatchStrategy&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, tbox::Pointer&lt; xfer::RefineTransactionFactory&lt; DIM &gt; &gt; transaction_factory=(xfer::RefineTransactionFactory&lt; DIM &gt; *)(0))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::createSchedule           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>fill_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6d6662b51eef6392f243444be1db031b"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::createSchedule" ref="6d6662b51eef6392f243444be1db031b" args="(tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; level, const int next_coarser_level, tbox::Pointer&lt; hier::PatchHierarchy&lt; DIM &gt; &gt; hierarchy, xfer::RefinePatchStrategy&lt; DIM &gt; *patch_strategy=((xfer::RefinePatchStrategy&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, tbox::Pointer&lt; xfer::RefineTransactionFactory&lt; DIM &gt; &gt; transaction_factory=(xfer::RefineTransactionFactory&lt; DIM &gt; *)(0))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::createSchedule           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>next_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a communication schedule that moves data from the interiors of the source data components on the patch level and coarser levels in the patch hierarchy into the interior and boundary cells of the destination data components on the given patch level where those sources and destinations overlap. Data is time interpolated between old and new sources on coarser levels when and where time interpolation is needed and copied from the source components on the patch level into the destination components otherwise. 
<p>
In certain rare cases in may be necessary to perform time interpolation between old and new sources on the given patch level. In this case the optional argument use_time_interpolation should be set to true. Regardless of the value of this argument, time interpolation on coarser levels will always occur whenever needed.<p>
Note that the next coarser level number must correspond to a level in the hierarchy that represents a region of coarser index space than the destination level.<p>
Note that the schedule remains valid as long as the patches on the levels involved in its creation do not change; thus, it can be used for multiple data communication cycles.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refine schedule that performs the data transfers.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to destination level; cannot be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>next_coarser_level</em>&nbsp;</td><td>Integer number of next coarser patch level in the patch hierarchy relative to the destination level. Note that when the destination level has number zero (i.e., the coarsest level), this value should be &lt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to patch hierarchy from which data to fill level should come. This pointer may be null only when the next_coarser_level is &lt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine patch strategy that provides user-defined physical boundary filling operations and user-defined spatial interpolation operations. If this patch strategy is null (default state), then no physical boundary filling or user-defined interpolation is performed. Note that this may cause problems since interpolation of data from coarser levels to some finer level may require physical boundary data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_time_interpolation</em>&nbsp;</td><td>Optional boolean flag to create the schedule with the ability to perform time interpolation Default is no time interpolation (false). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html">StandardRefineTransactionFactory</a> object will be used. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fce5e2bf765dee149f6759668d4ed867"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::createSchedule" ref="fce5e2bf765dee149f6759668d4ed867" args="(tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; dst_level, tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; src_level, const int next_coarser_level, tbox::Pointer&lt; hier::PatchHierarchy&lt; DIM &gt; &gt; hierarchy, xfer::RefinePatchStrategy&lt; DIM &gt; *patch_strategy=((xfer::RefinePatchStrategy&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, tbox::Pointer&lt; xfer::RefineTransactionFactory&lt; DIM &gt; &gt; transaction_factory=(xfer::RefineTransactionFactory&lt; DIM &gt; *)(0))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::createSchedule           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>next_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a communication schedule that moves data from the interiors of the source data components on the source level and coarser levels in the hierarchy into the interior and boundary cells of the destination data components on the destination level where those sources and destinations overlap. Data is time interpolated between old and new sources on coarser levels when and where time interpolation is needed and from the source data components on the source level into the destination data components otherwise. 
<p>
This form of schedule construction is typically used after regridding (where the source level is the patch level being replaced by the destination level in the patch hierarchy) or when the data on destination patch level is to be overwritten by data interpolated from coarser levels in the patch hierarchy. In the first case, data on the destination level will be copied from the source level in regions where those two levels overlap and filled with interpolated values from the hierarchy elsewhere. In the latter case, the source level pointer may be null. Then, data on the destination level will be filled using interpolated data from coarser hierarchy levels.<p>
In certain cases it may be necessary to perform time interpolation between old and new sources onto the destination level. In this case the optional argument use_time_interpolation should be set to true. Regardless of the value of this argument, time interpolation on coarser levels will always occur whenever needed.<p>
Note that when the source level pointer is non-null, the index spaces of the source and destination levels must be aligned with one another.<p>
Note that the schedule remains valid as long as the patches on the levels involved in its creation do not change; thus, it can be used for multiple data communication cycles.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refine schedule that performs the data transfers.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst_level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to destination level; cannot be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to source level. This pointer may be null. In this case, data on the destination level will be filled only using interpolated data from coarser hierarchy levels. When this pointer is not null, the source level must live in the same AMR hierarchy index space as the destination level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>next_coarser_level</em>&nbsp;</td><td>Integer number of next coarser patch level in a patch hierarchy relative to the destination level. Note that when the destination level has number zero (i.e., the coarsest level), this value should be &lt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to patch hierarchy from which data to fill level should come. This pointer may be null only when the next_coarser_level is &lt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine patch strategy that provides user-defined physical boundary filling operations and user-defined spatial interpolation operations. If this patch strategy is null (default state), then no physical boundary filling or user-defined interpolation is performed. Note that this may cause problems since interpolation of data from coarser levels to some finer level may require physical boundary data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_time_interpolation</em>&nbsp;</td><td>Optional boolean flag to create the schedule with the ability to perform time interpolation Default is no time interpolation (false). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html">StandardRefineTransactionFactory</a> object will be used. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e41fd8380aaefed028233d0e08a57f15"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::createSchedule" ref="e41fd8380aaefed028233d0e08a57f15" args="(const std::string &amp;fill_pattern, tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; level, const int next_coarser_level, tbox::Pointer&lt; hier::PatchHierarchy&lt; DIM &gt; &gt; hierarchy, xfer::RefinePatchStrategy&lt; DIM &gt; *patch_strategy=((xfer::RefinePatchStrategy&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, tbox::Pointer&lt; xfer::RefineTransactionFactory&lt; DIM &gt; &gt; transaction_factory=(xfer::RefineTransactionFactory&lt; DIM &gt; *)(0))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::createSchedule           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>fill_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>next_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to the version of createSchedule without the <code>fill_pattern</code> argument. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fill_pattern</em>&nbsp;</td><td>Indicates which parts of the destination level to fill. See <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> for valid values.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to destination level; cannot be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>next_coarser_level</em>&nbsp;</td><td>Integer number of next coarser patch level in a patch hierarchy relative to the destination level. Note that when the destination level has number zero (i.e., the coarsest level), this value should be &lt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to patch hierarchy from which data to fill level should come. This pointer may be null only when the next_coarser_level is &lt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine patch strategy that provides user-defined physical boundary filling operations and user-defined spatial interpolation operations. If this patch strategy is null (default state), then no physical boundary filling or user-defined interpolation is performed. Note that this may cause problems since interpolation of data from coarser levels to some finer level may require physical boundary data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_time_interpolation</em>&nbsp;</td><td>Optional boolean flag to create the schedule with the ability to perform time interpolation Default is no time interpolation (false). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html">StandardRefineTransactionFactory</a> object will be used. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7e6b00e2dca9ca7ae490178d5325a478"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::createSchedule" ref="7e6b00e2dca9ca7ae490178d5325a478" args="(const std::string &amp;fill_pattern, tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; dst_level, tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; src_level, const int next_coarser_level, tbox::Pointer&lt; hier::PatchHierarchy&lt; DIM &gt; &gt; hierarchy, xfer::RefinePatchStrategy&lt; DIM &gt; *patch_strategy=((xfer::RefinePatchStrategy&lt; DIM &gt; *)(0)), bool use_time_interpolation=false, tbox::Pointer&lt; xfer::RefineTransactionFactory&lt; DIM &gt; &gt; transaction_factory=(xfer::RefineTransactionFactory&lt; DIM &gt; *)(0))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::createSchedule           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>fill_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>next_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt;&nbsp;DIM&nbsp;&gt;&nbsp;*)(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to the version of createSchedule without the <code>fill_pattern</code> argument. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fill_pattern</em>&nbsp;</td><td>Indicates which parts of the destination level to fill. See <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> for valid values.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to destination level; cannot be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to source level. This pointer may be null. In this case, data on the destination level will be filled only using interpolated data from coarser hierarchy levels. When this pointer is not null, the source level must live in the same AMR hierarchy index space as the destination level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>next_coarser_level</em>&nbsp;</td><td>Integer number of next coarser patch level in a patch hierarchy relative to the destination level. Note that when the destination level has number zero (i.e., the coarsest level), this value should be &lt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to patch hierarchy from which data to fill level should come. This pointer may be null only when the next_coarser_level is &lt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine patch strategy that provides user-defined physical boundary filling operations and user-defined spatial interpolation operations. If this patch strategy is null (default state), then no physical boundary filling or user-defined interpolation is performed. Note that this may cause problems since interpolation of data from coarser levels to some finer level may require physical boundary data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_time_interpolation</em>&nbsp;</td><td>Optional boolean flag to create the schedule with the ability to perform time interpolation Default is no time interpolation (false). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html">StandardRefineTransactionFactory</a> object will be used. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4b0a8e58a915d88924b1c6ed5d032021"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::checkConsistency" ref="4b0a8e58a915d88924b1c6ed5d032021" args="(tbox::Pointer&lt; xfer::RefineSchedule&lt; DIM &gt; &gt; schedule) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::checkConsistency           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>schedule</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a previously-generated refine schedule, check for consistency with this refine algorithm object to see whether a call to <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#bdfec753c30902472e7e2291137aa0d6">resetSchedule()</a> is a valid operation. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Boolean true if schedule reset is valid; false otherwise.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>schedule</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refine schedule, which cannot be null. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bdfec753c30902472e7e2291137aa0d6"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::resetSchedule" ref="bdfec753c30902472e7e2291137aa0d6" args="(tbox::Pointer&lt; xfer::RefineSchedule&lt; DIM &gt; &gt; schedule) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::resetSchedule           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>schedule</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a previously-generated refine schedule, reconfigure it to peform the communication operations registered with this refine algorithm object. That is, the schedule will be transformed so that it will funcions as though this refine algorithm created it. Note that the set of operations registered with this refine algorithm must be essentially the same as those registered with the refine algorithm that created the schedule originallyl. That is, the number of operations registered must be the same and the source, destination, scratch patch data items and operators for each operation must have identical characteristics (i.e., data centering, ghost cell widths, stencil requirements, etc.). However, However, the specific source, destination, scratch patch data ids and operators can be different. Detailed and fairly complete error checking is performed when this routine is called to prevent potential errors or unexpected behavior. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>schedule</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refine schedule, which cannot be null. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fcb325aa44cd3aec262dcf3ead5236d4"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::getEquivalenceClasses" ref="fcb325aa44cd3aec262dcf3ead5236d4" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">xfer::RefineClasses</a>&lt; DIM &gt; &gt; &amp; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::getEquivalenceClasses           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return const reference to the pointer to refine equivalence classes used in algorithm. 
<p>

</div>
</div><p>
<a class="anchor" name="4ed85f6233c367be9db2759e42bcc0fd"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::setEquivalenceClasses" ref="4ed85f6233c367be9db2759e42bcc0fd" args="(const tbox::Pointer&lt; RefineClasses&lt; DIM &gt; &gt; refine_classes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::setEquivalenceClasses           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>refine_classes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the pointer to the refine equivalence classes to be equal to the given argument. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>refine_classes</em>&nbsp;</td><td>A pointer to refine equivalence classes </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e596663bcd27d5fa87f8b62222a946a7"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::printClassData" ref="e596663bcd27d5fa87f8b62222a946a7" args="(std::ostream &amp;stream) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::printClassData           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the refine algorithm state to the specified data stream.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Output data stream. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/transfer/datamovers/standard/<a class="el" href="RefineAlgorithm_8h.html">RefineAlgorithm.h</a><li>source/transfer/datamovers/standard/<a class="el" href="RefineAlgorithm_8C.html">RefineAlgorithm.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:29:10 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
