<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::mesh::LoadBalanceStrategy&lt; DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>::<a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a></div>
<h1>SAMRAI::mesh::LoadBalanceStrategy&lt; DIM &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::mesh::LoadBalanceStrategy" -->Class LoadBalanceStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface for operations that load balance patches on a single AMR patch hierarchy level. Typically, such operations are invoked after the domain of a new hierarchy level is determined (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., via some error estimation procedure) and is applied to the collection of boxes that describe the domain. The load balancing process produces a set of boxes from which patches on the new level are created and a processor mapping describing how the new patches are mapped to processors.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/mesh/load_balance/LoadBalanceStrategy.h&gt;</code>
<p>
Inheritance diagram for SAMRAI::mesh::LoadBalanceStrategy&lt; DIM &gt;:<p><center><img src="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy__inherit__graph.png" border="0" usemap="#SAMRAI_1_1mesh_1_1LoadBalanceStrategy_3_01DIM_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="SAMRAI_1_1mesh_1_1LoadBalanceStrategy_3_01DIM_01_4__inherit__map">
<area href="classSAMRAI_1_1mesh_1_1LoadBalancer.html" shape="rect" coords="29,83,280,107" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#686404c665a7116098904ee836d8b033">LoadBalanceStrategy</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#3c3397a4ca5962b9fe16723b4b5dc5d9">~LoadBalanceStrategy</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#950b4d7674b5de98175f1f3fa5ef62e2">getLoadBalanceDependsOnPatchData</a> (int level_number) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#937d37fc96bba1ec1a3c943a72787b0a">loadBalanceBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;out_boxes, <a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;mapping, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;in_boxes, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const int level_number, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;physical_domain, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ratio_to_hierarchy_level_zero, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;max_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;cut_factor, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;bad_interval) const =0</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class SAMRAI::mesh::LoadBalanceStrategy&lt; DIM &gt;</h3>

Class LoadBalanceStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface for operations that load balance patches on a single AMR patch hierarchy level. Typically, such operations are invoked after the domain of a new hierarchy level is determined (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., via some error estimation procedure) and is applied to the collection of boxes that describe the domain. The load balancing process produces a set of boxes from which patches on the new level are created and a processor mapping describing how the new patches are mapped to processors. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> <p>
<a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="686404c665a7116098904ee836d8b033"></a><!-- doxytag: member="SAMRAI::mesh::LoadBalanceStrategy::LoadBalanceStrategy" ref="686404c665a7116098904ee836d8b033" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">SAMRAI::mesh::LoadBalanceStrategy</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct load balance strategy object. 
</div>
</div><p>
<a class="anchor" name="3c3397a4ca5962b9fe16723b4b5dc5d9"></a><!-- doxytag: member="SAMRAI::mesh::LoadBalanceStrategy::~LoadBalanceStrategy" ref="3c3397a4ca5962b9fe16723b4b5dc5d9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">SAMRAI::mesh::LoadBalanceStrategy</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This virtual destructor does nothing interesting. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="950b4d7674b5de98175f1f3fa5ef62e2"></a><!-- doxytag: member="SAMRAI::mesh::LoadBalanceStrategy::getLoadBalanceDependsOnPatchData" ref="950b4d7674b5de98175f1f3fa5ef62e2" args="(int level_number) const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">SAMRAI::mesh::LoadBalanceStrategy</a>&lt; DIM &gt;::getLoadBalanceDependsOnPatchData           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicate whether load balancing procedure for given level depends on patch data on mesh. This can be used to determine whether a level needs to be rebalanced although its box configuration is unchanged.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Boolean value of true if load balance routines for level depend on patch data; false otherwise.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level_number</em>&nbsp;</td><td>Integer level number. </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalancer.html#0137e70df7e18703b38fe3385ab29cab">SAMRAI::mesh::LoadBalancer&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="937d37fc96bba1ec1a3c943a72787b0a"></a><!-- doxytag: member="SAMRAI::mesh::LoadBalanceStrategy::loadBalanceBoxes" ref="937d37fc96bba1ec1a3c943a72787b0a" args="(hier::BoxArray&lt; DIM &gt; &amp;out_boxes, hier::ProcessorMapping &amp;mapping, const hier::BoxList&lt; DIM &gt; &amp;in_boxes, const tbox::Pointer&lt; hier::PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const int level_number, const hier::BoxArray&lt; DIM &gt; &amp;physical_domain, const hier::IntVector&lt; DIM &gt; &amp;ratio_to_hierarchy_level_zero, const hier::IntVector&lt; DIM &gt; &amp;min_size, const hier::IntVector&lt; DIM &gt; &amp;max_size, const hier::IntVector&lt; DIM &gt; &amp;cut_factor, const hier::IntVector&lt; DIM &gt; &amp;bad_interval) const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">SAMRAI::mesh::LoadBalanceStrategy</a>&lt; DIM &gt;::loadBalanceBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>in_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>physical_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_hierarchy_level_zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a list of boxes, the union of which represents the domain of a specified level in the AMR hierarchy, generate an array of boxes and an associated processor mapping from which the patches for the level may be generated. This process typically involves chopping each box in the original list that is "too large" (in a manner defined by the concrete implementation of this subclass) into a set of boxes each smaller than some size. Thus, the union of the boxes in the generated box array is the same as that of the original box list. A variety of constraints must be applied typically during the chopping process. These input arguments are described here.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out_boxes</em>&nbsp;</td><td>Output box array for generating patches on level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mapping</em>&nbsp;</td><td>Output processor mapping for patches on level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>in_boxes</em>&nbsp;</td><td>Input box list representing union of patches on level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>Input patch hierarchy in which level will reside. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_number</em>&nbsp;</td><td>Input integer number of level in patch hierarchy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>physical_domain</em>&nbsp;</td><td>Input box array representing physical extent of the problem domain in the index space of the level to be load balanced. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ratio_to_hierarchy_level_zero</em>&nbsp;</td><td>Input <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> indicating ratio between index space of level and coarsest hierarchy level (i.e., level zero). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_size</em>&nbsp;</td><td>Input <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> representing mimimum box size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_size</em>&nbsp;</td><td>Input <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> representing maximum box size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cut_factor</em>&nbsp;</td><td>Input <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> indicating factor for chopping each side of a box; i.e., after chopping a box, the number of cells along each direction of each piece must be an integer multiple of the corresponding entry in the cut factor vector. For example, the cut factor may be related to the coarsen ratio between levels in the hierarchy in which case it may be used to produce boxes that can be coarsened by a certain factor if needed. See hier::BoxUtilities&lt;DIM&gt; header file for more information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bad_interval</em>&nbsp;</td><td>Input <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> indicating the length of an interval of cells along each side of the box where chopping the box may produce boxes with certain "bad" properties. For example, this is primiarily used to avoid generating ghost regions for patches that intersect the domain boundary in ways that may it difficult for a use to provide boundary values. Thus, it is typically related to the maximum ghost cell width in the problem. See hier::BoxUtilities&lt;DIM&gt; header file for more information. </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalancer.html#c3c5032f828636d20153c0e441a6f2d1">SAMRAI::mesh::LoadBalancer&lt; DIM &gt;</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/mesh/load_balance/<a class="el" href="LoadBalanceStrategy_8h.html">LoadBalanceStrategy.h</a><li>source/mesh/load_balance/<a class="el" href="LoadBalanceStrategy_8C.html">LoadBalanceStrategy.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:28:41 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
