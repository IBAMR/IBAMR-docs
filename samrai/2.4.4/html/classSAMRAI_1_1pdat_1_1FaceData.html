<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::pdat::FaceData&lt; DIM, TYPE &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1pdat.html">pdat</a>::<a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">FaceData</a></div>
<h1>SAMRAI::pdat::FaceData&lt; DIM, TYPE &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::pdat::FaceData" --><!-- doxytag: inherits="SAMRAI::hier::PatchData" -->Class FaceData&lt;DIM&gt; provides an implementation for data defined at cell faces on AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, a face data object represents data of some template TYPE and depth on the faces of the cells in the box. Here, depth indicates the number of data values at each face index location. The <a class="el" href="classSAMRAI_1_1pdat_1_1FaceGeometry.html">FaceGeometry</a> class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and face-centered data.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/patchdata/face/FaceData.h&gt;</code>
<p>
Inheritance diagram for SAMRAI::pdat::FaceData&lt; DIM, TYPE &gt;:<p><center><img src="classSAMRAI_1_1pdat_1_1FaceData__inherit__graph.png" border="0" usemap="#SAMRAI_1_1pdat_1_1FaceData_3_01DIM_00_01TYPE_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="SAMRAI_1_1pdat_1_1FaceData_3_01DIM_00_01TYPE_01_4__inherit__map">
<area href="classSAMRAI_1_1hier_1_1PatchData.html" shape="rect" coords="28,8,247,32" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classSAMRAI_1_1pdat_1_1FaceData-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1pdat_1_1FaceIterator.html">FaceIterator</a>&lt; DIM &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#232a2fac1784fab46f885563f7c523c8">Iterator</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#c5c2e0626a21b0bac0f9df2ef76017d0">FaceData</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box, int <a class="el" href="algs__nodeouternodeops3d_8f.html#9caca90cc65f72a7168924922fa5d34e">depth</a>, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ghosts, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Arena.html">tbox::Arena</a> &gt; pool=<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Arena.html">tbox::Arena</a> &gt;((0)))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The constructor for a face data object.  <a href="#c5c2e0626a21b0bac0f9df2ef76017d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#d526cda5b8bff92117f3ae2aed1b28df">~FaceData</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The virtual destructor for a face data object.  <a href="#d526cda5b8bff92117f3ae2aed1b28df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#776251f4aecd385c57307e56481db7b7">getDepth</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the depth (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., the number of components in each spatial location) of the array.  <a href="#776251f4aecd385c57307e56481db7b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#c40ccd0d7809e68e97d9556e4a2b7932">getPointer</a> (int face_normal, int <a class="el" href="algs__nodeouternodeops3d_8f.html#9caca90cc65f72a7168924922fa5d34e">depth</a>=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to the beginning of a particular face normal and depth component of the face centered array.  <a href="#c40ccd0d7809e68e97d9556e4a2b7932"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#40c453c88ff516a66c6154d507a8f8ca">getPointer</a> (int face_normal, int <a class="el" href="algs__nodeouternodeops3d_8f.html#9caca90cc65f72a7168924922fa5d34e">depth</a>=0) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a const pointer to the beginning of a particular face normal and depth component of the face centered array.  <a href="#40c453c88ff516a66c6154d507a8f8ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#b73a36d2fccc461938a62e6fad47cdb0">operator()</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1FaceIndex.html">FaceIndex</a>&lt; DIM &gt; &amp;i, int <a class="el" href="algs__nodeouternodeops3d_8f.html#9caca90cc65f72a7168924922fa5d34e">depth</a>=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a reference to the data entry corresponding to a given face index and depth.  <a href="#b73a36d2fccc461938a62e6fad47cdb0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#7501ac6e6f91bb4039875a4f1b6348ab">operator()</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1FaceIndex.html">FaceIndex</a>&lt; DIM &gt; &amp;i, int <a class="el" href="algs__nodeouternodeops3d_8f.html#9caca90cc65f72a7168924922fa5d34e">depth</a>=0) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const reference to the data entry corresponding to a given face index and depth.  <a href="#7501ac6e6f91bb4039875a4f1b6348ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; DIM, TYPE &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#d399ed4b064e142a935bfc15f1ad54b9">getArrayData</a> (int face_normal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a reference to the array data object for the given face normal of the face centered data object.  <a href="#d399ed4b064e142a935bfc15f1ad54b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; DIM, TYPE &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#8baa9f2296f9807bf7ad524860e18183">getArrayData</a> (int face_normal) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const reference to the array data object for the given face normal of the face centered data object.  <a href="#8baa9f2296f9807bf7ad524860e18183"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#a1d9e3b6039f5f67222724e6467aa35f">copy</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a>&lt; DIM &gt; &amp;src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A fast copy from source to destination (i.e., this) patch data object.  <a href="#a1d9e3b6039f5f67222724e6467aa35f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#decdbc7e3d0e873feb2e282fd7596c19">copy2</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a>&lt; DIM &gt; &amp;dst) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A fast copy from source (i.e., this) to destination patch data object.  <a href="#decdbc7e3d0e873feb2e282fd7596c19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#97119ac81d50132414cd44427aa1d426">copy</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a>&lt; DIM &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a>&lt; DIM &gt; &amp;overlap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy data from source to destination (i.e., this) patch data object on the given overlap.  <a href="#97119ac81d50132414cd44427aa1d426"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#6f380d3424723087322063c5e038cff4">copy2</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a>&lt; DIM &gt; &amp;dst, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a>&lt; DIM &gt; &amp;overlap) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy data from source (i.e., this) to destination patch data object on the given overlap.  <a href="#6f380d3424723087322063c5e038cff4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#a4a2e52691703505170c05dd0c2efcfc">copyOnBox</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">FaceData</a>&lt; DIM, TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy data from source to destination (i.e., this) patch data object on the given CELL-centered AMR index box.  <a href="#a4a2e52691703505170c05dd0c2efcfc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#7d95ff80d4c96b51ff3e1b27d8802c85">copyDepth</a> (int dst_depth, const <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">FaceData</a>&lt; DIM, TYPE &gt; &amp;src, int src_depth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast copy (i.e., source and this face data objects are defined over the same box) to this destination face data object from the given source face data object at the specified depths.  <a href="#7d95ff80d4c96b51ff3e1b27d8802c85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#bd4d4e293a274e6f20395ceeab94fb65">canEstimateStreamSizeFromBox</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if the patch data object can estimate the stream size required to fit its data using only index space information (i.e., a box).  <a href="#bd4d4e293a274e6f20395ceeab94fb65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#6be5c861b2c4abebf5dfddcac669b57e">getDataStreamSize</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a>&lt; DIM &gt; &amp;overlap) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of bytes needed to stream the data in this patch data object lying in the specified box overlap region.  <a href="#6be5c861b2c4abebf5dfddcac669b57e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#f45fc4b671de83f1b84b613169340961">packStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1AbstractStream.html">tbox::AbstractStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a>&lt; DIM &gt; &amp;overlap) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack data in this patch data object lying in the specified box overlap region into the stream. The overlap must be an <a class="el" href="classSAMRAI_1_1pdat_1_1FaceOverlap.html">FaceOverlap</a> of the same DIM.  <a href="#f45fc4b671de83f1b84b613169340961"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#869f3e721f64ed3a35ebbd0b34ccea8f">unpackStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1AbstractStream.html">tbox::AbstractStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a>&lt; DIM &gt; &amp;overlap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack data from stream into this patch data object over the specified box overlap region. The overlap must be an <a class="el" href="classSAMRAI_1_1pdat_1_1FaceOverlap.html">FaceOverlap</a> of the same DIM.  <a href="#869f3e721f64ed3a35ebbd0b34ccea8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#98f29205a1ee41739f7a3adb9df98c65">fill</a> (const TYPE &amp;t, int d=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill all values at depth d with the value t.  <a href="#98f29205a1ee41739f7a3adb9df98c65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#01b76c2c1fb86a14ec22349e2de69c7f">fill</a> (const TYPE &amp;t, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box, int d=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill all values at depth d within the box with the value t.  <a href="#01b76c2c1fb86a14ec22349e2de69c7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#f290c5d818589bb7d53ea7585bb17347">fillAll</a> (const TYPE &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill all depth components with value t.  <a href="#f290c5d818589bb7d53ea7585bb17347"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#5e8dbbc46c640a0b5f4a1ee01e4179be">fillAll</a> (const TYPE &amp;t, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill all depth components within the box with value t.  <a href="#5e8dbbc46c640a0b5f4a1ee01e4179be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#80f78fcfc94ebb1b5022219a1c1ebdc9">print</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box, std::ostream &amp;os=<a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a>, int prec=12) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print all face data values residing in the specified box. If the depth of the array is greater than one, all depths are printed.  <a href="#80f78fcfc94ebb1b5022219a1c1ebdc9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#e57ff617d1876a93356f2d89182ae133">print</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box, int <a class="el" href="algs__nodeouternodeops3d_8f.html#9caca90cc65f72a7168924922fa5d34e">depth</a>, std::ostream &amp;os=<a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a>, int prec=12) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print all face data values at the given array depth in the specified box.  <a href="#e57ff617d1876a93356f2d89182ae133"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#b6ac62c749fe7ba67f7e3208fb4f4bb2">printAxis</a> (int face_normal, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box, std::ostream &amp;os=<a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a>, int prec=12) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print all face centered data values for specified face normal direction residing in the specified box. If the depth of the data is greater than one, all depths are printed.  <a href="#b6ac62c749fe7ba67f7e3208fb4f4bb2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#31d33e2746c6bc1678784ba41bb270cb">printAxis</a> (int face_normal, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box, int <a class="el" href="algs__nodeouternodeops3d_8f.html#9caca90cc65f72a7168924922fa5d34e">depth</a>, std::ostream &amp;os=<a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a>, int prec=12) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print all face centered data values for specified face normal direction residing in the specified box. If the depth of the data is greater than one, all depths are printed.  <a href="#31d33e2746c6bc1678784ba41bb270cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#dea6378fe60509cb8dc1c9b37e9dfc47">getSpecializedFromDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; database)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#02052838b5c0ece28fc75ca99ceb6515">putSpecializedToDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; database)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html#b1ce30a9be0056a22d690ca250362531">getSizeOfData</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box, int <a class="el" href="algs__nodeouternodeops3d_8f.html#9caca90cc65f72a7168924922fa5d34e">depth</a>, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ghosts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the amount of memory needed to represent face- centered data over a CELL-centered AMR index space box.  <a href="#b1ce30a9be0056a22d690ca250362531"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM, class TYPE&gt;<br>
 class SAMRAI::pdat::FaceData&lt; DIM, TYPE &gt;</h3>

Class FaceData&lt;DIM&gt; provides an implementation for data defined at cell faces on AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, a face data object represents data of some template TYPE and depth on the faces of the cells in the box. Here, depth indicates the number of data values at each face index location. The <a class="el" href="classSAMRAI_1_1pdat_1_1FaceGeometry.html">FaceGeometry</a> class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and face-centered data. 
<p>
Face data is stored in DIM arrays, each of which contains the data for the faces normal to a corresponding coordinate direction. In addition, the array indices are permuted so that the fastest array dimension is the same as the normal direction of the face. Memory allocation is in column-major ordering (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., Fortran style) so that the leftmost index runs fastest in memory. For example, a three-dimensional face data object created over a CELL-centered AMR index space [l0:u0,l1:u1,l2:u2] allocates three data arrays dimensioned as follows: <div class="fragment"><pre class="fragment">
 
   face normal 0 
     [ l0 : u0+1 ,
       l1 : u1 ,
       l2 : u2 , d ]   ,
 
   face normal 1 
     [ l1 : u1+1 ,
       l2 : u2 ,
       l0 : u0 , d ]   ,
 
   face normal 2 
     [ l2 : u2+1 ,
       l0 : u0 ,
       l1 : u1 , d ]   ,
       
 * </pre></div> Here the face normal directions 0, 1, 2 can be thought of as the x, y, and z face normal directions, respectively, and d is the depth index (i.e., number of values at each face index location). Other spatial dimensions are represented similarly.<p>
The data type TYPE must define a default constructor (that takes no arguments) and also the assignment operator.<p>
IMPORTANT: The SideData&lt;DIM&gt; class provides the same storage as this face data class, except that the coordinate directions of the individual arrays are not permuted.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a> <p>
<a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> <p>
<a class="el" href="classSAMRAI_1_1pdat_1_1FaceDataFactory.html">pdat::FaceDataFactory</a> <p>
<a class="el" href="classSAMRAI_1_1pdat_1_1FaceIndex.html">pdat::FaceIndex</a> <p>
<a class="el" href="classSAMRAI_1_1pdat_1_1FaceIterator.html">pdat::FaceIterator</a> <p>
<a class="el" href="classSAMRAI_1_1pdat_1_1FaceGeometry.html">pdat::FaceGeometry</a> </dd></dl>

<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="232a2fac1784fab46f885563f7c523c8"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::Iterator" ref="232a2fac1784fab46f885563f7c523c8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1pdat_1_1FaceIterator.html">FaceIterator</a>&lt;DIM&gt; <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::<a class="el" href="classSAMRAI_1_1pdat_1_1FaceIterator.html">Iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The face iterator iterates over the elements on one face normal of a face centered box geometry. This typedef is a convenience for using the FaceIterator&lt;DIM&gt; class. 
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="c5c2e0626a21b0bac0f9df2ef76017d0"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::FaceData" ref="c5c2e0626a21b0bac0f9df2ef76017d0" args="(const hier::Box&lt; DIM &gt; &amp;box, int depth, const hier::IntVector&lt; DIM &gt; &amp;ghosts, tbox::Pointer&lt; tbox::Arena &gt; pool=tbox::Pointer&lt; tbox::Arena &gt;((0)))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::<a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">FaceData</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Arena.html">tbox::Arena</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>pool</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;&nbsp;<a class="el" href="classSAMRAI_1_1tbox_1_1Arena.html">tbox::Arena</a>&nbsp;&gt;((0))</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The constructor for a face data object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>const Box reference describing the interior of the standard CELL-centered index box over which the face data object will be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>gives the number of components for each spatial location in the array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>const IntVector reference indicating the width of the ghost cell region around the box over which the face data will be allocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>memory arena. If not given, then the standard arena is used. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d526cda5b8bff92117f3ae2aed1b28df"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::~FaceData" ref="d526cda5b8bff92117f3ae2aed1b28df" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::~<a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">FaceData</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The virtual destructor for a face data object. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="b1ce30a9be0056a22d690ca250362531"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::getSizeOfData" ref="b1ce30a9be0056a22d690ca250362531" args="(const hier::Box&lt; DIM &gt; &amp;box, int depth, const hier::IntVector&lt; DIM &gt; &amp;ghosts)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::getSizeOfData           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ghosts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the amount of memory needed to represent face- centered data over a CELL-centered AMR index space box. 
<p>
This function assumes that the amount of memory needed for TYPE is sizeof(TYPE). If this is not the case, then a specialized function must be defined.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>const Box reference describing the interior of the standard CELL-centered index box over which the face data object will be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>gives the number of components for each spatial location in the array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>const IntVector reference indicating the width of the ghost cell region around the box over which the face data will be allocated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="776251f4aecd385c57307e56481db7b7"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::getDepth" ref="776251f4aecd385c57307e56481db7b7" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::getDepth           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the depth (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#34cb3de4879ab966bef34a9678efd968">e.g</a>., the number of components in each spatial location) of the array. 
<p>

</div>
</div><p>
<a class="anchor" name="c40ccd0d7809e68e97d9556e4a2b7932"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::getPointer" ref="c40ccd0d7809e68e97d9556e4a2b7932" args="(int face_normal, int depth=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE * <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::getPointer           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>face_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a pointer to the beginning of a particular face normal and depth component of the face centered array. 
<p>

</div>
</div><p>
<a class="anchor" name="40c453c88ff516a66c6154d507a8f8ca"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::getPointer" ref="40c453c88ff516a66c6154d507a8f8ca" args="(int face_normal, int depth=0) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const TYPE * <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::getPointer           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>face_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a const pointer to the beginning of a particular face normal and depth component of the face centered array. 
<p>

</div>
</div><p>
<a class="anchor" name="b73a36d2fccc461938a62e6fad47cdb0"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::operator()" ref="b73a36d2fccc461938a62e6fad47cdb0" args="(const FaceIndex&lt; DIM &gt; &amp;i, int depth=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1FaceIndex.html">FaceIndex</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a reference to the data entry corresponding to a given face index and depth. 
<p>

</div>
</div><p>
<a class="anchor" name="7501ac6e6f91bb4039875a4f1b6348ab"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::operator()" ref="7501ac6e6f91bb4039875a4f1b6348ab" args="(const FaceIndex&lt; DIM &gt; &amp;i, int depth=0) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const TYPE &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1FaceIndex.html">FaceIndex</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a const reference to the data entry corresponding to a given face index and depth. 
<p>

</div>
</div><p>
<a class="anchor" name="d399ed4b064e142a935bfc15f1ad54b9"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::getArrayData" ref="d399ed4b064e142a935bfc15f1ad54b9" args="(int face_normal)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; DIM, TYPE &gt; &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::getArrayData           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>face_normal</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a reference to the array data object for the given face normal of the face centered data object. 
<p>

</div>
</div><p>
<a class="anchor" name="8baa9f2296f9807bf7ad524860e18183"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::getArrayData" ref="8baa9f2296f9807bf7ad524860e18183" args="(int face_normal) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; DIM, TYPE &gt; &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::getArrayData           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>face_normal</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a const reference to the array data object for the given face normal of the face centered data object. 
<p>

</div>
</div><p>
<a class="anchor" name="a1d9e3b6039f5f67222724e6467aa35f"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::copy" ref="a1d9e3b6039f5f67222724e6467aa35f" args="(const hier::PatchData&lt; DIM &gt; &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::copy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A fast copy from source to destination (i.e., this) patch data object. 
<p>
Data is copied where there is overlap in the underlying index space. The copy is performed on the interior plus the ghost cell width (for both the source and destination). Currently, source data must be an <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">FaceData</a> of the same DIM and TYPE. If not, then an unrecoverable error results. 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#823c8ae468be74a350a8a250827302e4">SAMRAI::hier::PatchData&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="decdbc7e3d0e873feb2e282fd7596c19"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::copy2" ref="decdbc7e3d0e873feb2e282fd7596c19" args="(hier::PatchData&lt; DIM &gt; &amp;dst) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::copy2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A fast copy from source (i.e., this) to destination patch data object. 
<p>
Data is copied where there is overlap in the underlying index space. The copy is performed on the interior plus the ghost cell width (for both the source and destination). Currently, destination data must be an <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">FaceData</a> of the same DIM and TYPE. If not, then an unrecoverable error results. 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#601e0a27be4cd1360ccee18fb539994a">SAMRAI::hier::PatchData&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="97119ac81d50132414cd44427aa1d426"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::copy" ref="97119ac81d50132414cd44427aa1d426" args="(const hier::PatchData&lt; DIM &gt; &amp;src, const hier::BoxOverlap&lt; DIM &gt; &amp;overlap)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::copy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy data from source to destination (i.e., this) patch data object on the given overlap. 
<p>
Currently, source data must be <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">FaceData</a> of the same DIM and TYPE and the overlap must be a <a class="el" href="classSAMRAI_1_1pdat_1_1FaceOverlap.html">FaceOverlap</a> of the same DIM. If not, then an unrecoverable error results. 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#78e7f77fc4f90463a107323de8b187b7">SAMRAI::hier::PatchData&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="6f380d3424723087322063c5e038cff4"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::copy2" ref="6f380d3424723087322063c5e038cff4" args="(hier::PatchData&lt; DIM &gt; &amp;dst, const hier::BoxOverlap&lt; DIM &gt; &amp;overlap) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::copy2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy data from source (i.e., this) to destination patch data object on the given overlap. 
<p>
Currently, destination data must be <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">FaceData</a> of the same DIM and TYPE and the overlap must be a <a class="el" href="classSAMRAI_1_1pdat_1_1FaceOverlap.html">FaceOverlap</a> of the same DIM. If not, then an unrecoverable error results. 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#6fc9799b0f6b2a0336a359e496eb93de">SAMRAI::hier::PatchData&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="a4a2e52691703505170c05dd0c2efcfc"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::copyOnBox" ref="a4a2e52691703505170c05dd0c2efcfc" args="(const FaceData&lt; DIM, TYPE &gt; &amp;src, const hier::Box&lt; DIM &gt; &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::copyOnBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">FaceData</a>&lt; DIM, TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy data from source to destination (i.e., this) patch data object on the given CELL-centered AMR index box. 
<p>

</div>
</div><p>
<a class="anchor" name="7d95ff80d4c96b51ff3e1b27d8802c85"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::copyDepth" ref="7d95ff80d4c96b51ff3e1b27d8802c85" args="(int dst_depth, const FaceData&lt; DIM, TYPE &gt; &amp;src, int src_depth)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::copyDepth           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dst_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">FaceData</a>&lt; DIM, TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fast copy (i.e., source and this face data objects are defined over the same box) to this destination face data object from the given source face data object at the specified depths. 
<p>

</div>
</div><p>
<a class="anchor" name="bd4d4e293a274e6f20395ceeab94fb65"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::canEstimateStreamSizeFromBox" ref="bd4d4e293a274e6f20395ceeab94fb65" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::canEstimateStreamSizeFromBox           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if the patch data object can estimate the stream size required to fit its data using only index space information (i.e., a box). 
<p>
This routine is defined for the standard types (bool, char, double, float, int, and dcomplex). 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#cc1d54b101ae88823ee55352b4b68587">SAMRAI::hier::PatchData&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="6be5c861b2c4abebf5dfddcac669b57e"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::getDataStreamSize" ref="6be5c861b2c4abebf5dfddcac669b57e" args="(const hier::BoxOverlap&lt; DIM &gt; &amp;overlap) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::getDataStreamSize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of bytes needed to stream the data in this patch data object lying in the specified box overlap region. 
<p>
This routine is defined for the standard types (bool, char, double, float, int, and dcomplex). 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#024dc1052a1c0ec25f6ad22e310fa432">SAMRAI::hier::PatchData&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="f45fc4b671de83f1b84b613169340961"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::packStream" ref="f45fc4b671de83f1b84b613169340961" args="(tbox::AbstractStream &amp;stream, const hier::BoxOverlap&lt; DIM &gt; &amp;overlap) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::packStream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1AbstractStream.html">tbox::AbstractStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pack data in this patch data object lying in the specified box overlap region into the stream. The overlap must be an <a class="el" href="classSAMRAI_1_1pdat_1_1FaceOverlap.html">FaceOverlap</a> of the same DIM. 
<p>

<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#3c7251d7a0005072db2c4e5b84744d12">SAMRAI::hier::PatchData&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="869f3e721f64ed3a35ebbd0b34ccea8f"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::unpackStream" ref="869f3e721f64ed3a35ebbd0b34ccea8f" args="(tbox::AbstractStream &amp;stream, const hier::BoxOverlap&lt; DIM &gt; &amp;overlap)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::unpackStream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1AbstractStream.html">tbox::AbstractStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unpack data from stream into this patch data object over the specified box overlap region. The overlap must be an <a class="el" href="classSAMRAI_1_1pdat_1_1FaceOverlap.html">FaceOverlap</a> of the same DIM. 
<p>

<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#fc4b24aaa56c7bad5e54b62a55d06ca5">SAMRAI::hier::PatchData&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="98f29205a1ee41739f7a3adb9df98c65"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::fill" ref="98f29205a1ee41739f7a3adb9df98c65" args="(const TYPE &amp;t, int d=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::fill           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill all values at depth d with the value t. 
<p>

</div>
</div><p>
<a class="anchor" name="01b76c2c1fb86a14ec22349e2de69c7f"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::fill" ref="01b76c2c1fb86a14ec22349e2de69c7f" args="(const TYPE &amp;t, const hier::Box&lt; DIM &gt; &amp;box, int d=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::fill           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill all values at depth d within the box with the value t. 
<p>

</div>
</div><p>
<a class="anchor" name="f290c5d818589bb7d53ea7585bb17347"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::fillAll" ref="f290c5d818589bb7d53ea7585bb17347" args="(const TYPE &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::fillAll           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill all depth components with value t. 
<p>

</div>
</div><p>
<a class="anchor" name="5e8dbbc46c640a0b5f4a1ee01e4179be"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::fillAll" ref="5e8dbbc46c640a0b5f4a1ee01e4179be" args="(const TYPE &amp;t, const hier::Box&lt; DIM &gt; &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::fillAll           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill all depth components within the box with value t. 
<p>

</div>
</div><p>
<a class="anchor" name="80f78fcfc94ebb1b5022219a1c1ebdc9"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::print" ref="80f78fcfc94ebb1b5022219a1c1ebdc9" args="(const hier::Box&lt; DIM &gt; &amp;box, std::ostream &amp;os=tbox::plog, int prec=12) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::print           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prec</em> = <code>12</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print all face data values residing in the specified box. If the depth of the array is greater than one, all depths are printed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>const reference to box over whioch to print data. Note box is assumed to reside in standard cell-centered index space and will be converted to face index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>reference to output stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prec</em>&nbsp;</td><td>integer precision for printing floating point numbers (i.e., TYPE = float, double, or dcomplex). The default is 12 decimal places for double and complex floating point numbers, and the default is 6 decimal places floats. For other types, this value is ignored. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e57ff617d1876a93356f2d89182ae133"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::print" ref="e57ff617d1876a93356f2d89182ae133" args="(const hier::Box&lt; DIM &gt; &amp;box, int depth, std::ostream &amp;os=tbox::plog, int prec=12) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::print           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prec</em> = <code>12</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print all face data values at the given array depth in the specified box. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>const reference to box over whioch to print data. Note box is assumed to reside in standard cell-centered index space and will be converted to face index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>integer depth component, must satisfy 0 &lt;= depth &lt; actual depth of data array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>reference to output stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prec</em>&nbsp;</td><td>integer precision for printing floating point numbers (i.e., TYPE = float, double, or dcomplex). The default is 12 decimal places for double and complex floating point numbers, and the default is 6 decimal places floats. For other types, this value is ignored. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b6ac62c749fe7ba67f7e3208fb4f4bb2"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::printAxis" ref="b6ac62c749fe7ba67f7e3208fb4f4bb2" args="(int face_normal, const hier::Box&lt; DIM &gt; &amp;box, std::ostream &amp;os=tbox::plog, int prec=12) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::printAxis           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>face_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prec</em> = <code>12</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print all face centered data values for specified face normal direction residing in the specified box. If the depth of the data is greater than one, all depths are printed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>face_normal</em>&nbsp;</td><td>integer face normal coordinate direction, must satisfy 0 &lt;= face_normal &lt; DIM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>const reference to box over whioch to print data. Note box is assumed to reside in standard cell-centered index space and will be converted to face index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>reference to output stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prec</em>&nbsp;</td><td>integer precision for printing floating point numbers (i.e., TYPE = float, double, or dcomplex). The default is 12 decimal places for double and complex floating point numbers, and the default is 6 decimal places floats. For other types, this value is ignored. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="31d33e2746c6bc1678784ba41bb270cb"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::printAxis" ref="31d33e2746c6bc1678784ba41bb270cb" args="(int face_normal, const hier::Box&lt; DIM &gt; &amp;box, int depth, std::ostream &amp;os=tbox::plog, int prec=12) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::printAxis           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>face_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prec</em> = <code>12</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print all face centered data values for specified face normal direction residing in the specified box. If the depth of the data is greater than one, all depths are printed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>face_normal</em>&nbsp;</td><td>integer face normal coordinate direction, must satisfy 0 &lt;= face_normal &lt; DIM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>const reference to box over whioch to print data. Note box is assumed to reside in standard cell-centered index space and will be converted to face index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>integer depth component, must satisfy 0 &lt;= depth &lt; actual depth of data array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>reference to output stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prec</em>&nbsp;</td><td>integer precision for printing floating point numbers (i.e., TYPE = float, double, or dcomplex). The default is 12 decimal places for double and complex floating point numbers, and the default is 6 decimal places floats. For other types, this value is ignored. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dea6378fe60509cb8dc1c9b37e9dfc47"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::getSpecializedFromDatabase" ref="dea6378fe60509cb8dc1c9b37e9dfc47" args="(tbox::Pointer&lt; tbox::Database &gt; database)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::getSpecializedFromDatabase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>database</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that class version and restart file version are equal. If so, read data members from the database.<p>
Assertions: database must be non-null pointer. 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#2e4d8e089567cdcb76dd18da491eaa87">SAMRAI::hier::PatchData&lt; DIM &gt;</a>.
</div>
</div><p>
<a class="anchor" name="02052838b5c0ece28fc75ca99ceb6515"></a><!-- doxytag: member="SAMRAI::pdat::FaceData::putSpecializedToDatabase" ref="02052838b5c0ece28fc75ca99ceb6515" args="(tbox::Pointer&lt; tbox::Database &gt; database)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData</a>&lt; DIM, TYPE &gt;::putSpecializedToDatabase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>database</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write out the class version number and other data members to the database.<p>
Assertions: database must be non-null pointer. 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#3473c4d3a9c85fcb9068113b50e0deab">SAMRAI::hier::PatchData&lt; DIM &gt;</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/patchdata/face/<a class="el" href="FaceData_8h.html">FaceData.h</a><li>source/patchdata/face/<a class="el" href="FaceData_8C.html">FaceData.C</a><li>source/patchdata/face/<a class="el" href="FaceData_8I.html">FaceData.I</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 18 11:28:45 2009 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
