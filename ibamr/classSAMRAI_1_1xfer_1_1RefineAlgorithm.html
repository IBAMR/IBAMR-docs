<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: SAMRAI::xfer::RefineAlgorithm&lt; DIM &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IBAMR
   &#160;<span id="projectnumber">IBAMR version 0.18.</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a></li><li class="navelem"><a class="el" href="namespaceSAMRAI_1_1xfer.html">xfer</a></li><li class="navelem"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSAMRAI_1_1xfer_1_1RefineAlgorithm-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SAMRAI::xfer::RefineAlgorithm&lt; DIM &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class RefineAlgorithm&lt;DIM&gt; encapsulates the AMR communication pattern to refine data to, copy data to, or fill physical boundary data on any destination patch level. The basic procedure for moving data follows three steps:  
 <a href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#details">More...</a></p>

<p><code>#include &lt;ibamr/IBStrategy.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SAMRAI::xfer::RefineAlgorithm&lt; DIM &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSAMRAI_1_1xfer_1_1RefineAlgorithm__inherit__graph.png" border="0" usemap="#SAMRAI_1_1xfer_1_1RefineAlgorithm_3_01DIM_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="SAMRAI_1_1xfer_1_1RefineAlgorithm_3_01DIM_01_4_inherit__map" id="SAMRAI_1_1xfer_1_1RefineAlgorithm_3_01DIM_01_4_inherit__map">
<area shape="rect" title="Class RefineAlgorithm&lt;DIM&gt; encapsulates the AMR communication pattern to refine data to,..." alt="" coords="5,81,227,123"/>
<area shape="rect" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html" title=" " alt="" coords="5,185,227,227"/>
<area shape="rect" href="classSAMRAI_1_1tbox_1_1DescribedClass.html" title="Base class for all objects that use run&#45;time type identification (RTTI)." alt="" coords="7,5,225,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a22b55cd1b9740ab82f472c1ef74354e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a22b55cd1b9740ab82f472c1ef74354e9">RefineAlgorithm</a> ()</td></tr>
<tr class="separator:a22b55cd1b9740ab82f472c1ef74354e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d7a6c859545a718ea44d2694da0559"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a90d7a6c859545a718ea44d2694da0559">~RefineAlgorithm</a> ()</td></tr>
<tr class="separator:a90d7a6c859545a718ea44d2694da0559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996d67ca0b591ea40755bb1bf754d9d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a996d67ca0b591ea40755bb1bf754d9d6">registerRefine</a> (const <a class="el" href="classint.html">int</a> dst, const <a class="el" href="classint.html">int</a> src, const <a class="el" href="classint.html">int</a> scratch, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">RefineOperator</a>&lt; DIM &gt; &gt; oprefine, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a>&lt; DIM &gt; &gt; var_fill_pattern=<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1BoxGeometryFillPattern.html">BoxGeometryFillPattern</a>&lt; DIM &gt; &gt;())</td></tr>
<tr class="separator:a996d67ca0b591ea40755bb1bf754d9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25415f4113b009be6a8a252a5505b4ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a25415f4113b009be6a8a252a5505b4ff">registerRefine</a> (const <a class="el" href="classint.html">int</a> dst, const <a class="el" href="classint.html">int</a> src, const <a class="el" href="classint.html">int</a> src_told, const <a class="el" href="classint.html">int</a> src_tnew, const <a class="el" href="classint.html">int</a> scratch, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">RefineOperator</a>&lt; DIM &gt; &gt; oprefine, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1TimeInterpolateOperator.html">TimeInterpolateOperator</a>&lt; DIM &gt; &gt; optime, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a>&lt; DIM &gt; &gt; var_fill_pattern=<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1BoxGeometryFillPattern.html">BoxGeometryFillPattern</a>&lt; DIM &gt; &gt;())</td></tr>
<tr class="separator:a25415f4113b009be6a8a252a5505b4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff3b3edcbc0b5d309b4fbf28e788f16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#afff3b3edcbc0b5d309b4fbf28e788f16">createSchedule</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *) NULL), <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; *) NULL)</td></tr>
<tr class="memdesc:afff3b3edcbc0b5d309b4fbf28e788f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a communication schedule that moves data from the interiors of the source data components into the interior and boundary cells of the destination data components on the same level where those sources and destinations overlap. <br  />
  <a href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#afff3b3edcbc0b5d309b4fbf28e788f16">More...</a><br /></td></tr>
<tr class="separator:afff3b3edcbc0b5d309b4fbf28e788f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4bb0404f653db3cb267c6353a9769a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a4f4bb0404f653db3cb267c6353a9769a">createSchedule</a> (const std::string &amp;fill_pattern, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *) NULL), <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; *) NULL)</td></tr>
<tr class="separator:a4f4bb0404f653db3cb267c6353a9769a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a7bf751519c022e0b4da1c455d17bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a16a7bf751519c022e0b4da1c455d17bc">createSchedule</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; dst_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; src_level, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *) NULL), <a class="el" href="classbool.html">bool</a> use_time_interpolation=false, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; *) NULL)</td></tr>
<tr class="memdesc:a16a7bf751519c022e0b4da1c455d17bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a communication schedule that moves data from the interiors of the source data components on a source level into the interior and boundary cells of the destination data components on a destination level where those sources and destinations overlap. <br  />
  <a href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a16a7bf751519c022e0b4da1c455d17bc">More...</a><br /></td></tr>
<tr class="separator:a16a7bf751519c022e0b4da1c455d17bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7167dfdfd57de2957096c500f493f83d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a7167dfdfd57de2957096c500f493f83d">createSchedule</a> (const std::string &amp;fill_pattern, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; dst_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; src_level, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *) NULL), <a class="el" href="classbool.html">bool</a> use_time_interpolation=false, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; *) NULL)</td></tr>
<tr class="separator:a7167dfdfd57de2957096c500f493f83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9262287f6dd2502c2ab4ded7101fa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a0d9262287f6dd2502c2ab4ded7101fa5">createSchedule</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level, const <a class="el" href="classint.html">int</a> next_coarser_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *) NULL), <a class="el" href="classbool.html">bool</a> use_time_interpolation=false, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; *) NULL)</td></tr>
<tr class="memdesc:a0d9262287f6dd2502c2ab4ded7101fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a communication schedule that moves data from the interiors of the source data components on the patch level and coarser levels in the patch hierarchy into the interior and boundary cells of the destination data components on the given patch level where those sources and destinations overlap. <br  />
 Data is time interpolated between old and new sources on coarser levels when and where time interpolation is needed and copied from the source components on the patch level into the destination components otherwise.  <a href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a0d9262287f6dd2502c2ab4ded7101fa5">More...</a><br /></td></tr>
<tr class="separator:a0d9262287f6dd2502c2ab4ded7101fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2f46d65dad69e7c5624fe293655c63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#aaf2f46d65dad69e7c5624fe293655c63">createSchedule</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; dst_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; src_level, const <a class="el" href="classint.html">int</a> next_coarser_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *) NULL), <a class="el" href="classbool.html">bool</a> use_time_interpolation=false, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; *) NULL)</td></tr>
<tr class="memdesc:aaf2f46d65dad69e7c5624fe293655c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a communication schedule that moves data from the interiors of the source data components on the source level and coarser levels in the hierarchy into the interior and boundary cells of the destination data components on the destination level where those sources and destinations overlap. Data is time interpolated between old and new sources on coarser levels when and where time interpolation is needed and from the source data components on the source level into the destination data components otherwise.  <a href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#aaf2f46d65dad69e7c5624fe293655c63">More...</a><br /></td></tr>
<tr class="separator:aaf2f46d65dad69e7c5624fe293655c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d2f2c95bafe2dd8ef3450af057e2b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a14d2f2c95bafe2dd8ef3450af057e2b0">createSchedule</a> (const std::string &amp;fill_pattern, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level, const <a class="el" href="classint.html">int</a> next_coarser_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *) NULL), <a class="el" href="classbool.html">bool</a> use_time_interpolation=false, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; *) NULL)</td></tr>
<tr class="memdesc:a14d2f2c95bafe2dd8ef3450af057e2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the version of createSchedule without the <code>fill_pattern</code> argument.  <a href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a14d2f2c95bafe2dd8ef3450af057e2b0">More...</a><br /></td></tr>
<tr class="separator:a14d2f2c95bafe2dd8ef3450af057e2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f40be92f2919bee257fb0384d1c1f2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a5f40be92f2919bee257fb0384d1c1f2f">createSchedule</a> (const std::string &amp;fill_pattern, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; dst_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; src_level, const <a class="el" href="classint.html">int</a> next_coarser_level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *patch_strategy=((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *) NULL), <a class="el" href="classbool.html">bool</a> use_time_interpolation=false, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt; transaction_factory=(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; *) NULL)</td></tr>
<tr class="memdesc:a5f40be92f2919bee257fb0384d1c1f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the version of createSchedule without the <code>fill_pattern</code> argument.  <a href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a5f40be92f2919bee257fb0384d1c1f2f">More...</a><br /></td></tr>
<tr class="separator:a5f40be92f2919bee257fb0384d1c1f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782956e016ea00c8db0163614e0df6b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a782956e016ea00c8db0163614e0df6b9">checkConsistency</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt; schedule) const</td></tr>
<tr class="memdesc:a782956e016ea00c8db0163614e0df6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a previously-generated refine schedule, check for consistency with this refine algorithm object to see whether a call to <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a329e0c11a240d468ce7d447c73487037" title="Given a previously-generated refine schedule, reconfigure it to peform the communication operations r...">resetSchedule()</a> is a valid operation.  <a href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a782956e016ea00c8db0163614e0df6b9">More...</a><br /></td></tr>
<tr class="separator:a782956e016ea00c8db0163614e0df6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329e0c11a240d468ce7d447c73487037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a329e0c11a240d468ce7d447c73487037">resetSchedule</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt; schedule) const</td></tr>
<tr class="memdesc:a329e0c11a240d468ce7d447c73487037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a previously-generated refine schedule, reconfigure it to peform the communication operations registered with this refine algorithm object. That is, the schedule will be transformed so that it will funcions as though this refine algorithm created it. Note that the set of operations registered with this refine algorithm must be essentially the same as those registered with the refine algorithm that created the schedule originallyl. That is, the number of operations registered must be the same and the source, destination, scratch patch data items and operators for each operation must have identical characteristics (i.e., data centering, ghost cell widths, stencil requirements, etc.). However, However, the specific source, destination, scratch patch data ids and operators can be different. Detailed and fairly complete error checking is performed when this routine is called to prevent potential errors or unexpected behavior.  <a href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a329e0c11a240d468ce7d447c73487037">More...</a><br /></td></tr>
<tr class="separator:a329e0c11a240d468ce7d447c73487037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfc0d5edec99adff57293aa37ec11d1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a>&lt; DIM &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#accfc0d5edec99adff57293aa37ec11d1">getEquivalenceClasses</a> () const</td></tr>
<tr class="memdesc:accfc0d5edec99adff57293aa37ec11d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const reference to the pointer to refine equivalence classes used in algorithm.  <a href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#accfc0d5edec99adff57293aa37ec11d1">More...</a><br /></td></tr>
<tr class="separator:accfc0d5edec99adff57293aa37ec11d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed85f6233c367be9db2759e42bcc0fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a4ed85f6233c367be9db2759e42bcc0fd">setEquivalenceClasses</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a>&lt; DIM &gt; &gt; refine_classes)</td></tr>
<tr class="memdesc:a4ed85f6233c367be9db2759e42bcc0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the pointer to the refine equivalence classes to be equal to the given argument.  <a href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a4ed85f6233c367be9db2759e42bcc0fd">More...</a><br /></td></tr>
<tr class="separator:a4ed85f6233c367be9db2759e42bcc0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae634ce47dafbe7d7ab376b55df78c72e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#ae634ce47dafbe7d7ab376b55df78c72e">printClassData</a> (std::ostream &amp;stream) const</td></tr>
<tr class="separator:ae634ce47dafbe7d7ab376b55df78c72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:af5064fc7de664630bec21f053fa0c86b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#af5064fc7de664630bec21f053fa0c86b">RefineAlgorithm</a> (const <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a>&lt; DIM &gt; &amp;)</td></tr>
<tr class="separator:af5064fc7de664630bec21f053fa0c86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d13183af2fd9a964bb3252bc6ba0d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#ac3d13183af2fd9a964bb3252bc6ba0d1">operator=</a> (const <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a>&lt; DIM &gt; &amp;)</td></tr>
<tr class="separator:ac3d13183af2fd9a964bb3252bc6ba0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a9585c2e7556387066901d76069150b08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a>&lt; DIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a9585c2e7556387066901d76069150b08">d_refine_classes</a></td></tr>
<tr class="separator:a9585c2e7556387066901d76069150b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a63fcfee2b8a19d59cf2b971e601108"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a8a63fcfee2b8a19d59cf2b971e601108">d_schedule_created</a></td></tr>
<tr class="separator:a8a63fcfee2b8a19d59cf2b971e601108"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int DIM&gt;<br />
class SAMRAI::xfer::RefineAlgorithm&lt; DIM &gt;</h3>

<ol type="1">
<li>interpolate data (spatial and possibly temporal) from coarser levels</li>
<li>copy data from the same level of refinement</li>
<li>fill physical boundary conditions regions</li>
</ol>
<p>Each data communication procedure generally consists of three parts: an algorithm, a schedule, and a patch strategy. The algorithm describes the patch data components and time and space interpolation operations, but is independent of the configuration of the patches in an AMR hierarchy. <br  />
 Patch data items and their associated spatial and time interpolation operators are registered with an instantiation of this algorithm class. <br  />
 To generate the communication dependencies for a particular patch hierarchy configuration, the algorithm creates a refine schedule based on the state of a given hierarchy and the information in the algorithm. The schedule can then perform the communication operations that move data to the destination patch level using the associated operators. User-defined operations (such as filling physical boundaries and special interpolation procedures) are provided through a refine patch strategy object.</p>
<p>In general, source data is copied into the designated scratch data for temporary processing. The scratch space must contain sufficient ghost cells to accommodate the stencil width of the given interpolation operators and any physical boundary data that must be filled. The scratch storage is copied into the destination data space at the end of the communication process. <br  />
 Thus, copy operations between source, scratch, and destination patch data objects must be defined. In general, it is the user's responsibility to register valid operations with the refine algorithm so that the data communication can occur.</p>
<p>In general, the destination and scratch data components may be the same (assuming that the scratch component has a sufficient ghost cells width). The source and scratch components SHOULD NOT be the same, since the interiors of the source space would be changed by the use of the scratch data as temporary work space.</p>
<p>Note that each refine schedule created by a refine algorithm remains valid as long as the patches involved in the communication process do not change; thus, they can be used for multiple data communication cycles.</p>
<p>Typical usage of a refine algorithm to perform inter-patch communication on an AMR hierarchy involves four steps:</p>
<ol type="1">
<li>Construct a refine algorithm object.</li>
<li>Register refine operations with the refine algorithm. Using the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a996d67ca0b591ea40755bb1bf754d9d6">registerRefine()</a> methods(s), one provides source and destination patch data information, as well as time and space interpolation operators as needed. Two <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a996d67ca0b591ea40755bb1bf754d9d6">registerRefine()</a> methods appear in this class; one supports time interpolation, one does not.</li>
<li>After all operations are registered with the algorithm, one creates a communication schedule using one of the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#afff3b3edcbc0b5d309b4fbf28e788f16" title="Create a communication schedule that moves data from the interiors of the source data components into...">createSchedule()</a> methods. These methods are distinguished by the resulting data communication pattern (e.g., interpatch communication on a single level, between two different levels at the same grid resolution, interpolation of data between different AMR hierarchy levels, etc.) Note that when creating a communication schedule, a concrete instance of a RefinePatchStrategy&lt;DIM&gt; object may be required to supply physical boundary conditions as well as user-defined spatial data interpolation operations.</li>
<li>Invoke the fillData() method in the communication schedule to perform the data transfers. <br  />
</li>
</ol>
<p>User-defined interpolation operations can be written using the interfaces in <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo...">RefinePatchStrategy</a> for preprocessRefine() and postProcessRefine(). Users who use create these operations must note that all data that is to be used in such operations should be registered with the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html" title="Class RefineAlgorithm&lt;DIM&gt; encapsulates the AMR communication pattern to refine data to,...">RefineAlgorithm</a> using <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a996d67ca0b591ea40755bb1bf754d9d6">registerRefine()</a>, whether or not the data is to be refined.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html" title="Class RefineSchedule&lt;DIM&gt; performs the communication operations that refine data to,...">xfer::RefineSchedule</a> </dd>
<dd>
<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo...">xfer::RefinePatchStrategy</a> </dd>
<dd>
<a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">xfer::RefineClasses</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a22b55cd1b9740ab82f472c1ef74354e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b55cd1b9740ab82f472c1ef74354e9">&#9670;&nbsp;</a></span>RefineAlgorithm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a refinement algorithm and initialize its basic state. Note that refinement operations must be registered with this algorithm before it can do anything useful. See the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a996d67ca0b591ea40755bb1bf754d9d6">registerRefine()</a> routines for details. </p>

</div>
</div>
<a id="a90d7a6c859545a718ea44d2694da0559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d7a6c859545a718ea44d2694da0559">&#9670;&nbsp;</a></span>~RefineAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The virtual destructor for the algorithm releases all internal storage. </p>

</div>
</div>
<a id="af5064fc7de664630bec21f053fa0c86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5064fc7de664630bec21f053fa0c86b">&#9670;&nbsp;</a></span>RefineAlgorithm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a996d67ca0b591ea40755bb1bf754d9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996d67ca0b591ea40755bb1bf754d9d6">&#9670;&nbsp;</a></span>registerRefine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::registerRefine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">RefineOperator</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>oprefine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>var_fill_pattern</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1BoxGeometryFillPattern.html">BoxGeometryFillPattern</a>&lt;&#160;DIM&#160;&gt;&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a refine operation with the refine algorithm object. This routine does not support time interpolation. Data values will be moved from the source component to the destination component using scratch component as a temporary work space. The scratch component must have sufficient ghost cells to cover the required operator stencil width and any needed physical boundary ghost cells. <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Integer destination patch data index to be filled on the destination level. </td></tr>
    <tr><td class="paramname">src</td><td>Integer source patch data index on the source level. </td></tr>
    <tr><td class="paramname">scratch</td><td>Integer patch data index used as a temporary work space. </td></tr>
    <tr><td class="paramname">oprefine</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refinement operator. This may be a null pointer. In this case, refinement must be handled by the refine patch strategy member functions. See the comments for <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a4e647ae59b0d7b45ac8e3e3072f69912">RefinePatchStrategy&lt;DIM&gt;::preprocessRefine()</a> and <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#aa8630858c8464794242a469bbcd48672">RefinePatchStrategy&lt;DIM&gt;::postprocessRefine()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25415f4113b009be6a8a252a5505b4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25415f4113b009be6a8a252a5505b4ff">&#9670;&nbsp;</a></span>registerRefine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::registerRefine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>src_told</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>src_tnew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">RefineOperator</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>oprefine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1TimeInterpolateOperator.html">TimeInterpolateOperator</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>optime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>var_fill_pattern</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1BoxGeometryFillPattern.html">BoxGeometryFillPattern</a>&lt;&#160;DIM&#160;&gt;&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a refine operation with the refine algorithm object. This routine supports time interpolation. Time interpolation will take place between the old and new source data components on coarser levels. On the destination level, data will be moved from the source component to the destination component using scratch component as a temporary work space. The scratch component must have sufficient ghost cells to cover the required operator stencil width and any needed physical boundary ghost cells. The time interpolation operator cannot be null. When assertion checking is active, passing in a null pointer will result in an unrecoverable exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Integer destination patch data index to be filled on the destination level. </td></tr>
    <tr><td class="paramname">src</td><td>Integer source patch data index on the source level. </td></tr>
    <tr><td class="paramname">src_told</td><td>Integer source patch data index for old data used in time interpolation. </td></tr>
    <tr><td class="paramname">src_tnew</td><td>Integer source patch data index for new data used in time interpolation. </td></tr>
    <tr><td class="paramname">scratch</td><td>Integer patch data index used as a temporary work space. </td></tr>
    <tr><td class="paramname">oprefine</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refinement operator. This may be a null pointer. In this case, refinement must be handled by the refine patch strategy member functions. See the comments for <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a4e647ae59b0d7b45ac8e3e3072f69912">RefinePatchStrategy&lt;DIM&gt;::preprocessRefine()</a> and <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#aa8630858c8464794242a469bbcd48672">RefinePatchStrategy&lt;DIM&gt;::postprocessRefine()</a>. </td></tr>
    <tr><td class="paramname">optime</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to time interpolation operator. This pointer may not be null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afff3b3edcbc0b5d309b4fbf28e788f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff3b3edcbc0b5d309b4fbf28e788f16">&#9670;&nbsp;</a></span>createSchedule() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt;DIM&gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::createSchedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *&#160;</td>
          <td class="paramname"><em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt;&#160;DIM&#160;&gt;&#160;*)&#160;NULL)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt;&#160;DIM&#160;&gt;&#160;*)&#160;NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Neither time nor spatial interpolation is performed. <br  />
</p>
<p>Note that the schedule remains valid as long as the patches on the level do not change; thus, it can be used for multiple data communication cycles.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refine schedule that performs the data transfers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to level on which interpatch transfers occur. This pointer cannot be null. </td></tr>
    <tr><td class="paramname">patch_strategy</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine patch strategy that provides user-defined physical boundary filling operations. If this patch strategy is null (default state), then no physical boundary filling is performed. </td></tr>
    <tr><td class="paramname">transaction_factory</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html" title="Concrete subclass of RefineTransactionFactory&lt;DIM&gt; base class that allocates RefineCopyTransaction&lt;DI...">StandardRefineTransactionFactory</a> object will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f4bb0404f653db3cb267c6353a9769a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4bb0404f653db3cb267c6353a9769a">&#9670;&nbsp;</a></span>createSchedule() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt;DIM&gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::createSchedule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fill_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *&#160;</td>
          <td class="paramname"><em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt;&#160;DIM&#160;&gt;&#160;*)&#160;NULL)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt;&#160;DIM&#160;&gt;&#160;*)&#160;NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16a7bf751519c022e0b4da1c455d17bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a7bf751519c022e0b4da1c455d17bc">&#9670;&nbsp;</a></span>createSchedule() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt;DIM&gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::createSchedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *&#160;</td>
          <td class="paramname"><em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt;&#160;DIM&#160;&gt;&#160;*)&#160;NULL)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt;&#160;DIM&#160;&gt;&#160;*)&#160;NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Note that both levels must reside in the same AMR hierarchy index space, or in index spaces that represent the same level of mesh refinement. No spatial interpolation is performed.</p>
<p>In certain rare cases it may be desired to use this schedule to perform time interpolation, in which case the use_time_interpolation optional argument should be set to true.</p>
<p>Note that the schedule remains valid as long as the patches on the levels do not change; thus, it can be used for multiple data communication cycles.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refine schedule that performs the data transfers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst_level</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to destination level; cannot be null. </td></tr>
    <tr><td class="paramname">src_level</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to source level; cannot be null. </td></tr>
    <tr><td class="paramname">patch_strategy</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine patch strategy that provides user-defined physical boundary filling operations. If this patch strategy is null (default state), then no physical boundary filling is performed. </td></tr>
    <tr><td class="paramname">use_time_interpolation</td><td>Optional boolean flag to create the schedule with the ability to perform time interpolation. Default is no time interpolation (false). </td></tr>
    <tr><td class="paramname">transaction_factory</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html" title="Concrete subclass of RefineTransactionFactory&lt;DIM&gt; base class that allocates RefineCopyTransaction&lt;DI...">StandardRefineTransactionFactory</a> object will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7167dfdfd57de2957096c500f493f83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7167dfdfd57de2957096c500f493f83d">&#9670;&nbsp;</a></span>createSchedule() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt;DIM&gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::createSchedule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fill_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *&#160;</td>
          <td class="paramname"><em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt;&#160;DIM&#160;&gt;&#160;*)&#160;NULL)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt;&#160;DIM&#160;&gt;&#160;*)&#160;NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d9262287f6dd2502c2ab4ded7101fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9262287f6dd2502c2ab4ded7101fa5">&#9670;&nbsp;</a></span>createSchedule() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt;DIM&gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::createSchedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>next_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *&#160;</td>
          <td class="paramname"><em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt;&#160;DIM&#160;&gt;&#160;*)&#160;NULL)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt;&#160;DIM&#160;&gt;&#160;*)&#160;NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In certain rare cases in may be necessary to perform time interpolation between old and new sources on the given patch level. In this case the optional argument use_time_interpolation should be set to true. Regardless of the value of this argument, time interpolation on coarser levels will always occur whenever needed.</p>
<p>Note that the next coarser level number must correspond to a level in the hierarchy that represents a region of coarser index space than the destination level.</p>
<p>Note that the schedule remains valid as long as the patches on the levels involved in its creation do not change; thus, it can be used for multiple data communication cycles.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refine schedule that performs the data transfers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to destination level; cannot be null. </td></tr>
    <tr><td class="paramname">next_coarser_level</td><td>Integer number of next coarser patch level in the patch hierarchy relative to the destination level. Note that when the destination level has number zero (i.e., the coarsest level), this value should be &lt; 0. </td></tr>
    <tr><td class="paramname">hierarchy</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to patch hierarchy from which data to fill level should come. This pointer may be null only when the next_coarser_level is &lt; 0. <br  />
 </td></tr>
    <tr><td class="paramname">patch_strategy</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine patch strategy that provides user-defined physical boundary filling operations and user-defined spatial interpolation operations. If this patch strategy is null (default state), then no physical boundary filling or user-defined interpolation is performed. Note that this may cause problems since interpolation of data from coarser levels to some finer level may require physical boundary data. </td></tr>
    <tr><td class="paramname">use_time_interpolation</td><td>Optional boolean flag to create the schedule with the ability to perform time interpolation Default is no time interpolation (false). </td></tr>
    <tr><td class="paramname">transaction_factory</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html" title="Concrete subclass of RefineTransactionFactory&lt;DIM&gt; base class that allocates RefineCopyTransaction&lt;DI...">StandardRefineTransactionFactory</a> object will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf2f46d65dad69e7c5624fe293655c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2f46d65dad69e7c5624fe293655c63">&#9670;&nbsp;</a></span>createSchedule() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt;DIM&gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::createSchedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>next_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *&#160;</td>
          <td class="paramname"><em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt;&#160;DIM&#160;&gt;&#160;*)&#160;NULL)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt;&#160;DIM&#160;&gt;&#160;*)&#160;NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This form of schedule construction is typically used after regridding (where the source level is the patch level being replaced by the destination level in the patch hierarchy) or when the data on destination patch level is to be overwritten by data interpolated from coarser levels in the patch hierarchy. In the first case, data on the destination level will be copied from the source level in regions where those two levels overlap and filled with interpolated values from the hierarchy elsewhere. In the latter case, the source level pointer may be null. Then, data on the destination level will be filled using interpolated data from coarser hierarchy levels.</p>
<p>In certain cases it may be necessary to perform time interpolation between old and new sources onto the destination level. In this case the optional argument use_time_interpolation should be set to true. Regardless of the value of this argument, time interpolation on coarser levels will always occur whenever needed.</p>
<p>Note that when the source level pointer is non-null, the index spaces of the source and destination levels must be aligned with one another.</p>
<p>Note that the schedule remains valid as long as the patches on the levels involved in its creation do not change; thus, it can be used for multiple data communication cycles.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refine schedule that performs the data transfers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst_level</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to destination level; cannot be null. </td></tr>
    <tr><td class="paramname">src_level</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to source level. This pointer may be null. In this case, data on the destination level will be filled only using interpolated data from coarser hierarchy levels. When this pointer is not null, the source level must live in the same AMR hierarchy index space as the destination level. </td></tr>
    <tr><td class="paramname">next_coarser_level</td><td>Integer number of next coarser patch level in a patch hierarchy relative to the destination level. Note that when the destination level has number zero (i.e., the coarsest level), this value should be &lt; 0. </td></tr>
    <tr><td class="paramname">hierarchy</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to patch hierarchy from which data to fill level should come. This pointer may be null only when the next_coarser_level is &lt; 0. </td></tr>
    <tr><td class="paramname">patch_strategy</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine patch strategy that provides user-defined physical boundary filling operations and user-defined spatial interpolation operations. If this patch strategy is null (default state), then no physical boundary filling or user-defined interpolation is performed. Note that this may cause problems since interpolation of data from coarser levels to some finer level may require physical boundary data. </td></tr>
    <tr><td class="paramname">use_time_interpolation</td><td>Optional boolean flag to create the schedule with the ability to perform time interpolation Default is no time interpolation (false). </td></tr>
    <tr><td class="paramname">transaction_factory</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html" title="Concrete subclass of RefineTransactionFactory&lt;DIM&gt; base class that allocates RefineCopyTransaction&lt;DI...">StandardRefineTransactionFactory</a> object will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14d2f2c95bafe2dd8ef3450af057e2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d2f2c95bafe2dd8ef3450af057e2b0">&#9670;&nbsp;</a></span>createSchedule() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt;DIM&gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::createSchedule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fill_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>next_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *&#160;</td>
          <td class="paramname"><em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt;&#160;DIM&#160;&gt;&#160;*)&#160;NULL)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt;&#160;DIM&#160;&gt;&#160;*)&#160;NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fill_pattern</td><td>Indicates which parts of the destination level to fill. See <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html" title="Class RefineSchedule&lt;DIM&gt; performs the communication operations that refine data to,...">RefineSchedule</a> for valid values.</td></tr>
    <tr><td class="paramname">level</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to destination level; cannot be null. </td></tr>
    <tr><td class="paramname">next_coarser_level</td><td>Integer number of next coarser patch level in a patch hierarchy relative to the destination level. Note that when the destination level has number zero (i.e., the coarsest level), this value should be &lt; 0. </td></tr>
    <tr><td class="paramname">hierarchy</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to patch hierarchy from which data to fill level should come. This pointer may be null only when the next_coarser_level is &lt; 0. </td></tr>
    <tr><td class="paramname">patch_strategy</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine patch strategy that provides user-defined physical boundary filling operations and user-defined spatial interpolation operations. If this patch strategy is null (default state), then no physical boundary filling or user-defined interpolation is performed. Note that this may cause problems since interpolation of data from coarser levels to some finer level may require physical boundary data. </td></tr>
    <tr><td class="paramname">use_time_interpolation</td><td>Optional boolean flag to create the schedule with the ability to perform time interpolation Default is no time interpolation (false). </td></tr>
    <tr><td class="paramname">transaction_factory</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html" title="Concrete subclass of RefineTransactionFactory&lt;DIM&gt; base class that allocates RefineCopyTransaction&lt;DI...">StandardRefineTransactionFactory</a> object will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f40be92f2919bee257fb0384d1c1f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f40be92f2919bee257fb0384d1c1f2f">&#9670;&nbsp;</a></span>createSchedule() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt;DIM&gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::createSchedule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fill_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>next_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt; DIM &gt; *&#160;</td>
          <td class="paramname"><em>patch_strategy</em> = <code>((<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>&lt;&#160;DIM&#160;&gt;&#160;*)&#160;NULL)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>transaction_factory</em> = <code>(<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a>&lt;&#160;DIM&#160;&gt;&#160;*)&#160;NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fill_pattern</td><td>Indicates which parts of the destination level to fill. See <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html" title="Class RefineSchedule&lt;DIM&gt; performs the communication operations that refine data to,...">RefineSchedule</a> for valid values.</td></tr>
    <tr><td class="paramname">dst_level</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to destination level; cannot be null. </td></tr>
    <tr><td class="paramname">src_level</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to source level. This pointer may be null. In this case, data on the destination level will be filled only using interpolated data from coarser hierarchy levels. When this pointer is not null, the source level must live in the same AMR hierarchy index space as the destination level. </td></tr>
    <tr><td class="paramname">next_coarser_level</td><td>Integer number of next coarser patch level in a patch hierarchy relative to the destination level. Note that when the destination level has number zero (i.e., the coarsest level), this value should be &lt; 0. </td></tr>
    <tr><td class="paramname">hierarchy</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to patch hierarchy from which data to fill level should come. This pointer may be null only when the next_coarser_level is &lt; 0. </td></tr>
    <tr><td class="paramname">patch_strategy</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine patch strategy that provides user-defined physical boundary filling operations and user-defined spatial interpolation operations. If this patch strategy is null (default state), then no physical boundary filling or user-defined interpolation is performed. Note that this may cause problems since interpolation of data from coarser levels to some finer level may require physical boundary data. </td></tr>
    <tr><td class="paramname">use_time_interpolation</td><td>Optional boolean flag to create the schedule with the ability to perform time interpolation Default is no time interpolation (false). </td></tr>
    <tr><td class="paramname">transaction_factory</td><td>Optional <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html" title="Concrete subclass of RefineTransactionFactory&lt;DIM&gt; base class that allocates RefineCopyTransaction&lt;DI...">StandardRefineTransactionFactory</a> object will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a782956e016ea00c8db0163614e0df6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782956e016ea00c8db0163614e0df6b9">&#9670;&nbsp;</a></span>checkConsistency()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::checkConsistency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>schedule</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Boolean true if schedule reset is valid; false otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schedule</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refine schedule, which cannot be null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a329e0c11a240d468ce7d447c73487037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329e0c11a240d468ce7d447c73487037">&#9670;&nbsp;</a></span>resetSchedule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::resetSchedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>schedule</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schedule</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to refine schedule, which cannot be null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accfc0d5edec99adff57293aa37ec11d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfc0d5edec99adff57293aa37ec11d1">&#9670;&nbsp;</a></span>getEquivalenceClasses()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a>&lt;DIM&gt; &gt;&amp; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::getEquivalenceClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ed85f6233c367be9db2759e42bcc0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed85f6233c367be9db2759e42bcc0fd">&#9670;&nbsp;</a></span>setEquivalenceClasses()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::setEquivalenceClasses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>refine_classes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refine_classes</td><td>A pointer to refine equivalence classes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae634ce47dafbe7d7ab376b55df78c72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae634ce47dafbe7d7ab376b55df78c72e">&#9670;&nbsp;</a></span>printClassData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::printClassData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the refine algorithm state to the specified data stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output data stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3d13183af2fd9a964bb3252bc6ba0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d13183af2fd9a964bb3252bc6ba0d1">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9585c2e7556387066901d76069150b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9585c2e7556387066901d76069150b08">&#9670;&nbsp;</a></span>d_refine_classes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a>&lt;DIM&gt; &gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::d_refine_classes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a63fcfee2b8a19d59cf2b971e601108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a63fcfee2b8a19d59cf2b971e601108">&#9670;&nbsp;</a></span>d_schedule_created</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; DIM &gt;::d_schedule_created</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/samrai/include/<a class="el" href="RefineAlgorithm_8h.html">RefineAlgorithm.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
