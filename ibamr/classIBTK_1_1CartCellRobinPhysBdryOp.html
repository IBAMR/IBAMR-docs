<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: IBTK::CartCellRobinPhysBdryOp Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IBAMR
   &#160;<span id="projectnumber">IBAMR version 0.18.</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceIBTK.html">IBTK</a></li><li class="navelem"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html">CartCellRobinPhysBdryOp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classIBTK_1_1CartCellRobinPhysBdryOp-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IBTK::CartCellRobinPhysBdryOp Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class <a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html" title="Class CartCellRobinPhysBdryOp is a concrete SAMRAI::xfer::RefinePatchStrategy for setting Robin bound...">CartCellRobinPhysBdryOp</a> is a concrete <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo...">SAMRAI::xfer::RefinePatchStrategy</a> for setting Robin boundary conditions at physical boundaries for cell-centered scalar- and vector-valued quantities.  
 <a href="classIBTK_1_1CartCellRobinPhysBdryOp.html#details">More...</a></p>

<p><code>#include &lt;ibtk/CartCellRobinPhysBdryOp.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IBTK::CartCellRobinPhysBdryOp:</div>
<div class="dyncontent">
<div class="center"><img src="classIBTK_1_1CartCellRobinPhysBdryOp__inherit__graph.png" border="0" usemap="#IBTK_1_1CartCellRobinPhysBdryOp_inherit__map" alt="Inheritance graph"/></div>
<map name="IBTK_1_1CartCellRobinPhysBdryOp_inherit__map" id="IBTK_1_1CartCellRobinPhysBdryOp_inherit__map">
<area shape="rect" title="Class CartCellRobinPhysBdryOp is a concrete SAMRAI::xfer::RefinePatchStrategy for setting Robin bound..." alt="" coords="6,367,234,393"/>
<area shape="rect" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html" title="Class RobinPhysBdryPatchStrategy is an abstract strategy class that extends the SAMRAI::xfer::RefineP..." alt="" coords="23,276,217,317"/>
<area shape="rect" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title=" " alt="" coords="24,185,216,227"/>
<area shape="rect" href="classSAMRAI_1_1tbox_1_1DescribedClass.html" title="Base class for all objects that use run&#45;time type identification (RTTI)." alt="" coords="5,5,224,32"/>
<area shape="rect" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo..." alt="" coords="136,81,328,123"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a25a062ffeb191e47cc65e91f896ff7c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html#a25a062ffeb191e47cc65e91f896ff7c8">CartCellRobinPhysBdryOp</a> ()</td></tr>
<tr class="memdesc:a25a062ffeb191e47cc65e91f896ff7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classIBTK_1_1CartCellRobinPhysBdryOp.html#a25a062ffeb191e47cc65e91f896ff7c8">More...</a><br /></td></tr>
<tr class="separator:a25a062ffeb191e47cc65e91f896ff7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd05607964189c518f5db4ba912b908"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html#aedd05607964189c518f5db4ba912b908">CartCellRobinPhysBdryOp</a> (<a class="el" href="classint.html">int</a> patch_data_index, <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt; NDIM &gt; *bc_coef, <a class="el" href="classbool.html">bool</a> homogeneous_bc=false, std::string type=&quot;LINEAR&quot;)</td></tr>
<tr class="memdesc:aedd05607964189c518f5db4ba912b908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to fill boundary conditions for scalar-valued quantities.  <a href="classIBTK_1_1CartCellRobinPhysBdryOp.html#aedd05607964189c518f5db4ba912b908">More...</a><br /></td></tr>
<tr class="separator:aedd05607964189c518f5db4ba912b908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1418a40fc8ae5231a9ce3297d756af5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html#ab1418a40fc8ae5231a9ce3297d756af5">CartCellRobinPhysBdryOp</a> (const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;patch_data_indices, <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt; NDIM &gt; *bc_coef, <a class="el" href="classbool.html">bool</a> homogeneous_bc=false, std::string type=&quot;LINEAR&quot;)</td></tr>
<tr class="memdesc:ab1418a40fc8ae5231a9ce3297d756af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to fill boundary conditions for scalar-valued quantities.  <a href="classIBTK_1_1CartCellRobinPhysBdryOp.html#ab1418a40fc8ae5231a9ce3297d756af5">More...</a><br /></td></tr>
<tr class="separator:ab1418a40fc8ae5231a9ce3297d756af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab508c2f49936f977a3152a83540d3469"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html#ab508c2f49936f977a3152a83540d3469">CartCellRobinPhysBdryOp</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">SAMRAI::hier::ComponentSelector</a> &amp;patch_data_indices, <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt; NDIM &gt; *bc_coef, <a class="el" href="classbool.html">bool</a> homogeneous_bc=false, std::string type=&quot;LINEAR&quot;)</td></tr>
<tr class="memdesc:ab508c2f49936f977a3152a83540d3469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to fill boundary conditions for scalar-valued quantities.  <a href="classIBTK_1_1CartCellRobinPhysBdryOp.html#ab508c2f49936f977a3152a83540d3469">More...</a><br /></td></tr>
<tr class="separator:ab508c2f49936f977a3152a83540d3469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4494dca9c1a37af72759b0e5df829d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html#a0b4494dca9c1a37af72759b0e5df829d">CartCellRobinPhysBdryOp</a> (<a class="el" href="classint.html">int</a> patch_data_index, const std::vector&lt; <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt; NDIM &gt; * &gt; &amp;bc_coefs, <a class="el" href="classbool.html">bool</a> homogeneous_bc=false, std::string type=&quot;LINEAR&quot;)</td></tr>
<tr class="memdesc:a0b4494dca9c1a37af72759b0e5df829d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to fill boundary conditions for vector-valued quantities. In this case, we require that distinct boundary condition objects are provided for each data depth.  <a href="classIBTK_1_1CartCellRobinPhysBdryOp.html#a0b4494dca9c1a37af72759b0e5df829d">More...</a><br /></td></tr>
<tr class="separator:a0b4494dca9c1a37af72759b0e5df829d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c0463e58cb5fb853b0b504effe2699"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html#af0c0463e58cb5fb853b0b504effe2699">CartCellRobinPhysBdryOp</a> (const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;patch_data_indices, const std::vector&lt; <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt; NDIM &gt; * &gt; &amp;bc_coefs, <a class="el" href="classbool.html">bool</a> homogeneous_bc=false, std::string type=&quot;LINEAR&quot;)</td></tr>
<tr class="memdesc:af0c0463e58cb5fb853b0b504effe2699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to fill boundary conditions for vector-valued quantities.  <a href="classIBTK_1_1CartCellRobinPhysBdryOp.html#af0c0463e58cb5fb853b0b504effe2699">More...</a><br /></td></tr>
<tr class="separator:af0c0463e58cb5fb853b0b504effe2699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ab67ef355217df62eff92ded7f9b62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html#af5ab67ef355217df62eff92ded7f9b62">CartCellRobinPhysBdryOp</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">SAMRAI::hier::ComponentSelector</a> &amp;patch_data_indices, const std::vector&lt; <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt; NDIM &gt; * &gt; &amp;bc_coefs, <a class="el" href="classbool.html">bool</a> homogeneous_bc=false, std::string type=&quot;LINEAR&quot;)</td></tr>
<tr class="memdesc:af5ab67ef355217df62eff92ded7f9b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to fill boundary conditions for vector-valued quantities.  <a href="classIBTK_1_1CartCellRobinPhysBdryOp.html#af5ab67ef355217df62eff92ded7f9b62">More...</a><br /></td></tr>
<tr class="separator:af5ab67ef355217df62eff92ded7f9b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d636f5f1452ec54e063661db58affbd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html#a5d636f5f1452ec54e063661db58affbd">~CartCellRobinPhysBdryOp</a> ()</td></tr>
<tr class="memdesc:a5d636f5f1452ec54e063661db58affbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classIBTK_1_1CartCellRobinPhysBdryOp.html#a5d636f5f1452ec54e063661db58affbd">More...</a><br /></td></tr>
<tr class="separator:a5d636f5f1452ec54e063661db58affbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0e8fa290f85719e7f5099c01b63773"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a2d0e8fa290f85719e7f5099c01b63773">setPatchDataIndex</a> (<a class="el" href="classint.html">int</a> patch_data_index)</td></tr>
<tr class="memdesc:a2d0e8fa290f85719e7f5099c01b63773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the patch data index operated upon by this class.  <a href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a2d0e8fa290f85719e7f5099c01b63773">More...</a><br /></td></tr>
<tr class="separator:a2d0e8fa290f85719e7f5099c01b63773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052f712ac937e1c7a571530a194b68e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a052f712ac937e1c7a571530a194b68e4">setPatchDataIndices</a> (const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;patch_data_indices)</td></tr>
<tr class="memdesc:a052f712ac937e1c7a571530a194b68e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the patch data indices operated upon by this class.  <a href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a052f712ac937e1c7a571530a194b68e4">More...</a><br /></td></tr>
<tr class="separator:a052f712ac937e1c7a571530a194b68e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20127fe01e0dfac65464429a5dc42614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a20127fe01e0dfac65464429a5dc42614">setPatchDataIndices</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">SAMRAI::hier::ComponentSelector</a> &amp;patch_data_indices)</td></tr>
<tr class="memdesc:a20127fe01e0dfac65464429a5dc42614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the patch data indices operated upon by this class.  <a href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a20127fe01e0dfac65464429a5dc42614">More...</a><br /></td></tr>
<tr class="separator:a20127fe01e0dfac65464429a5dc42614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34cba46245c65d607c8949ae683d8cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#ae34cba46245c65d607c8949ae683d8cb">setPhysicalBcCoef</a> (<a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt; NDIM &gt; *bc_coef)</td></tr>
<tr class="memdesc:ae34cba46245c65d607c8949ae683d8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the Robin boundary condition specification object employed by this class to set physical boundary conditions.  <a href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#ae34cba46245c65d607c8949ae683d8cb">More...</a><br /></td></tr>
<tr class="separator:ae34cba46245c65d607c8949ae683d8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac101c68fa7eabdc08f70016895fae22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#aac101c68fa7eabdc08f70016895fae22">setPhysicalBcCoefs</a> (const std::vector&lt; <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt; NDIM &gt; * &gt; &amp;bc_coefs)</td></tr>
<tr class="memdesc:aac101c68fa7eabdc08f70016895fae22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the Robin boundary condition specification object employed by this class to set physical boundary conditions.  <a href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#aac101c68fa7eabdc08f70016895fae22">More...</a><br /></td></tr>
<tr class="separator:aac101c68fa7eabdc08f70016895fae22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccb94ff10c87a6b2099732f6b1c8761"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a0ccb94ff10c87a6b2099732f6b1c8761">setHomogeneousBc</a> (<a class="el" href="classbool.html">bool</a> homogeneous_bc)</td></tr>
<tr class="memdesc:a0ccb94ff10c87a6b2099732f6b1c8761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether boundary filling should employ homogeneous boundary conditions.  <a href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a0ccb94ff10c87a6b2099732f6b1c8761">More...</a><br /></td></tr>
<tr class="separator:a0ccb94ff10c87a6b2099732f6b1c8761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb449d07b55dcf964d4a851eb8812d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a7fb449d07b55dcf964d4a851eb8812d9">getHomogeneousBc</a> () const</td></tr>
<tr class="separator:a7fb449d07b55dcf964d4a851eb8812d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e647ae59b0d7b45ac8e3e3072f69912"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a4e647ae59b0d7b45ac8e3e3072f69912">preprocessRefine</a> (hier::Patch&lt; DIM &gt; &amp;fine, const hier::Patch&lt; DIM &gt; &amp;coarse, const hier::Box&lt; DIM &gt; &amp;fine_box, const hier::IntVector&lt; DIM &gt; &amp;ratio)=0</td></tr>
<tr class="separator:a4e647ae59b0d7b45ac8e3e3072f69912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8630858c8464794242a469bbcd48672"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#aa8630858c8464794242a469bbcd48672">postprocessRefine</a> (hier::Patch&lt; DIM &gt; &amp;fine, const hier::Patch&lt; DIM &gt; &amp;coarse, const hier::Box&lt; DIM &gt; &amp;fine_box, const hier::IntVector&lt; DIM &gt; &amp;ratio)=0</td></tr>
<tr class="separator:aa8630858c8464794242a469bbcd48672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece784dfaef6ec58bfbf678e68d2d2d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#aece784dfaef6ec58bfbf678e68d2d2d3">setPhysicalBoundaryConditions</a> (hier::Patch&lt; DIM &gt; &amp;patch, const <a class="el" href="classdouble.html">double</a> fill_time, const hier::IntVector&lt; DIM &gt; &amp;ghost_width_to_fill)=0</td></tr>
<tr class="separator:aece784dfaef6ec58bfbf678e68d2d2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c93cfbcc150cd3ba647f510a102d17"><td class="memItemLeft" align="right" valign="top">virtual hier::IntVector&lt; DIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a92c93cfbcc150cd3ba647f510a102d17">getRefineOpStencilWidth</a> () const=0</td></tr>
<tr class="separator:a92c93cfbcc150cd3ba647f510a102d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133e4c3a0b27a9cf9e97ab4b5ec33111"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a133e4c3a0b27a9cf9e97ab4b5ec33111">preprocessRefineBoxes</a> (hier::Patch&lt; DIM &gt; &amp;fine, const hier::Patch&lt; DIM &gt; &amp;coarse, const hier::BoxList&lt; DIM &gt; &amp;fine_boxes, const hier::IntVector&lt; DIM &gt; &amp;ratio)</td></tr>
<tr class="separator:a133e4c3a0b27a9cf9e97ab4b5ec33111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f7581b8c4a5daf9997bbe6f579209d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#aa0f7581b8c4a5daf9997bbe6f579209d">postprocessRefineBoxes</a> (hier::Patch&lt; DIM &gt; &amp;fine, const hier::Patch&lt; DIM &gt; &amp;coarse, const hier::BoxList&lt; DIM &gt; &amp;fine_boxes, const hier::IntVector&lt; DIM &gt; &amp;ratio)</td></tr>
<tr class="separator:aa0f7581b8c4a5daf9997bbe6f579209d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Implementation of SAMRAI::xfer::RefinePatchStrategy interface.</h2></td></tr>
<tr class="memitem:aa4bde07f5bcaa0877e2245a93395b75a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html#aa4bde07f5bcaa0877e2245a93395b75a">d_type</a> = &quot;LINEAR&quot;</td></tr>
<tr class="separator:aa4bde07f5bcaa0877e2245a93395b75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27545ead41cbe84775f27e74a3102d0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html#a27545ead41cbe84775f27e74a3102d0d">setPhysicalBoundaryConditions</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a>&lt; NDIM &gt; &amp;patch, <a class="el" href="classdouble.html">double</a> fill_time, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;ghost_width_to_fill) override</td></tr>
<tr class="separator:a27545ead41cbe84775f27e74a3102d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147de55c671754ac4283119c094505e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html#a147de55c671754ac4283119c094505e1">getRefineOpStencilWidth</a> () const override</td></tr>
<tr class="separator:a147de55c671754ac4283119c094505e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f935bc07387388e0830cca214a3c102"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html#a0f935bc07387388e0830cca214a3c102">accumulateFromPhysicalBoundaryData</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a>&lt; NDIM &gt; &amp;patch, <a class="el" href="classdouble.html">double</a> fill_time, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;ghost_width_to_fill) override</td></tr>
<tr class="separator:a0f935bc07387388e0830cca214a3c102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d10de26159b3496eba689c37e856eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html#ae9d10de26159b3496eba689c37e856eb">CartCellRobinPhysBdryOp</a> (const <a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html">CartCellRobinPhysBdryOp</a> &amp;from)=delete</td></tr>
<tr class="memdesc:ae9d10de26159b3496eba689c37e856eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classIBTK_1_1CartCellRobinPhysBdryOp.html#ae9d10de26159b3496eba689c37e856eb">More...</a><br /></td></tr>
<tr class="separator:ae9d10de26159b3496eba689c37e856eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cc0fa5fe3f34e093a4b9d4e17a5130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html">CartCellRobinPhysBdryOp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html#ac1cc0fa5fe3f34e093a4b9d4e17a5130">operator=</a> (const <a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html">CartCellRobinPhysBdryOp</a> &amp;that)=delete</td></tr>
<tr class="memdesc:ac1cc0fa5fe3f34e093a4b9d4e17a5130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classIBTK_1_1CartCellRobinPhysBdryOp.html#ac1cc0fa5fe3f34e093a4b9d4e17a5130">More...</a><br /></td></tr>
<tr class="separator:ac1cc0fa5fe3f34e093a4b9d4e17a5130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2903e806be25f58d84b0e8e7c1343ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html#aa2903e806be25f58d84b0e8e7c1343ac">fillGhostCellValuesCodim1</a> (<a class="el" href="classint.html">int</a> patch_data_idx, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">SAMRAI::tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">SAMRAI::hier::BoundaryBox</a>&lt; NDIM &gt; &gt; &amp;physical_codim1_boxes, <a class="el" href="classdouble.html">double</a> fill_time, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;ghost_width_to_fill, <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a>&lt; NDIM &gt; &amp;patch, <a class="el" href="classbool.html">bool</a> adjoint_op)</td></tr>
<tr class="memdesc:aa2903e806be25f58d84b0e8e7c1343ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the boundary conditions along the co-dimension one boundary.  <a href="classIBTK_1_1CartCellRobinPhysBdryOp.html#aa2903e806be25f58d84b0e8e7c1343ac">More...</a><br /></td></tr>
<tr class="separator:aa2903e806be25f58d84b0e8e7c1343ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107a8ad571070e2602a52921ed0b235d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html#a107a8ad571070e2602a52921ed0b235d">fillGhostCellValuesCodim2</a> (<a class="el" href="classint.html">int</a> patch_data_idx, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">SAMRAI::tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">SAMRAI::hier::BoundaryBox</a>&lt; NDIM &gt; &gt; &amp;physical_codim2_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;ghost_width_to_fill, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a>&lt; NDIM &gt; &amp;patch, <a class="el" href="classbool.html">bool</a> adjoint_op)</td></tr>
<tr class="memdesc:a107a8ad571070e2602a52921ed0b235d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the boundary conditions along the co-dimension two boundary.  <a href="classIBTK_1_1CartCellRobinPhysBdryOp.html#a107a8ad571070e2602a52921ed0b235d">More...</a><br /></td></tr>
<tr class="separator:a107a8ad571070e2602a52921ed0b235d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Partial implementation of SAMRAI::xfer::RefinePatchStrategy</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp842e264883f5d49648e9065477ad3cb7"></a>interface. </p>
</td></tr>
<tr class="memitem:a364da7b3001b640091f75b1b2d0c6300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a364da7b3001b640091f75b1b2d0c6300">preprocessRefine</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a>&lt; NDIM &gt; &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a>&lt; NDIM &gt; &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &amp;fine_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;ratio) override</td></tr>
<tr class="separator:a364da7b3001b640091f75b1b2d0c6300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c10d501f9ec027a187dbbc4148bbc60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a1c10d501f9ec027a187dbbc4148bbc60">postprocessRefine</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a>&lt; NDIM &gt; &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a>&lt; NDIM &gt; &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &amp;fine_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;ratio) override</td></tr>
<tr class="separator:a1c10d501f9ec027a187dbbc4148bbc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a22fdba226fa3f69546f03299208f7"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a88a22fdba226fa3f69546f03299208f7">d_patch_data_indices</a></td></tr>
<tr class="separator:a88a22fdba226fa3f69546f03299208f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9721193b648a09825321c9a39c6303"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt; NDIM &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a2e9721193b648a09825321c9a39c6303">d_bc_coefs</a></td></tr>
<tr class="separator:a2e9721193b648a09825321c9a39c6303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348da6b55ad8ef8daf66a5a416841041"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a348da6b55ad8ef8daf66a5a416841041">d_homogeneous_bc</a> = false</td></tr>
<tr class="separator:a348da6b55ad8ef8daf66a5a416841041"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This implementation works similarly to the <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html" title="Helper utility for setting Robin boundary conditions.">SAMRAI::solv::CartesianRobinBcHelper</a> class. An important difference between the two classes is that class <a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html" title="Class CartCellRobinPhysBdryOp is a concrete SAMRAI::xfer::RefinePatchStrategy for setting Robin bound...">CartCellRobinPhysBdryOp</a> allows for the specification of boundary conditions for vector-valued quantities. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a25a062ffeb191e47cc65e91f896ff7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a062ffeb191e47cc65e91f896ff7c8">&#9670;&nbsp;</a></span>CartCellRobinPhysBdryOp() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::CartCellRobinPhysBdryOp::CartCellRobinPhysBdryOp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This constructor leaves the class in an undefined state. In particular, the patch data indices requiring cell filling and the boundary condition specifications must be set prior to use of method <a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html#a27545ead41cbe84775f27e74a3102d0d">setPhysicalBoundaryConditions()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a2d0e8fa290f85719e7f5099c01b63773" title="Reset the patch data index operated upon by this class.">setPatchDataIndex</a> </dd>
<dd>
<a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a052f712ac937e1c7a571530a194b68e4" title="Reset the patch data indices operated upon by this class.">setPatchDataIndices</a> </dd>
<dd>
<a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#ae34cba46245c65d607c8949ae683d8cb" title="Reset the Robin boundary condition specification object employed by this class to set physical bounda...">setPhysicalBcCoef</a> </dd>
<dd>
<a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#aac101c68fa7eabdc08f70016895fae22" title="Reset the Robin boundary condition specification object employed by this class to set physical bounda...">setPhysicalBcCoefs</a> </dd>
<dd>
<a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a0ccb94ff10c87a6b2099732f6b1c8761" title="Set whether boundary filling should employ homogeneous boundary conditions.">setHomogeneousBc</a> </dd></dl>

</div>
</div>
<a id="aedd05607964189c518f5db4ba912b908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd05607964189c518f5db4ba912b908">&#9670;&nbsp;</a></span>CartCellRobinPhysBdryOp() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::CartCellRobinPhysBdryOp::CartCellRobinPhysBdryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>patch_data_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt; NDIM &gt; *&#160;</td>
          <td class="paramname"><em>bc_coef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>homogeneous_bc</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>type</em> = <code>&quot;LINEAR&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch_data_index</td><td>Patch data index requiring ghost cell filling. </td></tr>
    <tr><td class="paramname">bc_coef</td><td>Robin boundary conditions to use with this class. </td></tr>
    <tr><td class="paramname">homogeneous_bc</td><td>Whether to employ the homogeneous form of the boundary conditions. </td></tr>
    <tr><td class="paramname">type</td><td>Type of interpolation to use. Valid options are "LINEAR" or "QUADRATIC". Defaults to "LINEAR". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1418a40fc8ae5231a9ce3297d756af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1418a40fc8ae5231a9ce3297d756af5">&#9670;&nbsp;</a></span>CartCellRobinPhysBdryOp() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::CartCellRobinPhysBdryOp::CartCellRobinPhysBdryOp </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch_data_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt; NDIM &gt; *&#160;</td>
          <td class="paramname"><em>bc_coef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>homogeneous_bc</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>type</em> = <code>&quot;LINEAR&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch_data_indices</td><td>Collection of patch data indices which require ghost cell filling. </td></tr>
    <tr><td class="paramname">bc_coef</td><td>Robin boundary conditions to use with this class. </td></tr>
    <tr><td class="paramname">homogeneous_bc</td><td>Whether to employ the homogeneous form of the boundary conditions. </td></tr>
    <tr><td class="paramname">type</td><td>Type of interpolation to use. Valid options are "LINEAR" or "QUADRATIC". Defaults to "LINEAR". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab508c2f49936f977a3152a83540d3469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab508c2f49936f977a3152a83540d3469">&#9670;&nbsp;</a></span>CartCellRobinPhysBdryOp() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::CartCellRobinPhysBdryOp::CartCellRobinPhysBdryOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">SAMRAI::hier::ComponentSelector</a> &amp;&#160;</td>
          <td class="paramname"><em>patch_data_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt; NDIM &gt; *&#160;</td>
          <td class="paramname"><em>bc_coef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>homogeneous_bc</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>type</em> = <code>&quot;LINEAR&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch_data_indices</td><td>Collection of patch data indices which require ghost cell filling. </td></tr>
    <tr><td class="paramname">bc_coef</td><td>Robin boundary conditions to use with this class. </td></tr>
    <tr><td class="paramname">homogeneous_bc</td><td>Whether to employ the homogeneous form of the boundary conditions. </td></tr>
    <tr><td class="paramname">type</td><td>Type of interpolation to use. Valid options are "LINEAR" or "QUADRATIC". Defaults to "LINEAR". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b4494dca9c1a37af72759b0e5df829d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4494dca9c1a37af72759b0e5df829d">&#9670;&nbsp;</a></span>CartCellRobinPhysBdryOp() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::CartCellRobinPhysBdryOp::CartCellRobinPhysBdryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>patch_data_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt; NDIM &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc_coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>homogeneous_bc</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>type</em> = <code>&quot;LINEAR&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch_data_index</td><td>Patch data index requiring ghost cell filling. </td></tr>
    <tr><td class="paramname">bc_coefs</td><td>Robin boundary conditions to use with this class. </td></tr>
    <tr><td class="paramname">homogeneous_bc</td><td>Whether to employ the homogeneous form of the boundary conditions. </td></tr>
    <tr><td class="paramname">type</td><td>Type of interpolation to use. Valid options are "LINEAR" or "QUADRATIC". Defaults to "LINEAR". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0c0463e58cb5fb853b0b504effe2699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c0463e58cb5fb853b0b504effe2699">&#9670;&nbsp;</a></span>CartCellRobinPhysBdryOp() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::CartCellRobinPhysBdryOp::CartCellRobinPhysBdryOp </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch_data_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt; NDIM &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc_coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>homogeneous_bc</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>type</em> = <code>&quot;LINEAR&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch_data_indices</td><td>Collection of patch data indices which require ghost cell filling. </td></tr>
    <tr><td class="paramname">bc_coefs</td><td>Robin boundary conditions to use with this class. </td></tr>
    <tr><td class="paramname">homogeneous_bc</td><td>Whether to employ the homogeneous form of the boundary conditions. </td></tr>
    <tr><td class="paramname">type</td><td>Type of interpolation to use. Valid options are "LINEAR" or "QUADRATIC". Defaults to "LINEAR". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5ab67ef355217df62eff92ded7f9b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ab67ef355217df62eff92ded7f9b62">&#9670;&nbsp;</a></span>CartCellRobinPhysBdryOp() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::CartCellRobinPhysBdryOp::CartCellRobinPhysBdryOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">SAMRAI::hier::ComponentSelector</a> &amp;&#160;</td>
          <td class="paramname"><em>patch_data_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt; NDIM &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc_coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>homogeneous_bc</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>type</em> = <code>&quot;LINEAR&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch_data_indices</td><td>Collection of patch data indices which require ghost cell filling. </td></tr>
    <tr><td class="paramname">bc_coefs</td><td>Robin boundary conditions to use with this class. </td></tr>
    <tr><td class="paramname">homogeneous_bc</td><td>Whether to employ the homogeneous form of the boundary conditions. </td></tr>
    <tr><td class="paramname">type</td><td>Type of interpolation to use. Valid options are "LINEAR" or "QUADRATIC". Defaults to "LINEAR". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d636f5f1452ec54e063661db58affbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d636f5f1452ec54e063661db58affbd">&#9670;&nbsp;</a></span>~CartCellRobinPhysBdryOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::CartCellRobinPhysBdryOp::~CartCellRobinPhysBdryOp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9d10de26159b3496eba689c37e856eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d10de26159b3496eba689c37e856eb">&#9670;&nbsp;</a></span>CartCellRobinPhysBdryOp() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::CartCellRobinPhysBdryOp::CartCellRobinPhysBdryOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html">CartCellRobinPhysBdryOp</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This constructor is not implemented and should not be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The value to copy to this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a27545ead41cbe84775f27e74a3102d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27545ead41cbe84775f27e74a3102d0d">&#9670;&nbsp;</a></span>setPhysicalBoundaryConditions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::CartCellRobinPhysBdryOp::setPhysicalBoundaryConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_width_to_fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to set data associated with the given list of patch data indices at patch boundaries that intersect the physical domain boundary. The patch data components set in this routine correspond to the "scratch" components specified in calls to the registerRefine() function in the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html" title="Class RefineAlgorithm&lt;DIM&gt; encapsulates the AMR communication pattern to refine data to,...">SAMRAI::xfer::RefineAlgorithm</a> class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>Patch on which to fill boundary data. </td></tr>
    <tr><td class="paramname">fill_time</td><td>Double simulation time for boundary filling. </td></tr>
    <tr><td class="paramname">ghost_width_to_fill</td><td>Integer vector describing maximum ghost width to fill over all registered scratch components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a147de55c671754ac4283119c094505e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147de55c671754ac4283119c094505e1">&#9670;&nbsp;</a></span>getRefineOpStencilWidth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt;NDIM&gt; IBTK::CartCellRobinPhysBdryOp::getRefineOpStencilWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to return maximum stencil width needed over user-defined data interpolation operations. This is needed to determine the correct interpolation data dependencies. </p>

</div>
</div>
<a id="a0f935bc07387388e0830cca214a3c102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f935bc07387388e0830cca214a3c102">&#9670;&nbsp;</a></span>accumulateFromPhysicalBoundaryData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::CartCellRobinPhysBdryOp::accumulateFromPhysicalBoundaryData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_width_to_fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to accumulate data near physical boundaries from values set in the ghost cell region using the adjoint of the operator used to extrapolate the ghost cell values. This function can be used to construct the adjoint of linear operators that use ghost cell data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>Patch on which to fill boundary data. </td></tr>
    <tr><td class="paramname">fill_time</td><td>Double simulation time for boundary filling. </td></tr>
    <tr><td class="paramname">ghost_width_to_fill</td><td>Integer vector describing maximum ghost width to fill over all registered scratch components. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a4f927d1b5c3ac69106e3fb7d10869948">IBTK::RobinPhysBdryPatchStrategy</a>.</p>

</div>
</div>
<a id="ac1cc0fa5fe3f34e093a4b9d4e17a5130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cc0fa5fe3f34e093a4b9d4e17a5130">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html">CartCellRobinPhysBdryOp</a>&amp; IBTK::CartCellRobinPhysBdryOp::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html">CartCellRobinPhysBdryOp</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This operator is not implemented and should not be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>The value to assign to this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<a id="aa2903e806be25f58d84b0e8e7c1343ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2903e806be25f58d84b0e8e7c1343ac">&#9670;&nbsp;</a></span>fillGhostCellValuesCodim1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::CartCellRobinPhysBdryOp::fillGhostCellValuesCodim1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>patch_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">SAMRAI::tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">SAMRAI::hier::BoundaryBox</a>&lt; NDIM &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>physical_codim1_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_width_to_fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adjoint_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a107a8ad571070e2602a52921ed0b235d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107a8ad571070e2602a52921ed0b235d">&#9670;&nbsp;</a></span>fillGhostCellValuesCodim2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::CartCellRobinPhysBdryOp::fillGhostCellValuesCodim2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>patch_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">SAMRAI::tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">SAMRAI::hier::BoundaryBox</a>&lt; NDIM &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>physical_codim2_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_width_to_fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adjoint_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d0e8fa290f85719e7f5099c01b63773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0e8fa290f85719e7f5099c01b63773">&#9670;&nbsp;</a></span>setPatchDataIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::RobinPhysBdryPatchStrategy::setPatchDataIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>patch_data_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a052f712ac937e1c7a571530a194b68e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052f712ac937e1c7a571530a194b68e4">&#9670;&nbsp;</a></span>setPatchDataIndices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::RobinPhysBdryPatchStrategy::setPatchDataIndices </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch_data_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a20127fe01e0dfac65464429a5dc42614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20127fe01e0dfac65464429a5dc42614">&#9670;&nbsp;</a></span>setPatchDataIndices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::RobinPhysBdryPatchStrategy::setPatchDataIndices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">SAMRAI::hier::ComponentSelector</a> &amp;&#160;</td>
          <td class="paramname"><em>patch_data_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae34cba46245c65d607c8949ae683d8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34cba46245c65d607c8949ae683d8cb">&#9670;&nbsp;</a></span>setPhysicalBcCoef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::RobinPhysBdryPatchStrategy::setPhysicalBcCoef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt; NDIM &gt; *&#160;</td>
          <td class="paramname"><em>bc_coef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd><em>bc_coef</em> cannot be nullptr. </dd></dl>

</div>
</div>
<a id="aac101c68fa7eabdc08f70016895fae22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac101c68fa7eabdc08f70016895fae22">&#9670;&nbsp;</a></span>setPhysicalBcCoefs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::RobinPhysBdryPatchStrategy::setPhysicalBcCoefs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt; NDIM &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc_coefs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>None of the elements of <em>bc_coefs</em> can be nullptr. </dd></dl>

</div>
</div>
<a id="a0ccb94ff10c87a6b2099732f6b1c8761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccb94ff10c87a6b2099732f6b1c8761">&#9670;&nbsp;</a></span>setHomogeneousBc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::RobinPhysBdryPatchStrategy::setHomogeneousBc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>homogeneous_bc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>By default, inhomogeneous boundary conditions are assumed. </dd></dl>

</div>
</div>
<a id="a7fb449d07b55dcf964d4a851eb8812d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb449d07b55dcf964d4a851eb8812d9">&#9670;&nbsp;</a></span>getHomogeneousBc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::RobinPhysBdryPatchStrategy::getHomogeneousBc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether boundary filling employs homogeneous boundary conditions. </dd></dl>

</div>
</div>
<a id="a364da7b3001b640091f75b1b2d0c6300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364da7b3001b640091f75b1b2d0c6300">&#9670;&nbsp;</a></span>preprocessRefine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::RobinPhysBdryPatchStrategy::preprocessRefine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to perform user-defined preprocess data refine operations. This member function is called before standard refine operations (expressed using concrete subclasses of the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">SAMRAI::xfer::RefineOperator</a> base class). The preprocess function must refine data from the scratch components of the coarse patch into the scratch components of the fine patch on the specified fine box region. Recall that the scratch components are specified in calls to the registerRefine() function in the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html" title="Class RefineAlgorithm&lt;DIM&gt; encapsulates the AMR communication pattern to refine data to,...">SAMRAI::xfer::RefineAlgorithm</a> class.</p>
<p>The default implementation does nothing. This behavior can be overridden by subclasses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fine</td><td>Fine patch containing destination data. </td></tr>
    <tr><td class="paramname">coarse</td><td>Coarse patch containing source data. </td></tr>
    <tr><td class="paramname">fine_box</td><td>Box region on fine patch into which data is refined. </td></tr>
    <tr><td class="paramname">ratio</td><td>Integer vector containing ratio relating index space between coarse and fine patches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e647ae59b0d7b45ac8e3e3072f69912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e647ae59b0d7b45ac8e3e3072f69912">&#9670;&nbsp;</a></span>preprocessRefine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a>&lt; DIM &gt;::preprocessRefine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pure virtual function to perform user-defined preprocess data refine operations. This member function is called before standard refine operations (expressed using concrete subclasses of the RefineOperator&lt;DIM&gt; base class). The preprocess function must refine data from the scratch components of the coarse patch into the scratch components of the fine patch on the specified fine box region. Recall that the scratch components are specified in calls to the registerRefine() function in the RefineAlgorithm&lt;DIM&gt; class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fine</td><td>Fine patch containing destination data. </td></tr>
    <tr><td class="paramname">coarse</td><td>Coarse patch containing source data. </td></tr>
    <tr><td class="paramname">fine_box</td><td>hier::Box region on fine patch into which data is refined. </td></tr>
    <tr><td class="paramname">ratio</td><td>Integer vector containing ratio relating index space between coarse and fine patches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c10d501f9ec027a187dbbc4148bbc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c10d501f9ec027a187dbbc4148bbc60">&#9670;&nbsp;</a></span>postprocessRefine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::RobinPhysBdryPatchStrategy::postprocessRefine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to perform user-defined postprocess data refine operations. This member function is called after standard refine operations (expressed using concrete subclasses of the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">SAMRAI::xfer::RefineOperator</a> base class). The postprocess function must refine data from the scratch components of the coarse patch into the scratch components of the fine patch on the specified fine box region. Recall that the scratch components are specified in calls to the registerRefine() function in the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html" title="Class RefineAlgorithm&lt;DIM&gt; encapsulates the AMR communication pattern to refine data to,...">SAMRAI::xfer::RefineAlgorithm</a> class.</p>
<p>The implementation does nothing. This behavior can be overridden by subclasses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fine</td><td>Fine patch containing destination data. </td></tr>
    <tr><td class="paramname">coarse</td><td>Coarse patch containing source data. </td></tr>
    <tr><td class="paramname">fine_box</td><td>Box region on fine patch into which data is refined. </td></tr>
    <tr><td class="paramname">ratio</td><td>Integer vector containing ratio relating index space between coarse and fine patches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8630858c8464794242a469bbcd48672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8630858c8464794242a469bbcd48672">&#9670;&nbsp;</a></span>postprocessRefine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a>&lt; DIM &gt;::postprocessRefine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pure virtual function to perform user-defined postprocess data refine operations. This member function is called after standard refine operations (expressed using concrete subclasses of the RefineOperator&lt;DIM&gt; base class). The postprocess function must refine data from the scratch components of the coarse patch into the scratch components of the fine patch on the specified fine box region. Recall that the scratch components are specified in calls to the registerRefine() function in the RefineAlgorithm&lt;DIM&gt; class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fine</td><td>Fine patch containing destination data. </td></tr>
    <tr><td class="paramname">coarse</td><td>Coarse patch containing source data. </td></tr>
    <tr><td class="paramname">fine_box</td><td>hier::Box region on fine patch into which data is refined. </td></tr>
    <tr><td class="paramname">ratio</td><td>Integer vector containing ratio relating index space between coarse and fine patches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aece784dfaef6ec58bfbf678e68d2d2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece784dfaef6ec58bfbf678e68d2d2d3">&#9670;&nbsp;</a></span>setPhysicalBoundaryConditions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a>&lt; DIM &gt;::setPhysicalBoundaryConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_width_to_fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pure virtual function to set data associated with the given list of patch data indices at patch boundaries that intersect the physical domain boundary. The specific boundary conditions are determined by the user. The patch data components set in this routine correspond to the "scratch" components specified in calls to the registerRefine() function in the RefineAlgorithm&lt;DIM&gt; class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>hier::Patch on which to fill boundary data. </td></tr>
    <tr><td class="paramname">fill_time</td><td>Double simulation time for boundary filling. </td></tr>
    <tr><td class="paramname">ghost_width_to_fill</td><td>Integer vector describing maximum ghost width to fill over all registered scratch components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92c93cfbcc150cd3ba647f510a102d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c93cfbcc150cd3ba647f510a102d17">&#9670;&nbsp;</a></span>getRefineOpStencilWidth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual hier::IntVector&lt;DIM&gt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a>&lt; DIM &gt;::getRefineOpStencilWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pure virtual function to return maximum stencil width needed over user-defined data interpolation operations. This is needed to determine the correct interpolation data dependencies. </p>

</div>
</div>
<a id="a133e4c3a0b27a9cf9e97ab4b5ec33111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133e4c3a0b27a9cf9e97ab4b5ec33111">&#9670;&nbsp;</a></span>preprocessRefineBoxes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a>&lt; DIM &gt;::preprocessRefineBoxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual function to perform user-defined refine operations. This member function is called before standard refining operations (expressed using concrete subclasses of the RefineOperator&lt;DIM&gt; base class). The preprocess function must refine data from the scratch components of the coarse patch into the scratch components of the fine patch on the specified fine box regions.</p>
<p>Typically, only the pure virtual members of this class are implemented in user-defined subclasses of this base class. This version of the preprocess function operates on an entire box list. By default, this version simply loops over the box list and calls the single-box version, which is a pure virtual function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fine</td><td>Fine patch containing destination data. </td></tr>
    <tr><td class="paramname">coarse</td><td>Coarse patch containing source data. </td></tr>
    <tr><td class="paramname">fine_boxes</td><td>tbox::List of box regions on fine patch into which data is refined. </td></tr>
    <tr><td class="paramname">ratio</td><td>Integer vector containing ratio relating index space between coarse and fine patches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0f7581b8c4a5daf9997bbe6f579209d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f7581b8c4a5daf9997bbe6f579209d">&#9670;&nbsp;</a></span>postprocessRefineBoxes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a>&lt; DIM &gt;::postprocessRefineBoxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual function to perform user-defined refine operations. This member function is called after standard refining operations (expressed using concrete subclasses of the RefineOperator&lt;DIM&gt; base class). The postprocess function must refine data from the scratch components of the coarse patch into the scratch components of the fine patch on the specified fine box regions.</p>
<p>Typically, only the pure virtual members of this class are implemented in user-defined subclasses of this base class. This version of the postprocess function operates on an entire box list. By default, this version simply loops over the box list and calls the single-box version, which is a pure virtual function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fine</td><td>Fine patch containing destination data. </td></tr>
    <tr><td class="paramname">coarse</td><td>Coarse patch containing source data. </td></tr>
    <tr><td class="paramname">fine_boxes</td><td>tbox::List of box regions on fine patch into which data is refined. </td></tr>
    <tr><td class="paramname">ratio</td><td>Integer vector containing ratio relating index space between coarse and fine patches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa4bde07f5bcaa0877e2245a93395b75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4bde07f5bcaa0877e2245a93395b75a">&#9670;&nbsp;</a></span>d_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string IBTK::CartCellRobinPhysBdryOp::d_type = &quot;LINEAR&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a88a22fdba226fa3f69546f03299208f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a22fdba226fa3f69546f03299208f7">&#9670;&nbsp;</a></span>d_patch_data_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="classint.html">int</a>&gt; IBTK::RobinPhysBdryPatchStrategy::d_patch_data_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e9721193b648a09825321c9a39c6303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9721193b648a09825321c9a39c6303">&#9670;&nbsp;</a></span>d_bc_coefs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a>&lt;NDIM&gt;*&gt; IBTK::RobinPhysBdryPatchStrategy::d_bc_coefs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a348da6b55ad8ef8daf66a5a416841041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348da6b55ad8ef8daf66a5a416841041">&#9670;&nbsp;</a></span>d_homogeneous_bc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::RobinPhysBdryPatchStrategy::d_homogeneous_bc = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ibtk/include/ibtk/<a class="el" href="CartCellRobinPhysBdryOp_8h.html">CartCellRobinPhysBdryOp.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
