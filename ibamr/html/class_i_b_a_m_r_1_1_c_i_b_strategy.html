<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: IBAMR::CIBStrategy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IBAMR
   </div>
   <div id="projectbrief">An adaptive and distributed-memory parallel implementation of the immersed boundary (IB) method</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_i_b_a_m_r.html">IBAMR</a></li><li class="navelem"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html">CIBStrategy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_i_b_a_m_r_1_1_c_i_b_strategy-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">IBAMR::CIBStrategy Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Class <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html" title="Class CIBStrategy is a lightweight abstract strategy class which provides support for constraint base...">CIBStrategy</a> is a lightweight abstract strategy class which provides support for constraint based IB methods for rigid bodies.  
 <a href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#details">More...</a></p>

<p><code>#include &lt;/home/runner/work/IBAMR/IBAMR/include/ibamr/CIBStrategy.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IBAMR::CIBStrategy:</div>
<div class="dyncontent">
<div class="center"><img src="class_i_b_a_m_r_1_1_c_i_b_strategy__inherit__graph.png" border="0" usemap="#a_i_b_a_m_r_1_1_c_i_b_strategy_inherit__map" alt="Inheritance graph"/></div>
<map name="a_i_b_a_m_r_1_1_c_i_b_strategy_inherit__map" id="a_i_b_a_m_r_1_1_c_i_b_strategy_inherit__map">
<area shape="rect" title="Class CIBStrategy is a lightweight abstract strategy class which provides support for constraint base..." alt="" coords="39,79,190,104"/>
<area shape="rect" href="class_i_b_a_m_r_1_1_c_i_b_method.html" title="Class CIBMethod is a concrete CIBStrategy and IBMethod class which implements the motion of rigid bod..." alt="" coords="43,152,187,177"/>
<area shape="poly" title=" " alt="" coords="117,118,117,152,112,152,112,118"/>
<area shape="rect" title=" " alt="" coords="5,5,224,31"/>
<area shape="poly" title=" " alt="" coords="117,44,117,79,112,79,112,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e705bfc074714dabd25ae9c8350dda2" id="r_a3e705bfc074714dabd25ae9c8350dda2"><td class="memItemLeft" align="right" valign="top"><a id="a3e705bfc074714dabd25ae9c8350dda2" name="a3e705bfc074714dabd25ae9c8350dda2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CIBStrategy</b> (const unsigned int parts)</td></tr>
<tr class="memdesc:a3e705bfc074714dabd25ae9c8350dda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class. <br /></td></tr>
<tr class="separator:a3e705bfc074714dabd25ae9c8350dda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec1810adf70667459948296002a441a" id="r_a4ec1810adf70667459948296002a441a"><td class="memItemLeft" align="right" valign="top"><a id="a4ec1810adf70667459948296002a441a" name="a4ec1810adf70667459948296002a441a"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~CIBStrategy</b> ()</td></tr>
<tr class="memdesc:a4ec1810adf70667459948296002a441a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the class. <br /></td></tr>
<tr class="separator:a4ec1810adf70667459948296002a441a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573493dce74f45976fb62db1c4102f17" id="r_a573493dce74f45976fb62db1c4102f17"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a573493dce74f45976fb62db1c4102f17">setConstraintForce</a> (Vec L, const double data_time, const double scale=1.0)=0</td></tr>
<tr class="memdesc:a573493dce74f45976fb62db1c4102f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the implementation class for sprading constraint force. In particular, set the constraint Lagrangian force in the internal data structure of the class.  <br /></td></tr>
<tr class="separator:a573493dce74f45976fb62db1c4102f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4682dd04b56f42e5fb3a12d1ed24efed" id="r_a4682dd04b56f42e5fb3a12d1ed24efed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a4682dd04b56f42e5fb3a12d1ed24efed">getConstraintForce</a> (Vec *L, const double data_time)=0</td></tr>
<tr class="memdesc:a4682dd04b56f42e5fb3a12d1ed24efed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the constraint rigid body force at the specified time within the current time interval. Generally, the implementation class maintains and stores the constraint force. This routine is called by constraint solver to update the contraint force after the (converged) solution is obtained.  <br /></td></tr>
<tr class="separator:a4682dd04b56f42e5fb3a12d1ed24efed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121e7ba461b15037c5ddbc4891bad915" id="r_a121e7ba461b15037c5ddbc4891bad915"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a121e7ba461b15037c5ddbc4891bad915">getFreeRigidVelocities</a> (Vec *U, const double data_time)</td></tr>
<tr class="memdesc:a121e7ba461b15037c5ddbc4891bad915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the free rigid velocities (DOFs) at the specified time within the current time interval. This routine is called by constraint solver to update the free rigid DOFs after the (converged) solution is obtained.  <br /></td></tr>
<tr class="separator:a121e7ba461b15037c5ddbc4891bad915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979f20b4bf1208b5e6056a279abd08c4" id="r_a979f20b4bf1208b5e6056a279abd08c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a979f20b4bf1208b5e6056a279abd08c4">getNetExternalForceTorque</a> (Vec *F, const double data_time)</td></tr>
<tr class="memdesc:a979f20b4bf1208b5e6056a279abd08c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get net external force and torque at the specified time within the current time interval. This routine is called by constraint solver to form the appropriate RHS.  <br /></td></tr>
<tr class="separator:a979f20b4bf1208b5e6056a279abd08c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d78c835e925b0f5f55b93edadaacfd" id="r_ad9d78c835e925b0f5f55b93edadaacfd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#ad9d78c835e925b0f5f55b93edadaacfd">subtractMeanConstraintForce</a> (Vec L, int f_data_idx, const double scale=1.0)=0</td></tr>
<tr class="memdesc:ad9d78c835e925b0f5f55b93edadaacfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract the mean of constraint force from the background Eulerian grid. This is required for certain cases like periodic steady Stokes.  <br /></td></tr>
<tr class="separator:ad9d78c835e925b0f5f55b93edadaacfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f38fe08ba19fd622ca931a4b2c54bb9" id="r_a7f38fe08ba19fd622ca931a4b2c54bb9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a7f38fe08ba19fd622ca931a4b2c54bb9">setInterpolatedVelocityVector</a> (Vec V, const double data_time)</td></tr>
<tr class="memdesc:a7f38fe08ba19fd622ca931a4b2c54bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the implementation class for getting the interpolated fluid velocity on the Lagrangian vector <code>V</code>.  <br /></td></tr>
<tr class="separator:a7f38fe08ba19fd622ca931a4b2c54bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778c86c5fadf9ea9ea5657b02a2d5ef2" id="r_a778c86c5fadf9ea9ea5657b02a2d5ef2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a778c86c5fadf9ea9ea5657b02a2d5ef2">getInterpolatedVelocity</a> (Vec V, const double data_time, const double scale=1.0)=0</td></tr>
<tr class="memdesc:a778c86c5fadf9ea9ea5657b02a2d5ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interpolated velocity from the Eulerian grid at the specified time.  <br /></td></tr>
<tr class="separator:a778c86c5fadf9ea9ea5657b02a2d5ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381066ff0fe88d278f3a0d07d4d3a633" id="r_a381066ff0fe88d278f3a0d07d4d3a633"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a381066ff0fe88d278f3a0d07d4d3a633">computeMobilityRegularization</a> (Vec D, Vec L, const double scale=1.0)=0</td></tr>
<tr class="memdesc:a381066ff0fe88d278f3a0d07d4d3a633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute regularization vector for the mobility problem.  <br /></td></tr>
<tr class="separator:a381066ff0fe88d278f3a0d07d4d3a633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac28b98c635db5889693d71f67456cd8" id="r_aac28b98c635db5889693d71f67456cd8"><td class="memItemLeft" align="right" valign="top"><a id="aac28b98c635db5889693d71f67456cd8" name="aac28b98c635db5889693d71f67456cd8"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberOfRigidStructures</b> () const</td></tr>
<tr class="memdesc:aac28b98c635db5889693d71f67456cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of rigid structures registered with this class. <br /></td></tr>
<tr class="separator:aac28b98c635db5889693d71f67456cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22c5d41e5e385eb7720691e0050b4b0" id="r_af22c5d41e5e385eb7720691e0050b4b0"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#af22c5d41e5e385eb7720691e0050b4b0">getNumberOfNodes</a> (const unsigned int part) const =0</td></tr>
<tr class="memdesc:af22c5d41e5e385eb7720691e0050b4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of nodes associated with the particular structure.  <br /></td></tr>
<tr class="separator:af22c5d41e5e385eb7720691e0050b4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc7a6bedd44f4cd0a06df8af06461a1" id="r_a0fc7a6bedd44f4cd0a06df8af06461a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a0fc7a6bedd44f4cd0a06df8af06461a1">setInitialCenterOfMass</a> (const unsigned int part, const Eigen::Vector3d &amp;XCOM_0)</td></tr>
<tr class="memdesc:a0fc7a6bedd44f4cd0a06df8af06461a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the initial center of mass location for the structures.  <br /></td></tr>
<tr class="separator:a0fc7a6bedd44f4cd0a06df8af06461a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c84ef0df606bb8dad89923392de5491" id="r_a0c84ef0df606bb8dad89923392de5491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a0c84ef0df606bb8dad89923392de5491">setSolveRigidBodyVelocity</a> (const unsigned int part, const IBTK::FreeRigidDOFVector &amp;solve_rigid_dofs)</td></tr>
<tr class="memdesc:a0c84ef0df606bb8dad89923392de5491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set what rigid DOFs need to be solved for this particular structure.  <br /></td></tr>
<tr class="separator:a0c84ef0df606bb8dad89923392de5491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b8d632eb42e2e29ac4cf2061eef184" id="r_a55b8d632eb42e2e29ac4cf2061eef184"><td class="memItemLeft" align="right" valign="top"><a id="a55b8d632eb42e2e29ac4cf2061eef184" name="a55b8d632eb42e2e29ac4cf2061eef184"></a>
const IBTK::FreeRigidDOFVector &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSolveRigidBodyVelocity</b> (const unsigned int part, int &amp;num_free_dofs) const</td></tr>
<tr class="memdesc:a55b8d632eb42e2e29ac4cf2061eef184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query what rigid DOFs need to be solved for. <br /></td></tr>
<tr class="separator:a55b8d632eb42e2e29ac4cf2061eef184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b814e860e4713dc9f437f43856a2a0" id="r_a74b814e860e4713dc9f437f43856a2a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a74b814e860e4713dc9f437f43856a2a0">setRigidBodyVelocity</a> (const unsigned int part, const IBTK::RigidDOFVector &amp;U, Vec V)=0</td></tr>
<tr class="memdesc:a74b814e860e4713dc9f437f43856a2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the rigid body velocity at the nodal/marker points contained in the Vec <em>V</em>.  <br /></td></tr>
<tr class="separator:a74b814e860e4713dc9f437f43856a2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac613d5efc96f4d2496c4a466eb95515f" id="r_ac613d5efc96f4d2496c4a466eb95515f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#ac613d5efc96f4d2496c4a466eb95515f">setRigidBodyVelocity</a> (const unsigned int part, Vec U, Vec V)</td></tr>
<tr class="memdesc:ac613d5efc96f4d2496c4a466eb95515f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the rigid body velocity at the nodal/marker points contained in the Vec <em>V</em>.  <br /></td></tr>
<tr class="separator:ac613d5efc96f4d2496c4a466eb95515f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aedcf48f2c8e3b327a3f7c9c33012d9" id="r_a8aedcf48f2c8e3b327a3f7c9c33012d9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a8aedcf48f2c8e3b327a3f7c9c33012d9">setRigidBodyVelocity</a> (Vec U, Vec V, const bool only_free_dofs, const bool only_imposed_dofs, const bool all_dofs=false)</td></tr>
<tr class="memdesc:a8aedcf48f2c8e3b327a3f7c9c33012d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the rigid body velocity at the nodal/marker points contained in the Vec V.  <br /></td></tr>
<tr class="separator:a8aedcf48f2c8e3b327a3f7c9c33012d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3387134bbce5257db7969ef019a1a2" id="r_a9f3387134bbce5257db7969ef019a1a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a9f3387134bbce5257db7969ef019a1a2">computeNetRigidGeneralizedForce</a> (const unsigned int part, Vec L, IBTK::RigidDOFVector &amp;F)=0</td></tr>
<tr class="memdesc:a9f3387134bbce5257db7969ef019a1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute total force and torque on the structure.  <br /></td></tr>
<tr class="separator:a9f3387134bbce5257db7969ef019a1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55cf5d26e834ca92ce20340ac09eba5" id="r_aa55cf5d26e834ca92ce20340ac09eba5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#aa55cf5d26e834ca92ce20340ac09eba5">computeNetRigidGeneralizedForce</a> (const unsigned int part, Vec L, Vec F)</td></tr>
<tr class="memdesc:aa55cf5d26e834ca92ce20340ac09eba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute total force and torque on the structure.  <br /></td></tr>
<tr class="separator:aa55cf5d26e834ca92ce20340ac09eba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d10658e4ec0e662af2c7f0076d9bf1" id="r_a90d10658e4ec0e662af2c7f0076d9bf1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a90d10658e4ec0e662af2c7f0076d9bf1">computeNetRigidGeneralizedForce</a> (Vec L, Vec F, const bool only_free_dofs, const bool only_imposed_dofs, const bool all_dofs=false)</td></tr>
<tr class="memdesc:a90d10658e4ec0e662af2c7f0076d9bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute total force and torque on the structure.  <br /></td></tr>
<tr class="separator:a90d10658e4ec0e662af2c7f0076d9bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5892b8ec96cf31870687b39362eec6f" id="r_aa5892b8ec96cf31870687b39362eec6f"><td class="memItemLeft" align="right" valign="top">const IBTK::RigidDOFVector &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#aa5892b8ec96cf31870687b39362eec6f">getNetRigidGeneralizedForce</a> (const unsigned int part)</td></tr>
<tr class="memdesc:aa5892b8ec96cf31870687b39362eec6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total torque and force on the structure at new_time within the current time interval.  <br /></td></tr>
<tr class="separator:aa5892b8ec96cf31870687b39362eec6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc476b84ad7a6b45321e48474992f7ff" id="r_adc476b84ad7a6b45321e48474992f7ff"><td class="memItemLeft" align="right" valign="top"><a id="adc476b84ad7a6b45321e48474992f7ff" name="adc476b84ad7a6b45321e48474992f7ff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateFreeDOFsMapping</b> ()</td></tr>
<tr class="memdesc:adc476b84ad7a6b45321e48474992f7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the mapping of free DOFs for all structures if they are collected in a global vector. <br /></td></tr>
<tr class="separator:adc476b84ad7a6b45321e48474992f7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46aa12a75eec15beeed92da1a05bf297" id="r_a46aa12a75eec15beeed92da1a05bf297"><td class="memItemLeft" align="right" valign="top"><a id="a46aa12a75eec15beeed92da1a05bf297" name="a46aa12a75eec15beeed92da1a05bf297"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateNewRigidBodyVelocity</b> (const unsigned int part, const IBTK::RigidDOFVector &amp;U)</td></tr>
<tr class="memdesc:a46aa12a75eec15beeed92da1a05bf297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the rigid body velocity obtained from the constraint Stokes solver for free-moving case. <br /></td></tr>
<tr class="separator:a46aa12a75eec15beeed92da1a05bf297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadb163509d0ca86f327fa9e9580b529" id="r_aaadb163509d0ca86f327fa9e9580b529"><td class="memItemLeft" align="right" valign="top"><a id="aaadb163509d0ca86f327fa9e9580b529" name="aaadb163509d0ca86f327fa9e9580b529"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateNewRigidBodyVelocity</b> (const unsigned int part, Vec U)</td></tr>
<tr class="memdesc:aaadb163509d0ca86f327fa9e9580b529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the rigid body velocity obtained from the constraint Stokes solver for free-moving case. <br /></td></tr>
<tr class="separator:aaadb163509d0ca86f327fa9e9580b529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ba22af2d0b3afde292157273f933ff" id="r_a01ba22af2d0b3afde292157273f933ff"><td class="memItemLeft" align="right" valign="top"><a id="a01ba22af2d0b3afde292157273f933ff" name="a01ba22af2d0b3afde292157273f933ff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateNewRigidBodyVelocity</b> (Vec U, const bool only_free_dofs, const bool only_imposed_dofs, const bool all_dofs=false)</td></tr>
<tr class="memdesc:a01ba22af2d0b3afde292157273f933ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the rigid body velocity obtained from the constraint Stokes solver for free-moving case. <br /></td></tr>
<tr class="separator:a01ba22af2d0b3afde292157273f933ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca50a6e3a58400b2df63624eeae2a037" id="r_aca50a6e3a58400b2df63624eeae2a037"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#aca50a6e3a58400b2df63624eeae2a037">copyVecToArray</a> (Vec <a class="elRef" href="../../samrai/2.4.4/html/solv__cartesianrobinbchelper2d_8f.html#e621b6d97e8da0c5028d78a69a4452bf">b</a>, double *<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01918.html">array</a>, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; unsigned &gt; &amp;struct_ids, const int data_depth, const int array_rank)</td></tr>
<tr class="memdesc:aca50a6e3a58400b2df63624eeae2a037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from distributed PETSc Vec for specified stucture indices to an array defined on a single processor. A default empty implementation is provided.  <br /></td></tr>
<tr class="separator:aca50a6e3a58400b2df63624eeae2a037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfbf6ea361c5936e8d5844c9bc68674" id="r_a7cfbf6ea361c5936e8d5844c9bc68674"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a7cfbf6ea361c5936e8d5844c9bc68674">copyFreeDOFsVecToArray</a> (Vec <a class="elRef" href="../../samrai/2.4.4/html/solv__cartesianrobinbchelper2d_8f.html#e621b6d97e8da0c5028d78a69a4452bf">b</a>, double *<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01918.html">array</a>, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; unsigned &gt; &amp;struct_ids, const int array_rank)</td></tr>
<tr class="memdesc:a7cfbf6ea361c5936e8d5844c9bc68674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from distributed PETSc Vec for specified stucture indices to an array defined on a single processor. A default implementation is provided.  <br /></td></tr>
<tr class="separator:a7cfbf6ea361c5936e8d5844c9bc68674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a8e37ca4699b7c3ead810e0a877fad" id="r_a14a8e37ca4699b7c3ead810e0a877fad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a14a8e37ca4699b7c3ead810e0a877fad">copyArrayToVec</a> (Vec <a class="elRef" href="../../samrai/2.4.4/html/solv__cartesianrobinbchelper2d_8f.html#e621b6d97e8da0c5028d78a69a4452bf">b</a>, double *<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01918.html">array</a>, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; unsigned &gt; &amp;struct_ids, const int data_depth, const int array_rank)</td></tr>
<tr class="memdesc:a14a8e37ca4699b7c3ead810e0a877fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from array defined on a single processor for specified stucture indices to distributed PETScVec. A default empty implementation is provided.  <br /></td></tr>
<tr class="separator:a14a8e37ca4699b7c3ead810e0a877fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad543fc8d11125d54d5320aef2a50301b" id="r_ad543fc8d11125d54d5320aef2a50301b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#ad543fc8d11125d54d5320aef2a50301b">copyFreeDOFsArrayToVec</a> (Vec <a class="elRef" href="../../samrai/2.4.4/html/solv__cartesianrobinbchelper2d_8f.html#e621b6d97e8da0c5028d78a69a4452bf">b</a>, double *<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01918.html">array</a>, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; unsigned &gt; &amp;struct_ids, const int array_rank)</td></tr>
<tr class="memdesc:ad543fc8d11125d54d5320aef2a50301b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from array defined on a single processor for specified stucture indices to distributed PETScVec. A default implementation is provided.  <br /></td></tr>
<tr class="separator:ad543fc8d11125d54d5320aef2a50301b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e57bb1d7568e9f2e1ba1954c603eb35" id="r_a6e57bb1d7568e9f2e1ba1954c603eb35"><td class="memItemLeft" align="right" valign="top"><a id="a6e57bb1d7568e9f2e1ba1954c603eb35" name="a6e57bb1d7568e9f2e1ba1954c603eb35"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentRigidBodyVelocity</b> (const unsigned int part, IBTK::RigidDOFVector &amp;U)</td></tr>
<tr class="memdesc:a6e57bb1d7568e9f2e1ba1954c603eb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rigid body translational velocity at the beginning of the timestep. <br /></td></tr>
<tr class="separator:a6e57bb1d7568e9f2e1ba1954c603eb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eff8796b3637e0f4731b32762d9154f" id="r_a5eff8796b3637e0f4731b32762d9154f"><td class="memItemLeft" align="right" valign="top"><a id="a5eff8796b3637e0f4731b32762d9154f" name="a5eff8796b3637e0f4731b32762d9154f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getNewRigidBodyVelocity</b> (const unsigned int part, IBTK::RigidDOFVector &amp;U)</td></tr>
<tr class="memdesc:a5eff8796b3637e0f4731b32762d9154f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rigid body translational velocity at the end of the timestep. <br /></td></tr>
<tr class="separator:a5eff8796b3637e0f4731b32762d9154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cf5c9e94431ac4e49b8399113e5b19" id="r_ac1cf5c9e94431ac4e49b8399113e5b19"><td class="memItemLeft" align="right" valign="top"><a id="ac1cf5c9e94431ac4e49b8399113e5b19" name="ac1cf5c9e94431ac4e49b8399113e5b19"></a>
const Eigen::Vector3d &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentBodyCenterOfMass</b> (const unsigned int part)</td></tr>
<tr class="memdesc:ac1cf5c9e94431ac4e49b8399113e5b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get body center of mass at the current time step. <br /></td></tr>
<tr class="separator:ac1cf5c9e94431ac4e49b8399113e5b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4422fc21c4fd9a406be1e7d0b6bc5de" id="r_ab4422fc21c4fd9a406be1e7d0b6bc5de"><td class="memItemLeft" align="right" valign="top"><a id="ab4422fc21c4fd9a406be1e7d0b6bc5de" name="ab4422fc21c4fd9a406be1e7d0b6bc5de"></a>
const Eigen::Vector3d &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getNewBodyCenterOfMass</b> (const unsigned int part)</td></tr>
<tr class="memdesc:ab4422fc21c4fd9a406be1e7d0b6bc5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get body center of mass at half time step. <br /></td></tr>
<tr class="separator:ab4422fc21c4fd9a406be1e7d0b6bc5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d701f11346e0a86cf9e964c8fbdbb1" id="r_a81d701f11346e0a86cf9e964c8fbdbb1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a81d701f11346e0a86cf9e964c8fbdbb1">constructMobilityMatrix</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01653.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;mat_name, <a class="el" href="namespace_i_b_a_m_r.html#a591304f336aef144a5ae4595cffc3f70">MobilityMatrixType</a> mat_type, Mat &amp;mobility_mat, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; unsigned &gt; &amp;prototype_struct_ids, const double *grid_dx, const double *domain_extents, const bool initial_time, double rho, double mu, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07166.html">std::pair</a>&lt; double, double &gt; &amp;scale, double f_periodic_corr, const int managing_rank)</td></tr>
<tr class="memdesc:a81d701f11346e0a86cf9e964c8fbdbb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct dense mobility matrix for the prototypical structures identified by their indices.  <br /></td></tr>
<tr class="separator:a81d701f11346e0a86cf9e964c8fbdbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779940b90dd0ff8a5bd7d2fff703bc35" id="r_a779940b90dd0ff8a5bd7d2fff703bc35"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a779940b90dd0ff8a5bd7d2fff703bc35">constructGeometricMatrix</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01653.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;mat_name, Mat &amp;geometric_mat, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; unsigned &gt; &amp;prototype_struct_ids, const bool initial_time, const int managing_rank)</td></tr>
<tr class="memdesc:a779940b90dd0ff8a5bd7d2fff703bc35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a geometric matrix for the prototypical structures identified by their indices. A geometric matrix maps center of mass rigid body velocity to nodal velocities. Geometric matrix is generally used with a dense mobility matrices to construct an associated body-mobility matrix algebrically.  <br /></td></tr>
<tr class="separator:a779940b90dd0ff8a5bd7d2fff703bc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa46371e9674b3997952b8ad8d9b04d0" id="r_aaa46371e9674b3997952b8ad8d9b04d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#aaa46371e9674b3997952b8ad8d9b04d0">rotateArray</a> (double *<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01918.html">array</a>, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; unsigned &gt; &amp;struct_ids, const bool use_transpose, const int managing_rank, const int <a class="elRef" href="../../samrai/2.4.4/html/algs__nodeouternodeops2d_8f.html#9caca90cc65f72a7168924922fa5d34e">depth</a>)</td></tr>
<tr class="memdesc:aaa46371e9674b3997952b8ad8d9b04d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate vector using rotation matrix to/from the reference frame of the structures (which is at the initial time of the simulation).  <br /></td></tr>
<tr class="separator:aaa46371e9674b3997952b8ad8d9b04d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a215484112996c974eb4c2e9bcbb2293d" id="r_a215484112996c974eb4c2e9bcbb2293d"><td class="memItemLeft" align="right" valign="top"><a id="a215484112996c974eb4c2e9bcbb2293d" name="a215484112996c974eb4c2e9bcbb2293d"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>vecToRDV</b> (Vec U, IBTK::RigidDOFVector &amp;Ur)</td></tr>
<tr class="memdesc:a215484112996c974eb4c2e9bcbb2293d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the DOFs from PETSc Vec <code>U</code> to RigidDOFVector <code>Ur</code>. <br /></td></tr>
<tr class="separator:a215484112996c974eb4c2e9bcbb2293d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30803fe27fdcf1b2ab01e67ae10dc9db" id="r_a30803fe27fdcf1b2ab01e67ae10dc9db"><td class="memItemLeft" align="right" valign="top"><a id="a30803fe27fdcf1b2ab01e67ae10dc9db" name="a30803fe27fdcf1b2ab01e67ae10dc9db"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>rdvToVec</b> (const IBTK::RigidDOFVector &amp;Ur, Vec &amp;U)</td></tr>
<tr class="memdesc:a30803fe27fdcf1b2ab01e67ae10dc9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the DOFs from RigidDOFVector <code>Ur</code> to PETSc Vec <code>U</code>. <br /></td></tr>
<tr class="separator:a30803fe27fdcf1b2ab01e67ae10dc9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af235024d7e246bdcf736a5a4ffbfa593" id="r_af235024d7e246bdcf736a5a4ffbfa593"><td class="memItemLeft" align="right" valign="top"><a id="af235024d7e246bdcf736a5a4ffbfa593" name="af235024d7e246bdcf736a5a4ffbfa593"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>eigenToRDV</b> (const Eigen::Vector3d &amp;U, const Eigen::Vector3d &amp;W, IBTK::RigidDOFVector &amp;UW)</td></tr>
<tr class="memdesc:af235024d7e246bdcf736a5a4ffbfa593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the DOFs from Eigen::Vector3d <code>U</code> and <code>W</code> to RigidDOFVector <code>UW</code>. <br /></td></tr>
<tr class="separator:af235024d7e246bdcf736a5a4ffbfa593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4725daa33f4d8f871898a80828f733a3" id="r_a4725daa33f4d8f871898a80828f733a3"><td class="memItemLeft" align="right" valign="top"><a id="a4725daa33f4d8f871898a80828f733a3" name="a4725daa33f4d8f871898a80828f733a3"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>rdvToEigen</b> (const IBTK::RigidDOFVector &amp;UW, Eigen::Vector3d &amp;U, Eigen::Vector3d &amp;W)</td></tr>
<tr class="memdesc:a4725daa33f4d8f871898a80828f733a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the DOFs from RigidDOFVector <code>UW</code> to Eigen::Vector3d <code>U</code> and <code>W</code>. <br /></td></tr>
<tr class="separator:a4725daa33f4d8f871898a80828f733a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a087733d93ea9af2d37c730dbb86f83a2" id="r_a087733d93ea9af2d37c730dbb86f83a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a087733d93ea9af2d37c730dbb86f83a2">setRotationMatrix</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Vector3d &gt; &amp;rot_vel, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Quaterniond &gt; &amp;q_old, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Quaterniond &gt; &amp;q_new, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Matrix3d &gt; &amp;rot_mat, const double dt)</td></tr>
<tr class="memdesc:a087733d93ea9af2d37c730dbb86f83a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the rotation matrix.  <br /></td></tr>
<tr class="separator:a087733d93ea9af2d37c730dbb86f83a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a78c7b5094d5a3d78ea27f119d13a84cb" id="r_a78c7b5094d5a3d78ea27f119d13a84cb"><td class="memItemLeft" align="right" valign="top"><a id="a78c7b5094d5a3d78ea27f119d13a84cb" name="a78c7b5094d5a3d78ea27f119d13a84cb"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>d_num_rigid_parts</b></td></tr>
<tr class="separator:a78c7b5094d5a3d78ea27f119d13a84cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9605c08a1475a205eff9afe1aa6a6697" id="r_a9605c08a1475a205eff9afe1aa6a6697"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a9605c08a1475a205eff9afe1aa6a6697">d_center_of_mass_initial</a></td></tr>
<tr class="separator:a9605c08a1475a205eff9afe1aa6a6697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe66c1c916ebf8cc41a50e0d176de75a" id="r_abe66c1c916ebf8cc41a50e0d176de75a"><td class="memItemLeft" align="right" valign="top"><a id="abe66c1c916ebf8cc41a50e0d176de75a" name="abe66c1c916ebf8cc41a50e0d176de75a"></a>
<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>d_center_of_mass_current</b></td></tr>
<tr class="separator:abe66c1c916ebf8cc41a50e0d176de75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac8a64acf8f7af721cad92aee80bbb1" id="r_a9ac8a64acf8f7af721cad92aee80bbb1"><td class="memItemLeft" align="right" valign="top"><a id="a9ac8a64acf8f7af721cad92aee80bbb1" name="a9ac8a64acf8f7af721cad92aee80bbb1"></a>
<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>d_center_of_mass_half</b></td></tr>
<tr class="separator:a9ac8a64acf8f7af721cad92aee80bbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c8cc709ffdd9adb602d079665fcf48" id="r_ac7c8cc709ffdd9adb602d079665fcf48"><td class="memItemLeft" align="right" valign="top"><a id="ac7c8cc709ffdd9adb602d079665fcf48" name="ac7c8cc709ffdd9adb602d079665fcf48"></a>
<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>d_center_of_mass_new</b></td></tr>
<tr class="separator:ac7c8cc709ffdd9adb602d079665fcf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b378a544fd6b8a871abe3ec3807d98" id="r_af5b378a544fd6b8a871abe3ec3807d98"><td class="memItemLeft" align="right" valign="top"><a id="af5b378a544fd6b8a871abe3ec3807d98" name="af5b378a544fd6b8a871abe3ec3807d98"></a>
<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>d_compute_center_of_mass_initial</b></td></tr>
<tr class="separator:af5b378a544fd6b8a871abe3ec3807d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0997a2def8f09191bfa55a29e90c969" id="r_af0997a2def8f09191bfa55a29e90c969"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Quaterniond &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#af0997a2def8f09191bfa55a29e90c969">d_quaternion_current</a></td></tr>
<tr class="separator:af0997a2def8f09191bfa55a29e90c969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac429d5ed3731531af860043d007aec6a" id="r_ac429d5ed3731531af860043d007aec6a"><td class="memItemLeft" align="right" valign="top"><a id="ac429d5ed3731531af860043d007aec6a" name="ac429d5ed3731531af860043d007aec6a"></a>
<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Quaterniond &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>d_quaternion_half</b></td></tr>
<tr class="separator:ac429d5ed3731531af860043d007aec6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac219c2dad3198f4452eb91caa19d2d80" id="r_ac219c2dad3198f4452eb91caa19d2d80"><td class="memItemLeft" align="right" valign="top"><a id="ac219c2dad3198f4452eb91caa19d2d80" name="ac219c2dad3198f4452eb91caa19d2d80"></a>
<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Quaterniond &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>d_quaternion_new</b></td></tr>
<tr class="separator:ac219c2dad3198f4452eb91caa19d2d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd7755ec6ff2466d39205ba1eb007fe" id="r_adfd7755ec6ff2466d39205ba1eb007fe"><td class="memItemLeft" align="right" valign="top"><a id="adfd7755ec6ff2466d39205ba1eb007fe" name="adfd7755ec6ff2466d39205ba1eb007fe"></a>
<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; IBTK::FRDV &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>d_solve_rigid_vel</b></td></tr>
<tr class="separator:adfd7755ec6ff2466d39205ba1eb007fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22ae8b85ca8df0fd9b812fdb4b5692b" id="r_ab22ae8b85ca8df0fd9b812fdb4b5692b"><td class="memItemLeft" align="right" valign="top"><a id="ab22ae8b85ca8df0fd9b812fdb4b5692b" name="ab22ae8b85ca8df0fd9b812fdb4b5692b"></a>
Vec&#160;</td><td class="memItemRight" valign="bottom"><b>d_U</b></td></tr>
<tr class="separator:ab22ae8b85ca8df0fd9b812fdb4b5692b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b7f78c9725bab72d66fbe6af279fea" id="r_a08b7f78c9725bab72d66fbe6af279fea"><td class="memItemLeft" align="right" valign="top"><a id="a08b7f78c9725bab72d66fbe6af279fea" name="a08b7f78c9725bab72d66fbe6af279fea"></a>
Vec&#160;</td><td class="memItemRight" valign="bottom"><b>d_F</b></td></tr>
<tr class="separator:a08b7f78c9725bab72d66fbe6af279fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7fd46d9caa77a2a5c73d300fecc1ac" id="r_a2b7fd46d9caa77a2a5c73d300fecc1ac"><td class="memItemLeft" align="right" valign="top"><a id="a2b7fd46d9caa77a2a5c73d300fecc1ac" name="a2b7fd46d9caa77a2a5c73d300fecc1ac"></a>
<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07166.html">std::pair</a>&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>d_free_dofs_map</b></td></tr>
<tr class="separator:a2b7fd46d9caa77a2a5c73d300fecc1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07a284a69aeca5ca96bf5b973e79ebf" id="r_ab07a284a69aeca5ca96bf5b973e79ebf"><td class="memItemLeft" align="right" valign="top"><a id="ab07a284a69aeca5ca96bf5b973e79ebf" name="ab07a284a69aeca5ca96bf5b973e79ebf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>d_free_dofs_map_updated</b></td></tr>
<tr class="separator:ab07a284a69aeca5ca96bf5b973e79ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f327733ed226b3dab4570a091b8f320" id="r_a1f327733ed226b3dab4570a091b8f320"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html#a1f327733ed226b3dab4570a091b8f320">d_trans_vel_current</a></td></tr>
<tr class="separator:a1f327733ed226b3dab4570a091b8f320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aec9a253505c8aec29c7fa61d1fb679" id="r_a8aec9a253505c8aec29c7fa61d1fb679"><td class="memItemLeft" align="right" valign="top"><a id="a8aec9a253505c8aec29c7fa61d1fb679" name="a8aec9a253505c8aec29c7fa61d1fb679"></a>
<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>d_trans_vel_half</b></td></tr>
<tr class="separator:a8aec9a253505c8aec29c7fa61d1fb679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72aa507b4762f5e2ab47f04b7c7a975f" id="r_a72aa507b4762f5e2ab47f04b7c7a975f"><td class="memItemLeft" align="right" valign="top"><a id="a72aa507b4762f5e2ab47f04b7c7a975f" name="a72aa507b4762f5e2ab47f04b7c7a975f"></a>
<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>d_trans_vel_new</b></td></tr>
<tr class="separator:a72aa507b4762f5e2ab47f04b7c7a975f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84feb76bf0b3cdfdcbffab8d876cde9f" id="r_a84feb76bf0b3cdfdcbffab8d876cde9f"><td class="memItemLeft" align="right" valign="top"><a id="a84feb76bf0b3cdfdcbffab8d876cde9f" name="a84feb76bf0b3cdfdcbffab8d876cde9f"></a>
<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>d_rot_vel_current</b></td></tr>
<tr class="separator:a84feb76bf0b3cdfdcbffab8d876cde9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afc85a233ca21712f4ad4e785676083" id="r_a3afc85a233ca21712f4ad4e785676083"><td class="memItemLeft" align="right" valign="top"><a id="a3afc85a233ca21712f4ad4e785676083" name="a3afc85a233ca21712f4ad4e785676083"></a>
<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>d_rot_vel_half</b></td></tr>
<tr class="separator:a3afc85a233ca21712f4ad4e785676083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d45fbba4a53b330b711f8e1eb869dbb" id="r_a3d45fbba4a53b330b711f8e1eb869dbb"><td class="memItemLeft" align="right" valign="top"><a id="a3d45fbba4a53b330b711f8e1eb869dbb" name="a3d45fbba4a53b330b711f8e1eb869dbb"></a>
<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>d_rot_vel_new</b></td></tr>
<tr class="separator:a3d45fbba4a53b330b711f8e1eb869dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a571c74a9f31de87ea505275f416f7e" id="r_a8a571c74a9f31de87ea505275f416f7e"><td class="memItemLeft" align="right" valign="top"><a id="a8a571c74a9f31de87ea505275f416f7e" name="a8a571c74a9f31de87ea505275f416f7e"></a>
<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; IBTK::RigidDOFVector &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>d_net_rigid_generalized_force</b></td></tr>
<tr class="separator:a8a571c74a9f31de87ea505275f416f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_strategy.html" title="Class CIBStrategy is a lightweight abstract strategy class which provides support for constraint base...">CIBStrategy</a> is a lightweight abstract strategy class which provides support for constraint based IB methods for rigid bodies. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a381066ff0fe88d278f3a0d07d4d3a633" name="a381066ff0fe88d278f3a0d07d4d3a633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381066ff0fe88d278f3a0d07d4d3a633">&#9670;&#160;</a></span>computeMobilityRegularization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::computeMobilityRegularization </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute regularization vector for the mobility problem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Vector containing the regularization for the mobility problem.</td></tr>
    <tr><td class="paramname">L</td><td>Vector from which regularization is to be computed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#a83a48b1fb791aa8944ac5fcdd0ba40b8">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a9f3387134bbce5257db7969ef019a1a2" name="a9f3387134bbce5257db7969ef019a1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3387134bbce5257db7969ef019a1a2">&#9670;&#160;</a></span>computeNetRigidGeneralizedForce() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::computeNetRigidGeneralizedForce </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IBTK::RigidDOFVector &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute total force and torque on the structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The Lagrange multiplier vector.</td></tr>
    <tr><td class="paramname">F</td><td>Vector RDV storing the net generalized force.</td></tr>
    <tr><td class="paramname">F</td><td>RDV storing the net generalized force. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#a1351588b3bbeda76d138b1565bec1776">IBAMR::CIBMethod</a>, and <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#a9f3387134bbce5257db7969ef019a1a2">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="aa55cf5d26e834ca92ce20340ac09eba5" name="aa55cf5d26e834ca92ce20340ac09eba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55cf5d26e834ca92ce20340ac09eba5">&#9670;&#160;</a></span>computeNetRigidGeneralizedForce() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::computeNetRigidGeneralizedForce </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute total force and torque on the structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The structure index.</td></tr>
    <tr><td class="paramname">L</td><td>The Lagrange multiplier vector.</td></tr>
    <tr><td class="paramname">F</td><td>Vec storing the net generalized force. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#aa55cf5d26e834ca92ce20340ac09eba5">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a90d10658e4ec0e662af2c7f0076d9bf1" name="a90d10658e4ec0e662af2c7f0076d9bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d10658e4ec0e662af2c7f0076d9bf1">&#9670;&#160;</a></span>computeNetRigidGeneralizedForce() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::computeNetRigidGeneralizedForce </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>only_free_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>only_imposed_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>all_dofs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute total force and torque on the structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The Lagrange multiplier vector. </td></tr>
    <tr><td class="paramname">F</td><td>Vec storing the net generalized force.</td></tr>
    <tr><td class="paramname">only_free_dofs</td><td>Boolean indicating if the net generalized force and torque is to be computed only for free dofs of all bodies.</td></tr>
    <tr><td class="paramname">only_imposed_dofs</td><td>Boolean indicating if the net generalized force and torque is to be computed for imposed dofs of all bodies.</td></tr>
    <tr><td class="paramname">all_dofs</td><td>Boolean indicating if the net generalized force and torque is to be computed for all dofs of all bodies.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>User is responsible for setting correct number of subvecs in F that corresponds to the particular combination of booleans. </dd></dl>

<p>Reimplemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#a90d10658e4ec0e662af2c7f0076d9bf1">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a779940b90dd0ff8a5bd7d2fff703bc35" name="a779940b90dd0ff8a5bd7d2fff703bc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779940b90dd0ff8a5bd7d2fff703bc35">&#9670;&#160;</a></span>constructGeometricMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::constructGeometricMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01653.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>mat_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>geometric_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>prototype_struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>managing_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a geometric matrix for the prototypical structures identified by their indices. A geometric matrix maps center of mass rigid body velocity to nodal velocities. Geometric matrix is generally used with a dense mobility matrices to construct an associated body-mobility matrix algebrically. </p>
<dl class="section note"><dt>Note</dt><dd>A default empty implementation is provided in this class. The derived class provides the actual implementation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_name</td><td>Matrix handle.</td></tr>
    <tr><td class="paramname">geometric_mat</td><td>Dense sequential geometric matrix. The matrix is stored in column-major(FORTRAN) order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Must be allocated prior to entering this routine.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prototype_struct_ids</td><td>Indices of the structures as registered with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i_b_a_m_r_1_1_i_b_strategy.html" title="Class IBStrategy provides a generic interface for specifying the implementation details of a particul...">IBAMR::IBStrategy</a> class. A combined block-diagonal geometric matrix will be formed for multiple structures.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_time</td><td>Boolean to indicate if the corresponding geometric matrix is to be generated for the initial position of the structures.</td></tr>
    <tr><td class="paramname">managing_rank</td><td>Rank of the processor managing this dense matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#a649e4ca9381f49dc39a90b7411fccd3a">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a81d701f11346e0a86cf9e964c8fbdbb1" name="a81d701f11346e0a86cf9e964c8fbdbb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d701f11346e0a86cf9e964c8fbdbb1">&#9670;&#160;</a></span>constructMobilityMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::constructMobilityMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01653.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>mat_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_i_b_a_m_r.html#a591304f336aef144a5ae4595cffc3f70">MobilityMatrixType</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>mobility_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>prototype_struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>grid_dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>domain_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07166.html">std::pair</a>&lt; double, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f_periodic_corr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>managing_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct dense mobility matrix for the prototypical structures identified by their indices. </p>
<dl class="section note"><dt>Note</dt><dd>A default empty implementation is provided in this class. The derived class provides the actual implementation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_name</td><td>Matrix handle.</td></tr>
    <tr><td class="paramname">mat_type</td><td>Mobility matrix type, e.g., RPY, EMPIRICAL, etc.</td></tr>
    <tr><td class="paramname">mobility_mat</td><td>Dense sequential mobility matrix. The matrix is stored in column-major(FORTRAN) order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Must be allocated prior to entering this routine.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prototype_struct_ids</td><td>Indices of the structures as registered with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i_b_a_m_r_1_1_i_b_strategy.html" title="Class IBStrategy provides a generic interface for specifying the implementation details of a particul...">IBAMR::IBStrategy</a> class. A combined dense mobility matrix will formed for multiple structures.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid_dx</td><td>NDIM vector of grid spacing of structure level.</td></tr>
    <tr><td class="paramname">domain_extents</td><td>NDIM vector of domain length.</td></tr>
    <tr><td class="paramname">initial_time</td><td>Boolean to indicate if the mobility matrix is to be generated for the initial position of the structures.</td></tr>
    <tr><td class="paramname">rho</td><td>Fluid density</td></tr>
    <tr><td class="paramname">mu</td><td>Fluid viscosity.</td></tr>
    <tr><td class="paramname">scale</td><td>Scale for improving the conditioning number of dense mobility matrix. The matrix is scaled as: <picture><source srcset="form_88_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$  = \alpha * mobility_mat + \beta * identity_mat. $" src="form_88.png"/></picture></td></tr>
    <tr><td class="paramname">managing_rank</td><td>Rank of the processor managing this dense matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#a7a6d6ef7fa9cfcc376571763c27f5375">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a14a8e37ca4699b7c3ead810e0a877fad" name="a14a8e37ca4699b7c3ead810e0a877fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a8e37ca4699b7c3ead810e0a877fad">&#9670;&#160;</a></span>copyArrayToVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::copyArrayToVec </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>data_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>array_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data from array defined on a single processor for specified stucture indices to distributed PETScVec. A default empty implementation is provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Copy to PETSc Vec.</td></tr>
    <tr><td class="paramname">array</td><td>Copy from data pointer.</td></tr>
    <tr><td class="paramname">struct_ids</td><td>Vector of structure indices.</td></tr>
    <tr><td class="paramname">data_depth</td><td>Depth of the data stored at each Lagrangian node.</td></tr>
    <tr><td class="paramname">array_rank</td><td>Rank of the processor on which the array is located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The size of <em>array</em> is assummed to be sum of nodes of all the structures given in <em>struct_ids</em> times the <em>data_depth</em>. The caller is responsible for allocating and destroying array memory outside of this routine. </dd></dl>

<p>Reimplemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#aed267e3dc9ec08c21ea8bab8bf4bb7fd">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="ad543fc8d11125d54d5320aef2a50301b" name="ad543fc8d11125d54d5320aef2a50301b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad543fc8d11125d54d5320aef2a50301b">&#9670;&#160;</a></span>copyFreeDOFsArrayToVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::copyFreeDOFsArrayToVec </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>array_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data from array defined on a single processor for specified stucture indices to distributed PETScVec. A default implementation is provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Copy to PETSc Vec. The Vec stores only free DOFs of <em>all</em> the structures.</td></tr>
    <tr><td class="paramname">array</td><td>Copy from data pointer. It is a linear array of maximum free DOFs of the passed structure IDs.</td></tr>
    <tr><td class="paramname">struct_ids</td><td>Vector of structure indices.</td></tr>
    <tr><td class="paramname">array_rank</td><td>Rank of the processor on which the array is located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The size of <em>array</em> is assummed to be sum of maximum number of free degrees of freedom of all the structures given in <em>struct_ids</em>. The caller is responsible for allocating and destroying array memory outside of this routine. </dd></dl>

</div>
</div>
<a id="a7cfbf6ea361c5936e8d5844c9bc68674" name="a7cfbf6ea361c5936e8d5844c9bc68674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfbf6ea361c5936e8d5844c9bc68674">&#9670;&#160;</a></span>copyFreeDOFsVecToArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::copyFreeDOFsVecToArray </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>array_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data from distributed PETSc Vec for specified stucture indices to an array defined on a single processor. A default implementation is provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>PETSc Vec to copy from. The Vec stores only free DOFs of <em>all</em> the structures.</td></tr>
    <tr><td class="paramname">array</td><td>Data pointer to copy to. It is a linear array of maximum free DOFs of the passed structure IDs.</td></tr>
    <tr><td class="paramname">struct_ids</td><td>Vector of structure indices.</td></tr>
    <tr><td class="paramname">array_rank</td><td>Rank of the processor on which the array is located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The size of <em>array</em> is assummed to be sum of maximum number of free degrees of freedom of all the structures given in <em>struct_ids</em>. The caller is responsible for allocating and destroying array memory outside of this routine. </dd></dl>

</div>
</div>
<a id="aca50a6e3a58400b2df63624eeae2a037" name="aca50a6e3a58400b2df63624eeae2a037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca50a6e3a58400b2df63624eeae2a037">&#9670;&#160;</a></span>copyVecToArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::copyVecToArray </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>data_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>array_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data from distributed PETSc Vec for specified stucture indices to an array defined on a single processor. A default empty implementation is provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>PETSc Vec to copy from. The Vec stores data for nodal/marker points.</td></tr>
    <tr><td class="paramname">array</td><td>Data pointer to copy to.</td></tr>
    <tr><td class="paramname">struct_ids</td><td>Vector of structure indices.</td></tr>
    <tr><td class="paramname">data_depth</td><td>Depth of the data stored at each Lagrangian node.</td></tr>
    <tr><td class="paramname">array_rank</td><td>Rank of the processor on which the array is located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The size of <em>array</em> is assummed to be sum of nodes of all the structures given in <em>struct_ids</em> times the <em>data_depth</em>. </dd></dl>

<p>Reimplemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#a2fefde49aaede47f291596c329e65653">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a4682dd04b56f42e5fb3a12d1ed24efed" name="a4682dd04b56f42e5fb3a12d1ed24efed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4682dd04b56f42e5fb3a12d1ed24efed">&#9670;&#160;</a></span>getConstraintForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::getConstraintForce </td>
          <td>(</td>
          <td class="paramtype">Vec *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the constraint rigid body force at the specified time within the current time interval. Generally, the implementation class maintains and stores the constraint force. This routine is called by constraint solver to update the contraint force after the (converged) solution is obtained. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Time (current_time or new_time) at which constraint force is required. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#af45b029cc8728c27286c2bcc694fc310">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a121e7ba461b15037c5ddbc4891bad915" name="a121e7ba461b15037c5ddbc4891bad915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121e7ba461b15037c5ddbc4891bad915">&#9670;&#160;</a></span>getFreeRigidVelocities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::getFreeRigidVelocities </td>
          <td>(</td>
          <td class="paramtype">Vec *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the free rigid velocities (DOFs) at the specified time within the current time interval. This routine is called by constraint solver to update the free rigid DOFs after the (converged) solution is obtained. </p>
<dl class="section note"><dt>Note</dt><dd>A default implementation is provided that returns the vector of free DOFs.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Time (current_time or new_time) at which constraint force is required. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#ad4835128d49df6cf81c36fcd4fefa113">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a778c86c5fadf9ea9ea5657b02a2d5ef2" name="a778c86c5fadf9ea9ea5657b02a2d5ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778c86c5fadf9ea9ea5657b02a2d5ef2">&#9670;&#160;</a></span>getInterpolatedVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::getInterpolatedVelocity </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the interpolated velocity from the Eulerian grid at the specified time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>Vector that should contain the interpolated velocity.</td></tr>
    <tr><td class="paramname">data_time</td><td>Time at which Eulerian velocity is to be interpolated.</td></tr>
    <tr><td class="paramname">scale</td><td>Scales the velocity vector after interpolating from the Eulerian grid. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#a0ed97c5c4495ccd3b4f58dcde10e871e">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a979f20b4bf1208b5e6056a279abd08c4" name="a979f20b4bf1208b5e6056a279abd08c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979f20b4bf1208b5e6056a279abd08c4">&#9670;&#160;</a></span>getNetExternalForceTorque()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::getNetExternalForceTorque </td>
          <td>(</td>
          <td class="paramtype">Vec *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get net external force and torque at the specified time within the current time interval. This routine is called by constraint solver to form the appropriate RHS. </p>
<dl class="section note"><dt>Note</dt><dd>A default implementation is provided that returns the vector of net external force and torque for the corresponding free DOFs.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Time (current_time or new_time) at which external force and torque is required. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#a2b98203ac819fcdb2afb4f64bdfa6ca2">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="aa5892b8ec96cf31870687b39362eec6f" name="aa5892b8ec96cf31870687b39362eec6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5892b8ec96cf31870687b39362eec6f">&#9670;&#160;</a></span>getNetRigidGeneralizedForce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const RigidDOFVector &amp; IBAMR::CIBStrategy::getNetRigidGeneralizedForce </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get total torque and force on the structure at new_time within the current time interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The rigid part. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af22c5d41e5e385eb7720691e0050b4b0" name="af22c5d41e5e385eb7720691e0050b4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22c5d41e5e385eb7720691e0050b4b0">&#9670;&#160;</a></span>getNumberOfNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int IBAMR::CIBStrategy::getNumberOfNodes </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of nodes associated with the particular structure. </p>

<p>Implemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#ad117216876ac8f3ba82873f9732f7774">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="aaa46371e9674b3997952b8ad8d9b04d0" name="aaa46371e9674b3997952b8ad8d9b04d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa46371e9674b3997952b8ad8d9b04d0">&#9670;&#160;</a></span>rotateArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::rotateArray </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_transpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>managing_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate vector using rotation matrix to/from the reference frame of the structures (which is at the initial time of the simulation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Raw data pointer containing the vector enteries.</td></tr>
    <tr><td class="paramname">struct_ids</td><td>Structure ID indices.</td></tr>
    <tr><td class="paramname">use_transpose</td><td>Use transpose of rotation matrix to rotate the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Transpose of rotation matrix is its inverse and it takes the vector back to its reference frame.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">managing_rank</td><td>Rank of the processor managing the matrix.</td></tr>
    <tr><td class="paramname">depth</td><td>Depth of the data array components. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#aa5361e9c9f9875c55a82c6185886592b">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a573493dce74f45976fb62db1c4102f17" name="a573493dce74f45976fb62db1c4102f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573493dce74f45976fb62db1c4102f17">&#9670;&#160;</a></span>setConstraintForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::setConstraintForce </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare the implementation class for sprading constraint force. In particular, set the constraint Lagrangian force in the internal data structure of the class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Vec containing the constraint force for all structures.</td></tr>
    <tr><td class="paramname">data_time</td><td>Time at which constraint force is to be spread.</td></tr>
    <tr><td class="paramname">scale</td><td>Scales the constraint force before spreading. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#ab5b21e4a631bea521aaa8e7bc39707c3">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a0fc7a6bedd44f4cd0a06df8af06461a1" name="a0fc7a6bedd44f4cd0a06df8af06461a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc7a6bedd44f4cd0a06df8af06461a1">&#9670;&#160;</a></span>setInitialCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::setInitialCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>XCOM_0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the initial center of mass location for the structures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The rigid body for which we are setting the initial center of mass position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f38fe08ba19fd622ca931a4b2c54bb9" name="a7f38fe08ba19fd622ca931a4b2c54bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f38fe08ba19fd622ca931a4b2c54bb9">&#9670;&#160;</a></span>setInterpolatedVelocityVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::setInterpolatedVelocityVector </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare the implementation class for getting the interpolated fluid velocity on the Lagrangian vector <code>V</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>Vector that should contain the interpolated velocity.</td></tr>
    <tr><td class="paramname">data_time</td><td>Time at which Eulerian velocity is to be interpolated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A default implementation is provided that does nothing. </dd></dl>

<p>Reimplemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#af71152ec5820e42360c48c63eaeeb408">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a74b814e860e4713dc9f437f43856a2a0" name="a74b814e860e4713dc9f437f43856a2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b814e860e4713dc9f437f43856a2a0">&#9670;&#160;</a></span>setRigidBodyVelocity() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::setRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IBTK::RigidDOFVector &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the rigid body velocity at the nodal/marker points contained in the Vec <em>V</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The rigid part for which velocity needs to be set.</td></tr>
    <tr><td class="paramname">U</td><td>RDV contains the rigid component of velocities. For two-dimensions the vector contains the values <picture><source srcset="form_84_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$[u,v,\omega_z]$" src="form_84.png"/></picture> and for three-dimensions the vector values are <picture><source srcset="form_85_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$[u,v,w,\omega_x,\omega_y,\omega_z]$" src="form_85.png"/></picture>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#a9098bc848b12dab953743a64fd946f74">IBAMR::CIBMethod</a>, and <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#a74b814e860e4713dc9f437f43856a2a0">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="ac613d5efc96f4d2496c4a466eb95515f" name="ac613d5efc96f4d2496c4a466eb95515f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac613d5efc96f4d2496c4a466eb95515f">&#9670;&#160;</a></span>setRigidBodyVelocity() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::setRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the rigid body velocity at the nodal/marker points contained in the Vec <em>V</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The rigid part for which velocity needs to be set.</td></tr>
    <tr><td class="paramname">U</td><td>Vec contains the rigid component of velocities. For two-dimensions the vector contains the values <picture><source srcset="form_84_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$[u,v,\omega_z]$" src="form_84.png"/></picture> and for three-dimensions the vector values are <picture><source srcset="form_85_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$[u,v,w,\omega_x,\omega_y,\omega_z]$" src="form_85.png"/></picture>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#ac613d5efc96f4d2496c4a466eb95515f">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a8aedcf48f2c8e3b327a3f7c9c33012d9" name="a8aedcf48f2c8e3b327a3f7c9c33012d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aedcf48f2c8e3b327a3f7c9c33012d9">&#9670;&#160;</a></span>setRigidBodyVelocity() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::setRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>only_free_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>only_imposed_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>all_dofs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the rigid body velocity at the nodal/marker points contained in the Vec V. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>Vec that contains the rigid component of velocities for the required components. For two-dimensions each sub Vec contains the values <picture><source srcset="form_84_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$[u,v,\omega_z]$" src="form_84.png"/></picture> and for three-dimensions the vector values are <picture><source srcset="form_85_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$[u,v,w,\omega_x,\omega_y,\omega_z]$" src="form_85.png"/></picture>.</td></tr>
    <tr><td class="paramname">only_free_dofs</td><td>Boolean indicating if the rigid body velocity is to be set only for free DOFS for all parts. The corresponding size of U_sub would be <picture><source srcset="form_86_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ U_{sub} \leq NDIM * (NDIM + 1) / 2 $" src="form_86.png"/></picture>.</td></tr>
    <tr><td class="paramname">only_imposed_dofs</td><td>Boolean indicating if the rigid body velocity is to be set only for prescribed kinematics dofs for all parts. The corresponding size of U_sub would be <picture><source srcset="form_86_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ U_{sub} \leq NDIM * (NDIM + 1) / 2 $" src="form_86.png"/></picture>.</td></tr>
    <tr><td class="paramname">all_dofs</td><td>Boolean indicating if the rigid body velocity is to be set for all parts. The corresponding size of U_sub would be <picture><source srcset="form_87_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ U_{sub} = NDIM * (NDIM + 1) / 2 $" src="form_87.png"/></picture>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>User is responsible for setting correct number of subvecs in U that corresponds to the particular combination of booleans. </dd></dl>

<p>Reimplemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#a8aedcf48f2c8e3b327a3f7c9c33012d9">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a087733d93ea9af2d37c730dbb86f83a2" name="a087733d93ea9af2d37c730dbb86f83a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087733d93ea9af2d37c730dbb86f83a2">&#9670;&#160;</a></span>setRotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::setRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>rot_vel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Quaterniond &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Quaterniond &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt; Eigen::Matrix3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>rot_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the rotation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_old</td><td>Previous applied quaternion. </td></tr>
    <tr><td class="paramname">q_new</td><td>New quaternion to set. </td></tr>
    <tr><td class="paramname">rot_mat</td><td>Matrix to set. </td></tr>
    <tr><td class="paramname">dt</td><td>Time interval of rotation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c84ef0df606bb8dad89923392de5491" name="a0c84ef0df606bb8dad89923392de5491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c84ef0df606bb8dad89923392de5491">&#9670;&#160;</a></span>setSolveRigidBodyVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::setSolveRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IBTK::FreeRigidDOFVector &amp;&#160;</td>
          <td class="paramname"><em>solve_rigid_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set what rigid DOFs need to be solved for this particular structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The rigid body for which we are setting the free DOFs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9d78c835e925b0f5f55b93edadaacfd" name="ad9d78c835e925b0f5f55b93edadaacfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d78c835e925b0f5f55b93edadaacfd">&#9670;&#160;</a></span>subtractMeanConstraintForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::subtractMeanConstraintForce </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract the mean of constraint force from the background Eulerian grid. This is required for certain cases like periodic steady Stokes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Vec containing the constraint force.</td></tr>
    <tr><td class="paramname">f_data_idx</td><td>Patch data index of Eulerian body force.</td></tr>
    <tr><td class="paramname">scale</td><td>Factor by which <code>L</code> is scaled. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_i_b_a_m_r_1_1_c_i_b_method.html#a641234ee6e8d986a5d4d4a8ad72730cd">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9605c08a1475a205eff9afe1aa6a6697" name="a9605c08a1475a205eff9afe1aa6a6697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9605c08a1475a205eff9afe1aa6a6697">&#9670;&#160;</a></span>d_center_of_mass_initial</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_center_of_mass_initial</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Center of mass. </p>

</div>
</div>
<a id="af0997a2def8f09191bfa55a29e90c969" name="af0997a2def8f09191bfa55a29e90c969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0997a2def8f09191bfa55a29e90c969">&#9670;&#160;</a></span>d_quaternion_current</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt;Eigen::Quaterniond&gt; IBAMR::CIBStrategy::d_quaternion_current</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Quaternion of the body. </p>

</div>
</div>
<a id="a1f327733ed226b3dab4570a091b8f320" name="a1f327733ed226b3dab4570a091b8f320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f327733ed226b3dab4570a091b8f320">&#9670;&#160;</a></span>d_trans_vel_current</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07426.html">std::vector</a>&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_trans_vel_current</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rigid body velocity of the structures. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/IBAMR/IBAMR/include/ibamr/<b>CIBStrategy.h</b></li>
<li>/home/runner/work/IBAMR/IBAMR/src/IB/<b>CIBStrategy.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 21 2025 20:22:48 for IBAMR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
