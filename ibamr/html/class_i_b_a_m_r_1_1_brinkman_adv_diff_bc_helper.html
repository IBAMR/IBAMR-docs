<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: IBAMR::BrinkmanAdvDiffBcHelper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IBAMR
   </div>
   <div id="projectbrief">An adaptive and distributed-memory parallel implementation of the immersed boundary (IB) method</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_i_b_a_m_r.html">IBAMR</a></li><li class="navelem"><a class="el" href="class_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper.html">BrinkmanAdvDiffBcHelper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">IBAMR::BrinkmanAdvDiffBcHelper Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper.html" title="BrinkmanAdvDiffBcHelper is an abstract class that provides an interface to implement Brinkman penaliz...">BrinkmanAdvDiffBcHelper</a> is an abstract class that provides an interface to implement Brinkman penalization body force in the advection-diffusion equation in order to enforce Dirichlet, Neumann and Robin boundary conditions on surfaces of rigid immersed bodies. A single instance of this class is meant to handle all of the Brinkman penalization zones for multiple transported quantities with various boundary conditions.  
 <a href="class_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper.html#details">More...</a></p>

<p><code>#include &lt;/home/runner/work/IBAMR/IBAMR/include/ibamr/BrinkmanAdvDiffBcHelper.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IBAMR::BrinkmanAdvDiffBcHelper:</div>
<div class="dyncontent">
<div class="center"><img src="class_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper__inherit__graph.png" border="0" usemap="#a_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper_inherit__map" alt="Inheritance graph"/></div>
<map name="a_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper_inherit__map" id="a_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper_inherit__map">
<area shape="rect" title="BrinkmanAdvDiffBcHelper is an abstract class that provides an interface to implement Brinkman penaliz..." alt="" coords="15,79,215,119"/>
<area shape="rect" title=" " alt="" coords="5,5,224,31"/>
<area shape="poly" title=" " alt="" coords="117,44,117,79,112,79,112,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a78602385fad14b973d0e3646e76ac9f5" id="r_a78602385fad14b973d0e3646e76ac9f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper.html#a78602385fad14b973d0e3646e76ac9f5">BrinkmanInhomogeneousBCsFcnPtr</a> = void(*)(int B_idx, <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt; ls_var, <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="class_i_b_t_k_1_1_hierarchy_math_ops.html">IBTK::HierarchyMathOps</a> &gt; hier_math_ops, double time, void *ctx)</td></tr>
<tr class="memdesc:a78602385fad14b973d0e3646e76ac9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function specifying the optional forcing function for inhomogeneous boundary conditions <picture><source srcset="form_34_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \zeta q + \kappa n \dot \nabla q = \g $" src="form_34.png"/></picture>.  <br /></td></tr>
<tr class="separator:a78602385fad14b973d0e3646e76ac9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a464131c0fdfc1c1d5d4181181b1f8512" id="r_a464131c0fdfc1c1d5d4181181b1f8512"><td class="memItemLeft" align="right" valign="top"><a id="a464131c0fdfc1c1d5d4181181b1f8512" name="a464131c0fdfc1c1d5d4181181b1f8512"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BrinkmanAdvDiffBcHelper</b> (<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01653.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> object_name, <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="class_i_b_a_m_r_1_1_adv_diff_hierarchy_integrator.html">IBAMR::AdvDiffHierarchyIntegrator</a> &gt; adv_diff_solver)</td></tr>
<tr class="memdesc:a464131c0fdfc1c1d5d4181181b1f8512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class. <br /></td></tr>
<tr class="separator:a464131c0fdfc1c1d5d4181181b1f8512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b182c9fd76f76b38b68b2fb6a31a989" id="r_a0b182c9fd76f76b38b68b2fb6a31a989"><td class="memItemLeft" align="right" valign="top"><a id="a0b182c9fd76f76b38b68b2fb6a31a989" name="a0b182c9fd76f76b38b68b2fb6a31a989"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~BrinkmanAdvDiffBcHelper</b> ()=default</td></tr>
<tr class="memdesc:a0b182c9fd76f76b38b68b2fb6a31a989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the class. <br /></td></tr>
<tr class="separator:a0b182c9fd76f76b38b68b2fb6a31a989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8532e69bfc1d0717224c2c4b9c1954d7" id="r_a8532e69bfc1d0717224c2c4b9c1954d7"><td class="memItemLeft" align="right" valign="top"><a id="a8532e69bfc1d0717224c2c4b9c1954d7" name="a8532e69bfc1d0717224c2c4b9c1954d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setTimeInterval</b> (double current_time, double new_time)</td></tr>
<tr class="memdesc:a8532e69bfc1d0717224c2c4b9c1954d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the time interval in which Brinkman forcing is computed. <br /></td></tr>
<tr class="separator:a8532e69bfc1d0717224c2c4b9c1954d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3a095bad91fe3106e9b2bb7b8405ca" id="r_acf3a095bad91fe3106e9b2bb7b8405ca"><td class="memItemLeft" align="right" valign="top"><a id="acf3a095bad91fe3106e9b2bb7b8405ca" name="acf3a095bad91fe3106e9b2bb7b8405ca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>preprocessBrinkmanAdvDiffBcHelper</b> (double current_time, double new_time, int num_cycles)</td></tr>
<tr class="memdesc:acf3a095bad91fe3106e9b2bb7b8405ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preprocess routine before computing Brinkman penalization terms. <br /></td></tr>
<tr class="separator:acf3a095bad91fe3106e9b2bb7b8405ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5f06ca5619118ccc281c7d392a034e" id="r_a8c5f06ca5619118ccc281c7d392a034e"><td class="memItemLeft" align="right" valign="top"><a id="a8c5f06ca5619118ccc281c7d392a034e" name="a8c5f06ca5619118ccc281c7d392a034e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>postprocessBrinkmanAdvDiffBcHelper</b> (double current_time, double new_time, int num_cycles)</td></tr>
<tr class="memdesc:a8c5f06ca5619118ccc281c7d392a034e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postprocess routine after computing Brinkman penalization terms. <br /></td></tr>
<tr class="separator:a8c5f06ca5619118ccc281c7d392a034e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c7624ffea4851f201831bfe33847fd" id="r_a78c7624ffea4851f201831bfe33847fd"><td class="memItemLeft" align="right" valign="top"><a id="a78c7624ffea4851f201831bfe33847fd" name="a78c7624ffea4851f201831bfe33847fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setPenaltyCoefficient</b> (double eta_penalty_coef)</td></tr>
<tr class="memdesc:a78c7624ffea4851f201831bfe33847fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Brinkman penalization penalty factor for all level sets. <br /></td></tr>
<tr class="separator:a78c7624ffea4851f201831bfe33847fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4c053f713ffe988338a1adf8a149d4" id="r_afb4c053f713ffe988338a1adf8a149d4"><td class="memItemLeft" align="right" valign="top"><a id="afb4c053f713ffe988338a1adf8a149d4" name="afb4c053f713ffe988338a1adf8a149d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setNumInterfaceCells</b> (double num_interface_cells)</td></tr>
<tr class="memdesc:afb4c053f713ffe988338a1adf8a149d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of interface cells for all level sets. <br /></td></tr>
<tr class="separator:afb4c053f713ffe988338a1adf8a149d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed29e002ee483b83380d2c02ef1acf72" id="r_aed29e002ee483b83380d2c02ef1acf72"><td class="memItemLeft" align="right" valign="top"><a id="aed29e002ee483b83380d2c02ef1acf72" name="aed29e002ee483b83380d2c02ef1acf72"></a>
const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01653.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getName</b> () const</td></tr>
<tr class="memdesc:aed29e002ee483b83380d2c02ef1acf72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the object. <br /></td></tr>
<tr class="separator:aed29e002ee483b83380d2c02ef1acf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1deeb29282be0bf896ce55d2ed60c6e" id="r_ac1deeb29282be0bf896ce55d2ed60c6e"><td class="memItemLeft" align="right" valign="top"><a id="ac1deeb29282be0bf896ce55d2ed60c6e" name="ac1deeb29282be0bf896ce55d2ed60c6e"></a>
<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07166.html">std::pair</a>&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentTimeInterval</b> () const</td></tr>
<tr class="memdesc:ac1deeb29282be0bf896ce55d2ed60c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current time interval <picture><source srcset="form_33_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ [t^{n+1}, t^n] $" src="form_33.png"/></picture> in which Brinkman velocity is computed. <br /></td></tr>
<tr class="separator:ac1deeb29282be0bf896ce55d2ed60c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5827128cb1094ae752c572b103ebabf5" id="r_a5827128cb1094ae752c572b103ebabf5"><td class="memItemLeft" align="right" valign="top"><a id="a5827128cb1094ae752c572b103ebabf5" name="a5827128cb1094ae752c572b103ebabf5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasBrinkmanBoundaryCondition</b> (<a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt; Q_var) const</td></tr>
<tr class="memdesc:a5827128cb1094ae752c572b103ebabf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to determine if a transported quantity has Brinkman boundary conditions associated with it. <br /></td></tr>
<tr class="separator:a5827128cb1094ae752c572b103ebabf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf55a8068f86682c36d8cf7b37b31d8" id="r_aacf55a8068f86682c36d8cf7b37b31d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper.html#aacf55a8068f86682c36d8cf7b37b31d8">registerHomogeneousBC</a> (<a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt; Q_var, <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt; ls_solid_var, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01653.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> bc_type, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01653.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> indicator_func_type=&quot;SMOOTH&quot;, double num_interface_cells=2.0, double eta_penalty_coef=1.0e-8)</td></tr>
<tr class="memdesc:aacf55a8068f86682c36d8cf7b37b31d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a transported quantity with this object, along with the solid level set variable for which to apply a homogeneous boundary condition.  <br /></td></tr>
<tr class="separator:aacf55a8068f86682c36d8cf7b37b31d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab629f33702e05c90a6b956fe2c3daa0e" id="r_ab629f33702e05c90a6b956fe2c3daa0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper.html#ab629f33702e05c90a6b956fe2c3daa0e">registerInhomogeneousBC</a> (<a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt; Q_var, <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt; ls_solid_var, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01653.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> bc_type, <a class="el" href="class_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper.html#a78602385fad14b973d0e3646e76ac9f5">BrinkmanInhomogeneousBCsFcnPtr</a> callback=nullptr, void *ctx=nullptr, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01653.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> indicator_func_type=&quot;SMOOTH&quot;, double num_interface_cells=2.0, double eta_penalty_coef=1.0e-8, double bc_val=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a02702.html">std::numeric_limits</a>&lt; double &gt;::signaling_NaN())</td></tr>
<tr class="memdesc:ab629f33702e05c90a6b956fe2c3daa0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a transported quantity with this object, along with the solid level set variable on which to apply inhomogeneous boundary conditions.  <br /></td></tr>
<tr class="separator:ab629f33702e05c90a6b956fe2c3daa0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1326eb41fc356448be021c0b99f8488d" id="r_a1326eb41fc356448be021c0b99f8488d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper.html#a1326eb41fc356448be021c0b99f8488d">computeDampingCoefficient</a> (int C_idx, <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt; Q_var)</td></tr>
<tr class="memdesc:a1326eb41fc356448be021c0b99f8488d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the cell-centered coefficient to the damping linear operator and RHS of the advection-diffusion equation for a specified transported quantity Q_var.  <br /></td></tr>
<tr class="separator:a1326eb41fc356448be021c0b99f8488d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfc72767d9465186c58fb196ff97ea5" id="r_a4dfc72767d9465186c58fb196ff97ea5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper.html#a4dfc72767d9465186c58fb196ff97ea5">computeDiffusionCoefficient</a> (int D_idx, <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt; Q_var, int kappa_idx, double kappa)</td></tr>
<tr class="memdesc:a4dfc72767d9465186c58fb196ff97ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the side-centered coefficient to the diffusion linear operator and RHS of the advection-diffusion equation for a specified transported quantity Q_var with diffusion coefficient kappa.  <br /></td></tr>
<tr class="separator:a4dfc72767d9465186c58fb196ff97ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80aee1dd860715b90ed40ff71e7a614f" id="r_a80aee1dd860715b90ed40ff71e7a614f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper.html#a80aee1dd860715b90ed40ff71e7a614f">computeForcing</a> (int F_idx, <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt; Q_var)</td></tr>
<tr class="memdesc:a80aee1dd860715b90ed40ff71e7a614f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the Brinkman forcing contribution to the RHS of the advection-diffusion solver for a specified transported quantity Q_var.  <br /></td></tr>
<tr class="separator:a80aee1dd860715b90ed40ff71e7a614f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f42b29cc683d6033a1f4057ea355df" id="r_a71f42b29cc683d6033a1f4057ea355df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper.html#a71f42b29cc683d6033a1f4057ea355df">maskForcingTerm</a> (int N_idx, <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt; Q_var, const bool mask_smeared_region=false)</td></tr>
<tr class="memdesc:a71f42b29cc683d6033a1f4057ea355df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to mask the additional forcing terms on the RHS of the advection-diffusion solver e.g. <picture><source srcset="form_45_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ u \dot \grad Q$" src="form_45.png"/></picture> and body forces.  <br /></td></tr>
<tr class="separator:a71f42b29cc683d6033a1f4057ea355df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper.html" title="BrinkmanAdvDiffBcHelper is an abstract class that provides an interface to implement Brinkman penaliz...">BrinkmanAdvDiffBcHelper</a> is an abstract class that provides an interface to implement Brinkman penalization body force in the advection-diffusion equation in order to enforce Dirichlet, Neumann and Robin boundary conditions on surfaces of rigid immersed bodies. A single instance of this class is meant to handle all of the Brinkman penalization zones for multiple transported quantities with various boundary conditions. </p>
<p><a class="el" href="class_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper.html" title="BrinkmanAdvDiffBcHelper is an abstract class that provides an interface to implement Brinkman penaliz...">BrinkmanAdvDiffBcHelper</a> provides an implementation of a volume penalized body force and linear operator modifications required to impose Dirichlet, Neumann and Robin boundary conditions to scalar quantities maintained by BrinkmanSemiImplicitAdvDiffHierarchyIntegrator.</p>
<p>Boundary conditions can be applied to multiple interfaces, which are demarcated using level set variables. This class assumes that the penalized region coincides with negative values of the level set. The sign convention of the level set variable is specified by the user.</p>
<p>Reference Sakurai, T., Yoshimatsu, K., Okamoto N. and Schneider K.,<a href="https://www.sciencedirect.com/science/article/pii/S0021999119302414">Volume penalization for inhomogeneous Neumann boundary conditions modeling scalar flux in complicated geometry</a> </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a78602385fad14b973d0e3646e76ac9f5" name="a78602385fad14b973d0e3646e76ac9f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78602385fad14b973d0e3646e76ac9f5">&#9670;&#160;</a></span>BrinkmanInhomogeneousBCsFcnPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper.html#a78602385fad14b973d0e3646e76ac9f5">IBAMR::BrinkmanAdvDiffBcHelper::BrinkmanInhomogeneousBCsFcnPtr</a> =  void (*)(int B_idx, <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt;NDIM, double&gt; &gt; ls_var, <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="class_i_b_t_k_1_1_hierarchy_math_ops.html">IBTK::HierarchyMathOps</a>&gt; hier_math_ops, double time, void* ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function specifying the optional forcing function for inhomogeneous boundary conditions <picture><source srcset="form_34_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \zeta q + \kappa n \dot \nabla q = \g $" src="form_34.png"/></picture>. </p>
<p>The user must set the patch data B_idx such that <picture><source srcset="form_35_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ n \dot B = g $" src="form_35.png"/></picture>. The applied forcing term is then computed internally as <picture><source srcset="form_36_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \nabla \dot (\chi B) - \chi \nabla \dot B $" src="form_36.png"/></picture>. Note that B_idx contains side-centered patch data. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1326eb41fc356448be021c0b99f8488d" name="a1326eb41fc356448be021c0b99f8488d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1326eb41fc356448be021c0b99f8488d">&#9670;&#160;</a></span>computeDampingCoefficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::BrinkmanAdvDiffBcHelper::computeDampingCoefficient </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>C_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt;&#160;</td>
          <td class="paramname"><em>Q_var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute the cell-centered coefficient to the damping linear operator and RHS of the advection-diffusion equation for a specified transported quantity Q_var. </p>
<dl class="section note"><dt>Note</dt><dd>It is assumed that the physical damping coefficient <picture><source srcset="form_37_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\lambda$" src="form_37.png"/></picture> is zero.</dd></dl>
<p>The functional form of the Brinkman damping coefficient is <picture><source srcset="form_38_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ C = \sum_{Dirichlet} \chi_i/\eta  + \sum_{Robin} \nabla \dot (\chi_i n_i) - \chi_i \nabla \dot n_i$" src="form_38.png"/></picture> where the sum is taken over all level sets with Dirichlet and Robin BCs. Here <picture><source srcset="form_39_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\chi_i = 1-H_i$" src="form_39.png"/></picture>. Note that Neumann BCs do not contribute anything to this term. </p>

</div>
</div>
<a id="a4dfc72767d9465186c58fb196ff97ea5" name="a4dfc72767d9465186c58fb196ff97ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfc72767d9465186c58fb196ff97ea5">&#9670;&#160;</a></span>computeDiffusionCoefficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::BrinkmanAdvDiffBcHelper::computeDiffusionCoefficient </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt;&#160;</td>
          <td class="paramname"><em>Q_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kappa_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kappa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute the side-centered coefficient to the diffusion linear operator and RHS of the advection-diffusion equation for a specified transported quantity Q_var with diffusion coefficient kappa. </p>
<dl class="section note"><dt>Note</dt><dd>This function is able to handle both constant and variable kappa.</dd></dl>
<p>The functional form of the Brinkman diffusion coefficient is <picture><source srcset="form_40_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ D = \kappa + \sum_{Neumann} (-\chi_i + \eta \chi_i) + \sum_{Robin} (-\chi_i + \eta \chi_i)$" src="form_40.png"/></picture> where <picture><source srcset="form_39_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\chi_i = 1-H_i$" src="form_39.png"/></picture> and the sum is taken over all level sets with Neumann and Robin BCs . Note that Dirichlet BCs do not contribute anything to this term. </p>

</div>
</div>
<a id="a80aee1dd860715b90ed40ff71e7a614f" name="a80aee1dd860715b90ed40ff71e7a614f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80aee1dd860715b90ed40ff71e7a614f">&#9670;&#160;</a></span>computeForcing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::BrinkmanAdvDiffBcHelper::computeForcing </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>F_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt;&#160;</td>
          <td class="paramname"><em>Q_var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute the Brinkman forcing contribution to the RHS of the advection-diffusion solver for a specified transported quantity Q_var. </p>
<p>For Inhomogeneous Dirichlet BCs, <picture><source srcset="form_41_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F_i = \chi_i/\eta Q_{bc}$" src="form_41.png"/></picture> where <picture><source srcset="form_39_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\chi_i = 1-H_i$" src="form_39.png"/></picture>. For inhomogeneous Neumann and Robin BCs, <picture><source srcset="form_42_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ F_i = \nabla \dot (\chi_i B) - \chi_i \nabla \dot B_i $" src="form_42.png"/></picture>, with a user defined <picture><source srcset="form_43_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$B_i$" src="form_43.png"/></picture>. The overall functional form of the Brinkman body force is <picture><source srcset="form_44_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$F = \sum_{i} F_i$" src="form_44.png"/></picture>. </p>

</div>
</div>
<a id="a71f42b29cc683d6033a1f4057ea355df" name="a71f42b29cc683d6033a1f4057ea355df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f42b29cc683d6033a1f4057ea355df">&#9670;&#160;</a></span>maskForcingTerm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::BrinkmanAdvDiffBcHelper::maskForcingTerm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt;&#160;</td>
          <td class="paramname"><em>Q_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>mask_smeared_region</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to mask the additional forcing terms on the RHS of the advection-diffusion solver e.g. <picture><source srcset="form_45_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ u \dot \grad Q$" src="form_45.png"/></picture> and body forces. </p>
<p>The functional form of the Brinkman masking term is <picture><source srcset="form_46_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ N = (1-\sum_{Neumann and Robin} \chi_i) N$" src="form_46.png"/></picture> where <picture><source srcset="form_39_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\chi_i = 1-H_i$" src="form_39.png"/></picture> and the sum is taken over all level sets with Neumann and Robin BCs. Note that Dirichlet BCs do not mask this term presently. </p>

</div>
</div>
<a id="aacf55a8068f86682c36d8cf7b37b31d8" name="aacf55a8068f86682c36d8cf7b37b31d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf55a8068f86682c36d8cf7b37b31d8">&#9670;&#160;</a></span>registerHomogeneousBC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::BrinkmanAdvDiffBcHelper::registerHomogeneousBC </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt;&#160;</td>
          <td class="paramname"><em>Q_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt;&#160;</td>
          <td class="paramname"><em>ls_solid_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01653.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td>
          <td class="paramname"><em>bc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01653.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td>
          <td class="paramname"><em>indicator_func_type</em> = <code>&quot;SMOOTH&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>num_interface_cells</em> = <code>2.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eta_penalty_coef</em> = <code>1.0e-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a transported quantity with this object, along with the solid level set variable for which to apply a homogeneous boundary condition. </p>
<dl class="section note"><dt>Note</dt><dd>This function can only be used to register homogeneous Dirichlet, Neumann and Robin BCs. </dd></dl>

</div>
</div>
<a id="ab629f33702e05c90a6b956fe2c3daa0e" name="ab629f33702e05c90a6b956fe2c3daa0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab629f33702e05c90a6b956fe2c3daa0e">&#9670;&#160;</a></span>registerInhomogeneousBC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::BrinkmanAdvDiffBcHelper::registerInhomogeneousBC </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt;&#160;</td>
          <td class="paramname"><em>Q_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="elRef" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, double &gt; &gt;&#160;</td>
          <td class="paramname"><em>ls_solid_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01653.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td>
          <td class="paramname"><em>bc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_b_a_m_r_1_1_brinkman_adv_diff_bc_helper.html#a78602385fad14b973d0e3646e76ac9f5">BrinkmanInhomogeneousBCsFcnPtr</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01653.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td>
          <td class="paramname"><em>indicator_func_type</em> = <code>&quot;SMOOTH&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>num_interface_cells</em> = <code>2.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eta_penalty_coef</em> = <code>1.0e-8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bc_val</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a02702.html">std::numeric_limits</a>&lt;double&gt;::signaling_NaN()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a transported quantity with this object, along with the solid level set variable on which to apply inhomogeneous boundary conditions. </p>
<dl class="section note"><dt>Note</dt><dd>Inhomogeneous BCs are treated uniquely within this class and require additional user callback inputs. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/IBAMR/IBAMR/include/ibamr/<b>BrinkmanAdvDiffBcHelper.h</b></li>
<li>/home/runner/work/IBAMR/IBAMR/src/IB/<b>BrinkmanAdvDiffBcHelper.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 27 2025 20:27:40 for IBAMR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
