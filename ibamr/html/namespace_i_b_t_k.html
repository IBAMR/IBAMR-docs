<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>IBAMR: IBTK Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IBAMR
   </div>
   <div id="projectbrief">An adaptive and distributed-memory parallel implementation of the immersed boundary (IB) method</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">IBTK Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_app_initializer.html">AppInitializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_app_initializer.html" title="Class AppInitializer provides functionality to simplify the initialization code in an application cod...">AppInitializer</a> provides functionality to simplify the initialization code in an application code.  <a href="class_i_b_t_k_1_1_app_initializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_b_gauss_seidel_preconditioner.html">BGaussSeidelPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_b_gauss_seidel_preconditioner.html" title="Class BGaussSeidelPreconditioner is a block Gauss-Seidel preconditioner which implements the abstract...">BGaussSeidelPreconditioner</a> is a block Gauss-Seidel preconditioner which implements the abstract <a class="el" href="class_i_b_t_k_1_1_linear_solver.html" title="Class LinearSolver provides an abstract interface for the implementation of solvers for linear proble...">LinearSolver</a> interface.  <a href="class_i_b_t_k_1_1_b_gauss_seidel_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_b_jacobi_preconditioner.html">BJacobiPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_b_jacobi_preconditioner.html" title="Class BJacobiPreconditioner is a block Jacobi preconditioner which implements the abstract LinearSolv...">BJacobiPreconditioner</a> is a block Jacobi preconditioner which implements the abstract <a class="el" href="class_i_b_t_k_1_1_linear_solver.html" title="Class LinearSolver provides an abstract interface for the implementation of solvers for linear proble...">LinearSolver</a> interface.  <a href="class_i_b_t_k_1_1_b_jacobi_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_box_partitioner.html">BoxPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespacelib_mesh.html">libMesh</a> partitioner that partitions a mesh based on <a class="el" href="class_i_b_t_k_1_1_partitioning_box.html" title="Class PartitioningBox implements an NDIM-dimensional bounding box defined by two points. Unlike a standard bounding box, a PartitioningBox is an NDIM-dimensional tensor product of half-open intervals: i.e., it is a half-open box. This property allows one to partition a domain into a set of boxes. ">PartitioningBox</a> objects owned by each processor.  <a href="class_i_b_t_k_1_1_box_partitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_cart_cell_double_bounds_preserving_conservative_linear_refine.html">CartCellDoubleBoundsPreservingConservativeLinearRefine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_cart_cell_double_bounds_preserving_conservative_linear_refine.html" title="Class CartCellDoubleBoundsPreservingConservativeLinearRefine is a concrete SAMRAI::xfer::RefineOperat...">CartCellDoubleBoundsPreservingConservativeLinearRefine</a> is a concrete <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefineOperator.html">SAMRAI::xfer::RefineOperator</a> object which prolongs cell-centered double precision patch data via conservative linear interpolation with an additional bounds preservation repair step.  <a href="class_i_b_t_k_1_1_cart_cell_double_bounds_preserving_conservative_linear_refine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_cart_cell_double_cubic_coarsen.html">CartCellDoubleCubicCoarsen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_cart_cell_double_cubic_coarsen.html" title="Class CartCellDoubleCubicCoarsen is a concrete SAMRAI::xfer::CoarsenOperator for restricting cell-cen...">CartCellDoubleCubicCoarsen</a> is a concrete <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1CoarsenOperator.html">SAMRAI::xfer::CoarsenOperator</a> for restricting cell-centered double precision patch data via cubic interpolation.  <a href="class_i_b_t_k_1_1_cart_cell_double_cubic_coarsen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_cart_cell_double_linear_c_f_interpolation.html">CartCellDoubleLinearCFInterpolation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_cart_cell_double_linear_c_f_interpolation.html" title="Class CartCellDoubleLinearCFInterpolation is a concrete SAMRAI::xfer::RefinePatchStrategy which sets ...">CartCellDoubleLinearCFInterpolation</a> is a concrete <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a> which sets coarse-fine interface ghost cell values for cell-centered double precision patch data via linear interpolation in the normal and tangential directions at coarse-fine interfaces.  <a href="class_i_b_t_k_1_1_cart_cell_double_linear_c_f_interpolation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_cart_cell_double_quadratic_c_f_interpolation.html">CartCellDoubleQuadraticCFInterpolation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_cart_cell_double_quadratic_c_f_interpolation.html" title="Class CartCellDoubleQuadraticCFInterpolation is a concrete SAMRAI::xfer::RefinePatchStrategy which se...">CartCellDoubleQuadraticCFInterpolation</a> is a concrete <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a> which sets coarse-fine interface ghost cell values for cell-centered double precision patch data via quadratic interpolation in the normal and tangential directions at coarse-fine interfaces.  <a href="class_i_b_t_k_1_1_cart_cell_double_quadratic_c_f_interpolation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_cart_cell_double_quadratic_refine.html">CartCellDoubleQuadraticRefine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_cart_cell_double_quadratic_refine.html" title="Class CartCellDoubleQuadraticRefine is a concrete SAMRAI::xfer::RefineOperator object which prolongs ...">CartCellDoubleQuadraticRefine</a> is a concrete <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefineOperator.html">SAMRAI::xfer::RefineOperator</a> object which prolongs cell-centered double precision patch data via quadratic interpolation.  <a href="class_i_b_t_k_1_1_cart_cell_double_quadratic_refine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_cart_cell_robin_phys_bdry_op.html">CartCellRobinPhysBdryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_cart_cell_robin_phys_bdry_op.html" title="Class CartCellRobinPhysBdryOp is a concrete SAMRAI::xfer::RefinePatchStrategy for setting Robin bound...">CartCellRobinPhysBdryOp</a> is a concrete <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a> for setting Robin boundary conditions at physical boundaries for cell-centered scalar- and vector-valued quantities.  <a href="class_i_b_t_k_1_1_cart_cell_robin_phys_bdry_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_cart_extrap_phys_bdry_op.html">CartExtrapPhysBdryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_cart_extrap_phys_bdry_op.html" title="Class CartExtrapPhysBdryOp is a concrete SAMRAI::xfer::RefinePatchStrategy for setting ghost cell val...">CartExtrapPhysBdryOp</a> is a concrete <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a> for setting ghost cell values at physical boundaries via constant, linear, or quadratic extrapolation from interior values.  <a href="class_i_b_t_k_1_1_cart_extrap_phys_bdry_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_cart_grid_function.html">CartGridFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_cart_grid_function.html" title="Class CartGridFunction provides an abstract interface for objects for evaluating functions to set val...">CartGridFunction</a> provides an abstract interface for objects for evaluating functions to set values in <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1PatchData.html">SAMRAI::hier::PatchData</a> objects.  <a href="class_i_b_t_k_1_1_cart_grid_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_cart_grid_function_set.html">CartGridFunctionSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_cart_grid_function_set.html" title="Class CartGridFunctionSet is a concrete CartGridFunction that is used to allow multiple CartGridFunct...">CartGridFunctionSet</a> is a concrete <a class="el" href="class_i_b_t_k_1_1_cart_grid_function.html" title="Class CartGridFunction provides an abstract interface for objects for evaluating functions to set val...">CartGridFunction</a> that is used to allow multiple <a class="el" href="class_i_b_t_k_1_1_cart_grid_function.html" title="Class CartGridFunction provides an abstract interface for objects for evaluating functions to set val...">CartGridFunction</a> objects to act as a single function.  <a href="class_i_b_t_k_1_1_cart_grid_function_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_cart_side_double_cubic_coarsen.html">CartSideDoubleCubicCoarsen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_cart_side_double_cubic_coarsen.html" title="Class CartSideDoubleCubicCoarsen is a concrete SAMRAI::xfer::CoarsenOperator for restricting side-cen...">CartSideDoubleCubicCoarsen</a> is a concrete <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1CoarsenOperator.html">SAMRAI::xfer::CoarsenOperator</a> for restricting side-centered double precision patch data via cubic interpolation.  <a href="class_i_b_t_k_1_1_cart_side_double_cubic_coarsen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_cart_side_double_div_preserving_refine.html">CartSideDoubleDivPreservingRefine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_cart_side_double_div_preserving_refine.html" title="Class CartSideDoubleDivPreservingRefine is a concrete SAMRAI::xfer::RefinePatchStrategy which prolong...">CartSideDoubleDivPreservingRefine</a> is a concrete <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a> which prolongs side-centered double precision patch data via conservative linear interpolation with divergence- and curl-preserving corrections.  <a href="class_i_b_t_k_1_1_cart_side_double_div_preserving_refine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_cart_side_double_quadratic_c_f_interpolation.html">CartSideDoubleQuadraticCFInterpolation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_cart_side_double_quadratic_c_f_interpolation.html" title="Class CartSideDoubleQuadraticCFInterpolation is a concrete SAMRAI::xfer::RefinePatchStrategy which se...">CartSideDoubleQuadraticCFInterpolation</a> is a concrete <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a> which sets coarse-fine interface ghost cell values for side-centered double precision patch data via quadratic interpolation in the normal and tangential directions at coarse-fine interfaces.  <a href="class_i_b_t_k_1_1_cart_side_double_quadratic_c_f_interpolation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_cart_side_double_r_t0_coarsen.html">CartSideDoubleRT0Coarsen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_cart_side_double_r_t0_coarsen.html" title="Class CartSideDoubleRT0Coarsen is a concrete SAMRAI::xfer::CoarsenOperator for restricting side-cente...">CartSideDoubleRT0Coarsen</a> is a concrete <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1CoarsenOperator.html">SAMRAI::xfer::CoarsenOperator</a> for restricting side-centered double precision patch data via the adjoint of RT0 interpolation.  <a href="class_i_b_t_k_1_1_cart_side_double_r_t0_coarsen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_cart_side_double_r_t0_refine.html">CartSideDoubleRT0Refine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_cart_side_double_r_t0_refine.html" title="Class CartSideDoubleRT0Refine is a concrete SAMRAI::xfer::RefineOperator object that prolongs side-ce...">CartSideDoubleRT0Refine</a> is a concrete <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefineOperator.html">SAMRAI::xfer::RefineOperator</a> object that prolongs side-centered double precision patch data via RT0-based interpolation.  <a href="class_i_b_t_k_1_1_cart_side_double_r_t0_refine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_cart_side_double_specialized_linear_refine.html">CartSideDoubleSpecializedLinearRefine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_cart_side_double_specialized_linear_refine.html" title="Class CartSideDoubleSpecializedLinearRefine is a concrete SAMRAI::xfer::RefineOperator object that pr...">CartSideDoubleSpecializedLinearRefine</a> is a concrete <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefineOperator.html">SAMRAI::xfer::RefineOperator</a> object that prolongs side-centered double precision patch data via linear interpolation in the normal direction and MC-limited piecewise-linear interpolation in the tangential direction.  <a href="class_i_b_t_k_1_1_cart_side_double_specialized_linear_refine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_cart_side_robin_phys_bdry_op.html">CartSideRobinPhysBdryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_cart_side_robin_phys_bdry_op.html" title="Class CartSideRobinPhysBdryOp is a concrete SAMRAI::xfer::RefinePatchStrategy for setting Robin bound...">CartSideRobinPhysBdryOp</a> is a concrete <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a> for setting Robin boundary conditions at physical boundaries for side-centered vector-valued quantities.  <a href="class_i_b_t_k_1_1_cart_side_robin_phys_bdry_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_c_c_laplace_operator.html">CCLaplaceOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_c_c_laplace_operator.html" title="Class CCLaplaceOperator is a concrete LaplaceOperator which implements a globally second-order accura...">CCLaplaceOperator</a> is a concrete <a class="el" href="class_i_b_t_k_1_1_laplace_operator.html" title="Class LaplaceOperator is an abstract base class for a Laplace-type operators. ">LaplaceOperator</a> which implements a globally second-order accurate cell-centered finite difference discretization of a scalar elliptic operator of the form <img class="formulaInl" alt="$ L = C I + \nabla \cdot D \nabla$" src="form_113.png"/>.  <a href="class_i_b_t_k_1_1_c_c_laplace_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_c_c_poisson_box_relaxation_f_a_c_operator.html">CCPoissonBoxRelaxationFACOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_c_c_poisson_box_relaxation_f_a_c_operator.html" title="Class CCPoissonBoxRelaxationFACOperator is a concrete PoissonFACPreconditionerStrategy for solving el...">CCPoissonBoxRelaxationFACOperator</a> is a concrete <a class="el" href="class_i_b_t_k_1_1_poisson_f_a_c_preconditioner_strategy.html" title="Class PoissonFACPreconditionerStrategy is an abstract FACPreconditionerStrategy implementing many of ...">PoissonFACPreconditionerStrategy</a> for solving elliptic equations of the form <img class="formulaInl" alt="$ \mbox{$L u$} = \mbox{$(C I + \nabla \cdot D \nabla) u$} = f $" src="form_114.png"/> using a globally second-order accurate cell-centered finite-volume discretization, with support for Robin and periodic boundary conditions.  <a href="class_i_b_t_k_1_1_c_c_poisson_box_relaxation_f_a_c_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_c_c_poisson_hypre_level_solver.html">CCPoissonHypreLevelSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_c_c_poisson_hypre_level_solver.html" title="Class CCPoissonHypreLevelSolver is a concrete LinearSolver for solving elliptic equations of the form...">CCPoissonHypreLevelSolver</a> is a concrete <a class="el" href="class_i_b_t_k_1_1_linear_solver.html" title="Class LinearSolver provides an abstract interface for the implementation of solvers for linear proble...">LinearSolver</a> for solving elliptic equations of the form <img class="formulaInl" alt="$ \mbox{$L u$} = \mbox{$(C I + \nabla \cdot D \nabla) u$} = f $" src="form_114.png"/> on a <em>single</em> <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a> using <a href="https://computation.llnl.gov/casc/linear_solvers/sls_hypre.html">hypre</a>.  <a href="class_i_b_t_k_1_1_c_c_poisson_hypre_level_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_c_c_poisson_level_relaxation_f_a_c_operator.html">CCPoissonLevelRelaxationFACOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_c_c_poisson_level_relaxation_f_a_c_operator.html" title="Class CCPoissonLevelRelaxationFACOperator is a concrete PoissonFACPreconditionerStrategy for solving ...">CCPoissonLevelRelaxationFACOperator</a> is a concrete <a class="el" href="class_i_b_t_k_1_1_poisson_f_a_c_preconditioner_strategy.html" title="Class PoissonFACPreconditionerStrategy is an abstract FACPreconditionerStrategy implementing many of ...">PoissonFACPreconditionerStrategy</a> for solving elliptic equations of the form <img class="formulaInl" alt="$ \mbox{$L u$} = \mbox{$(C I + \nabla \cdot D \nabla) u$} = f $" src="form_114.png"/> using a globally second-order accurate cell-centered finite-volume discretization, with support for Robin and periodic boundary conditions.  <a href="class_i_b_t_k_1_1_c_c_poisson_level_relaxation_f_a_c_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_c_c_poisson_p_e_t_sc_level_solver.html">CCPoissonPETScLevelSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_c_c_poisson_p_e_t_sc_level_solver.html" title="Class CCPoissonPETScLevelSolver is a concrete PETScLevelSolver for solving elliptic equations of the ...">CCPoissonPETScLevelSolver</a> is a concrete <a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_level_solver.html" title="Class PETScLevelSolver is an abstract LinearSolver for solving systems of linear equations on a singl...">PETScLevelSolver</a> for solving elliptic equations of the form <img class="formulaInl" alt="$ \mbox{$L u$} = \mbox{$(C I + \nabla \cdot D \nabla) u$} = f $" src="form_114.png"/> on a <em>single</em> <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a>.  <a href="class_i_b_t_k_1_1_c_c_poisson_p_e_t_sc_level_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_c_c_poisson_point_relaxation_f_a_c_operator.html">CCPoissonPointRelaxationFACOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_c_c_poisson_point_relaxation_f_a_c_operator.html" title="Class CCPoissonPointRelaxationFACOperator is a concrete PoissonFACPreconditionerStrategy for solving ...">CCPoissonPointRelaxationFACOperator</a> is a concrete <a class="el" href="class_i_b_t_k_1_1_poisson_f_a_c_preconditioner_strategy.html" title="Class PoissonFACPreconditionerStrategy is an abstract FACPreconditionerStrategy implementing many of ...">PoissonFACPreconditionerStrategy</a> for solving elliptic equations of the form <img class="formulaInl" alt="$ \mbox{$L u$} = \mbox{$(C I + \nabla \cdot D \nabla) u$} = f $" src="form_114.png"/> using a globally second-order accurate cell-centered finite-volume discretization, with support for Robin and periodic boundary conditions.  <a href="class_i_b_t_k_1_1_c_c_poisson_point_relaxation_f_a_c_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_c_c_poisson_solver_manager.html">CCPoissonSolverManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_c_c_poisson_solver_manager.html" title="Class CCPoissonSolverManager is a singleton manager class to provide access to generic cell-centered ...">CCPoissonSolverManager</a> is a singleton manager class to provide access to generic cell-centered <a class="el" href="class_i_b_t_k_1_1_poisson_solver.html" title="Class PoissonSolver is an abstract base class for Poisson solvers. ">PoissonSolver</a> implementations.  <a href="class_i_b_t_k_1_1_c_c_poisson_solver_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_cell_no_corners_fill_pattern.html">CellNoCornersFillPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class CellCellNoCornersFillPattern is a concrete implementation of the abstract base class <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1VariableFillPattern.html">SAMRAI::xfer::VariableFillPattern</a>. It is used to calculate overlaps according to a pattern which limits overlaps to the cell-centered ghost region surrounding a patch, excluding all corners. In 3D, it is also possible to configure this fill pattern object also to exclude all edges.  <a href="class_i_b_t_k_1_1_cell_no_corners_fill_pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_coarse_fine_boundary_refine_patch_strategy.html">CoarseFineBoundaryRefinePatchStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_coarse_fine_boundary_refine_patch_strategy.html" title="Class CoarseFineBoundaryRefinePatchStrategy is a subclass of the abstract base class SAMRAI::xfer::Re...">CoarseFineBoundaryRefinePatchStrategy</a> is a subclass of the abstract base class <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a> that extends the functionality of <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a> to facilitate the implementation of coarse-fine interface discretizations.  <a href="class_i_b_t_k_1_1_coarse_fine_boundary_refine_patch_strategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_coarsen_patch_strategy_set.html">CoarsenPatchStrategySet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_coarsen_patch_strategy_set.html" title="Class CoarsenPatchStrategySet is a utility class that allows multiple SAMRAI::xfer::CoarsenPatchStrat...">CoarsenPatchStrategySet</a> is a utility class that allows multiple <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html">SAMRAI::xfer::CoarsenPatchStrategy</a> objects to be employed by a single <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>.  <a href="class_i_b_t_k_1_1_coarsen_patch_strategy_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_copy_to_root_schedule.html">CopyToRootSchedule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_copy_to_root_schedule.html" title="Class CopyToRootSchedule is used to communicate distributed patch data to a unified patch data object...">CopyToRootSchedule</a> is used to communicate distributed patch data to a unified patch data object on a root MPI process.  <a href="class_i_b_t_k_1_1_copy_to_root_schedule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_copy_to_root_transaction.html">CopyToRootTransaction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_copy_to_root_transaction.html" title="Class CopyToRootTransaction is a concrete implementation of the abstract base class SAMRAI::tbox::Tra...">CopyToRootTransaction</a> is a concrete implementation of the abstract base class <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1Transaction.html">SAMRAI::tbox::Transaction</a>. It is used to communicate distributed patch data to a unified patch data object on a root MPI process.  <a href="class_i_b_t_k_1_1_copy_to_root_transaction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_debugging_utilities.html">DebuggingUtilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_debugging_utilities.html" title="Class DebuggingUtilities provides debugging functionality. ">DebuggingUtilities</a> provides debugging functionality.  <a href="class_i_b_t_k_1_1_debugging_utilities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_b_t_k_1_1_dof_object_comp.html">DofObjectComp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_edge_data_synchronization.html">EdgeDataSynchronization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_edge_data_synchronization.html" title="Class EdgeDataSynchronization encapsulates the operations required to &quot;synchronize&quot; edge-centered val...">EdgeDataSynchronization</a> encapsulates the operations required to "synchronize" edge-centered values defined at patch boundaries.  <a href="class_i_b_t_k_1_1_edge_data_synchronization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_edge_synch_copy_fill_pattern.html">EdgeSynchCopyFillPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class EdgeCellSynchCopyFillPattern is a concrete implementation of the abstract base class <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1VariableFillPattern.html">SAMRAI::xfer::VariableFillPattern</a>. It is used to calculate overlaps according to a pattern which limits overlaps to the edge-centered ghost region surrounding a patch appropriate for "synchronizing" edge-centered values in an axis-by-axis manner at patch boundaries.  <a href="class_i_b_t_k_1_1_edge_synch_copy_fill_pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_extended_robin_bc_coef_strategy.html">ExtendedRobinBcCoefStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_extended_robin_bc_coef_strategy.html" title="Class ExtendedRobinBcCoefStrategy is a subclass of the abstract base class SAMRAI::solv::RobinBcCoefS...">ExtendedRobinBcCoefStrategy</a> is a subclass of the abstract base class <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a> that extends the functionality of <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a> to allow for the specification of patch data descriptor indices that are required for filling, and the specification of whether homogeneous or inhomogeneous boundary data should be set.  <a href="class_i_b_t_k_1_1_extended_robin_bc_coef_strategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_face_data_synchronization.html">FaceDataSynchronization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_face_data_synchronization.html" title="Class FaceDataSynchronization encapsulates the operations required to &quot;synchronize&quot; face-centered val...">FaceDataSynchronization</a> encapsulates the operations required to "synchronize" face-centered values defined at patch boundaries.  <a href="class_i_b_t_k_1_1_face_data_synchronization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_face_synch_copy_fill_pattern.html">FaceSynchCopyFillPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class FaceCellSynchCopyFillPattern is a concrete implementation of the abstract base class <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1VariableFillPattern.html">SAMRAI::xfer::VariableFillPattern</a>. It is used to calculate overlaps according to a pattern which limits overlaps to the face-centered ghost region surrounding a patch appropriate for "synchronizing" face-centered values at patch boundaries.  <a href="class_i_b_t_k_1_1_face_synch_copy_fill_pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_f_a_c_preconditioner.html">FACPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_f_a_c_preconditioner.html" title="Class FACPreconditioner is a concrete LinearSolver for implementing FAC (multilevel multigrid) precon...">FACPreconditioner</a> is a concrete <a class="el" href="class_i_b_t_k_1_1_linear_solver.html" title="Class LinearSolver provides an abstract interface for the implementation of solvers for linear proble...">LinearSolver</a> for implementing FAC (multilevel multigrid) preconditioners.  <a href="class_i_b_t_k_1_1_f_a_c_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_f_a_c_preconditioner_strategy.html">FACPreconditionerStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_f_a_c_preconditioner_strategy.html" title="Class FACPreconditionerStrategy provides an interface for specifying the problem-specific operations ...">FACPreconditionerStrategy</a> provides an interface for specifying the problem-specific operations needed to implement a specific FAC preconditioner.  <a href="class_i_b_t_k_1_1_f_a_c_preconditioner_strategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_f_e_cache.html">FECache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class storing multiple libMesh::FE objects, each corresponding to a different quadrature rule. Each FE object is configured with a quadrature rule corresponding to the provided <code>quad_key</code> parameter.  <a href="class_i_b_t_k_1_1_f_e_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_f_e_data.html">FEData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_f_e_data_interpolation.html">FEDataInterpolation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_f_e_data_interpolation.html" title="Class FEDataInterpolation manages data required to evaluate one or more FE field variables at a colle...">FEDataInterpolation</a> manages data required to evaluate one or more FE field variables at a collection of points, possibly (not not necessarily) corresponding to the points of a quadrature rule.  <a href="class_i_b_t_k_1_1_f_e_data_interpolation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_f_e_data_manager.html">FEDataManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_f_e_data_manager.html" title="Class FEDataManager coordinates data required for Lagrangian-Eulerian interaction between a Lagrangia...">FEDataManager</a> coordinates data required for Lagrangian-Eulerian interaction between a Lagrangian finite element (FE) mesh. In particular, the <a class="el" href="class_i_b_t_k_1_1_f_e_data.html">FEData</a> member object stores the necessary finite element data while this class stores additional data dependent on the Eulerian grid.  <a href="class_i_b_t_k_1_1_f_e_data_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_f_e_map_cache.html">FEMapCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class storing multiple libMesh::FEMap objects, each corresponding to a different quadrature rule. Each FEMap object is configured with a quadrature rule corresponding to the provided <code>quad_key</code> parameter.  <a href="class_i_b_t_k_1_1_f_e_map_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_f_e_projector.html">FEProjector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_f_e_projector.html" title="Class FEProjector coordinates data structures for projecting fields in FE models. ...">FEProjector</a> coordinates data structures for projecting fields in FE models.  <a href="class_i_b_t_k_1_1_f_e_projector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_f_e_values.html">FEValues</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_f_e_values_base.html">FEValuesBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_fixed_sized_stream.html">FixedSizedStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_fixed_sized_stream.html" title="Class FixedSizedStream provides a fixed-size message buffer used by various communication routines...">FixedSizedStream</a> provides a fixed-size message buffer used by various communication routines.  <a href="class_i_b_t_k_1_1_fixed_sized_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_general_operator.html">GeneralOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_general_operator.html" title="Class GeneralOperator provides an abstract interface for the specification of general operators to co...">GeneralOperator</a> provides an abstract interface for the specification of general operators to compute <img class="formulaInl" alt="$ y=F[x] $" src="form_126.png"/> and <img class="formulaInl" alt="$ z=F[x]+y $" src="form_127.png"/>.  <a href="class_i_b_t_k_1_1_general_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_general_solver.html">GeneralSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_general_solver.html" title="Class GeneralSolver provides an abstract interface for the implementation of linear or nonlinear solv...">GeneralSolver</a> provides an abstract interface for the implementation of linear or nonlinear solvers for systems of equations defined on an AMR patch hierarchy.  <a href="class_i_b_t_k_1_1_general_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_hex27_mapping.html">Hex27Mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_hierarchy_ghost_cell_interpolation.html">HierarchyGhostCellInterpolation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_hierarchy_ghost_cell_interpolation.html" title="Class HierarchyGhostCellInterpolation encapsulates the operations required to set ghost cell values a...">HierarchyGhostCellInterpolation</a> encapsulates the operations required to set ghost cell values at physical and coarse-fine boundaries across a range of levels of a locally refined patch hierarchy.  <a href="class_i_b_t_k_1_1_hierarchy_ghost_cell_interpolation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_hierarchy_integrator.html">HierarchyIntegrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_hierarchy_integrator.html" title="Class HierarchyIntegrator provides an abstract interface for a time integrator for a system of equati...">HierarchyIntegrator</a> provides an abstract interface for a time integrator for a system of equations defined on an AMR grid hierarchy, along with basic data management for variables defined on that hierarchy.  <a href="class_i_b_t_k_1_1_hierarchy_integrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_hierarchy_math_ops.html">HierarchyMathOps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_hierarchy_math_ops.html" title="Class HierarchyMathOps provides functionality to perform &quot;composite-grid&quot; mathematical operations on ...">HierarchyMathOps</a> provides functionality to perform "composite-grid" mathematical operations on a range of levels in a <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a> object.  <a href="class_i_b_t_k_1_1_hierarchy_math_ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_b_t_k_1_1_i_b_t_k___m_p_i.html">IBTK_MPI</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides C++ wrapper around MPI routines.  <a href="struct_i_b_t_k_1_1_i_b_t_k___m_p_i.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_i_b_t_k_init.html">IBTKInit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization for <a class="el" href="namespace_i_b_a_m_r.html">IBAMR</a> programs.  <a href="class_i_b_t_k_1_1_i_b_t_k_init.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_b_t_k_1_1_index_order.html">IndexOrder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_index_utilities.html">IndexUtilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_index_utilities.html" title="Class IndexUtilities is a utility class that defines simple functions such as conversion routines bet...">IndexUtilities</a> is a utility class that defines simple functions such as conversion routines between physical coordinates and Cartesian index space.  <a href="class_i_b_t_k_1_1_index_utilities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_jacobian_calculator.html">JacobianCalculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_jacobian_calculator_cache.html">JacobianCalculatorCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class storing multiple <a class="el" href="class_i_b_t_k_1_1_jacobian_calculator.html">JacobianCalculator</a> objects. We assume that quadrature rules are uniquely determined by the element type, quadrature type, and approximation order. There are several places in <a class="el" href="namespace_i_b_t_k.html">IBTK</a> where we make this assumption, e.g., we will use data from two quadrature rules assumed to be equal (by this metric) to initialize FEMap objects.  <a href="class_i_b_t_k_1_1_jacobian_calculator_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_jacobian_operator.html">JacobianOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_jacobian_operator.html" title="Class JacobianOperator provides an abstract interface for the specification of general operators to c...">JacobianOperator</a> provides an abstract interface for the specification of general operators to compute Jacobian-vector products, i.e., <img class="formulaInl" alt="$ F'[x]v $" src="form_130.png"/>.  <a href="class_i_b_t_k_1_1_jacobian_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_krylov_linear_solver.html">KrylovLinearSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_krylov_linear_solver.html" title="Class KrylovLinearSolver provides an abstract interface for the implementation of Krylov subspace sol...">KrylovLinearSolver</a> provides an abstract interface for the implementation of Krylov subspace solvers for linear problems of the form <img class="formulaInl" alt="$Ax=b$" src="form_45.png"/>.  <a href="class_i_b_t_k_1_1_krylov_linear_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_krylov_linear_solver_manager.html">KrylovLinearSolverManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_krylov_linear_solver_manager.html" title="Class KrylovLinearSolverManager is a singleton manager class to provide access to generic KrylovLinea...">KrylovLinearSolverManager</a> is a singleton manager class to provide access to generic <a class="el" href="class_i_b_t_k_1_1_krylov_linear_solver.html" title="Class KrylovLinearSolver provides an abstract interface for the implementation of Krylov subspace sol...">KrylovLinearSolver</a> implementations.  <a href="class_i_b_t_k_1_1_krylov_linear_solver_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_krylov_linear_solver_poisson_solver_interface.html">KrylovLinearSolverPoissonSolverInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_krylov_linear_solver_poisson_solver_interface.html" title="Class KrylovLinearSolverPoissonSolverInterface provides an interface for KrylovLinearSolvers that are...">KrylovLinearSolverPoissonSolverInterface</a> provides an interface for KrylovLinearSolvers that are to be used as Poisson solvers.  <a href="class_i_b_t_k_1_1_krylov_linear_solver_poisson_solver_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_lagrange_mapping.html">LagrangeMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_laplace_operator.html">LaplaceOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_laplace_operator.html" title="Class LaplaceOperator is an abstract base class for a Laplace-type operators. ">LaplaceOperator</a> is an abstract base class for a Laplace-type operators.  <a href="class_i_b_t_k_1_1_laplace_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_data.html">LData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_data.html" title="Class LData provides storage for a single scalar- or vector-valued Lagrangian quantity. ">LData</a> provides storage for a single scalar- or vector-valued Lagrangian quantity.  <a href="class_i_b_t_k_1_1_l_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_data_manager.html">LDataManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_data_manager.html" title="Class LDataManager coordinates the irregular distribution of LNode and LData on the patch hierarchy...">LDataManager</a> coordinates the irregular distribution of <a class="el" href="class_i_b_t_k_1_1_l_node.html" title="Class LNode is the basic element of an LMesh. ">LNode</a> and <a class="el" href="class_i_b_t_k_1_1_l_data.html" title="Class LData provides storage for a single scalar- or vector-valued Lagrangian quantity. ">LData</a> on the patch hierarchy.  <a href="class_i_b_t_k_1_1_l_data_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_e_interactor.html">LEInteractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_e_interactor.html" title="Class LEInteractor is a utility class that defines several functions to interpolate data from Euleria...">LEInteractor</a> is a utility class that defines several functions to interpolate data from Eulerian grid patches onto Lagrangian meshes and to spread values (<em>not</em> densities) from Lagrangian meshes to Eulerian grid patches.  <a href="class_i_b_t_k_1_1_l_e_interactor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_lib_mesh_system_i_b_vectors.html">LibMeshSystemIBVectors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_lib_mesh_system_i_b_vectors.html" title="Class LibMeshSystemIBVectors is a convenience class that manages access to libMesh vectors for the sa...">LibMeshSystemIBVectors</a> is a convenience class that manages access to <a class="el" href="namespacelib_mesh.html">libMesh</a> vectors for the same system defined on multiple parts. It extends the base class <a class="el" href="class_i_b_t_k_1_1_lib_mesh_system_vectors.html" title="Class LibMeshSystemVectors is a convenience class that manages access to libMesh vectors for the same...">LibMeshSystemVectors</a> to provide access to vectors ghosted with both the Lagrangian partitioning (i.e., <a class="el" href="namespacelib_mesh.html">libMesh</a>'s computed partitioning, as in the base class) as well as the IB partitioning (i.e., the partitioning based on the distribution of <a class="el" href="namespace_s_a_m_r_a_i.html">SAMRAI</a> data).  <a href="class_i_b_t_k_1_1_lib_mesh_system_i_b_vectors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_lib_mesh_system_vectors.html">LibMeshSystemVectors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_lib_mesh_system_vectors.html" title="Class LibMeshSystemVectors is a convenience class that manages access to libMesh vectors for the same...">LibMeshSystemVectors</a> is a convenience class that manages access to <a class="el" href="namespacelib_mesh.html">libMesh</a> vectors for the same system defined on multiple parts. This class only supports access to vectors ghosted with the Lagrangian partitioning (i.e., <a class="el" href="namespacelib_mesh.html">libMesh</a>'s computed partitioning). The subclass <a class="el" href="class_i_b_t_k_1_1_lib_mesh_system_i_b_vectors.html" title="Class LibMeshSystemIBVectors is a convenience class that manages access to libMesh vectors for the sa...">LibMeshSystemIBVectors</a> provides access to the IB partitioning (i.e., the partitioning based on the distribution of <a class="el" href="namespace_s_a_m_r_a_i.html">SAMRAI</a> data).  <a href="class_i_b_t_k_1_1_lib_mesh_system_vectors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_index_set_data.html">LIndexSetData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_index_set_data.html" title="Class LIndexSetData is a specialization of the templated class LSetData that is intended to be used w...">LIndexSetData</a> is a specialization of the templated class <a class="el" href="class_i_b_t_k_1_1_l_set_data.html" title="Class LSetData is a specialization of the templated class SAMRAI::pdat::IndexData that provides acces...">LSetData</a> that is intended to be used with Lagrangian data objects that provide Lagrangian and PETSc indexing information.  <a href="class_i_b_t_k_1_1_l_index_set_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_index_set_data_factory.html">LIndexSetDataFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class LIndexSetPatchDataFactory provides a <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1PatchDataFactory.html">SAMRAI::hier::PatchDataFactory</a> class corresponding to patch data of type <a class="el" href="class_i_b_t_k_1_1_l_index_set_data.html" title="Class LIndexSetData is a specialization of the templated class LSetData that is intended to be used w...">LIndexSetData</a>.  <a href="class_i_b_t_k_1_1_l_index_set_data_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_index_set_variable.html">LIndexSetVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_index_set_variable.html" title="Class LIndexSetVariable provides a SAMRAI::hier::Variable class corresponding to patch data of type L...">LIndexSetVariable</a> provides a <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a> class corresponding to patch data of type <a class="el" href="class_i_b_t_k_1_1_l_index_set_data.html" title="Class LIndexSetData is a specialization of the templated class LSetData that is intended to be used w...">LIndexSetData</a>.  <a href="class_i_b_t_k_1_1_l_index_set_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_linear_operator.html">LinearOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_linear_operator.html" title="Class LinearOperator provides an abstract interface for the specification of linear operators to comp...">LinearOperator</a> provides an abstract interface for the specification of linear operators to compute <img class="formulaInl" alt="$ y=Ax $" src="form_132.png"/> and <img class="formulaInl" alt="$ z=Ax+y $" src="form_133.png"/> and, optionally, <img class="formulaInl" alt="$ y=A^{T} x $" src="form_134.png"/> and <img class="formulaInl" alt="$ z=A^{T}x+y $" src="form_135.png"/>.  <a href="class_i_b_t_k_1_1_linear_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_linear_solver.html">LinearSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_linear_solver.html" title="Class LinearSolver provides an abstract interface for the implementation of solvers for linear proble...">LinearSolver</a> provides an abstract interface for the implementation of solvers for linear problems of the form <img class="formulaInl" alt="$Ax=b$" src="form_45.png"/>.  <a href="class_i_b_t_k_1_1_linear_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_init_strategy.html">LInitStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_init_strategy.html" title="Class LInitStrategy provides a mechanism for specifying the initial configuration of the curvilinear ...">LInitStrategy</a> provides a mechanism for specifying the initial configuration of the curvilinear mesh.  <a href="class_i_b_t_k_1_1_l_init_strategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_marker.html">LMarker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_marker.html" title="Class LMarker provides inter-processor communications functionality for a Lagrangian marker...">LMarker</a> provides inter-processor communications functionality for a Lagrangian marker.  <a href="class_i_b_t_k_1_1_l_marker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_marker_coarsen.html">LMarkerCoarsen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_marker_coarsen.html" title="Class LMarkerCoarsen is a concrete SAMRAI::xfer::CoarsenOperator for restricting IB marker data from ...">LMarkerCoarsen</a> is a concrete <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1CoarsenOperator.html">SAMRAI::xfer::CoarsenOperator</a> for restricting IB marker data from finer levels to coarser levels in the patch hierarchy.  <a href="class_i_b_t_k_1_1_l_marker_coarsen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_marker_refine.html">LMarkerRefine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_marker_refine.html" title="Class LMarkerRefine is a concrete SAMRAI::xfer::RefineOperator for prolonging IB marker data from coa...">LMarkerRefine</a> is a concrete <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefineOperator.html">SAMRAI::xfer::RefineOperator</a> for prolonging IB marker data from coarser levels to finer levels in the patch hierarchy.  <a href="class_i_b_t_k_1_1_l_marker_refine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_marker_utilities.html">LMarkerUtilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_marker_utilities.html" title="Class LMarkerUtilities is a utility class that defines useful functions for dealing with Lagrangian m...">LMarkerUtilities</a> is a utility class that defines useful functions for dealing with Lagrangian marker particles.  <a href="class_i_b_t_k_1_1_l_marker_utilities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_mesh.html">LMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_mesh.html" title="Class LMesh is a collection of LNode objects. ">LMesh</a> is a collection of <a class="el" href="class_i_b_t_k_1_1_l_node.html" title="Class LNode is the basic element of an LMesh. ">LNode</a> objects.  <a href="class_i_b_t_k_1_1_l_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_node.html">LNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_node.html" title="Class LNode is the basic element of an LMesh. ">LNode</a> is the basic element of an <a class="el" href="class_i_b_t_k_1_1_l_mesh.html" title="Class LMesh is a collection of LNode objects. ">LMesh</a>.  <a href="class_i_b_t_k_1_1_l_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_node_index.html">LNodeIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_node_index.html" title="Class LNodeIndex provides Lagrangian and PETSc indexing information for a single node of a Lagrangian...">LNodeIndex</a> provides Lagrangian and <a href="http://www.mcs.anl.gov/petsc">PETSc</a> indexing information for a single node of a Lagrangian mesh.  <a href="class_i_b_t_k_1_1_l_node_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_b_t_k_1_1_l_node_index_global_p_e_t_sc_index_comp.html">LNodeIndexGlobalPETScIndexComp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor to order on the global PETSc index of the Lagrangian node.  <a href="struct_i_b_t_k_1_1_l_node_index_global_p_e_t_sc_index_comp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_b_t_k_1_1_l_node_index_global_p_e_t_sc_index_equal.html">LNodeIndexGlobalPETScIndexEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor to check for equality between between <a class="el" href="class_i_b_t_k_1_1_l_node_index.html" title="Class LNodeIndex provides Lagrangian and PETSc indexing information for a single node of a Lagrangian...">LNodeIndex</a> objects based on their global PETSc indices.  <a href="struct_i_b_t_k_1_1_l_node_index_global_p_e_t_sc_index_equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_b_t_k_1_1_l_node_index_lagrangian_index_comp.html">LNodeIndexLagrangianIndexComp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor to order on the Lagrangian index of the Lagrangian node.  <a href="struct_i_b_t_k_1_1_l_node_index_lagrangian_index_comp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_b_t_k_1_1_l_node_index_lagrangian_index_equal.html">LNodeIndexLagrangianIndexEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor to check for equality between <a class="el" href="class_i_b_t_k_1_1_l_node_index.html" title="Class LNodeIndex provides Lagrangian and PETSc indexing information for a single node of a Lagrangian...">LNodeIndex</a> objects based on their Lagrangian indices.  <a href="struct_i_b_t_k_1_1_l_node_index_lagrangian_index_equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_b_t_k_1_1_l_node_index_local_p_e_t_sc_index_comp.html">LNodeIndexLocalPETScIndexComp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor to order on the local PETSc index of the Lagrangian node.  <a href="struct_i_b_t_k_1_1_l_node_index_local_p_e_t_sc_index_comp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_b_t_k_1_1_l_node_index_local_p_e_t_sc_index_equal.html">LNodeIndexLocalPETScIndexEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor to check for equality between <a class="el" href="class_i_b_t_k_1_1_l_node_index.html" title="Class LNodeIndex provides Lagrangian and PETSc indexing information for a single node of a Lagrangian...">LNodeIndex</a> objects based on their local PETSc indices.  <a href="struct_i_b_t_k_1_1_l_node_index_local_p_e_t_sc_index_equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_node_index_posn_comp.html">LNodeIndexPosnComp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor to order on the physical location of the Lagrangian node.  <a href="class_i_b_t_k_1_1_l_node_index_posn_comp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_node_index_posn_equal.html">LNodeIndexPosnEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor to check for equality between <a class="el" href="class_i_b_t_k_1_1_l_node_index.html" title="Class LNodeIndex provides Lagrangian and PETSc indexing information for a single node of a Lagrangian...">LNodeIndex</a> objects based on their positions.  <a href="class_i_b_t_k_1_1_l_node_index_posn_equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_set.html">LSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_set.html" title="Class LSet provides inter-processor communications and database access functionality to a collection ...">LSet</a> provides inter-processor communications and database access functionality to a collection of Lagrangian objects.  <a href="class_i_b_t_k_1_1_l_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_set_data.html">LSetData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_set_data.html" title="Class LSetData is a specialization of the templated class SAMRAI::pdat::IndexData that provides acces...">LSetData</a> is a specialization of the templated class <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a> that provides access to Lagrangian objects that are embedded in the a Cartesian grid patch.  <a href="class_i_b_t_k_1_1_l_set_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_set_data_factory.html">LSetDataFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class LSetPatchDataFactory provides a <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1PatchDataFactory.html">SAMRAI::hier::PatchDataFactory</a> class corresponding to patch data of type <a class="el" href="class_i_b_t_k_1_1_l_set_data.html" title="Class LSetData is a specialization of the templated class SAMRAI::pdat::IndexData that provides acces...">LSetData</a>.  <a href="class_i_b_t_k_1_1_l_set_data_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_set_data_iterator.html">LSetDataIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_set_data_iterator.html" title="Class LSetDataIterator is an iterator class which may be used to iterate through LSet objects associa...">LSetDataIterator</a> is an iterator class which may be used to iterate through <a class="el" href="class_i_b_t_k_1_1_l_set.html" title="Class LSet provides inter-processor communications and database access functionality to a collection ...">LSet</a> objects associated with a specified box in cell-centered index space.  <a href="class_i_b_t_k_1_1_l_set_data_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_set_variable.html">LSetVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_set_variable.html" title="Class LSetVariable provides a SAMRAI::hier::Variable class corresponding to patch data of type LSetDa...">LSetVariable</a> provides a <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a> class corresponding to patch data of type <a class="el" href="class_i_b_t_k_1_1_l_set_data.html" title="Class LSetData is a specialization of the templated class SAMRAI::pdat::IndexData that provides acces...">LSetData</a>.  <a href="class_i_b_t_k_1_1_l_set_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_silo_data_writer.html">LSiloDataWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_silo_data_writer.html" title="Class LSiloDataWriter provides functionality to output Lagrangian data for visualization via the VisI...">LSiloDataWriter</a> provides functionality to output Lagrangian data for visualization via the <a href="http://www.llnl.gov/visit">VisIt visualization tool</a> in the Silo data format.  <a href="class_i_b_t_k_1_1_l_silo_data_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_l_transaction.html">LTransaction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_l_transaction.html" title="Class LTransaction represents a communication transaction between two processors or a local data copy...">LTransaction</a> represents a communication transaction between two processors or a local data copy for communicating or copying Lagrangian objects.  <a href="class_i_b_t_k_1_1_l_transaction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_mapping.html">Mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_merging_load_balancer.html">MergingLoadBalancer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_merging_load_balancer.html" title="Class MergingLoadBalancer merges the boxes generated by a load balancer in a final step to decrease t...">MergingLoadBalancer</a> merges the boxes generated by a load balancer in a final step to decrease the total number of boxes. In essence, it postprocesses the list of boxes generated by its parent class to try and coalesce the set of boxes on each process.  <a href="class_i_b_t_k_1_1_merging_load_balancer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1mu_parser_cart_grid_function.html">muParserCartGridFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1mu_parser_cart_grid_function.html" title="Class muParserCartGridFunction is an implementation of the strategy class CartGridFunction that allow...">muParserCartGridFunction</a> is an implementation of the strategy class <a class="el" href="class_i_b_t_k_1_1_cart_grid_function.html" title="Class CartGridFunction provides an abstract interface for objects for evaluating functions to set val...">CartGridFunction</a> that allows for the run-time specification of (possibly spatially- and temporally-varying) functions which are used to set double precision values on standard <a class="el" href="namespace_s_a_m_r_a_i.html">SAMRAI</a> <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1PatchData.html">SAMRAI::hier::PatchData</a> objects.  <a href="class_i_b_t_k_1_1mu_parser_cart_grid_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1mu_parser_robin_bc_coefs.html">muParserRobinBcCoefs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1mu_parser_robin_bc_coefs.html" title="Class muParserRobinBcCoefs is an implementation of the strategy class SAMRAI::solv::RobinBcCoefStrate...">muParserRobinBcCoefs</a> is an implementation of the strategy class <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a> that allows for the run-time specification of (possibly spatially- and temporally-varying) Robin boundary conditions.  <a href="class_i_b_t_k_1_1mu_parser_robin_bc_coefs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_newton_krylov_solver.html">NewtonKrylovSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_newton_krylov_solver.html" title="Class NewtonKrylovSolver provides an abstract interface for the implementation of inexact Newton-Kryl...">NewtonKrylovSolver</a> provides an abstract interface for the implementation of inexact Newton-Krylov solvers for nonlinear problems of the form <img class="formulaInl" alt="$ F[x]=b $" src="form_136.png"/>.  <a href="class_i_b_t_k_1_1_newton_krylov_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_newton_krylov_solver_manager.html">NewtonKrylovSolverManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_newton_krylov_solver_manager.html" title="Class NewtonKrylovSolverManager is a singleton manager class to provide access to generic NewtonKrylo...">NewtonKrylovSolverManager</a> is a singleton manager class to provide access to generic <a class="el" href="class_i_b_t_k_1_1_newton_krylov_solver.html" title="Class NewtonKrylovSolver provides an abstract interface for the implementation of inexact Newton-Kryl...">NewtonKrylovSolver</a> implementations.  <a href="class_i_b_t_k_1_1_newton_krylov_solver_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_nodal_mapping.html">NodalMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_node_data_synchronization.html">NodeDataSynchronization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_node_data_synchronization.html" title="Class NodeDataSynchronization encapsulates the operations required to &quot;synchronize&quot; node-centered val...">NodeDataSynchronization</a> encapsulates the operations required to "synchronize" node-centered values defined at patch boundaries.  <a href="class_i_b_t_k_1_1_node_data_synchronization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_node_synch_copy_fill_pattern.html">NodeSynchCopyFillPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class NodeCellSynchCopyFillPattern is a concrete implementation of the abstract base class <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1VariableFillPattern.html">SAMRAI::xfer::VariableFillPattern</a>. It is used to calculate overlaps according to a pattern which limits overlaps to the node-centered ghost region surrounding a patch appropriate for "synchronizing" node-centered values in an axis-by-axis manner at patch boundaries.  <a href="class_i_b_t_k_1_1_node_synch_copy_fill_pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_norm_ops.html">NormOps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_norm_ops.html" title="Class NormOps provides functionality for computing discrete vector norms. ">NormOps</a> provides functionality for computing discrete vector norms.  <a href="class_i_b_t_k_1_1_norm_ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_parallel_edge_map.html">ParallelEdgeMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_parallel_edge_map.html" title="Class ParallelEdgeMap is a utility class for managing edge maps (i.e., maps from vertices to links be...">ParallelEdgeMap</a> is a utility class for managing edge maps (i.e., maps from vertices to links between vertices) in parallel.  <a href="class_i_b_t_k_1_1_parallel_edge_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_parallel_map.html">ParallelMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_parallel_map.html" title="Class ParallelMap is a utility class for associating integer keys with arbitrary data items in parall...">ParallelMap</a> is a utility class for associating integer keys with arbitrary data items in parallel.  <a href="class_i_b_t_k_1_1_parallel_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_parallel_set.html">ParallelSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_parallel_set.html" title="Class ParallelSet is a utility class for storing collections of integer keys in parallel. ">ParallelSet</a> is a utility class for storing collections of integer keys in parallel.  <a href="class_i_b_t_k_1_1_parallel_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_partitioning_box.html">PartitioningBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_partitioning_box.html" title="Class PartitioningBox implements an NDIM-dimensional bounding box defined by two points. Unlike a standard bounding box, a PartitioningBox is an NDIM-dimensional tensor product of half-open intervals: i.e., it is a half-open box. This property allows one to partition a domain into a set of boxes. ">PartitioningBox</a> implements an NDIM-dimensional bounding box defined by two points. Unlike a standard bounding box, a <a class="el" href="class_i_b_t_k_1_1_partitioning_box.html" title="Class PartitioningBox implements an NDIM-dimensional bounding box defined by two points. Unlike a standard bounding box, a PartitioningBox is an NDIM-dimensional tensor product of half-open intervals: i.e., it is a half-open box. This property allows one to partition a domain into a set of boxes. ">PartitioningBox</a> is an <code>NDIM</code>-dimensional tensor product of half-open intervals: i.e., it is a half-open box. This property allows one to partition a domain into a set of boxes.  <a href="class_i_b_t_k_1_1_partitioning_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_partitioning_boxes.html">PartitioningBoxes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_partitioning_boxes.html" title="Class PartitioningBoxes stores a set of bounding boxes and can check if a point is in the set of part...">PartitioningBoxes</a> stores a set of bounding boxes and can check if a point is in the set of partitioning boxes or not in a more optimized way than just looping over a std::vector&lt;PartitioningBox&gt;.  <a href="class_i_b_t_k_1_1_partitioning_boxes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_patch_math_ops.html">PatchMathOps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_patch_math_ops.html" title="Class PatchMathOps provides functionality to perform mathematical operations on individual SAMRAI::hi...">PatchMathOps</a> provides functionality to perform mathematical operations on <em>individual</em> <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a> objects.  <a href="class_i_b_t_k_1_1_patch_math_ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_krylov_linear_solver.html">PETScKrylovLinearSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_krylov_linear_solver.html" title="Class PETScKrylovLinearSolver provides a KrylovLinearSolver interface for a PETSc Krylov subspace ite...">PETScKrylovLinearSolver</a> provides a <a class="el" href="class_i_b_t_k_1_1_krylov_linear_solver.html" title="Class KrylovLinearSolver provides an abstract interface for the implementation of Krylov subspace sol...">KrylovLinearSolver</a> interface for a <a href="http://www.mcs.anl.gov/petsc">PETSc</a> Krylov subspace iterative linear solver (KSP).  <a href="class_i_b_t_k_1_1_p_e_t_sc_krylov_linear_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_krylov_poisson_solver.html">PETScKrylovPoissonSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_krylov_poisson_solver.html" title="Class PETScKrylovPoissonSolver is an extension of class PETScKrylovLinearSolver that provides an impl...">PETScKrylovPoissonSolver</a> is an extension of class <a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_krylov_linear_solver.html" title="Class PETScKrylovLinearSolver provides a KrylovLinearSolver interface for a PETSc Krylov subspace ite...">PETScKrylovLinearSolver</a> that provides an implementation of the <a class="el" href="class_i_b_t_k_1_1_poisson_solver.html" title="Class PoissonSolver is an abstract base class for Poisson solvers. ">PoissonSolver</a> interface.  <a href="class_i_b_t_k_1_1_p_e_t_sc_krylov_poisson_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_level_solver.html">PETScLevelSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_level_solver.html" title="Class PETScLevelSolver is an abstract LinearSolver for solving systems of linear equations on a singl...">PETScLevelSolver</a> is an abstract <a class="el" href="class_i_b_t_k_1_1_linear_solver.html" title="Class LinearSolver provides an abstract interface for the implementation of solvers for linear proble...">LinearSolver</a> for solving systems of linear equations on a <em>single</em> <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a> using <a href="http://www.mcs.anl.gov/petsc/petsc-as">PETSc</a>.  <a href="class_i_b_t_k_1_1_p_e_t_sc_level_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_mat_l_o_wrapper.html">PETScMatLOWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_mat_l_o_wrapper.html" title="Class PETScMatLOWrapper provides a LinearOperator interface for a PETSc Mat object. ">PETScMatLOWrapper</a> provides a <a class="el" href="class_i_b_t_k_1_1_linear_operator.html" title="Class LinearOperator provides an abstract interface for the specification of linear operators to comp...">LinearOperator</a> interface for a <a href="http://www.mcs.anl.gov/petsc">PETSc</a> Mat object.  <a href="class_i_b_t_k_1_1_p_e_t_sc_mat_l_o_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_mat_utilities.html">PETScMatUtilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_mat_utilities.html" title="Class PETScMatUtilities provides utility functions for PETSc Mat objects. ">PETScMatUtilities</a> provides utility functions for <a href="http://www.mcs.anl.gov/petsc">PETSc</a> Mat objects.  <a href="class_i_b_t_k_1_1_p_e_t_sc_mat_utilities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_m_f_f_d_jacobian_operator.html">PETScMFFDJacobianOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_m_f_f_d_jacobian_operator.html" title="Class PETScMFFDJacobianOperator provides a method for computing Jacobian-vector products, i.e., , via a matrix-free finite-difference approach. ">PETScMFFDJacobianOperator</a> provides a method for computing Jacobian-vector products, i.e., <img class="formulaInl" alt="$ F'[x]v $" src="form_130.png"/>, via a matrix-free finite-difference approach.  <a href="class_i_b_t_k_1_1_p_e_t_sc_m_f_f_d_jacobian_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_newton_krylov_solver.html">PETScNewtonKrylovSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_newton_krylov_solver.html" title="Class PETScNewtonKrylovSolver provides a NewtonKrylovSolver interface for a PETSc inexact Newton-Kryl...">PETScNewtonKrylovSolver</a> provides a <a class="el" href="class_i_b_t_k_1_1_newton_krylov_solver.html" title="Class NewtonKrylovSolver provides an abstract interface for the implementation of inexact Newton-Kryl...">NewtonKrylovSolver</a> interface for a <a href="http://www.mcs.anl.gov/petsc">PETSc</a> inexact Newton-Krylov iterative nonlinear solver (SNES).  <a href="class_i_b_t_k_1_1_p_e_t_sc_newton_krylov_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_p_c_l_s_wrapper.html">PETScPCLSWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_p_c_l_s_wrapper.html" title="Class PETScPCLSWrapper provides a LinearSolver interface for a PETSc PC object. ">PETScPCLSWrapper</a> provides a <a class="el" href="class_i_b_t_k_1_1_linear_solver.html" title="Class LinearSolver provides an abstract interface for the implementation of solvers for linear proble...">LinearSolver</a> interface for a <a href="http://www.mcs.anl.gov/petsc">PETSc</a> PC object.  <a href="class_i_b_t_k_1_1_p_e_t_sc_p_c_l_s_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_s_a_m_r_a_i_vector_real.html">PETScSAMRAIVectorReal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_s_a_m_r_a_i_vector_real.html" title="Class PETScSAMRAIVectorReal is a class for wrapping SAMRAI::solv::SAMRAIVectorReal objects so that th...">PETScSAMRAIVectorReal</a> is a class for wrapping <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a> objects so that they may be used with the <a href="http://www.mcs.anl.gov/petsc">PETSc</a> solver package.  <a href="class_i_b_t_k_1_1_p_e_t_sc_s_a_m_r_a_i_vector_real.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_s_n_e_s_function_g_o_wrapper.html">PETScSNESFunctionGOWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_s_n_e_s_function_g_o_wrapper.html" title="Class PETScSNESFunctionGOWrapper provides a GeneralOperator interface for a PETSc SNES nonlinear func...">PETScSNESFunctionGOWrapper</a> provides a <a class="el" href="class_i_b_t_k_1_1_general_operator.html" title="Class GeneralOperator provides an abstract interface for the specification of general operators to co...">GeneralOperator</a> interface for a <a href="http://www.mcs.anl.gov/petsc">PETSc</a> SNES nonlinear function.  <a href="class_i_b_t_k_1_1_p_e_t_sc_s_n_e_s_function_g_o_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_s_n_e_s_jacobian_j_o_wrapper.html">PETScSNESJacobianJOWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_s_n_e_s_jacobian_j_o_wrapper.html" title="Class PETScSNESJacobianJOWrapper provides a JacobianOperator interface for a PETSc SNES Jacobian...">PETScSNESJacobianJOWrapper</a> provides a <a class="el" href="class_i_b_t_k_1_1_jacobian_operator.html" title="Class JacobianOperator provides an abstract interface for the specification of general operators to c...">JacobianOperator</a> interface for a <a href="http://www.mcs.anl.gov/petsc">PETSc</a> SNES Jacobian.  <a href="class_i_b_t_k_1_1_p_e_t_sc_s_n_e_s_jacobian_j_o_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_vec_utilities.html">PETScVecUtilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_vec_utilities.html" title="Class PETScVecUtilities provides utility functions for PETSc Vec objects. ">PETScVecUtilities</a> provides utility functions for <a href="http://www.mcs.anl.gov/petsc">PETSc</a> Vec objects.  <a href="class_i_b_t_k_1_1_p_e_t_sc_vec_utilities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_physical_boundary_utilities.html">PhysicalBoundaryUtilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_physical_boundary_utilities.html" title="Class PhysicalBoundaryUtilities is a utility class to organize functions related to setting values at...">PhysicalBoundaryUtilities</a> is a utility class to organize functions related to setting values at physical boundaries.  <a href="class_i_b_t_k_1_1_physical_boundary_utilities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_point_map.html">PointMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_poisson_f_a_c_preconditioner.html">PoissonFACPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_poisson_f_a_c_preconditioner.html" title="Class PoissonFACPreconditioner is a FACPreconditioner that has been specialized for Poisson problems...">PoissonFACPreconditioner</a> is a <a class="el" href="class_i_b_t_k_1_1_f_a_c_preconditioner.html" title="Class FACPreconditioner is a concrete LinearSolver for implementing FAC (multilevel multigrid) precon...">FACPreconditioner</a> that has been specialized for Poisson problems.  <a href="class_i_b_t_k_1_1_poisson_f_a_c_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_poisson_f_a_c_preconditioner_strategy.html">PoissonFACPreconditionerStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_poisson_f_a_c_preconditioner_strategy.html" title="Class PoissonFACPreconditionerStrategy is an abstract FACPreconditionerStrategy implementing many of ...">PoissonFACPreconditionerStrategy</a> is an abstract <a class="el" href="class_i_b_t_k_1_1_f_a_c_preconditioner_strategy.html" title="Class FACPreconditionerStrategy provides an interface for specifying the problem-specific operations ...">FACPreconditionerStrategy</a> implementing many of the operations required by smoothers for the Poisson equation and related problems.  <a href="class_i_b_t_k_1_1_poisson_f_a_c_preconditioner_strategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_poisson_solver.html">PoissonSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_poisson_solver.html" title="Class PoissonSolver is an abstract base class for Poisson solvers. ">PoissonSolver</a> is an abstract base class for Poisson solvers.  <a href="class_i_b_t_k_1_1_poisson_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_poisson_utilities.html">PoissonUtilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_poisson_utilities.html" title="Class PoissonUtilities provides utility functions for constructing Poisson solvers. ">PoissonUtilities</a> provides utility functions for constructing Poisson solvers.  <a href="class_i_b_t_k_1_1_poisson_utilities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_quad4_mapping.html">Quad4Mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_quad9_mapping.html">Quad9Mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_quadrature_cache.html">QuadratureCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class storing multiple <a class="el" href="namespacelib_mesh.html">libMesh</a> quadrature objects. We assume that quadrature rules are uniquely determined by the element type, quadrature type, and approximation order. There are several places in <a class="el" href="namespace_i_b_t_k.html">IBTK</a> where we make this assumption, e.g., we will use data from two quadrature rules assumed to be equal (by this metric) to initialize FEMap objects.  <a href="class_i_b_t_k_1_1_quadrature_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_refine_patch_strategy_set.html">RefinePatchStrategySet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_refine_patch_strategy_set.html" title="Class RefinePatchStrategySet is a utility class that allows multiple SAMRAI::xfer::RefinePatchStrateg...">RefinePatchStrategySet</a> is a utility class that allows multiple <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a> objects to be employed by a single <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>.  <a href="class_i_b_t_k_1_1_refine_patch_strategy_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_robin_phys_bdry_patch_strategy.html">RobinPhysBdryPatchStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_robin_phys_bdry_patch_strategy.html" title="Class RobinPhysBdryPatchStrategy is an abstract strategy class that extends the SAMRAI::xfer::RefineP...">RobinPhysBdryPatchStrategy</a> is an abstract strategy class that extends the <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a> interface to provide routines specific for setting Robin boundary conditions at physical boundaries. This class also provides default implementations of some methods defined in <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a> that are generally not needed for filling ghost cell values at physical boundaries.  <a href="class_i_b_t_k_1_1_robin_phys_bdry_patch_strategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_s_a_m_r_a_i_data_cache.html">SAMRAIDataCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_s_a_m_r_a_i_data_cache.html" title="Class SAMRAIDataCache is a utility class for caching cloned SAMRAI patch data. Patch data are allocat...">SAMRAIDataCache</a> is a utility class for caching cloned <a class="el" href="namespace_s_a_m_r_a_i.html">SAMRAI</a> patch data. Patch data are allocated as needed and should not be deallocated by the caller.  <a href="class_i_b_t_k_1_1_s_a_m_r_a_i_data_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_s_a_m_r_a_i_ghost_data_accumulator.html">SAMRAIGhostDataAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that can accumulate data summed into ghost regions on a patch hierarchy into their correct locations.  <a href="class_i_b_t_k_1_1_s_a_m_r_a_i_ghost_data_accumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_s_c_laplace_operator.html">SCLaplaceOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_s_c_laplace_operator.html" title="Class SCLaplaceOperator is a concrete LaplaceOperator which implements a globally second-order accura...">SCLaplaceOperator</a> is a concrete <a class="el" href="class_i_b_t_k_1_1_laplace_operator.html" title="Class LaplaceOperator is an abstract base class for a Laplace-type operators. ">LaplaceOperator</a> which implements a globally second-order accurate side-centered finite difference discretization of a scalar elliptic operator of the form <img class="formulaInl" alt="$ L = C I + \nabla \cdot D \nabla$" src="form_113.png"/>.  <a href="class_i_b_t_k_1_1_s_c_laplace_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_s_c_poisson_hypre_level_solver.html">SCPoissonHypreLevelSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_s_c_poisson_hypre_level_solver.html" title="Class SCPoissonHypreLevelSolver is a concrete LinearSolver for solving elliptic equations of the form...">SCPoissonHypreLevelSolver</a> is a concrete <a class="el" href="class_i_b_t_k_1_1_linear_solver.html" title="Class LinearSolver provides an abstract interface for the implementation of solvers for linear proble...">LinearSolver</a> for solving elliptic equations of the form <img class="formulaInl" alt="$ \mbox{$L u$} = \mbox{$(C I + \nabla \cdot D \nabla) u$} = f $" src="form_114.png"/> on a <em>single</em> <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a> using <a href="https://computation.llnl.gov/casc/linear_solvers/sls_hypre.html">hypre</a>.  <a href="class_i_b_t_k_1_1_s_c_poisson_hypre_level_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_s_c_poisson_p_e_t_sc_level_solver.html">SCPoissonPETScLevelSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_s_c_poisson_p_e_t_sc_level_solver.html" title="Class SCPoissonPETScLevelSolver is a concrete PETScLevelSolver for solving elliptic equations of the ...">SCPoissonPETScLevelSolver</a> is a concrete <a class="el" href="class_i_b_t_k_1_1_p_e_t_sc_level_solver.html" title="Class PETScLevelSolver is an abstract LinearSolver for solving systems of linear equations on a singl...">PETScLevelSolver</a> for solving elliptic equations of the form <img class="formulaInl" alt="$ \mbox{$L u$} = \mbox{$(C I + \nabla \cdot D \nabla) u$} = f $" src="form_114.png"/> on a <em>single</em> <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a> using <a href="http://www.mcs.anl.gov/petsc/petsc-as">PETSc</a>.  <a href="class_i_b_t_k_1_1_s_c_poisson_p_e_t_sc_level_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_s_c_poisson_point_relaxation_f_a_c_operator.html">SCPoissonPointRelaxationFACOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_s_c_poisson_point_relaxation_f_a_c_operator.html" title="Class SCPoissonPointRelaxationFACOperator is a concrete PoissonFACPreconditionerStrategy for solving ...">SCPoissonPointRelaxationFACOperator</a> is a concrete <a class="el" href="class_i_b_t_k_1_1_poisson_f_a_c_preconditioner_strategy.html" title="Class PoissonFACPreconditionerStrategy is an abstract FACPreconditionerStrategy implementing many of ...">PoissonFACPreconditionerStrategy</a> for solving elliptic equations of the form <img class="formulaInl" alt="$ \mbox{$L u$} = \mbox{$(C I + \nabla \cdot D \nabla) u$} = f $" src="form_114.png"/> using a globally second-order accurate side-centered finite-difference discretization, with support for Robin and periodic boundary conditions.  <a href="class_i_b_t_k_1_1_s_c_poisson_point_relaxation_f_a_c_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_s_c_poisson_solver_manager.html">SCPoissonSolverManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_s_c_poisson_solver_manager.html" title="Class SCPoissonSolverManager is a singleton manager class to provide access to generic side-centered ...">SCPoissonSolverManager</a> is a singleton manager class to provide access to generic side-centered <a class="el" href="class_i_b_t_k_1_1_poisson_solver.html" title="Class PoissonSolver is an abstract base class for Poisson solvers. ">PoissonSolver</a> implementations.  <a href="class_i_b_t_k_1_1_s_c_poisson_solver_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_side_data_synchronization.html">SideDataSynchronization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_side_data_synchronization.html" title="Class SideDataSynchronization encapsulates the operations required to &quot;synchronize&quot; side-centered val...">SideDataSynchronization</a> encapsulates the operations required to "synchronize" side-centered values defined at patch boundaries.  <a href="class_i_b_t_k_1_1_side_data_synchronization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_side_no_corners_fill_pattern.html">SideNoCornersFillPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class SideCellNoCornersFillPattern is a concrete implementation of the abstract base class <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1VariableFillPattern.html">SAMRAI::xfer::VariableFillPattern</a>. It is used to calculate overlaps according to a pattern which limits overlaps to the cell-centered ghost region surrounding a patch, excluding all corners. In 3D, it is also possible to configure this fill pattern object also to exclude all edges.  <a href="class_i_b_t_k_1_1_side_no_corners_fill_pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_side_synch_copy_fill_pattern.html">SideSynchCopyFillPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class SideCellSynchCopyFillPattern is a concrete implementation of the abstract base class <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1xfer_1_1VariableFillPattern.html">SAMRAI::xfer::VariableFillPattern</a>. It is used to calculate overlaps according to a pattern which limits overlaps to the side-centered ghost region surrounding a patch appropriate for "synchronizing" side-centered values at patch boundaries.  <a href="class_i_b_t_k_1_1_side_synch_copy_fill_pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_staggered_physical_boundary_helper.html">StaggeredPhysicalBoundaryHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_staggered_physical_boundary_helper.html" title="Class StaggeredPhysicalBoundaryHelper provides helper functions to handle physical boundary condition...">StaggeredPhysicalBoundaryHelper</a> provides helper functions to handle physical boundary conditions for a staggered grid discretizations.  <a href="class_i_b_t_k_1_1_staggered_physical_boundary_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_standard_tag_and_init_strategy_set.html">StandardTagAndInitStrategySet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_standard_tag_and_init_strategy_set.html" title="Class StandardTagAndInitStrategySet is a utility class that allows multiple SAMRAI::mesh::StandardTag...">StandardTagAndInitStrategySet</a> is a utility class that allows multiple <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a> objects to be employed by a single <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html">SAMRAI::mesh::StandardTagAndInitialize</a> object.  <a href="class_i_b_t_k_1_1_standard_tag_and_init_strategy_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_streamable.html">Streamable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_streamable.html" title="Class Streamable is an abstract interface for objects that can be packed into SAMRAI::tbox::AbstractS...">Streamable</a> is an abstract interface for objects that can be packed into <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1AbstractStream.html">SAMRAI::tbox::AbstractStream</a> data streams.  <a href="class_i_b_t_k_1_1_streamable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_streamable_factory.html">StreamableFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_streamable_factory.html" title="Class StreamableFactory is an abstract interface for classes that can unpack particular concrete Stre...">StreamableFactory</a> is an abstract interface for classes that can unpack particular concrete <a class="el" href="class_i_b_t_k_1_1_streamable.html" title="Class Streamable is an abstract interface for objects that can be packed into SAMRAI::tbox::AbstractS...">Streamable</a> objects from <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1AbstractStream.html">SAMRAI::tbox::AbstractStream</a> data streams.  <a href="class_i_b_t_k_1_1_streamable_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_streamable_manager.html">StreamableManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_streamable_manager.html" title="Class StreamableManager is a singleton manager class that organizes the actual packing and unpacking ...">StreamableManager</a> is a singleton manager class that organizes the actual packing and unpacking of concrete <a class="el" href="class_i_b_t_k_1_1_streamable.html" title="Class Streamable is an abstract interface for objects that can be packed into SAMRAI::tbox::AbstractS...">Streamable</a> objects for <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1tbox_1_1AbstractStream.html">SAMRAI::tbox::AbstractStream</a> based communication.  <a href="class_i_b_t_k_1_1_streamable_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_b_t_k_1_1_system_data.html">SystemData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_tet10_mapping.html">Tet10Mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_tet4_mapping.html">Tet4Mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_tri3_mapping.html">Tri3Mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_v_c_s_c_viscous_operator.html">VCSCViscousOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_v_c_s_c_viscous_operator.html" title="Class VCSCViscousOperator is a subclass of SCLaplaceOperator which implements a globally second-order...">VCSCViscousOperator</a> is a subclass of <a class="el" href="class_i_b_t_k_1_1_s_c_laplace_operator.html" title="Class SCLaplaceOperator is a concrete LaplaceOperator which implements a globally second-order accura...">SCLaplaceOperator</a> which implements a globally second-order accurate side-centered finite difference discretization of a vector elliptic operator of the form <img class="formulaInl" alt="$ L = \beta C I + \alpha \nabla \cdot \mu ( (\nabla u) + (\nabla u)^T ) $" src="form_142.png"/>.  <a href="class_i_b_t_k_1_1_v_c_s_c_viscous_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_v_c_s_c_viscous_op_point_relaxation_f_a_c_operator.html">VCSCViscousOpPointRelaxationFACOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_v_c_s_c_viscous_op_point_relaxation_f_a_c_operator.html" title="Class VCSCViscousOpPointRelaxationFACOperator is a specialization of SCPoissonPointRelaxationFACOpera...">VCSCViscousOpPointRelaxationFACOperator</a> is a specialization of <a class="el" href="class_i_b_t_k_1_1_s_c_poisson_point_relaxation_f_a_c_operator.html" title="Class SCPoissonPointRelaxationFACOperator is a concrete PoissonFACPreconditionerStrategy for solving ...">SCPoissonPointRelaxationFACOperator</a> for solving vector elliptic equation of the form <img class="formulaInl" alt="$ \mbox{$L u$} = C u + \nabla \cdot \mu (\nabla u + (\nabla u)^T) = f $" src="form_144.png"/> using a globally second-order accurate side-centered finite-difference discretization, with support for Robin and periodic boundary conditions.  <a href="class_i_b_t_k_1_1_v_c_s_c_viscous_op_point_relaxation_f_a_c_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_b_t_k_1_1_v_c_s_c_viscous_p_e_t_sc_level_solver.html">VCSCViscousPETScLevelSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="class_i_b_t_k_1_1_v_c_s_c_viscous_p_e_t_sc_level_solver.html" title="Class VCSCViscousPETScLevelSolver is a subclass of SCPoissonPETScLevelSolver class which solves vecto...">VCSCViscousPETScLevelSolver</a> is a subclass of <a class="el" href="class_i_b_t_k_1_1_s_c_poisson_p_e_t_sc_level_solver.html" title="Class SCPoissonPETScLevelSolver is a concrete PETScLevelSolver for solving elliptic equations of the ...">SCPoissonPETScLevelSolver</a> class which solves vector-valued elliptic equation of the form <img class="formulaInl" alt="$ \mbox{$L u$} = C u + \nabla \cdot \mu (\nabla u + (\nabla u)^T) = f $" src="form_144.png"/> on a <em>single</em> <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a> using <a href="http://www.mcs.anl.gov/petsc/petsc-as">PETSc</a>.  <a href="class_i_b_t_k_1_1_v_c_s_c_viscous_p_e_t_sc_level_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a454b0ed65ab2ecf794a6521c9544167a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a454b0ed65ab2ecf794a6521c9544167a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a454b0ed65ab2ecf794a6521c9544167a">EigenAlignedVector</a> = <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; T, Eigen::aligned_allocator&lt; T &gt; &gt;</td></tr>
<tr class="separator:a454b0ed65ab2ecf794a6521c9544167a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9a16623626884f27ea03f128cadfcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf9a16623626884f27ea03f128cadfcb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix2d</b> = Eigen::Matrix&lt; double, 2, 2 &gt;</td></tr>
<tr class="separator:adf9a16623626884f27ea03f128cadfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c2c9e6af54a75b53b2899e1dd737c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57c2c9e6af54a75b53b2899e1dd737c9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vector2d</b> = Eigen::Matrix&lt; double, 2, 1 &gt;</td></tr>
<tr class="separator:a57c2c9e6af54a75b53b2899e1dd737c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b3ea7366a0fe96f56b0200bc1b8e77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93b3ea7366a0fe96f56b0200bc1b8e77"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ColumnVector2d</b> = Eigen::Matrix&lt; double, 2, 1 &gt;</td></tr>
<tr class="separator:a93b3ea7366a0fe96f56b0200bc1b8e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7055bb6960f6fc39aa553494fb69d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d7055bb6960f6fc39aa553494fb69d4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>RowVector2d</b> = Eigen::Matrix&lt; double, 1, 2 &gt;</td></tr>
<tr class="separator:a8d7055bb6960f6fc39aa553494fb69d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ad687550740b96db47464cde5721f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82ad687550740b96db47464cde5721f4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix3d</b> = Eigen::Matrix&lt; double, 3, 3 &gt;</td></tr>
<tr class="separator:a82ad687550740b96db47464cde5721f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ae9d461191bfbc3f356a669835f365"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4ae9d461191bfbc3f356a669835f365"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vector3d</b> = Eigen::Matrix&lt; double, 3, 1 &gt;</td></tr>
<tr class="separator:ab4ae9d461191bfbc3f356a669835f365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed427cf9ba7c7dc4fccefdaba4be823b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed427cf9ba7c7dc4fccefdaba4be823b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ColumnVector3d</b> = Eigen::Matrix&lt; double, 3, 1 &gt;</td></tr>
<tr class="separator:aed427cf9ba7c7dc4fccefdaba4be823b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada34760f7623fade0ba21f04b76dcf63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada34760f7623fade0ba21f04b76dcf63"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>RowVector3d</b> = Eigen::Matrix&lt; double, 1, 3 &gt;</td></tr>
<tr class="separator:ada34760f7623fade0ba21f04b76dcf63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f18d4de9fe15f20d78f4f943f818bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67f18d4de9fe15f20d78f4f943f818bc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixNd</b> = Eigen::Matrix&lt; double, NDIM, NDIM &gt;</td></tr>
<tr class="separator:a67f18d4de9fe15f20d78f4f943f818bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b73983d16b31c6192694e6101f57273"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b73983d16b31c6192694e6101f57273"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VectorNd</b> = Eigen::Matrix&lt; double, NDIM, 1 &gt;</td></tr>
<tr class="separator:a2b73983d16b31c6192694e6101f57273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1137eefc68da668954ab11a43255186"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1137eefc68da668954ab11a43255186"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ColumnVectorNd</b> = Eigen::Matrix&lt; double, NDIM, 1 &gt;</td></tr>
<tr class="separator:af1137eefc68da668954ab11a43255186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca334f5726a653bdade6bb25e533b533"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca334f5726a653bdade6bb25e533b533"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>RowVectorNd</b> = Eigen::Matrix&lt; double, 1, NDIM &gt;</td></tr>
<tr class="separator:aca334f5726a653bdade6bb25e533b533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3d55a318b465924a7a4a9163c650ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b3d55a318b465924a7a4a9163c650ad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixXd</b> = Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a1b3d55a318b465924a7a4a9163c650ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c64fdd39a3b5adab73e8d5173aa9d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12c64fdd39a3b5adab73e8d5173aa9d2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VectorXd</b> = Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:a12c64fdd39a3b5adab73e8d5173aa9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451e0b737a3282a03632af2b90f8c026"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a451e0b737a3282a03632af2b90f8c026"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ColumnVectorXd</b> = Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:a451e0b737a3282a03632af2b90f8c026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839aacfd5da68aab82ccc0838f86d27a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a839aacfd5da68aab82ccc0838f86d27a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>RowVectorXd</b> = Eigen::Matrix&lt; double, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a839aacfd5da68aab82ccc0838f86d27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571dee285c7f5b44c20ffb11a1b96ed3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a571dee285c7f5b44c20ffb11a1b96ed3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix</b> = MatrixNd</td></tr>
<tr class="separator:a571dee285c7f5b44c20ffb11a1b96ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c97469e791a47756eb44b9ec93c59e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8c97469e791a47756eb44b9ec93c59e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Point</b> = VectorNd</td></tr>
<tr class="separator:ac8c97469e791a47756eb44b9ec93c59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a4d4ded781c3a9630a42d88680e89f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09a4d4ded781c3a9630a42d88680e89f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b> = VectorNd</td></tr>
<tr class="separator:a09a4d4ded781c3a9630a42d88680e89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5c7844e08cab1447e1ce7423a5fa3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d5c7844e08cab1447e1ce7423a5fa3c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>RigidDOFVector</b> = Eigen::Matrix&lt; double, s_max_free_dofs, 1 &gt;</td></tr>
<tr class="separator:a0d5c7844e08cab1447e1ce7423a5fa3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17100e3633baaf42d5aae6933b8e5db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad17100e3633baaf42d5aae6933b8e5db"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FreeRigidDOFVector</b> = Eigen::Matrix&lt; int, s_max_free_dofs, 1 &gt;</td></tr>
<tr class="separator:ad17100e3633baaf42d5aae6933b8e5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3765caccae641a3ff08f3bed8798af5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3765caccae641a3ff08f3bed8798af5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>RDV</b> = RigidDOFVector</td></tr>
<tr class="separator:ad3765caccae641a3ff08f3bed8798af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac19301c6fd0897bd5254ffad040e24c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac19301c6fd0897bd5254ffad040e24c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FRDV</b> = FreeRigidDOFVector</td></tr>
<tr class="separator:aac19301c6fd0897bd5254ffad040e24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6516d72a11e660ef8321ed1ed6b119d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6516d72a11e660ef8321ed1ed6b119d0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IndexFortranOrder</b> = struct <a class="el" href="struct_i_b_t_k_1_1_index_order.html">IndexOrder</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1Index.html">SAMRAI::hier::Index</a>&lt; NDIM &gt; &gt;</td></tr>
<tr class="separator:a6516d72a11e660ef8321ed1ed6b119d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bbac2eaf9010f28398d4c6a27cef96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98bbac2eaf9010f28398d4c6a27cef96"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CellIndexFortranOrder</b> = struct <a class="el" href="struct_i_b_t_k_1_1_index_order.html">IndexOrder</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1pdat_1_1CellIndex.html">SAMRAI::pdat::CellIndex</a>&lt; NDIM &gt; &gt;</td></tr>
<tr class="separator:a98bbac2eaf9010f28398d4c6a27cef96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f04732f2606c4a49ff92ca5b3c514b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f04732f2606c4a49ff92ca5b3c514b9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarMeshFcnPtr</b> = void(*)(double &amp;F, const libMesh::TensorValue&lt; double &gt; &amp;FF, const libMesh::Point &amp;x, const libMesh::Point &amp;X, libMesh::Elem *elem, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; * &gt; &amp;system_var_data, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::VectorValue&lt; double &gt; &gt; * &gt; &amp;system_grad_var_data, double data_time, void *ctx)</td></tr>
<tr class="separator:a3f04732f2606c4a49ff92ca5b3c514b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503cb21b0cf0bd3e1ed168623b674d8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a503cb21b0cf0bd3e1ed168623b674d8e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VectorMeshFcnPtr</b> = void(*)(libMesh::VectorValue&lt; double &gt; &amp;F, const libMesh::TensorValue&lt; double &gt; &amp;FF, const libMesh::Point &amp;x, const libMesh::Point &amp;X, libMesh::Elem *elem, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; * &gt; &amp;system_var_data, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::VectorValue&lt; double &gt; &gt; * &gt; &amp;system_grad_var_data, double data_time, void *ctx)</td></tr>
<tr class="separator:a503cb21b0cf0bd3e1ed168623b674d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2047e8d6003cdf2c5017d741cad69907"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2047e8d6003cdf2c5017d741cad69907"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TensorMeshFcnPtr</b> = void(*)(libMesh::TensorValue&lt; double &gt; &amp;F, const libMesh::TensorValue&lt; double &gt; &amp;FF, const libMesh::Point &amp;x, const libMesh::Point &amp;X, libMesh::Elem *elem, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; * &gt; &amp;system_var_data, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::VectorValue&lt; double &gt; &gt; * &gt; &amp;system_grad_var_data, double data_time, void *ctx)</td></tr>
<tr class="separator:a2047e8d6003cdf2c5017d741cad69907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0828e2d557e67a201c8526a7c9b761b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0828e2d557e67a201c8526a7c9b761b0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarSurfaceFcnPtr</b> = void(*)(double &amp;F, const libMesh::VectorValue&lt; double &gt; &amp;n, const libMesh::VectorValue&lt; double &gt; &amp;N, const libMesh::TensorValue&lt; double &gt; &amp;FF, const libMesh::Point &amp;x, const libMesh::Point &amp;X, libMesh::Elem *elem, unsigned short int side, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; * &gt; &amp;system_var_data, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::VectorValue&lt; double &gt; &gt; * &gt; &amp;system_grad_var_data, double data_time, void *ctx)</td></tr>
<tr class="separator:a0828e2d557e67a201c8526a7c9b761b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45007c53f48bbf752259fcec0884767c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45007c53f48bbf752259fcec0884767c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VectorSurfaceFcnPtr</b> = void(*)(libMesh::VectorValue&lt; double &gt; &amp;F, const libMesh::VectorValue&lt; double &gt; &amp;n, const libMesh::VectorValue&lt; double &gt; &amp;N, const libMesh::TensorValue&lt; double &gt; &amp;FF, const libMesh::Point &amp;x, const libMesh::Point &amp;X, libMesh::Elem *elem, unsigned short int side, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; * &gt; &amp;system_var_data, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::VectorValue&lt; double &gt; &gt; * &gt; &amp;system_grad_var_data, double data_time, void *ctx)</td></tr>
<tr class="separator:a45007c53f48bbf752259fcec0884767c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae611604880133ce595ea19e89a73b182"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae611604880133ce595ea19e89a73b182"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TensorSurfaceFcnPtr</b> = void(*)(libMesh::TensorValue&lt; double &gt; &amp;F, const libMesh::VectorValue&lt; double &gt; &amp;n, const libMesh::VectorValue&lt; double &gt; &amp;N, const libMesh::TensorValue&lt; double &gt; &amp;FF, const libMesh::Point &amp;x, const libMesh::Point &amp;X, libMesh::Elem *elem, unsigned short int side, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; * &gt; &amp;system_var_data, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::VectorValue&lt; double &gt; &gt; * &gt; &amp;system_grad_var_data, double data_time, void *ctx)</td></tr>
<tr class="separator:ae611604880133ce595ea19e89a73b182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbb90a8902f4f1b0e297d2fe94e98f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bbb90a8902f4f1b0e297d2fe94e98f6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LMarkerSet</b> = <a class="el" href="class_i_b_t_k_1_1_l_set.html">LSet</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_marker.html">LMarker</a> &gt;</td></tr>
<tr class="separator:a7bbb90a8902f4f1b0e297d2fe94e98f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8136e681d1fc6daedaf9dc9a87fee5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b8136e681d1fc6daedaf9dc9a87fee5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LMarkerSetData</b> = <a class="el" href="class_i_b_t_k_1_1_l_set_data.html">LSetData</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_marker.html">LMarker</a> &gt;</td></tr>
<tr class="separator:a4b8136e681d1fc6daedaf9dc9a87fee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca834ad6c7ebf879f0c77df35a4065c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adca834ad6c7ebf879f0c77df35a4065c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LMarkerSetDataFactory</b> = <a class="el" href="class_i_b_t_k_1_1_l_set_data_factory.html">LSetDataFactory</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_marker.html">LMarker</a> &gt;</td></tr>
<tr class="separator:adca834ad6c7ebf879f0c77df35a4065c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a122fcce28ef17bf540a86e90f8749d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a122fcce28ef17bf540a86e90f8749d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LMarkerSetDataIterator</b> = <a class="el" href="class_i_b_t_k_1_1_l_set_data_iterator.html">LSetDataIterator</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_marker.html">LMarker</a> &gt;</td></tr>
<tr class="separator:a7a122fcce28ef17bf540a86e90f8749d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b07bd444c7d69c9835de03ffe02773"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51b07bd444c7d69c9835de03ffe02773"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LMarkerSetVariable</b> = <a class="el" href="class_i_b_t_k_1_1_l_set_variable.html">LSetVariable</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_marker.html">LMarker</a> &gt;</td></tr>
<tr class="separator:a51b07bd444c7d69c9835de03ffe02773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad875c250fbc6b2896612215279b45f02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad875c250fbc6b2896612215279b45f02"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LMarkerTransaction</b> = <a class="el" href="class_i_b_t_k_1_1_l_transaction.html">LTransaction</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_marker.html">LMarker</a> &gt;</td></tr>
<tr class="separator:ad875c250fbc6b2896612215279b45f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d1dccdfce78faf8f3f8a0a2bd7f77f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49d1dccdfce78faf8f3f8a0a2bd7f77f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LNodeIndexSet</b> = <a class="el" href="class_i_b_t_k_1_1_l_set.html">LSet</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_node_index.html">LNodeIndex</a> &gt;</td></tr>
<tr class="separator:a49d1dccdfce78faf8f3f8a0a2bd7f77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c6e91d089ec5775d73b824dd4ac456"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26c6e91d089ec5775d73b824dd4ac456"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LNodeIndexSetData</b> = <a class="el" href="class_i_b_t_k_1_1_l_index_set_data.html">LIndexSetData</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_node_index.html">LNodeIndex</a> &gt;</td></tr>
<tr class="separator:a26c6e91d089ec5775d73b824dd4ac456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c714ac40dfb45d45a0f1a3a9ac79e96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c714ac40dfb45d45a0f1a3a9ac79e96"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LNodeIndexSetDataFactory</b> = <a class="el" href="class_i_b_t_k_1_1_l_index_set_data_factory.html">LIndexSetDataFactory</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_node_index.html">LNodeIndex</a> &gt;</td></tr>
<tr class="separator:a9c714ac40dfb45d45a0f1a3a9ac79e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fb2c83a523385b5d1c6fb70ff41b1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18fb2c83a523385b5d1c6fb70ff41b1f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LNodeIndexSetDataIterator</b> = <a class="el" href="class_i_b_t_k_1_1_l_set_data_iterator.html">LSetDataIterator</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_node_index.html">LNodeIndex</a> &gt;</td></tr>
<tr class="separator:a18fb2c83a523385b5d1c6fb70ff41b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fe4ea71ef285edd7994e07e781cdf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93fe4ea71ef285edd7994e07e781cdf5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LNodeIndexSetVariable</b> = <a class="el" href="class_i_b_t_k_1_1_l_index_set_variable.html">LIndexSetVariable</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_node_index.html">LNodeIndex</a> &gt;</td></tr>
<tr class="separator:a93fe4ea71ef285edd7994e07e781cdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b022d253611a53adfa402422e613d04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b022d253611a53adfa402422e613d04"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LNodeIndexTransaction</b> = <a class="el" href="class_i_b_t_k_1_1_l_transaction.html">LTransaction</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_node_index.html">LNodeIndex</a> &gt;</td></tr>
<tr class="separator:a6b022d253611a53adfa402422e613d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5e5af7d75b4b4246dd44d65c5439b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e5e5af7d75b4b4246dd44d65c5439b0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LNodeSet</b> = <a class="el" href="class_i_b_t_k_1_1_l_set.html">LSet</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_node.html">LNode</a> &gt;</td></tr>
<tr class="separator:a6e5e5af7d75b4b4246dd44d65c5439b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd5c02a25ef1925fd161c7297ff5224"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dd5c02a25ef1925fd161c7297ff5224"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LNodeSetData</b> = <a class="el" href="class_i_b_t_k_1_1_l_index_set_data.html">LIndexSetData</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_node.html">LNode</a> &gt;</td></tr>
<tr class="separator:a9dd5c02a25ef1925fd161c7297ff5224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab528c6bbf975269300b58d8178263599"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab528c6bbf975269300b58d8178263599"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LNodeSetDataFactory</b> = <a class="el" href="class_i_b_t_k_1_1_l_index_set_data_factory.html">LIndexSetDataFactory</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_node.html">LNode</a> &gt;</td></tr>
<tr class="separator:ab528c6bbf975269300b58d8178263599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1a0390039ab214bee68db589e9014b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac1a0390039ab214bee68db589e9014b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LNodeSetDataIterator</b> = <a class="el" href="class_i_b_t_k_1_1_l_set_data_iterator.html">LSetDataIterator</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_node.html">LNode</a> &gt;</td></tr>
<tr class="separator:aac1a0390039ab214bee68db589e9014b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb9f4aa1a24bc680e2744c833f6d439"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9eb9f4aa1a24bc680e2744c833f6d439"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LNodeSetVariable</b> = <a class="el" href="class_i_b_t_k_1_1_l_index_set_variable.html">LIndexSetVariable</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_node.html">LNode</a> &gt;</td></tr>
<tr class="separator:a9eb9f4aa1a24bc680e2744c833f6d439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed20f3055d55d60889801d99ef671c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeed20f3055d55d60889801d99ef671c1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LNodeTransaction</b> = <a class="el" href="class_i_b_t_k_1_1_l_transaction.html">LTransaction</a>&lt; <a class="el" href="class_i_b_t_k_1_1_l_node.html">LNode</a> &gt;</td></tr>
<tr class="separator:aeed20f3055d55d60889801d99ef671c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae8048f832efc6a3000180a8b59de9091"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> { <br />
&#160;&#160;<a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091a643d9c888b06a36de3593a171a6d456d">update_default</a> = 0, 
<a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091a9f04987cef3783ee1f9329eca30c5558">update_phi</a> = 1, 
<a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091acd49d3ad2cb8bd317153305be3d4245e">update_dphi</a> = 2, 
<a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091a58e0e6170d8bbc6c71e3178134956a98">update_contravariants</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091aa95b826ef42215b565c40633467c357e">update_covariants</a> = 8, 
<a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091a29569a61a25961316d205f2c5fb2a9f0">update_jacobians</a> = 16, 
<a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091adbc46effec6a8d7a3e96045f6c824059">update_JxW</a> = 32, 
<a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091a1203d6d0b8a28ce88108337cc289a477">update_quadrature_points</a> = 64
<br />
 }</td></tr>
<tr class="separator:ae8048f832efc6a3000180a8b59de9091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19008659d5b79c98ba2edfefb73b17a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19008659d5b79c98ba2edfefb73b17a0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a19008659d5b79c98ba2edfefb73b17a0">MGCycleType</a> { <br />
&#160;&#160;<b>F_CYCLE</b>, 
<b>FMG_CYCLE</b>, 
<b>V_CYCLE</b>, 
<b>W_CYCLE</b>, 
<br />
&#160;&#160;<b>UNKNOWN_MG_CYCLE_TYPE</b> = -1
<br />
 }<tr class="memdesc:a19008659d5b79c98ba2edfefb73b17a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type for different multigrid cycle types. <br /></td></tr>
</td></tr>
<tr class="separator:a19008659d5b79c98ba2edfefb73b17a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe95f73a473353d18098f9fbf7ba8567"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe95f73a473353d18098f9fbf7ba8567"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#afe95f73a473353d18098f9fbf7ba8567">RegridMode</a> { <b>STANDARD</b>, 
<b>AGGRESSIVE</b>, 
<b>UNKNOWN_REGRID_MODE</b> = -1
 }<tr class="memdesc:afe95f73a473353d18098f9fbf7ba8567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type for different regridding modes. <br /></td></tr>
</td></tr>
<tr class="separator:afe95f73a473353d18098f9fbf7ba8567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081318a0a7bce6de82de3b81dd67794a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a081318a0a7bce6de82de3b81dd67794a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a081318a0a7bce6de82de3b81dd67794a">VariableContextType</a> { <b>CURRENT_DATA</b>, 
<b>NEW_DATA</b>, 
<b>SCRATCH_DATA</b>, 
<b>UNKNOWN_VARIABLE_CONTEXT_TYPE</b> = -1
 }<tr class="memdesc:a081318a0a7bce6de82de3b81dd67794a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type for different standard data contexts. <br /></td></tr>
</td></tr>
<tr class="separator:a081318a0a7bce6de82de3b81dd67794a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0e485ab1820bbc97d938e4131d3972"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca0e485ab1820bbc97d938e4131d3972"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#aca0e485ab1820bbc97d938e4131d3972">VCInterpType</a> { <b>VC_AVERAGE_INTERP</b> = 1, 
<b>VC_HARMONIC_INTERP</b> = 2, 
<b>UNKNOWN_VC_INTERP_TYPE</b> = -1
 }<tr class="memdesc:aca0e485ab1820bbc97d938e4131d3972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type for different interpolation types for the material properties of the viscous solver. <br /></td></tr>
</td></tr>
<tr class="separator:aca0e485ab1820bbc97d938e4131d3972"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2b9a273f1a3e0c1b11314fac9896cef1"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a2b9a273f1a3e0c1b11314fac9896cef1">merge_boxes_by_longest_edge</a> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &gt; &amp;boxes)</td></tr>
<tr class="separator:a2b9a273f1a3e0c1b11314fac9896cef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2f64610b7d15183ce7e534a2f8a800"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a9a2f64610b7d15183ce7e534a2f8a800">operator&amp;</a> (const <a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> f1, const <a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> f2)</td></tr>
<tr class="separator:a9a2f64610b7d15183ce7e534a2f8a800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec91280c11f51e37e3b3f17c2c814a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#aeec91280c11f51e37e3b3f17c2c814a6">operator|</a> (const <a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> f1, const <a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> f2)</td></tr>
<tr class="separator:aeec91280c11f51e37e3b3f17c2c814a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e94038433d94b44c668708c398e402"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a57e94038433d94b44c668708c398e402">operator|=</a> (<a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> &amp;f1, const <a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> f2)</td></tr>
<tr class="separator:a57e94038433d94b44c668708c398e402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1582f6fd26602fbcf4515d3087f70b96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a1582f6fd26602fbcf4515d3087f70b96">operator&amp;=</a> (<a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> &amp;f1, const <a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> f2)</td></tr>
<tr class="separator:a1582f6fd26602fbcf4515d3087f70b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378982fbd968cc2b71685926f391cf97"><td class="memTemplParams" colspan="2"><a class="anchor" id="a378982fbd968cc2b71685926f391cf97"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a378982fbd968cc2b71685926f391cf97"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a378982fbd968cc2b71685926f391cf97">string_to_enum</a> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;)</td></tr>
<tr class="memdesc:a378982fbd968cc2b71685926f391cf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine for converting strings to enums. <br /></td></tr>
<tr class="separator:a378982fbd968cc2b71685926f391cf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c9374e709f84b9a7bf5b61f8064ecc"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa7c9374e709f84b9a7bf5b61f8064ecc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa7c9374e709f84b9a7bf5b61f8064ecc"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#aa7c9374e709f84b9a7bf5b61f8064ecc">enum_to_string</a> (T)</td></tr>
<tr class="memdesc:aa7c9374e709f84b9a7bf5b61f8064ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine for converting enums to strings. <br /></td></tr>
<tr class="separator:aa7c9374e709f84b9a7bf5b61f8064ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7ca4acf7739400e4b1bba7413312c3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7a7ca4acf7739400e4b1bba7413312c3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7a7ca4acf7739400e4b1bba7413312c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_i_b_t_k.html#a19008659d5b79c98ba2edfefb73b17a0">MGCycleType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>string_to_enum&lt; MGCycleType &gt;</b> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;val)</td></tr>
<tr class="separator:a7a7ca4acf7739400e4b1bba7413312c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f7c26c6b5f0c7960f38f41f9c5a3c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="af6f7c26c6b5f0c7960f38f41f9c5a3c4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af6f7c26c6b5f0c7960f38f41f9c5a3c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enum_to_string&lt; MGCycleType &gt;</b> (<a class="el" href="namespace_i_b_t_k.html#a19008659d5b79c98ba2edfefb73b17a0">MGCycleType</a> val)</td></tr>
<tr class="separator:af6f7c26c6b5f0c7960f38f41f9c5a3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fd86235dfd906319dea3bebb9e5c57"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab4fd86235dfd906319dea3bebb9e5c57"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab4fd86235dfd906319dea3bebb9e5c57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_i_b_t_k.html#afe95f73a473353d18098f9fbf7ba8567">RegridMode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>string_to_enum&lt; RegridMode &gt;</b> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;val)</td></tr>
<tr class="separator:ab4fd86235dfd906319dea3bebb9e5c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03001e01e2b7846bf23e2b0a5f039768"><td class="memTemplParams" colspan="2"><a class="anchor" id="a03001e01e2b7846bf23e2b0a5f039768"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a03001e01e2b7846bf23e2b0a5f039768"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enum_to_string&lt; RegridMode &gt;</b> (<a class="el" href="namespace_i_b_t_k.html#afe95f73a473353d18098f9fbf7ba8567">RegridMode</a> val)</td></tr>
<tr class="separator:a03001e01e2b7846bf23e2b0a5f039768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52eba6c97612fff98f870ce29db3555"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa52eba6c97612fff98f870ce29db3555"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa52eba6c97612fff98f870ce29db3555"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_i_b_t_k.html#a081318a0a7bce6de82de3b81dd67794a">VariableContextType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>string_to_enum&lt; VariableContextType &gt;</b> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;val)</td></tr>
<tr class="separator:aa52eba6c97612fff98f870ce29db3555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97bf54893b2b6fbe523a7a296367247"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac97bf54893b2b6fbe523a7a296367247"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac97bf54893b2b6fbe523a7a296367247"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enum_to_string&lt; VariableContextType &gt;</b> (<a class="el" href="namespace_i_b_t_k.html#a081318a0a7bce6de82de3b81dd67794a">VariableContextType</a> val)</td></tr>
<tr class="separator:ac97bf54893b2b6fbe523a7a296367247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6e3ba6c157be86c5696008d59b5f4d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9f6e3ba6c157be86c5696008d59b5f4d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9f6e3ba6c157be86c5696008d59b5f4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_i_b_t_k.html#aca0e485ab1820bbc97d938e4131d3972">VCInterpType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>string_to_enum&lt; VCInterpType &gt;</b> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;val)</td></tr>
<tr class="separator:a9f6e3ba6c157be86c5696008d59b5f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031c25dc335135dda3025f2705d3f04a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a031c25dc335135dda3025f2705d3f04a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a031c25dc335135dda3025f2705d3f04a"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enum_to_string&lt; VCInterpType &gt;</b> (<a class="el" href="namespace_i_b_t_k.html#aca0e485ab1820bbc97d938e4131d3972">VCInterpType</a> val)</td></tr>
<tr class="separator:a031c25dc335135dda3025f2705d3f04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddabfcd34ababf0834ec38c2a7c4c39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ddabfcd34ababf0834ec38c2a7c4c39"></a>
MPI_Datatype&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_type_id</b> (const double)</td></tr>
<tr class="separator:a6ddabfcd34ababf0834ec38c2a7c4c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c691a2b1f28c51707460a095cf2b15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8c691a2b1f28c51707460a095cf2b15"></a>
MPI_Datatype&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_type_id</b> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06756.html">std::pair</a>&lt; double, int &gt;)</td></tr>
<tr class="separator:ad8c691a2b1f28c51707460a095cf2b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b0c51d3da18f6ce9bd90804cebbb51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57b0c51d3da18f6ce9bd90804cebbb51"></a>
MPI_Datatype&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_type_id</b> (const int)</td></tr>
<tr class="separator:a57b0c51d3da18f6ce9bd90804cebbb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73599fa4fc37abf78a70e601b2f8695"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae73599fa4fc37abf78a70e601b2f8695"></a>
MPI_Datatype&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_type_id</b> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06756.html">std::pair</a>&lt; int, int &gt;)</td></tr>
<tr class="separator:ae73599fa4fc37abf78a70e601b2f8695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd3c0b75d6cecc44097ab5fc55c10d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fd3c0b75d6cecc44097ab5fc55c10d3"></a>
MPI_Datatype&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_type_id</b> (const float)</td></tr>
<tr class="separator:a8fd3c0b75d6cecc44097ab5fc55c10d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795e57846fae15ab87c8cede49ea627e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a795e57846fae15ab87c8cede49ea627e"></a>
MPI_Datatype&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_type_id</b> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06756.html">std::pair</a>&lt; float, int &gt;)</td></tr>
<tr class="separator:a795e57846fae15ab87c8cede49ea627e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbcd21d326bb27292544e3f61ec7ff7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfbcd21d326bb27292544e3f61ec7ff7"></a>
MPI_Datatype&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_type_id</b> (const char)</td></tr>
<tr class="separator:acfbcd21d326bb27292544e3f61ec7ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd5dfe1e8fa179577fc4113402bd286"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accd5dfe1e8fa179577fc4113402bd286"></a>
MPI_Datatype&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_type_id</b> (const unsigned int)</td></tr>
<tr class="separator:accd5dfe1e8fa179577fc4113402bd286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47de442a01da3c636968316c57049329"><td class="memTemplParams" colspan="2"><a class="anchor" id="a47de442a01da3c636968316c57049329"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a47de442a01da3c636968316c57049329"><td class="memTemplItemLeft" align="right" valign="top">MPI_Datatype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mpi_type_id</b> (const T &amp;)</td></tr>
<tr class="separator:a47de442a01da3c636968316c57049329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f0d16e02dcc4734ef6fb35bb70b0ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41f0d16e02dcc4734ef6fb35bb70b0ba"></a>
<a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_data_time_str</b> (const double data_time, const double current_time, const double new_time)</td></tr>
<tr class="separator:a41f0d16e02dcc4734ef6fb35bb70b0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745d00f9bbbb00d11e989436f8ce7911"><td class="memTemplParams" colspan="2"><a class="anchor" id="a745d00f9bbbb00d11e989436f8ce7911"></a>
template&lt;class T , unsigned N&gt; </td></tr>
<tr class="memitem:a745d00f9bbbb00d11e989436f8ce7911"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01696.html">std::array</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array_constant</b> (const T &amp;v)</td></tr>
<tr class="separator:a745d00f9bbbb00d11e989436f8ce7911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526c5e2ad3c545703a6e180a3e3231bc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a526c5e2ad3c545703a6e180a3e3231bc"></a>
template&lt;class T , unsigned N&gt; </td></tr>
<tr class="memitem:a526c5e2ad3c545703a6e180a3e3231bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01696.html">std::array</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array_one</b> ()</td></tr>
<tr class="separator:a526c5e2ad3c545703a6e180a3e3231bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac284988f6336dc2b082c6fd1ff38fbee"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac284988f6336dc2b082c6fd1ff38fbee"></a>
template&lt;class T , unsigned N&gt; </td></tr>
<tr class="memitem:ac284988f6336dc2b082c6fd1ff38fbee"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01696.html">std::array</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array_zero</b> ()</td></tr>
<tr class="separator:ac284988f6336dc2b082c6fd1ff38fbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a14e41cdb653b629ee7aed2958d387"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7a14e41cdb653b629ee7aed2958d387"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>level_can_be_refined</b> (int level_number, int max_levels)</td></tr>
<tr class="separator:ab7a14e41cdb653b629ee7aed2958d387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d81edd603b8e9ea39ec04e986480c6d"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06756.html">std::pair</a>&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a7d81edd603b8e9ea39ec04e986480c6d">voigt_to_tensor_idx</a> (const int k)</td></tr>
<tr class="separator:a7d81edd603b8e9ea39ec04e986480c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eed5a2c7a3e14447a70fe4a46b42aad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a5eed5a2c7a3e14447a70fe4a46b42aad">tensor_idx_to_voigt</a> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06756.html">std::pair</a>&lt; int, int &gt; &amp;idx)</td></tr>
<tr class="separator:a5eed5a2c7a3e14447a70fe4a46b42aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6862737600f8050ffc8a9193d2855fac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a6862737600f8050ffc8a9193d2855fac">get_dim</a> (const libMesh::ElemType elem_type)</td></tr>
<tr class="separator:a6862737600f8050ffc8a9193d2855fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a597273d59eba2e3a2a2c5f4f3978f6"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a5a597273d59eba2e3a2a2c5f4f3978f6">get_n_nodes</a> (const libMesh::ElemType elem_type)</td></tr>
<tr class="separator:a5a597273d59eba2e3a2a2c5f4f3978f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7726626d63e9010519ec81caa7ad6aec"><td class="memItemLeft" align="right" valign="top">libMesh::Order&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a7726626d63e9010519ec81caa7ad6aec">get_default_order</a> (const libMesh::ElemType elem_type)</td></tr>
<tr class="separator:a7726626d63e9010519ec81caa7ad6aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d9e757aec602f3e004b0f358aa4ac6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89d9e757aec602f3e004b0f358aa4ac6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_and_synch</b> (libMesh::NumericVector&lt; double &gt; &amp;v_in, libMesh::NumericVector&lt; double &gt; &amp;v_out, const bool close_v_in=true, const bool close_v_out=true)</td></tr>
<tr class="separator:a89d9e757aec602f3e004b0f358aa4ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bd271fbec4ef139e18db887375d1ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4bd271fbec4ef139e18db887375d1ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>batch_vec_copy</b> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::PetscVector&lt; double &gt; * &gt; &amp;x_vecs, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::PetscVector&lt; double &gt; * &gt; &amp;y_vecs)</td></tr>
<tr class="separator:ad4bd271fbec4ef139e18db887375d1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0aedb65486ee6f549037773c72e511"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b0aedb65486ee6f549037773c72e511"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>batch_vec_copy</b> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::PetscVector&lt; double &gt; * &gt; &gt; &amp;x_vecs, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::PetscVector&lt; double &gt; * &gt; &gt; &amp;y_vecs)</td></tr>
<tr class="separator:a5b0aedb65486ee6f549037773c72e511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fec04e6523e6c8f83de2f7d918810b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6fec04e6523e6c8f83de2f7d918810b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>batch_vec_assembly</b> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::PetscVector&lt; double &gt; * &gt; &amp;vecs)</td></tr>
<tr class="separator:aa6fec04e6523e6c8f83de2f7d918810b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40353749599abca6ca36c221001787a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40353749599abca6ca36c221001787a3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>batch_vec_assembly</b> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::PetscVector&lt; double &gt; * &gt; &gt; &amp;vecs)</td></tr>
<tr class="separator:a40353749599abca6ca36c221001787a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8557a2bff01645c5c9140b10323492b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8557a2bff01645c5c9140b10323492b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>batch_vec_ghost_update</b> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::PetscVector&lt; double &gt; * &gt; &amp;vecs, const InsertMode insert_mode, const ScatterMode scatter_mode)</td></tr>
<tr class="separator:ac8557a2bff01645c5c9140b10323492b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd21f0ce38740f36c527bd51d00cea2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbd21f0ce38740f36c527bd51d00cea2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>batch_vec_ghost_update</b> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::PetscVector&lt; double &gt; * &gt; &gt; &amp;vecs, const InsertMode insert_mode, const ScatterMode scatter_mode)</td></tr>
<tr class="separator:abbd21f0ce38740f36c527bd51d00cea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60d5a97f333088f598958c116655068"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a02996.html">std::tuple</a>&lt; libMesh::ElemType, libMesh::QuadratureType, libMesh::Order &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#af60d5a97f333088f598958c116655068">getQuadratureKey</a> (const libMesh::QuadratureType quad_type, libMesh::Order order, const bool use_adaptive_quadrature, const double point_density, const libMesh::Elem *const elem, const boost::multi_array&lt; double, 2 &gt; &amp;X_node, const double dx_min)</td></tr>
<tr class="separator:af60d5a97f333088f598958c116655068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed5aca02cba73e5d78468ef40470e7d"><td class="memTemplParams" colspan="2">template&lt;class MultiArray , class Array &gt; </td></tr>
<tr class="memitem:abed5aca02cba73e5d78468ef40470e7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#abed5aca02cba73e5d78468ef40470e7d">get_values_for_interpolation</a> (MultiArray &amp;U_node, const libMesh::PetscVector&lt; double &gt; &amp;U_petsc_vec, const Array &amp;U_local_soln, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; unsigned int &gt; &amp;dof_indices)</td></tr>
<tr class="separator:abed5aca02cba73e5d78468ef40470e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb1caa3fb7923e19777b08eab2b0d41"><td class="memTemplParams" colspan="2">template&lt;class MultiArray , class Array &gt; </td></tr>
<tr class="memitem:a6fb1caa3fb7923e19777b08eab2b0d41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a6fb1caa3fb7923e19777b08eab2b0d41">get_values_for_interpolation</a> (MultiArray &amp;U_node, const libMesh::PetscVector&lt; double &gt; &amp;U_petsc_vec, const Array &amp;U_local_soln, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; unsigned int &gt; &gt; &amp;dof_indices)</td></tr>
<tr class="separator:a6fb1caa3fb7923e19777b08eab2b0d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85814a33961cc7772ab4ce8d5ba38f06"><td class="memTemplParams" colspan="2">template&lt;class MultiArray &gt; </td></tr>
<tr class="memitem:a85814a33961cc7772ab4ce8d5ba38f06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a85814a33961cc7772ab4ce8d5ba38f06">get_values_for_interpolation</a> (MultiArray &amp;U_node, libMesh::NumericVector&lt; double &gt; &amp;U_vec, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; unsigned int &gt; &amp;dof_indices)</td></tr>
<tr class="separator:a85814a33961cc7772ab4ce8d5ba38f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7276a7c7f7a05886d3c8c057d0263b1"><td class="memTemplParams" colspan="2">template&lt;class MultiArray &gt; </td></tr>
<tr class="memitem:aa7276a7c7f7a05886d3c8c057d0263b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#aa7276a7c7f7a05886d3c8c057d0263b1">get_values_for_interpolation</a> (MultiArray &amp;U_node, libMesh::NumericVector&lt; double &gt; &amp;U_vec, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; unsigned int &gt; &gt; &amp;dof_indices)</td></tr>
<tr class="separator:aa7276a7c7f7a05886d3c8c057d0263b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e621904d431a494ee6d70939ea3517b"><td class="memTemplParams" colspan="2">template&lt;class MultiArray &gt; </td></tr>
<tr class="memitem:a6e621904d431a494ee6d70939ea3517b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a6e621904d431a494ee6d70939ea3517b">interpolate</a> (double &amp;U, const int qp, const MultiArray &amp;U_node, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &gt; &amp;phi)</td></tr>
<tr class="separator:a6e621904d431a494ee6d70939ea3517b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc24178d5490dc9c567ced0c6fd396dd"><td class="memTemplParams" colspan="2">template&lt;class MultiArray &gt; </td></tr>
<tr class="memitem:afc24178d5490dc9c567ced0c6fd396dd"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#afc24178d5490dc9c567ced0c6fd396dd">interpolate</a> (const int qp, const MultiArray &amp;U_node, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &gt; &amp;phi)</td></tr>
<tr class="separator:afc24178d5490dc9c567ced0c6fd396dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4cce3704003cf03a1d50ca1b5856cb"><td class="memTemplParams" colspan="2">template&lt;class MultiArray &gt; </td></tr>
<tr class="memitem:a8a4cce3704003cf03a1d50ca1b5856cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a8a4cce3704003cf03a1d50ca1b5856cb">interpolate</a> (double *const U, const int qp, const MultiArray &amp;U_node, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &gt; &amp;phi)</td></tr>
<tr class="separator:a8a4cce3704003cf03a1d50ca1b5856cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7533ce02f3c58746ebc2ea90405fcc2"><td class="memTemplParams" colspan="2">template&lt;class MultiArray &gt; </td></tr>
<tr class="memitem:ae7533ce02f3c58746ebc2ea90405fcc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#ae7533ce02f3c58746ebc2ea90405fcc2">interpolate</a> (libMesh::TypeVector&lt; double &gt; &amp;U, const int qp, const MultiArray &amp;U_node, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &gt; &amp;phi)</td></tr>
<tr class="separator:ae7533ce02f3c58746ebc2ea90405fcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9028293137d8bfcafec9ac4a39d5381e"><td class="memTemplParams" colspan="2">template&lt;class MultiArray &gt; </td></tr>
<tr class="memitem:a9028293137d8bfcafec9ac4a39d5381e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a9028293137d8bfcafec9ac4a39d5381e">jacobian</a> (libMesh::TypeTensor&lt; double &gt; &amp;dX_ds, const int qp, const MultiArray &amp;X_node, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::VectorValue&lt; double &gt; &gt; &gt; &amp;dphi)</td></tr>
<tr class="separator:a9028293137d8bfcafec9ac4a39d5381e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30f742f750669176152497db0ef0726"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae30f742f750669176152497db0ef0726"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tensor_inverse</b> (libMesh::TensorValue&lt; double &gt; &amp;A_inv, const libMesh::TensorValue&lt; double &gt; &amp;A, const int dim=NDIM)</td></tr>
<tr class="separator:ae30f742f750669176152497db0ef0726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f2422ce2973d7fd6a5e6cd59760c52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1f2422ce2973d7fd6a5e6cd59760c52"></a>
libMesh::TensorValue&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tensor_inverse</b> (const libMesh::TensorValue&lt; double &gt; &amp;A, const int dim=NDIM)</td></tr>
<tr class="separator:ad1f2422ce2973d7fd6a5e6cd59760c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a57a16c4c54f61aaa275e2dfe42c9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20a57a16c4c54f61aaa275e2dfe42c9b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tensor_inverse_transpose</b> (libMesh::TensorValue&lt; double &gt; &amp;A_inv_trans, const libMesh::TensorValue&lt; double &gt; &amp;A, const int dim=NDIM)</td></tr>
<tr class="separator:a20a57a16c4c54f61aaa275e2dfe42c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faa18f96d9a0bc0ebb915eb2d9c3744"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4faa18f96d9a0bc0ebb915eb2d9c3744"></a>
libMesh::TensorValue&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tensor_inverse_transpose</b> (const libMesh::TensorValue&lt; double &gt; &amp;A, const int dim=NDIM)</td></tr>
<tr class="separator:a4faa18f96d9a0bc0ebb915eb2d9c3744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef27a5af903369f0c26e66e4e2155b81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef27a5af903369f0c26e66e4e2155b81"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>outer_product</b> (libMesh::TensorValue&lt; double &gt; &amp;u_prod_v, const libMesh::TypeVector&lt; double &gt; &amp;u, const libMesh::TypeVector&lt; double &gt; &amp;v, const int dim=NDIM)</td></tr>
<tr class="separator:aef27a5af903369f0c26e66e4e2155b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa273687ead649c1d10fb8382ea1f21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fa273687ead649c1d10fb8382ea1f21"></a>
libMesh::TensorValue&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>outer_product</b> (const libMesh::TypeVector&lt; double &gt; &amp;u, const libMesh::TypeVector&lt; double &gt; &amp;v, const int dim=NDIM)</td></tr>
<tr class="separator:a2fa273687ead649c1d10fb8382ea1f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45293290dab489896e0d1bb04efb6d75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45293290dab489896e0d1bb04efb6d75"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>intersect_line_with_edge</b> (<a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06756.html">std::pair</a>&lt; double, libMesh::Point &gt; &gt; &amp;t_vals, libMesh::Edge *elem, libMesh::Point r, libMesh::VectorValue&lt; double &gt; q, const double tol=0.0)</td></tr>
<tr class="separator:a45293290dab489896e0d1bb04efb6d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4956967de7ecb8746eddcc1d54e24283"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4956967de7ecb8746eddcc1d54e24283"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>intersect_line_with_face</b> (<a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06756.html">std::pair</a>&lt; double, libMesh::Point &gt; &gt; &amp;t_vals, libMesh::Face *elem, libMesh::Point r, libMesh::VectorValue&lt; double &gt; q, const double tol=0.0)</td></tr>
<tr class="separator:a4956967de7ecb8746eddcc1d54e24283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d173c9bc7d2bcd1c37c549a2075adca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a6d173c9bc7d2bcd1c37c549a2075adca">get_nodal_dof_indices</a> (const libMesh::DofMap &amp;dof_map, const libMesh::Node *const node, const unsigned int variable_n, <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::dof_id_type &gt; &amp;nodal_indices)</td></tr>
<tr class="separator:a6d173c9bc7d2bcd1c37c549a2075adca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9fab55956157fb2e0bc09f77c0f425"><td class="memTemplParams" colspan="2">template&lt;class MultiArray &gt; </td></tr>
<tr class="memitem:aca9fab55956157fb2e0bc09f77c0f425"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#aca9fab55956157fb2e0bc09f77c0f425">get_max_edge_length</a> (const libMesh::Elem *const elem, const MultiArray &amp;X_node)</td></tr>
<tr class="separator:aca9fab55956157fb2e0bc09f77c0f425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceed8ef2e29cf7a38d720d5418751e73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#aceed8ef2e29cf7a38d720d5418751e73">write_elem_partitioning</a> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;file_name, const libMesh::System &amp;position_system)</td></tr>
<tr class="separator:aceed8ef2e29cf7a38d720d5418751e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ede2ffd0f710fcf1b00c933cdc4da8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a07ede2ffd0f710fcf1b00c933cdc4da8">write_node_partitioning</a> (const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;file_name, const libMesh::System &amp;position_system)</td></tr>
<tr class="separator:a07ede2ffd0f710fcf1b00c933cdc4da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14f22d4925da47f4a20383c6402525f"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMeshWrappers::BoundingBox &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#ad14f22d4925da47f4a20383c6402525f">get_local_active_element_bounding_boxes</a> (const libMesh::MeshBase &amp;mesh, const libMesh::System &amp;X_system, const libMesh::QuadratureType quad_type, const libMesh::Order quad_order, const bool use_adaptive_quadrature, const double point_density, const double patch_dx_min)</td></tr>
<tr class="separator:ad14f22d4925da47f4a20383c6402525f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e90ae8dd6167d27dce90df6588aa99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12e90ae8dd6167d27dce90df6588aa99"></a>
<a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMeshWrappers::BoundingBox &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_local_active_element_bounding_boxes</b> (const libMesh::MeshBase &amp;mesh, const libMesh::System &amp;X_system)</td></tr>
<tr class="separator:a12e90ae8dd6167d27dce90df6588aa99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5446a09ef85401fa4718f49b202e80a6"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMeshWrappers::BoundingBox &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a5446a09ef85401fa4718f49b202e80a6">get_global_active_element_bounding_boxes</a> (const libMesh::MeshBase &amp;mesh, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMeshWrappers::BoundingBox &gt; &amp;local_bboxes)</td></tr>
<tr class="separator:a5446a09ef85401fa4718f49b202e80a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ecd3e17f665c07cfe18be421084fc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49ecd3e17f665c07cfe18be421084fc6"></a>
<a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMeshWrappers::BoundingBox &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_global_active_element_bounding_boxes</b> (const libMesh::MeshBase &amp;mesh, const libMesh::System &amp;X_system)</td></tr>
<tr class="separator:a49ecd3e17f665c07cfe18be421084fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fdfe0a5d6114b04e025c647f22883f"><td class="memItemLeft" align="right" valign="top">Vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a67fdfe0a5d6114b04e025c647f22883f">setup_petsc_vector</a> (const unsigned int num_local_nodes, const unsigned int <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/algs__nodeouternodeops3d_8f.html#9caca90cc65f72a7168924922fa5d34e">depth</a>, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; int &gt; &amp;nonlocal_petsc_indices)</td></tr>
<tr class="separator:a67fdfe0a5d6114b04e025c647f22883f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aab901bde6055f89372825e50c731be"><td class="memTemplParams" colspan="2">template&lt;int n_vars, int n_basis, bool weights_are_unity = false&gt; </td></tr>
<tr class="memitem:a7aab901bde6055f89372825e50c731be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a7aab901bde6055f89372825e50c731be">sum_weighted_elem_solution_n_vars_n_basis</a> (const int qp_offset, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &gt; &amp;phi_F, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;weights, const boost::multi_array&lt; double, 2 &gt; &amp;F_node, <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;F_w_qp)</td></tr>
<tr class="memdesc:a7aab901bde6055f89372825e50c731be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of the finite element representation of the force and (optionally) a set of weights (e.g., JxW values) at all quadrature points on an element. See integrate_elem_rhs for details on the first two template arguments.  <a href="#a7aab901bde6055f89372825e50c731be">More...</a><br /></td></tr>
<tr class="separator:a7aab901bde6055f89372825e50c731be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff02057fe91a84cca1908580a1eff9e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7ff02057fe91a84cca1908580a1eff9e"></a>
template&lt;int n_vars, bool weights_are_unity = false&gt; </td></tr>
<tr class="memitem:a7ff02057fe91a84cca1908580a1eff9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sum_weighted_elem_solution_n_vars</b> (const int n_basis, const int qp_offset, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &gt; &amp;phi_F, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;weights, const boost::multi_array&lt; double, 2 &gt; &amp;F_node, <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;F_w_qp)</td></tr>
<tr class="separator:a7ff02057fe91a84cca1908580a1eff9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ac0e1467b67755adbed17211d546fc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a10ac0e1467b67755adbed17211d546fc"></a>
template&lt;bool weights_are_unity = false&gt; </td></tr>
<tr class="memitem:a10ac0e1467b67755adbed17211d546fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sum_weighted_elem_solution</b> (const int n_vars, const int n_basis, const int qp_offset, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &gt; &amp;phi_F, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;weights, const boost::multi_array&lt; double, 2 &gt; &amp;F_node, <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;F_w_qp)</td></tr>
<tr class="separator:a10ac0e1467b67755adbed17211d546fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6112f647ae259dfcf94c0be54ba818f2"><td class="memTemplParams" colspan="2">template&lt;int n_vars, int n_basis&gt; </td></tr>
<tr class="memitem:a6112f647ae259dfcf94c0be54ba818f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_i_b_t_k.html#a6112f647ae259dfcf94c0be54ba818f2">integrate_elem_rhs_n_vars_n_basis</a> (const int qp_offset, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &gt; &amp;phi_F, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;JxW_F, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;F_qp, <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;F_rhs_concatenated)</td></tr>
<tr class="memdesc:a6112f647ae259dfcf94c0be54ba818f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble the element contribution to a load vector.  <a href="#a6112f647ae259dfcf94c0be54ba818f2">More...</a><br /></td></tr>
<tr class="separator:a6112f647ae259dfcf94c0be54ba818f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9f1c522c152426035aca374d8888a6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7f9f1c522c152426035aca374d8888a6"></a>
template&lt;int n_vars&gt; </td></tr>
<tr class="memitem:a7f9f1c522c152426035aca374d8888a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integrate_elem_rhs_n_vars</b> (const int n_basis, const int qp_offset, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &gt; &amp;phi_F, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;JxW_F, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;F_qp, <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;F_rhs_concatenated)</td></tr>
<tr class="separator:a7f9f1c522c152426035aca374d8888a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f784acee6887b9ab0e5aff709472983"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f784acee6887b9ab0e5aff709472983"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>integrate_elem_rhs</b> (const int n_vars, const int n_basis, const int qp_offset, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &gt; &amp;phi_F, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;JxW_F, const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;F_qp, <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;F_rhs_concatenated)</td></tr>
<tr class="separator:a9f784acee6887b9ab0e5aff709472983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a93b29c3c7082c05d341446e477230"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa2a93b29c3c7082c05d341446e477230"></a>
template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aa2a93b29c3c7082c05d341446e477230"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, spacedim, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getCovariant</b> (const Eigen::Matrix&lt; double, spacedim, dim &gt; &amp;contravariant)</td></tr>
<tr class="separator:aa2a93b29c3c7082c05d341446e477230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e6d56546214fc1af840d482f2bfe0a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab2e6d56546214fc1af840d482f2bfe0a"></a>
template&lt;int dim&gt; </td></tr>
<tr class="memitem:ab2e6d56546214fc1af840d482f2bfe0a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, dim, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getCovariant</b> (const Eigen::Matrix&lt; double, dim, dim &gt; &amp;contravariant)</td></tr>
<tr class="separator:ab2e6d56546214fc1af840d482f2bfe0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines "using" declarations for all <a class="el" href="namespace_i_b_t_k.html">IBTK</a> namespaces. This header file may be included in application codes, but it MUST NOT be included in any other header (.h) or inline (-inl.h) file in the library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a454b0ed65ab2ecf794a6521c9544167a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_i_b_t_k.html#a454b0ed65ab2ecf794a6521c9544167a">IBTK::EigenAlignedVector</a> = typedef <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt;T, Eigen::aligned_allocator&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Eigen types have special alignment requirements and require a specific memory allocator. This is a convenience type alias for a <code><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a></code> with the correct allocator. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ae8048f832efc6a3000180a8b59de9091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">IBTK::FEUpdateFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration describing the various update options available for libMesh::FEBase objects stored by <a class="el" href="class_i_b_t_k_1_1_f_e_cache.html" title="Class storing multiple libMesh::FE objects, each corresponding to a different quadrature rule...">FECache</a>. Multiple flags can be enabled with bitwise or operations, e.g.,</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">IBTK::FEUpdateFlags</a> update_flags = <a class="code" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091a9f04987cef3783ee1f9329eca30c5558">IBTK::update_phi</a> | <a class="code" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091acd49d3ad2cb8bd317153305be3d4245e">IBTK::update_dphi</a>;</div></div><!-- fragment --><p>See <a class="el" href="class_i_b_t_k_1_1_f_e_cache.html" title="Class storing multiple libMesh::FE objects, each corresponding to a different quadrature rule...">IBTK::FECache</a> for more information. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae8048f832efc6a3000180a8b59de9091a643d9c888b06a36de3593a171a6d456d"></a>update_default&#160;</td><td class="fielddoc">
<p>Do not update anything. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae8048f832efc6a3000180a8b59de9091a9f04987cef3783ee1f9329eca30c5558"></a>update_phi&#160;</td><td class="fielddoc">
<p>Update phi (shape function values). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae8048f832efc6a3000180a8b59de9091acd49d3ad2cb8bd317153305be3d4245e"></a>update_dphi&#160;</td><td class="fielddoc">
<p>Update dphi (shape function gradients). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae8048f832efc6a3000180a8b59de9091a58e0e6170d8bbc6c71e3178134956a98"></a>update_contravariants&#160;</td><td class="fielddoc">
<p>Update mapping contravariants. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae8048f832efc6a3000180a8b59de9091aa95b826ef42215b565c40633467c357e"></a>update_covariants&#160;</td><td class="fielddoc">
<p>Update mapping covariants. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae8048f832efc6a3000180a8b59de9091a29569a61a25961316d205f2c5fb2a9f0"></a>update_jacobians&#160;</td><td class="fielddoc">
<p>Update mapping Jacobians. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae8048f832efc6a3000180a8b59de9091adbc46effec6a8d7a3e96045f6c824059"></a>update_JxW&#160;</td><td class="fielddoc">
<p>Update JxW values. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae8048f832efc6a3000180a8b59de9091a1203d6d0b8a28ce88108337cc289a477"></a>update_quadrature_points&#160;</td><td class="fielddoc">
<p>Update mapped quadrature points. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a7726626d63e9010519ec81caa7ad6aec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Order IBTK::get_default_order </td>
          <td>(</td>
          <td class="paramtype">const libMesh::ElemType&#160;</td>
          <td class="paramname"><em>elem_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Utility function for getting the default order of a <a class="el" href="namespacelib_mesh.html">libMesh</a> element type. </p>

</div>
</div>
<a class="anchor" id="a6862737600f8050ffc8a9193d2855fac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IBTK::get_dim </td>
          <td>(</td>
          <td class="paramtype">const libMesh::ElemType&#160;</td>
          <td class="paramname"><em>elem_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Utility function for getting the dimensionality of a <a class="el" href="namespacelib_mesh.html">libMesh</a> element type. </p>

</div>
</div>
<a class="anchor" id="a5446a09ef85401fa4718f49b202e80a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMeshWrappers::BoundingBox &gt; IBTK::get_global_active_element_bounding_boxes </td>
          <td>(</td>
          <td class="paramtype">const libMesh::MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMeshWrappers::BoundingBox &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_bboxes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the global list of bounding boxes from the local list. </p>

</div>
</div>
<a class="anchor" id="ad14f22d4925da47f4a20383c6402525f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMeshWrappers::BoundingBox &gt; IBTK::get_local_active_element_bounding_boxes </td>
          <td>(</td>
          <td class="paramtype">const libMesh::MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::System &amp;&#160;</td>
          <td class="paramname"><em>X_system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::QuadratureType&#160;</td>
          <td class="paramname"><em>quad_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::Order&#160;</td>
          <td class="paramname"><em>quad_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_adaptive_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>point_density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>patch_dx_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute bounding boxes based on where an elements quadrature points are. See getQuadratureKey for descriptions of the last five arguments. </p>

</div>
</div>
<a class="anchor" id="aca9fab55956157fb2e0bc09f77c0f425"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IBTK::get_max_edge_length </td>
          <td>(</td>
          <td class="paramtype">const libMesh::Elem *const&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArray &amp;&#160;</td>
          <td class="paramname"><em>X_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the maximum edge length of a given element with mapped nodes. If the edges of the mapped element are not straight lines (i.e., a Tet10 element subject to some nonlinear deformation) then the edge length is approximated as the sum of the lengths of the line segments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The given <a class="el" href="namespacelib_mesh.html">libMesh</a> element.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_node</td><td>Values of <code>elem's</code> shape functions of the structure location field (i.e., X): for interpolatory finite elements (e.g., libMesh::LAGRANGE) these the actual coordinates of the node (since shape functions will either be one or zero at nodes). <code>X_node</code> is assumed to be a two-dimensional array whose rows correspond to node number and whose columns correspond to x, y, and (in 3D) z coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a597273d59eba2e3a2a2c5f4f3978f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t IBTK::get_n_nodes </td>
          <td>(</td>
          <td class="paramtype">const libMesh::ElemType&#160;</td>
          <td class="paramname"><em>elem_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Utility function for getting the number of nodes of a <a class="el" href="namespacelib_mesh.html">libMesh</a> element type. </p>

</div>
</div>
<a class="anchor" id="a6d173c9bc7d2bcd1c37c549a2075adca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::get_nodal_dof_indices </td>
          <td>(</td>
          <td class="paramtype">const libMesh::DofMap &amp;&#160;</td>
          <td class="paramname"><em>dof_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::Node *const&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>variable_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::dof_id_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodal_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recent versions of <a class="el" href="namespacelib_mesh.html">libMesh</a> acquired a useful function that lets us extract the DoFs corresponding to basis functions with node value functionals. This compatibility function either calls that function directly or uses our own implementation if the present <a class="el" href="namespacelib_mesh.html">libMesh</a> is too old. </p>

</div>
</div>
<a class="anchor" id="abed5aca02cba73e5d78468ef40470e7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray , class Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::get_values_for_interpolation </td>
          <td>(</td>
          <td class="paramtype">MultiArray &amp;&#160;</td>
          <td class="paramname"><em>U_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::PetscVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>U_petsc_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>U_local_soln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Populate <code>U_node</code> with the finite element solution coefficients on the current element. This particular overload is for scalar finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">U_node</td><td>Multidimensional array (usually a boost::multi_array) which will be filled with finite element solution coefficients.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_petsc_vec</td><td>The relevant finite element solution vector.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_local_soln</td><td>A localized version of the current solution (i.e., the same information as <code>U_petsc_vec</code>, but accessed with local instead of global indices).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_indices</td><td>DoF indices of the current element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6fb1caa3fb7923e19777b08eab2b0d41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray , class Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::get_values_for_interpolation </td>
          <td>(</td>
          <td class="paramtype">MultiArray &amp;&#160;</td>
          <td class="paramname"><em>U_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::PetscVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>U_petsc_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>U_local_soln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Populate <code>U_node</code> with the finite element solution coefficients on the current element. This particular overload is for vector-valued finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">U_node</td><td>Multidimensional array (usually a boost::multi_array) which will be filled with finite element solution coefficients.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_petsc_vec</td><td>The relevant finite element solution vector.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_local_soln</td><td>A localized version of the current solution (i.e., the same information as <code>U_petsc_vec</code>, but accessed with local instead of global indices).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_indices</td><td>DoF indices of the current element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85814a33961cc7772ab4ce8d5ba38f06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::get_values_for_interpolation </td>
          <td>(</td>
          <td class="paramtype">MultiArray &amp;&#160;</td>
          <td class="paramname"><em>U_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libMesh::NumericVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>U_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Populate <code>U_node</code> with the finite element solution coefficients on the current element. This particular overload is for scalar finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">U_node</td><td>Multidimensional array (usually a boost::multi_array) which will be filled with finite element solution coefficients.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_vec</td><td>The relevant finite element solution vector. This must be a libMesh::PetscVector.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_indices</td><td>DoF indices of the current element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7276a7c7f7a05886d3c8c057d0263b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::get_values_for_interpolation </td>
          <td>(</td>
          <td class="paramtype">MultiArray &amp;&#160;</td>
          <td class="paramname"><em>U_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libMesh::NumericVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>U_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Populate <code>U_node</code> with the finite element solution coefficients on the current element. This particular overload is for vector-valued finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">U_node</td><td>Multidimensional array (usually a boost::multi_array) which will be filled with finite element solution coefficients.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_vec</td><td>The relevant finite element solution vector. This must be a libMesh::PetscVector.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_indices</td><td>DoF indices of the current element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af60d5a97f333088f598958c116655068"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a02996.html">std::tuple</a>&lt; libMesh::ElemType, libMesh::QuadratureType, libMesh::Order &gt; IBTK::getQuadratureKey </td>
          <td>(</td>
          <td class="paramtype">const libMesh::QuadratureType&#160;</td>
          <td class="paramname"><em>quad_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libMesh::Order&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_adaptive_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>point_density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::Elem *const&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dx_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the quadrature key description (see <a class="el" href="class_i_b_t_k_1_1_quadrature_cache.html" title="Class storing multiple libMesh quadrature objects. We assume that quadrature rules are uniquely deter...">QuadratureCache</a>, <a class="el" href="class_i_b_t_k_1_1_f_e_cache.html" title="Class storing multiple libMesh::FE objects, each corresponding to a different quadrature rule...">FECache</a>, and <a class="el" href="class_i_b_t_k_1_1_f_e_map_cache.html" title="Class storing multiple libMesh::FEMap objects, each corresponding to a different quadrature rule...">FEMapCache</a>) of a quadrature rule.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quad_type</td><td>The type of quadrature rule to use. At the present time only QGAUSS and QGRID are supported.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The order of the quadrature rule.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_adaptive_quadrature</td><td>Whether or not the element data should be read (and <code>order</code> possibly modified) to get the correct quadrature point spacing.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_density</td><td>Parameter for computing the number of points in the quadrature rule. The number of points is computed as <code>ceil(point_density * hmax / dx_min)</code>, where <code>hmax</code> is the maximum edge length of the deformed element (i.e., with nodal coordinates given by <code>X_node</code>).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The <a class="el" href="namespacelib_mesh.html">libMesh</a> element. The quadrature rule generated by this function will always have enough points to integrate the basis functions defined on the element exactly.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_node</td><td>Values of <code>elem's</code> shape functions of the structure location field (i.e., X): for interpolatory finite elements (e.g., libMesh::LAGRANGE) these the actual coordinates of the node (since shape functions will either be one or zero at nodes). <code>X_node</code> is assumed to be a two-dimensional array whose rows correspond to node number and whose columns correspond to x, y, and (in 3D) z coordinates.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dx_min</td><td>See <code>point_density</code>.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_i_b_t_k_1_1_f_e_data_manager.html#abe6333c87d4963f084def902e654e5e7">FEDataManager::updateQuadratureRule</a>. </p>

</div>
</div>
<a class="anchor" id="a6112f647ae259dfcf94c0be54ba818f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n_vars, int n_basis&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::integrate_elem_rhs_n_vars_n_basis </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>qp_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>JxW_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_rhs_concatenated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble the element contribution to a load vector. </p>
<p>The three functions below allow compile-time selection of the number of basis functions and number of variables. Fixing the loop bounds via templates and switch statements makes most IBFE codes a few percent faster.</p>
<p>This function (the last of the three) takes the number of variables and number of basis functions as template argument which allows the compiler to unroll the two inner loops when appropriate. Setting either value to -1 results in run-time selection of loop bounds (which is considerably slower).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qp_offset</td><td>Offset used to calculate an index into <code>F_qp</code>. The relevant part of the array is assumed to start at <code>n_vars * qp_offset</code>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi_F</td><td>Values of test functions evaluated at quadrature points, indexed by test function number and then quadrature point number.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">JxW_F</td><td>Products of Jacobian and quadrature weight at each quadrature point.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F_qp</td><td>Globally indexed array containing function values at quadrature points. The array is indexed by quadrature point and then by variable: i.e., if <code>n_vars</code> is greater than one then components of the vector-valued function being projected at a certain quadrature point are contiguous.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F_rhs_concatenated</td><td>Vector containing element integrals of products of test functions and values of the interpolated function. Unlike <code>F_qp</code>, the values in this vector are first indexed by variable and then by quadrature point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e621904d431a494ee6d70939ea3517b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::interpolate </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArray &amp;&#160;</td>
          <td class="paramname"><em>U_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the current solution at quadrature point number .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>Value of the finite element solution at the given point.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qp</td><td>Number of the quadrature point at which we will compute the solution value.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_node</td><td>Multidimensional array containing finite element solution coefficients on the current element.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi</td><td>Reference values of the shape functions indexed in the usual way (first by basis function number and then by quadrature point number). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc24178d5490dc9c567ced0c6fd396dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IBTK::interpolate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArray &amp;&#160;</td>
          <td class="paramname"><em>U_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the current solution at quadrature point number . Returns the value instead of taking a reference to it as the first argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qp</td><td>Number of the quadrature point at which we will compute the solution value.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_node</td><td>Multidimensional array containing finite element solution coefficients on the current element.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi</td><td>Reference values of the shape functions indexed in the usual way (first by basis function number and then by quadrature point number). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a4cce3704003cf03a1d50ca1b5856cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::interpolate </td>
          <td>(</td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArray &amp;&#160;</td>
          <td class="paramname"><em>U_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the current solution at quadrature point number . This version of <a class="el" href="namespace_i_b_t_k.html#a6e621904d431a494ee6d70939ea3517b">interpolate()</a> is vector-valued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>Array containing the output of this function. This function assumes that this array has at least <code>U_node.shape()[1]</code> entries.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qp</td><td>Number of the quadrature point at which we will compute the solution value.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_node</td><td>Multidimensional array containing finite element solution coefficients on the current element.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi</td><td>Reference values of the shape functions indexed in the usual way (first by basis function number and then by quadrature point number). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7533ce02f3c58746ebc2ea90405fcc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::interpolate </td>
          <td>(</td>
          <td class="paramtype">libMesh::TypeVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArray &amp;&#160;</td>
          <td class="paramname"><em>U_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the current solution at quadrature point number . This version of <a class="el" href="namespace_i_b_t_k.html#a6e621904d431a494ee6d70939ea3517b">interpolate()</a> is vector-valued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>Array containing the output of this function. This function assumes that this TypeVector has at least <code>U_node.shape()[1]</code> entries.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qp</td><td>Number of the quadrature point at which we will compute the solution value.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_node</td><td>Multidimensional array containing finite element solution coefficients on the current element.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi</td><td>Reference values of the shape functions indexed in the usual way (first by basis function number and then by quadrature point number). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9028293137d8bfcafec9ac4a39d5381e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::jacobian </td>
          <td>(</td>
          <td class="paramtype">libMesh::TypeTensor&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dX_ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArray &amp;&#160;</td>
          <td class="paramname"><em>X_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; libMesh::VectorValue&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dphi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the jacobian with respect to the initial configuration in the deformed configuration <code>X_node</code> at quadrature point number .</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ J(qp) = \sum_{i = 1}^n \xi_i \otimes \nabla_X \phi_i(qp) \]" src="form_131.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dX_ds</td><td>Tensor containing the output of this function of size 3x3.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qp</td><td>Number of the quadrature point at which we will compute the solution value.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_node</td><td>Values of the shape functions of the structure location field (i.e., X): for interpolatory finite elements (e.g., libMesh::LAGRANGE) these the actual coordinates of the node (since shape functions will either be one or zero at nodes). <code>X_node</code> is assumed to be a two-dimensional array whose rows correspond to node number and whose columns correspond to x, y, and (in 3D) z coordinates.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dphi</td><td>Reference values of the gradient of the shape functions indexed in the usual way (first by basis function number and then by quadrature point number). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b9a273f1a3e0c1b11314fac9896cef1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &gt; IBTK::merge_boxes_by_longest_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/samrai.tag:../../samrai/2.4.4/html/" href="../../samrai/2.4.4/html/classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a set of boxes (which describe a region in index space), return another set of boxes whose union covers the same index space. The returned set of boxes is formed by merging boxes in <code>boxes</code> along their longest edges. </p>

</div>
</div>
<a class="anchor" id="a9a2f64610b7d15183ce7e534a2f8a800"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> IBTK::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Permit modifying FEUpdateFlags as though it were an integer type. </p>

</div>
</div>
<a class="anchor" id="a1582f6fd26602fbcf4515d3087f70b96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&amp; IBTK::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Permit modifying FEUpdateFlags as though it were an integer type. </p>

</div>
</div>
<a class="anchor" id="aeec91280c11f51e37e3b3f17c2c814a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> IBTK::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Permit modifying FEUpdateFlags as though it were an integer type. </p>

</div>
</div>
<a class="anchor" id="a57e94038433d94b44c668708c398e402"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&amp; IBTK::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_i_b_t_k.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Permit modifying FEUpdateFlags as though it were an integer type. </p>

</div>
</div>
<a class="anchor" id="a67fdfe0a5d6114b04e025c647f22883f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vec IBTK::setup_petsc_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>num_local_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nonlocal_petsc_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal function for setting up a PETSc function of given size and depth. See the documentation of <a class="el" href="class_i_b_t_k_1_1_l_data.html" title="Class LData provides storage for a single scalar- or vector-valued Lagrangian quantity. ">LData</a> for more information. </p>

</div>
</div>
<a class="anchor" id="a7aab901bde6055f89372825e50c731be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n_vars, int n_basis, bool weights_are_unity = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::sum_weighted_elem_solution_n_vars_n_basis </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>qp_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_w_qp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the product of the finite element representation of the force and (optionally) a set of weights (e.g., JxW values) at all quadrature points on an element. See integrate_elem_rhs for details on the first two template arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">weights_are_unity</td><td>Assume that all values in <code>weights</code> are 1. This value should be true when we are only interpolating values at quadrature points and otherwise false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qp_offset</td><td>Offset used to calculate an index into <code>F_w_qp</code>. The relevant part of the array is assumed to start at <code>n_vars * qp_offset</code>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi_F</td><td>Values of test functions evaluated at quadrature points, indexed by test function number and then quadrature point number.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>Vector containing weights at quadrature points: in the case of force spreading this is the standard JxW array. If <code>weights_are_unity</code> is true then its values are assumed to be 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F_node</td><td>Values of the finite element solution (i.e., the multipliers on each trial function) on the current element.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F_w_qp</td><td>Globally indexed array containing the product of the finite element representation of the force and weights at the quadrature points on the current element. The array is indexed by quadrature point and then by variable: i.e., if <code>n_vars</code> is greater than one then variables of the vector-valued force being evaluated at a certain quadrature point are contiguous. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5eed5a2c7a3e14447a70fe4a46b42aad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IBTK::tensor_idx_to_voigt </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06756.html">std::pair</a>&lt; int, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a symmetric tensor index to the corresponding Voigt notation index. </p>

</div>
</div>
<a class="anchor" id="a7d81edd603b8e9ea39ec04e986480c6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06756.html">std::pair</a>&lt;int, int&gt; IBTK::voigt_to_tensor_idx </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a Voigt notation index to the corresponding symmetric tensor index. This function only returns the upper triangular index. </p>

</div>
</div>
<a class="anchor" id="aceed8ef2e29cf7a38d720d5418751e73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::write_elem_partitioning </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::System &amp;&#160;</td>
          <td class="paramname"><em>position_system</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save, in a plain text file, the <a class="el" href="namespacelib_mesh.html">libMesh</a> partitioning, with the format </p><pre class="fragment">x,y,z,rank
</pre><p>where x, y, and z are the center of an Elem and rank is the current MPI rank.</p>
<dl class="section note"><dt>Note</dt><dd>this function collates the output from all MPI processors in the communicator assigned to <code>position_system</code>, so it is an inherently serial function. </dd></dl>

</div>
</div>
<a class="anchor" id="a07ede2ffd0f710fcf1b00c933cdc4da8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::write_node_partitioning </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/travis/build/IBAMR/IBAMR/doc/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::System &amp;&#160;</td>
          <td class="paramname"><em>position_system</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save, in a plain text file, the <a class="el" href="namespacelib_mesh.html">libMesh</a> Node partitioning, with the format </p><pre class="fragment">x,y,z,rank
</pre><p>where x, y, and z are the coordinates of a Node and rank is the current MPI rank.</p>
<dl class="section note"><dt>Note</dt><dd>this function collates the output from all MPI processors in the communicator assigned to <code>position_system</code>, so it is an inherently serial function. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 22 2020 19:04:27 for IBAMR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
