<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: IBAMR::IBFEMethod Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IBAMR
   &#160;<span id="projectnumber">IBAMR version 0.18.</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceIBAMR.html">IBAMR</a></li><li class="navelem"><a class="el" href="classIBAMR_1_1IBFEMethod.html">IBFEMethod</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classIBAMR_1_1IBFEMethod-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IBAMR::IBFEMethod Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class <a class="el" href="classIBAMR_1_1IBFEMethod.html" title="Class IBFEMethod is an implementation of the abstract base class IBStrategy that provides functionali...">IBFEMethod</a> is an implementation of the abstract base class <a class="el" href="classIBAMR_1_1IBStrategy.html" title="Class IBStrategy provides a generic interface for specifying the implementation details of a particul...">IBStrategy</a> that provides functionality required by the IB method with finite element elasticity. Much of the setup for finite element computations is done by the <a class="el" href="classIBAMR_1_1FEMechanicsBase.html" title="Class FEMechanicsBase provides core finite element mechanics functionality and data management.">IBAMR::FEMechanicsBase</a>: see the documentation of that class for additional information on input parameters.  
 <a href="classIBAMR_1_1IBFEMethod.html#details">More...</a></p>

<p><code>#include &lt;ibamr/IBFEMethod.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IBAMR::IBFEMethod:</div>
<div class="dyncontent">
<div class="center"><img src="classIBAMR_1_1IBFEMethod__inherit__graph.png" border="0" usemap="#IBAMR_1_1IBFEMethod_inherit__map" alt="Inheritance graph"/></div>
<map name="IBAMR_1_1IBFEMethod_inherit__map" id="IBAMR_1_1IBFEMethod_inherit__map">
<area shape="rect" title="Class IBFEMethod is an implementation of the abstract base class IBStrategy that provides functionali..." alt="" coords="122,352,273,379"/>
<area shape="rect" href="classIBAMR_1_1FEMechanicsBase.html" title="Class FEMechanicsBase provides core finite element mechanics functionality and data management." alt="" coords="7,276,198,303"/>
<area shape="rect" href="classSAMRAI_1_1tbox_1_1Serializable.html" title=" " alt="" coords="5,193,200,219"/>
<area shape="rect" href="classIBAMR_1_1IBStrategy.html" title="Class IBStrategy provides a generic interface for specifying the implementation details of a particul..." alt="" coords="223,276,364,303"/>
<area shape="rect" href="classSAMRAI_1_1tbox_1_1DescribedClass.html" title="Base class for all objects that use run&#45;time type identification (RTTI)." alt="" coords="77,5,296,32"/>
<area shape="rect" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html" title=" " alt="" coords="225,185,431,227"/>
<area shape="rect" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html" title=" " alt="" coords="225,81,431,123"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIBAMR_1_1IBFEMethod_1_1LagBodySourceFcnData.html">LagBodySourceFcnData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6516bc3b0fe1cb7cc939f599d6938cbf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a6516bc3b0fe1cb7cc939f599d6938cbf">LagBodySourceFcnPtr</a> = <a class="el" href="namespaceIBTK.html#a3f04732f2606c4a49ff92ca5b3c514b9">IBTK::ScalarMeshFcnPtr</a></td></tr>
<tr class="separator:a6516bc3b0fe1cb7cc939f599d6938cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dc8aeb4a300f9f33a83c35084ce477"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a98dc8aeb4a300f9f33a83c35084ce477">CoordinateMappingFcnPtr</a> = void(*)(libMesh::Point &amp;x, const libMesh::Point &amp;X, void *ctx)</td></tr>
<tr class="separator:a98dc8aeb4a300f9f33a83c35084ce477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac964e673a98fe643de584a8878a100"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aaac964e673a98fe643de584a8878a100">InitialVelocityFcnPtr</a> = void(*)(<a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;U0, const libMesh::Point &amp;X0, void *ctx)</td></tr>
<tr class="separator:aaac964e673a98fe643de584a8878a100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3914db70c54c7409c974d1092523fd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#acd3914db70c54c7409c974d1092523fd">PK1StressFcnPtr</a> = <a class="el" href="namespaceIBTK.html#a2047e8d6003cdf2c5017d741cad69907">IBTK::TensorMeshFcnPtr</a></td></tr>
<tr class="separator:acd3914db70c54c7409c974d1092523fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b15d9db97ca4029e8a907b49e7903b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a80b15d9db97ca4029e8a907b49e7903b">LagBodyForceFcnPtr</a> = <a class="el" href="namespaceIBTK.html#a503cb21b0cf0bd3e1ed168623b674d8e">IBTK::VectorMeshFcnPtr</a></td></tr>
<tr class="separator:a80b15d9db97ca4029e8a907b49e7903b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f12aaeafdc62afba92f41096b775f1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a03f12aaeafdc62afba92f41096b775f1">LagSurfacePressureFcnPtr</a> = <a class="el" href="namespaceIBTK.html#a0828e2d557e67a201c8526a7c9b761b0">IBTK::ScalarSurfaceFcnPtr</a></td></tr>
<tr class="separator:a03f12aaeafdc62afba92f41096b775f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a022d74675df32bc5e0b5c4a81d332"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a82a022d74675df32bc5e0b5c4a81d332">LagSurfaceForceFcnPtr</a> = <a class="el" href="namespaceIBTK.html#a45007c53f48bbf752259fcec0884767c">IBTK::VectorSurfaceFcnPtr</a></td></tr>
<tr class="separator:a82a022d74675df32bc5e0b5c4a81d332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda305fe47cf0aa2699cff49769fe49e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aeda305fe47cf0aa2699cff49769fe49e">VolumetricEnergyDerivativeFcn</a> = <a class="el" href="classdouble.html">double</a>(*)(<a class="el" href="classdouble.html">double</a>)</td></tr>
<tr class="separator:aeda305fe47cf0aa2699cff49769fe49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1ed9494267dc54802972b735ac05e6c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a1ed9494267dc54802972b735ac05e6c4">IBFEMethod</a> (const std::string &amp;object_name, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; &amp;input_db, libMesh::MeshBase *mesh, <a class="el" href="classint.html">int</a> max_levels, <a class="el" href="classbool.html">bool</a> register_for_restart=true, const std::string &amp;restart_read_dirname=&quot;&quot;, unsigned <a class="el" href="classint.html">int</a> restart_restore_number=0)</td></tr>
<tr class="memdesc:a1ed9494267dc54802972b735ac05e6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a single-part model.  <a href="classIBAMR_1_1IBFEMethod.html#a1ed9494267dc54802972b735ac05e6c4">More...</a><br /></td></tr>
<tr class="separator:a1ed9494267dc54802972b735ac05e6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e84d18910a720e1319af00b58def614"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a6e84d18910a720e1319af00b58def614">IBFEMethod</a> (const std::string &amp;object_name, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; &amp;input_db, const std::vector&lt; libMesh::MeshBase * &gt; &amp;meshes, <a class="el" href="classint.html">int</a> max_levels, <a class="el" href="classbool.html">bool</a> register_for_restart=true, const std::string &amp;restart_read_dirname=&quot;&quot;, unsigned <a class="el" href="classint.html">int</a> restart_restore_number=0)</td></tr>
<tr class="memdesc:a6e84d18910a720e1319af00b58def614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a multi-part model.  <a href="classIBAMR_1_1IBFEMethod.html#a6e84d18910a720e1319af00b58def614">More...</a><br /></td></tr>
<tr class="separator:a6e84d18910a720e1319af00b58def614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87c905b3cad88a84e2d1e159999b7b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ab87c905b3cad88a84e2d1e159999b7b1">IBFEMethod</a> ()=delete</td></tr>
<tr class="memdesc:ab87c905b3cad88a84e2d1e159999b7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted default constructor.  <a href="classIBAMR_1_1IBFEMethod.html#ab87c905b3cad88a84e2d1e159999b7b1">More...</a><br /></td></tr>
<tr class="separator:ab87c905b3cad88a84e2d1e159999b7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0970830b1f97bde9ba7ac1e4305acd06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a0970830b1f97bde9ba7ac1e4305acd06">IBFEMethod</a> (const <a class="el" href="classIBAMR_1_1IBFEMethod.html">IBFEMethod</a> &amp;from)=delete</td></tr>
<tr class="memdesc:a0970830b1f97bde9ba7ac1e4305acd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <a href="classIBAMR_1_1IBFEMethod.html#a0970830b1f97bde9ba7ac1e4305acd06">More...</a><br /></td></tr>
<tr class="separator:a0970830b1f97bde9ba7ac1e4305acd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe3cae033d94492eaed326e973f0e4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBAMR_1_1IBFEMethod.html">IBFEMethod</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#affe3cae033d94492eaed326e973f0e4b">operator=</a> (const <a class="el" href="classIBAMR_1_1IBFEMethod.html">IBFEMethod</a> &amp;that)=delete</td></tr>
<tr class="memdesc:affe3cae033d94492eaed326e973f0e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted assignment operator.  <a href="classIBAMR_1_1IBFEMethod.html#affe3cae033d94492eaed326e973f0e4b">More...</a><br /></td></tr>
<tr class="separator:affe3cae033d94492eaed326e973f0e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345284bdac89d5af1297a18b74d29e8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a345284bdac89d5af1297a18b74d29e8c">~IBFEMethod</a> () override=default</td></tr>
<tr class="memdesc:a345284bdac89d5af1297a18b74d29e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted destructor.  <a href="classIBAMR_1_1IBFEMethod.html#a345284bdac89d5af1297a18b74d29e8c">More...</a><br /></td></tr>
<tr class="separator:a345284bdac89d5af1297a18b74d29e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4809678660681d026b8c13e5c6968397"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a4809678660681d026b8c13e5c6968397">getSourceSystemName</a> () const</td></tr>
<tr class="separator:a4809678660681d026b8c13e5c6968397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae917dca7c529cd37fc1617edcd037bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBTK_1_1FEDataManager.html">IBTK::FEDataManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ae917dca7c529cd37fc1617edcd037bce">getFEDataManager</a> (unsigned <a class="el" href="classint.html">int</a> part=0) const</td></tr>
<tr class="separator:ae917dca7c529cd37fc1617edcd037bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac379e9514ee73a499dc012cd9d6873a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ac379e9514ee73a499dc012cd9d6873a3">registerStaticPressurePart</a> (<a class="el" href="namespaceIBAMR.html#a62309df2b45664a6805692d7ed20e3a9">PressureProjectionType</a> projection_type=<a class="el" href="namespaceIBAMR.html#a62309df2b45664a6805692d7ed20e3a9a9c4964d505893bc3fa1c1d50cb4edd9b">CONSISTENT_PROJECTION</a>, <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aeda305fe47cf0aa2699cff49769fe49e">FEMechanicsBase::VolumetricEnergyDerivativeFcn</a> U_prime_fcn=nullptr, unsigned <a class="el" href="classint.html">int</a> part=0) override</td></tr>
<tr class="separator:ac379e9514ee73a499dc012cd9d6873a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f90394bbfd586569f698add87e06db"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ac5f90394bbfd586569f698add87e06db">registerStressNormalizationPart</a> (unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="separator:ac5f90394bbfd586569f698add87e06db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cedd4f91763a8709be18493c072897"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ac0cedd4f91763a8709be18493c072897">registerLagBodySourceFunction</a> (const <a class="el" href="structIBAMR_1_1IBFEMethod_1_1LagBodySourceFcnData.html">LagBodySourceFcnData</a> &amp;data, unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="separator:ac0cedd4f91763a8709be18493c072897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47ed582982fa1e1e475f429c0190bc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structIBAMR_1_1IBFEMethod_1_1LagBodySourceFcnData.html">LagBodySourceFcnData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ac47ed582982fa1e1e475f429c0190bc8">getLagBodySourceFunction</a> (unsigned <a class="el" href="classint.html">int</a> part=0) const</td></tr>
<tr class="separator:ac47ed582982fa1e1e475f429c0190bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac921c32e680078b72255b2a27542a376"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ac921c32e680078b72255b2a27542a376">registerDirectForcingKinematics</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBAMR_1_1IBFEDirectForcingKinematics.html">IBAMR::IBFEDirectForcingKinematics</a> &gt; &amp;data, unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="separator:ac921c32e680078b72255b2a27542a376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44945b50230b3deb2906d196f25ea807"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a44945b50230b3deb2906d196f25ea807">getMinimumGhostCellWidth</a> () const override</td></tr>
<tr class="separator:a44945b50230b3deb2906d196f25ea807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf2016743693e3c6a37277181eee3f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a2cf2016743693e3c6a37277181eee3f3">setupTagBuffer</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">SAMRAI::tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;tag_buffer, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt; gridding_alg) const override</td></tr>
<tr class="separator:a2cf2016743693e3c6a37277181eee3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e2f33d8a990ca6435ac8320e774c35"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a69e2f33d8a990ca6435ac8320e774c35">getMaxPointDisplacement</a> () const override</td></tr>
<tr class="separator:a69e2f33d8a990ca6435ac8320e774c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200b1b8997e92a13df67fb9833602c11"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a200b1b8997e92a13df67fb9833602c11">inactivateLagrangianStructure</a> (<a class="el" href="classint.html">int</a> structure_number=0, <a class="el" href="classint.html">int</a> level_number=std::numeric_limits&lt; <a class="el" href="classint.html">int</a> &gt;::max()) override</td></tr>
<tr class="separator:a200b1b8997e92a13df67fb9833602c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7ed02ad7dd6ca8ffe8c12ca40ab477"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#aea7ed02ad7dd6ca8ffe8c12ca40ab477">activateLagrangianStructure</a> (<a class="el" href="classint.html">int</a> structure_number=0, <a class="el" href="classint.html">int</a> level_number=std::numeric_limits&lt; <a class="el" href="classint.html">int</a> &gt;::max()) override</td></tr>
<tr class="separator:aea7ed02ad7dd6ca8ffe8c12ca40ab477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922aa7278e9f214b63cbc1151cafaea5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a922aa7278e9f214b63cbc1151cafaea5">getLagrangianStructureIsActivated</a> (<a class="el" href="classint.html">int</a> structure_number=0, <a class="el" href="classint.html">int</a> level_number=std::numeric_limits&lt; <a class="el" href="classint.html">int</a> &gt;::max()) const override</td></tr>
<tr class="separator:a922aa7278e9f214b63cbc1151cafaea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29507964e0fb82f935ca7d9a49569cd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a29507964e0fb82f935ca7d9a49569cd2">preprocessIntegrateData</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time, <a class="el" href="classint.html">int</a> num_cycles) override</td></tr>
<tr class="separator:a29507964e0fb82f935ca7d9a49569cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf49eb718d9b0b9dc17b711eb9ccfe0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a8cf49eb718d9b0b9dc17b711eb9ccfe0">postprocessIntegrateData</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time, <a class="el" href="classint.html">int</a> num_cycles) override</td></tr>
<tr class="separator:a8cf49eb718d9b0b9dc17b711eb9ccfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fd1b2a7066e20b67b9e1a06f529b5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a26fd1b2a7066e20b67b9e1a06f529b5b">interpolateVelocity</a> (<a class="el" href="classint.html">int</a> u_data_idx, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;u_synch_scheds, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;u_ghost_fill_scheds, <a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="separator:a26fd1b2a7066e20b67b9e1a06f529b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae406c44c5285a9935aa064a77062b729"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ae406c44c5285a9935aa064a77062b729">setUseMultistepTimeStepping</a> (unsigned <a class="el" href="classint.html">int</a> n_previous_steps=1) override</td></tr>
<tr class="separator:ae406c44c5285a9935aa064a77062b729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38332aad4b7478c644ba5d93c97eedf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#af38332aad4b7478c644ba5d93c97eedf">forwardEulerStep</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time) override</td></tr>
<tr class="separator:af38332aad4b7478c644ba5d93c97eedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d14d0844040c5e88d7ab81b4c3a8898"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a7d14d0844040c5e88d7ab81b4c3a8898">backwardEulerStep</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time) override</td></tr>
<tr class="separator:a7d14d0844040c5e88d7ab81b4c3a8898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add10641d74d05d57159a952f44d8899f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#add10641d74d05d57159a952f44d8899f">midpointStep</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time) override</td></tr>
<tr class="separator:add10641d74d05d57159a952f44d8899f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2781619cd7540db983ee9715027bea5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a2781619cd7540db983ee9715027bea5d">trapezoidalStep</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time) override</td></tr>
<tr class="separator:a2781619cd7540db983ee9715027bea5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcab93d9b8db4efb7b959a19f82f0c79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#abcab93d9b8db4efb7b959a19f82f0c79">AB2Step</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time) override</td></tr>
<tr class="separator:abcab93d9b8db4efb7b959a19f82f0c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cb110886698f4c239f0dbab461a4d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a22cb110886698f4c239f0dbab461a4d9">computeLagrangianForce</a> (<a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="separator:a22cb110886698f4c239f0dbab461a4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ad97cfb324cbc9af905fcf0675ebaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a52ad97cfb324cbc9af905fcf0675ebaa">spreadForce</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">IBTK::RobinPhysBdryPatchStrategy</a> *f_phys_bdry_op, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_prolongation_scheds, <a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="separator:a52ad97cfb324cbc9af905fcf0675ebaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f46b84c04db987dee05672c81c0bec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a09f46b84c04db987dee05672c81c0bec">hasFluidSources</a> () const override</td></tr>
<tr class="separator:a09f46b84c04db987dee05672c81c0bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6390dba78691fcc64fee8a51cdcae44f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a6390dba78691fcc64fee8a51cdcae44f">computeLagrangianFluidSource</a> (<a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="separator:a6390dba78691fcc64fee8a51cdcae44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2819f1c6a98a728c6ee0906da62be8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a0d2819f1c6a98a728c6ee0906da62be8">spreadFluidSource</a> (<a class="el" href="classint.html">int</a> q_data_idx, <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">IBTK::RobinPhysBdryPatchStrategy</a> *q_phys_bdry_op, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;q_prolongation_scheds, <a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="separator:a0d2819f1c6a98a728c6ee0906da62be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15851f70dd152079dc05487f9c4d55bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">IBTK::FEDataManager::InterpSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a15851f70dd152079dc05487f9c4d55bd">getDefaultInterpSpec</a> () const</td></tr>
<tr class="separator:a15851f70dd152079dc05487f9c4d55bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29931b1b6941d078dad969e57bc3f60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">IBTK::FEDataManager::SpreadSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ae29931b1b6941d078dad969e57bc3f60">getDefaultSpreadSpec</a> () const</td></tr>
<tr class="separator:ae29931b1b6941d078dad969e57bc3f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ae4c5f1c67d9b283b8fa057c241c1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a17ae4c5f1c67d9b283b8fa057c241c1e">setWorkloadSpec</a> (const <a class="el" href="structIBTK_1_1FEDataManager_1_1WorkloadSpec.html">IBTK::FEDataManager::WorkloadSpec</a> &amp;workload_spec, unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="separator:a17ae4c5f1c67d9b283b8fa057c241c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fe231a402d36d8bd1ea6b0fab26914"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a84fe231a402d36d8bd1ea6b0fab26914">setInterpSpec</a> (const <a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">IBTK::FEDataManager::InterpSpec</a> &amp;interp_spec, unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="separator:a84fe231a402d36d8bd1ea6b0fab26914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bed9afd40f2991a3e203bc3661e95b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a13bed9afd40f2991a3e203bc3661e95b">setSpreadSpec</a> (const <a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">IBTK::FEDataManager::SpreadSpec</a> &amp;spread_spec, unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="separator:a13bed9afd40f2991a3e203bc3661e95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efe212b70056f71d887e3f173432d42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a3efe212b70056f71d887e3f173432d42">registerEulerianVariables</a> () override</td></tr>
<tr class="memdesc:a3efe212b70056f71d887e3f173432d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register Eulerian variables with the parent <a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html" title="Class IBHierarchyIntegrator provides an abstract interface for a time integrator for various versions...">IBHierarchyIntegrator</a>.  <a href="classIBAMR_1_1IBFEMethod.html#a3efe212b70056f71d887e3f173432d42">More...</a><br /></td></tr>
<tr class="separator:a3efe212b70056f71d887e3f173432d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90a6f1603d1806f04094e303f8b1d37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ae90a6f1603d1806f04094e303f8b1d37">initializePatchHierarchy</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt; gridding_alg, <a class="el" href="classint.html">int</a> u_data_idx, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;u_synch_scheds, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;u_ghost_fill_scheds, <a class="el" href="classint.html">int</a> integrator_step, <a class="el" href="classdouble.html">double</a> init_data_time, <a class="el" href="classbool.html">bool</a> initial_time) override</td></tr>
<tr class="separator:ae90a6f1603d1806f04094e303f8b1d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abd4174181183da4113048fba4eec53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a9abd4174181183da4113048fba4eec53">addWorkloadEstimate</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classint.html">int</a> workload_data_idx) override</td></tr>
<tr class="separator:a9abd4174181183da4113048fba4eec53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa435f674667775eca22ef8fac79ca238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#aa435f674667775eca22ef8fac79ca238">beginDataRedistribution</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt; gridding_alg) override</td></tr>
<tr class="separator:aa435f674667775eca22ef8fac79ca238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22ac9c1888e9d44351a68b456fda604"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ae22ac9c1888e9d44351a68b456fda604">endDataRedistribution</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt; gridding_alg) override</td></tr>
<tr class="separator:ae22ac9c1888e9d44351a68b456fda604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295652bc060179b8cb5d730649e133dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a295652bc060179b8cb5d730649e133dd">initializeLevelData</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classint.html">int</a> level_number, <a class="el" href="classdouble.html">double</a> init_data_time, <a class="el" href="classbool.html">bool</a> can_be_refined, <a class="el" href="classbool.html">bool</a> initial_time, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt; old_level, <a class="el" href="classbool.html">bool</a> allocate_data) override</td></tr>
<tr class="separator:a295652bc060179b8cb5d730649e133dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd4f8a28b0cfebfe8ec7b7302bb627d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a0dd4f8a28b0cfebfe8ec7b7302bb627d">resetHierarchyConfiguration</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classint.html">int</a> coarsest_level, <a class="el" href="classint.html">int</a> finest_level) override</td></tr>
<tr class="separator:a0dd4f8a28b0cfebfe8ec7b7302bb627d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1032e0a37c2d874a18403a8ceb534d1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a1032e0a37c2d874a18403a8ceb534d1d">applyGradientDetector</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classint.html">int</a> level_number, <a class="el" href="classdouble.html">double</a> error_data_time, <a class="el" href="classint.html">int</a> tag_index, <a class="el" href="classbool.html">bool</a> initial_time, <a class="el" href="classbool.html">bool</a> uses_richardson_extrapolation_too) override</td></tr>
<tr class="separator:a1032e0a37c2d874a18403a8ceb534d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed478d4d5214191cd99a63f221537fbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#aed478d4d5214191cd99a63f221537fbf">putToDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; db) override</td></tr>
<tr class="separator:aed478d4d5214191cd99a63f221537fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01dc5f5d00ef3d13479e72e274b389b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a01dc5f5d00ef3d13479e72e274b389b6">getScratchHierarchy</a> ()</td></tr>
<tr class="separator:a01dc5f5d00ef3d13479e72e274b389b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcaefbb8b7b260e9f4c5d3705d81235"><td class="memItemLeft" align="right" valign="top">libMesh::EquationSystems *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#afbcaefbb8b7b260e9f4c5d3705d81235">getEquationSystems</a> (unsigned <a class="el" href="classint.html">int</a> part=0) const</td></tr>
<tr class="separator:afbcaefbb8b7b260e9f4c5d3705d81235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194ac6be6d209938221062d2686b6f5d"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a194ac6be6d209938221062d2686b6f5d">getCurrentCoordinatesSystemName</a> () const</td></tr>
<tr class="separator:a194ac6be6d209938221062d2686b6f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad6f4fc0a3765900ce78a8f2890708e"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aaad6f4fc0a3765900ce78a8f2890708e">getDisplacementSystemName</a> () const</td></tr>
<tr class="separator:aaad6f4fc0a3765900ce78a8f2890708e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203ced8a9e9954ec5c5738643765dd4c"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a203ced8a9e9954ec5c5738643765dd4c">getForceSystemName</a> () const</td></tr>
<tr class="separator:a203ced8a9e9954ec5c5738643765dd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fbc454a4ea1175714bf9b592561c5b"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a48fbc454a4ea1175714bf9b592561c5b">getPressureSystemName</a> () const</td></tr>
<tr class="separator:a48fbc454a4ea1175714bf9b592561c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807fad09e25de8a24ba473e0cd2f58e3"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a807fad09e25de8a24ba473e0cd2f58e3">getVelocitySystemName</a> () const</td></tr>
<tr class="separator:a807fad09e25de8a24ba473e0cd2f58e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880841f755dc28200c88eb89e4cba980"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classIBTK_1_1FEData.html">IBTK::FEData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a880841f755dc28200c88eb89e4cba980">getFEData</a> (unsigned <a class="el" href="classint.html">int</a> part=0) const</td></tr>
<tr class="separator:a880841f755dc28200c88eb89e4cba980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb9b35ba376f3bbb5d8e8909c319fd6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a3eb9b35ba376f3bbb5d8e8909c319fd6">registerInitialCoordinateMappingFunction</a> (const <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1CoordinateMappingFcnData.html">CoordinateMappingFcnData</a> &amp;data, unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="separator:a3eb9b35ba376f3bbb5d8e8909c319fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855edc9bb5296689bb2dffe7764c01ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1CoordinateMappingFcnData.html">CoordinateMappingFcnData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a855edc9bb5296689bb2dffe7764c01ae">getInitialCoordinateMappingFunction</a> (unsigned <a class="el" href="classint.html">int</a> part=0) const</td></tr>
<tr class="separator:a855edc9bb5296689bb2dffe7764c01ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd03b04f7716af955f2819ae951adebf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#abd03b04f7716af955f2819ae951adebf">registerInitialVelocityFunction</a> (const <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1InitialVelocityFcnData.html">InitialVelocityFcnData</a> &amp;data, unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="separator:abd03b04f7716af955f2819ae951adebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ebae1b8e0a35e523355bd3d49b867e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1InitialVelocityFcnData.html">InitialVelocityFcnData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aa5ebae1b8e0a35e523355bd3d49b867e">getInitialVelocityFunction</a> (unsigned <a class="el" href="classint.html">int</a> part=0) const</td></tr>
<tr class="separator:aa5ebae1b8e0a35e523355bd3d49b867e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfaa59d187a7ea211d5a0fbc0ea989ff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#adfaa59d187a7ea211d5a0fbc0ea989ff">registerPK1StressFunction</a> (const <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1PK1StressFcnData.html">PK1StressFcnData</a> &amp;data, unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="separator:adfaa59d187a7ea211d5a0fbc0ea989ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad875ff499ae980e1052d1059384fadb4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1PK1StressFcnData.html">PK1StressFcnData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#ad875ff499ae980e1052d1059384fadb4">getPK1StressFunction</a> (unsigned <a class="el" href="classint.html">int</a> part=0) const</td></tr>
<tr class="separator:ad875ff499ae980e1052d1059384fadb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5048e9b39e6cac0adb4e673863eb5eda"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a5048e9b39e6cac0adb4e673863eb5eda">registerLagBodyForceFunction</a> (const <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagBodyForceFcnData.html">LagBodyForceFcnData</a> &amp;data, unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="separator:a5048e9b39e6cac0adb4e673863eb5eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c45608c439a009c6da0062aa4f9be2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagBodyForceFcnData.html">LagBodyForceFcnData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a71c45608c439a009c6da0062aa4f9be2">getLagBodyForceFunction</a> (unsigned <a class="el" href="classint.html">int</a> part=0) const</td></tr>
<tr class="separator:a71c45608c439a009c6da0062aa4f9be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060ab8bb4ffff3d4cdef1102b45d238e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a060ab8bb4ffff3d4cdef1102b45d238e">registerLagSurfacePressureFunction</a> (const <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagSurfacePressureFcnData.html">LagSurfacePressureFcnData</a> &amp;data, unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="separator:a060ab8bb4ffff3d4cdef1102b45d238e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2384671da762544379cd2af88367ceb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagSurfacePressureFcnData.html">LagSurfacePressureFcnData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a2384671da762544379cd2af88367ceb3">getLagSurfacePressureFunction</a> (unsigned <a class="el" href="classint.html">int</a> part=0) const</td></tr>
<tr class="separator:a2384671da762544379cd2af88367ceb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a59d9fd6d76f75b6c95feab1ca4841"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a19a59d9fd6d76f75b6c95feab1ca4841">registerLagSurfaceForceFunction</a> (const <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagSurfaceForceFcnData.html">LagSurfaceForceFcnData</a> &amp;data, unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="separator:a19a59d9fd6d76f75b6c95feab1ca4841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16d68cf6a92d90ab5a20f3576470ecf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagSurfaceForceFcnData.html">LagSurfaceForceFcnData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#af16d68cf6a92d90ab5a20f3576470ecf">getLagSurfaceForceFunction</a> (unsigned <a class="el" href="classint.html">int</a> part=0) const</td></tr>
<tr class="separator:af16d68cf6a92d90ab5a20f3576470ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4a3651cef38c65b761cbbe43a2a8ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a2a4a3651cef38c65b761cbbe43a2a8ef">registerDynamicPressurePart</a> (<a class="el" href="namespaceIBAMR.html#a62309df2b45664a6805692d7ed20e3a9">PressureProjectionType</a> projection_type=<a class="el" href="namespaceIBAMR.html#a62309df2b45664a6805692d7ed20e3a9a9c4964d505893bc3fa1c1d50cb4edd9b">CONSISTENT_PROJECTION</a>, <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aeda305fe47cf0aa2699cff49769fe49e">VolumetricEnergyDerivativeFcn</a> d2U_dJ2_fcn=nullptr, unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="separator:a2a4a3651cef38c65b761cbbe43a2a8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d7ddb594b68ac84410f85919e6980a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a50d7ddb594b68ac84410f85919e6980a">partHasPressure</a> (unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="separator:a50d7ddb594b68ac84410f85919e6980a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae155fd7b769e6b4e3abd5df93e3b1bfc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#ae155fd7b769e6b4e3abd5df93e3b1bfc">initializeFEEquationSystems</a> ()</td></tr>
<tr class="separator:ae155fd7b769e6b4e3abd5df93e3b1bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f06e81bec3bc4f9cb5faaea0a5f76cf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a7f06e81bec3bc4f9cb5faaea0a5f76cf">initializeFEData</a> ()</td></tr>
<tr class="separator:a7f06e81bec3bc4f9cb5faaea0a5f76cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5356c7d2ef6e07b10f843334841652de"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a5356c7d2ef6e07b10f843334841652de">reinitializeFEData</a> ()</td></tr>
<tr class="separator:a5356c7d2ef6e07b10f843334841652de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d85468b535a473316d2f86bd47aafa5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a2d85468b535a473316d2f86bd47aafa5">writeFEDataToRestartFile</a> (const std::string &amp;restart_dump_dirname, unsigned <a class="el" href="classint.html">int</a> time_step_number)</td></tr>
<tr class="separator:a2d85468b535a473316d2f86bd47aafa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98445ef8b9ff1d190847323663f6a27"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#ab98445ef8b9ff1d190847323663f6a27">registerIBHierarchyIntegrator</a> (<a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html">IBHierarchyIntegrator</a> *ib_solver)</td></tr>
<tr class="separator:ab98445ef8b9ff1d190847323663f6a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec18a1b78a640c600e80aec1059418b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#aec18a1b78a640c600e80aec1059418b8">registerEulerianCommunicationAlgorithms</a> ()</td></tr>
<tr class="separator:aec18a1b78a640c600e80aec1059418b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0bace52c4d76fd7fe2ca073734a50d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a7c0bace52c4d76fd7fe2ca073734a50d">setUseFixedLEOperators</a> (<a class="el" href="classbool.html">bool</a> use_fixed_coupling_ops=true)</td></tr>
<tr class="separator:a7c0bace52c4d76fd7fe2ca073734a50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14fe8b8584832721a1c0017e5b8443b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#ad14fe8b8584832721a1c0017e5b8443b">updateFixedLEOperators</a> ()</td></tr>
<tr class="separator:ad14fe8b8584832721a1c0017e5b8443b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac269b2985aa6a7c55c5ff015c5e337eb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#ac269b2985aa6a7c55c5ff015c5e337eb">interpolatePressure</a> (<a class="el" href="classint.html">int</a> p_data_idx, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;p_synch_scheds, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;p_ghost_fill_scheds, <a class="el" href="classdouble.html">double</a> data_time)</td></tr>
<tr class="separator:ac269b2985aa6a7c55c5ff015c5e337eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d056e5284c58ba29315433c45154d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#ad1d056e5284c58ba29315433c45154d3">preprocessSolveFluidEquations</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time, <a class="el" href="classint.html">int</a> cycle_num)</td></tr>
<tr class="separator:ad1d056e5284c58ba29315433c45154d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6165a233879d675b6782790e6f4c05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#abc6165a233879d675b6782790e6f4c05">postprocessSolveFluidEquations</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time, <a class="el" href="classint.html">int</a> cycle_num)</td></tr>
<tr class="separator:abc6165a233879d675b6782790e6f4c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb319577288b037592afe728e29258e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#aedb319577288b037592afe728e29258e">postprocessData</a> ()</td></tr>
<tr class="separator:aedb319577288b037592afe728e29258e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e996bc402231206232370c2e442c64"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a41e996bc402231206232370c2e442c64">registerLoadBalancer</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalancer.html">SAMRAI::mesh::LoadBalancer</a>&lt; NDIM &gt; &gt; load_balancer, <a class="el" href="classint.html">int</a> workload_data_idx)</td></tr>
<tr class="separator:a41e996bc402231206232370c2e442c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f31cfe38a0690a629fcbeb7ad89888"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#af8f31cfe38a0690a629fcbeb7ad89888">initializeLevelData</a> (const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> level_number, const <a class="el" href="classdouble.html">double</a> init_data_time, const <a class="el" href="classbool.html">bool</a> can_be_refined, const <a class="el" href="classbool.html">bool</a> initial_time, const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; old_level=tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt;(NULL), const <a class="el" href="classbool.html">bool</a> allocate_data=true)=0</td></tr>
<tr class="separator:af8f31cfe38a0690a629fcbeb7ad89888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8d89482d4bdafc824307cc21c728c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a6f8d89482d4bdafc824307cc21c728c9">resetHierarchyConfiguration</a> (const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> coarsest_level, const <a class="el" href="classint.html">int</a> finest_level)=0</td></tr>
<tr class="separator:a6f8d89482d4bdafc824307cc21c728c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac201b9cd28087aa92f9c1370f147667a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#ac201b9cd28087aa92f9c1370f147667a">applyGradientDetector</a> (const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> level_number, const <a class="el" href="classdouble.html">double</a> error_data_time, const <a class="el" href="classint.html">int</a> tag_index, const <a class="el" href="classbool.html">bool</a> initial_time, const <a class="el" href="classbool.html">bool</a> uses_richardson_extrapolation_too)</td></tr>
<tr class="separator:ac201b9cd28087aa92f9c1370f147667a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5263bfe8622e41d1a2df35f9803a5ca1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a5263bfe8622e41d1a2df35f9803a5ca1">getLevelDt</a> (const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level, const <a class="el" href="classdouble.html">double</a> dt_time, const <a class="el" href="classbool.html">bool</a> initial_time)</td></tr>
<tr class="separator:a5263bfe8622e41d1a2df35f9803a5ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e8a35a6b5ab6ec7e14f040e718adf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a9e4e8a35a6b5ab6ec7e14f040e718adf">advanceLevel</a> (const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level, const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classdouble.html">double</a> current_time, const <a class="el" href="classdouble.html">double</a> new_time, const <a class="el" href="classbool.html">bool</a> first_step, const <a class="el" href="classbool.html">bool</a> last_step, const <a class="el" href="classbool.html">bool</a> regrid_advance=false)</td></tr>
<tr class="separator:a9e4e8a35a6b5ab6ec7e14f040e718adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97641642baa1b5c67749fada52b12341"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a97641642baa1b5c67749fada52b12341">resetTimeDependentData</a> (const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level, const <a class="el" href="classdouble.html">double</a> new_time, const <a class="el" href="classbool.html">bool</a> can_be_refined)</td></tr>
<tr class="separator:a97641642baa1b5c67749fada52b12341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f563618437d3a5231d35eb6937fcd1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#af6f563618437d3a5231d35eb6937fcd1">resetDataToPreadvanceState</a> (const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level)</td></tr>
<tr class="separator:af6f563618437d3a5231d35eb6937fcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e5b7b5d98eaf7221b5088b0d12a2a8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a81e5b7b5d98eaf7221b5088b0d12a2a8">applyRichardsonExtrapolation</a> (const tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; level, const <a class="el" href="classdouble.html">double</a> error_data_time, const <a class="el" href="classint.html">int</a> tag_index, const <a class="el" href="classdouble.html">double</a> deltat, const <a class="el" href="classint.html">int</a> error_coarsen_ratio, const <a class="el" href="classbool.html">bool</a> initial_time, const <a class="el" href="classbool.html">bool</a> uses_gradient_detector_too)</td></tr>
<tr class="separator:a81e5b7b5d98eaf7221b5088b0d12a2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3ec75cca71a27c6599a48ac6cd37ea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a9e3ec75cca71a27c6599a48ac6cd37ea">coarsenDataForRichardsonExtrapolation</a> (const tbox::Pointer&lt; hier::PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> level_number, const tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; coarser_level, const <a class="el" href="classdouble.html">double</a> coarsen_data_time, const <a class="el" href="classbool.html">bool</a> before_advance)</td></tr>
<tr class="separator:a9e3ec75cca71a27c6599a48ac6cd37ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:afcb64a0ec7ff2fe5daf3f9a25b5d1a1f"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#afcb64a0ec7ff2fe5daf3f9a25b5d1a1f">SOURCE_SYSTEM_NAME</a></td></tr>
<tr class="separator:afcb64a0ec7ff2fe5daf3f9a25b5d1a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a8b50c601d72471b975714c26b0420"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a94a8b50c601d72471b975714c26b0420">COORDS_SYSTEM_NAME</a></td></tr>
<tr class="separator:a94a8b50c601d72471b975714c26b0420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83bca3983fbb85eb52c466f4af4b3cf"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#af83bca3983fbb85eb52c466f4af4b3cf">COORD_MAPPING_SYSTEM_NAME</a></td></tr>
<tr class="separator:af83bca3983fbb85eb52c466f4af4b3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d73bec1cb016396b79a7fdffbdf2480"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a0d73bec1cb016396b79a7fdffbdf2480">FORCE_SYSTEM_NAME</a></td></tr>
<tr class="separator:a0d73bec1cb016396b79a7fdffbdf2480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247dfe4fc17cfaa19a9ff2ab9cb1f187"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a247dfe4fc17cfaa19a9ff2ab9cb1f187">PRESSURE_SYSTEM_NAME</a></td></tr>
<tr class="separator:a247dfe4fc17cfaa19a9ff2ab9cb1f187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb7feb349b6d4ffa42aac3badce66a2"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#abbb7feb349b6d4ffa42aac3badce66a2">VELOCITY_SYSTEM_NAME</a></td></tr>
<tr class="separator:abbb7feb349b6d4ffa42aac3badce66a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3827116ee9e47c50e65c17104e4cb145"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a3827116ee9e47c50e65c17104e4cb145">doInitializeFEEquationSystems</a> () override</td></tr>
<tr class="separator:a3827116ee9e47c50e65c17104e4cb145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f207371be2997586424ff392cb1aa1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a0f207371be2997586424ff392cb1aa1c">doInitializeFESystemVectors</a> () override</td></tr>
<tr class="separator:a0f207371be2997586424ff392cb1aa1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb98f3ce7d42f41d32c2daf6c35f1c88"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#adb98f3ce7d42f41d32c2daf6c35f1c88">doInitializeFEData</a> (<a class="el" href="classbool.html">bool</a> use_present_data) override</td></tr>
<tr class="separator:adb98f3ce7d42f41d32c2daf6c35f1c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f7249277522ae1fb237026b6bafbc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ad5f7249277522ae1fb237026b6bafbc3">computeStressNormalization</a> (<a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;P_vec, <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_vec, <a class="el" href="classdouble.html">double</a> data_time, unsigned <a class="el" href="classint.html">int</a> part)</td></tr>
<tr class="memdesc:ad5f7249277522ae1fb237026b6bafbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the stress normalization field.  <a href="classIBAMR_1_1IBFEMethod.html#ad5f7249277522ae1fb237026b6bafbc3">More...</a><br /></td></tr>
<tr class="separator:ad5f7249277522ae1fb237026b6bafbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9855d31db62b5372486bf2db1c9812"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a6a9855d31db62b5372486bf2db1c9812">spreadTransmissionForceDensity</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_ghost_vec, <a class="el" href="classdouble.html">double</a> data_time, unsigned <a class="el" href="classint.html">int</a> part)</td></tr>
<tr class="memdesc:a6a9855d31db62b5372486bf2db1c9812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spread the transmission force density along the physical boundary of the Lagrangian structure.  <a href="classIBAMR_1_1IBFEMethod.html#a6a9855d31db62b5372486bf2db1c9812">More...</a><br /></td></tr>
<tr class="separator:a6a9855d31db62b5372486bf2db1c9812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b21ebfb951f37d4c927785db0b64ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#af6b21ebfb951f37d4c927785db0b64ab">imposeJumpConditions</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F_ghost_vec, <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_ghost_vec, <a class="el" href="classdouble.html">double</a> data_time, unsigned <a class="el" href="classint.html">int</a> part)</td></tr>
<tr class="memdesc:af6b21ebfb951f37d4c927785db0b64ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose jump conditions determined from the interior and transmission force densities along the physical boundary of the Lagrangian structure.  <a href="classIBAMR_1_1IBFEMethod.html#af6b21ebfb951f37d4c927785db0b64ab">More...</a><br /></td></tr>
<tr class="separator:af6b21ebfb951f37d4c927785db0b64ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0657212e71dffd646ca626bcd27b628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#aa0657212e71dffd646ca626bcd27b628">getCoarsestPatchLevelNumber</a> () const</td></tr>
<tr class="separator:aa0657212e71dffd646ca626bcd27b628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0485d2574dc145caee6e10d6437d6869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a0485d2574dc145caee6e10d6437d6869">getFinestPatchLevelNumber</a> () const</td></tr>
<tr class="separator:a0485d2574dc145caee6e10d6437d6869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76927ac238c5f10110801e0949d6444e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a76927ac238c5f10110801e0949d6444e">getProlongationSchedule</a> (<a class="el" href="classint.html">int</a> level_number, <a class="el" href="classint.html">int</a> coarse_data_idx, <a class="el" href="classint.html">int</a> fine_data_idx)</td></tr>
<tr class="separator:a76927ac238c5f10110801e0949d6444e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c06b9300d48ddccef246ff043b94bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a11c06b9300d48ddccef246ff043b94bc">computeStaticPressure</a> (<a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;P_vec, <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_vec, <a class="el" href="classdouble.html">double</a> data_time, unsigned <a class="el" href="classint.html">int</a> part)</td></tr>
<tr class="memdesc:a11c06b9300d48ddccef246ff043b94bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the static pressure field.  <a href="classIBAMR_1_1FEMechanicsBase.html#a11c06b9300d48ddccef246ff043b94bc">More...</a><br /></td></tr>
<tr class="separator:a11c06b9300d48ddccef246ff043b94bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86e47012e4d7a442e6299b169b40107"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#ac86e47012e4d7a442e6299b169b40107">computeDynamicPressureRateOfChange</a> (<a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;dP_dt_vec, <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_vec, <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;U_vec, <a class="el" href="classdouble.html">double</a> data_time, unsigned <a class="el" href="classint.html">int</a> part)</td></tr>
<tr class="memdesc:ac86e47012e4d7a442e6299b169b40107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dynamic pressure time rate of change.  <a href="classIBAMR_1_1FEMechanicsBase.html#ac86e47012e4d7a442e6299b169b40107">More...</a><br /></td></tr>
<tr class="separator:ac86e47012e4d7a442e6299b169b40107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b28b5a38bc1ad1e56719f7ce3a0bf5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a41b28b5a38bc1ad1e56719f7ce3a0bf5">assembleInteriorForceDensityRHS</a> (<a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F_rhs_vec, <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_vec, <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *P_vec, <a class="el" href="classdouble.html">double</a> data_time, unsigned <a class="el" href="classint.html">int</a> part)</td></tr>
<tr class="separator:a41b28b5a38bc1ad1e56719f7ce3a0bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212f20bcd9adf419e84a78bb43796e62"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a212f20bcd9adf419e84a78bb43796e62">initializeCoordinates</a> (unsigned <a class="el" href="classint.html">int</a> part)</td></tr>
<tr class="separator:a212f20bcd9adf419e84a78bb43796e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1aac515040cc4b3ec8a3136190f3f9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a3f1aac515040cc4b3ec8a3136190f3f9">updateCoordinateMapping</a> (unsigned <a class="el" href="classint.html">int</a> part)</td></tr>
<tr class="separator:a3f1aac515040cc4b3ec8a3136190f3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd0f67d11edf17c6375334200afbb28"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a1cd0f67d11edf17c6375334200afbb28">initializeVelocity</a> (unsigned <a class="el" href="classint.html">int</a> part)</td></tr>
<tr class="separator:a1cd0f67d11edf17c6375334200afbb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f224564ea5405ff8ce12b7272d70e5"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a73f224564ea5405ff8ce12b7272d70e5">getLibMeshRestartFileName</a> (const std::string &amp;restart_dump_dirname, unsigned <a class="el" href="classint.html">int</a> time_step_number, unsigned <a class="el" href="classint.html">int</a> part, const std::string &amp;extension) const</td></tr>
<tr class="separator:a73f224564ea5405ff8ce12b7272d70e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8528c130bfe5261e668c29e79d70f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBAMR_1_1INSHierarchyIntegrator.html">INSHierarchyIntegrator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#aaf8528c130bfe5261e668c29e79d70f8">getINSHierarchyIntegrator</a> () const</td></tr>
<tr class="separator:aaf8528c130bfe5261e668c29e79d70f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93b6eb627f166c20aaae098ccd50865"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsReal.html">SAMRAI::math::HierarchyDataOpsReal</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#ad93b6eb627f166c20aaae098ccd50865">getVelocityHierarchyDataOps</a> () const</td></tr>
<tr class="separator:ad93b6eb627f166c20aaae098ccd50865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142514561f6e1ad3fc61751baafd1627"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsReal.html">SAMRAI::math::HierarchyDataOpsReal</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a142514561f6e1ad3fc61751baafd1627">getPressureHierarchyDataOps</a> () const</td></tr>
<tr class="separator:a142514561f6e1ad3fc61751baafd1627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4042917a2e54b8829948cb09f10e793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1HierarchyMathOps.html">IBTK::HierarchyMathOps</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#ad4042917a2e54b8829948cb09f10e793">getHierarchyMathOps</a> () const</td></tr>
<tr class="separator:ad4042917a2e54b8829948cb09f10e793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb81b46bc281abe474cfad82551e176b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#acb81b46bc281abe474cfad82551e176b">registerVariable</a> (<a class="el" href="classint.html">int</a> &amp;current_idx, <a class="el" href="classint.html">int</a> &amp;new_idx, <a class="el" href="classint.html">int</a> &amp;scratch_idx, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a>&lt; NDIM &gt; &gt; variable, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;scratch_ghosts=<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt;(0), const std::string &amp;coarsen_name=&quot;NO_COARSEN&quot;, const std::string &amp;refine_name=&quot;NO_REFINE&quot;, SAMRAI::tbox::Pointer&lt; <a class="el" href="classIBTK_1_1CartGridFunction.html">IBTK::CartGridFunction</a> &gt; init_fcn=nullptr, const <a class="el" href="classbool.html">bool</a> register_for_restart=true)</td></tr>
<tr class="separator:acb81b46bc281abe474cfad82551e176b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade8a368e03183d51d470c8d98c3c742"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#aade8a368e03183d51d470c8d98c3c742">registerVariable</a> (<a class="el" href="classint.html">int</a> &amp;idx, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a>&lt; NDIM &gt; &gt; variable, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;ghosts=<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt;(0), <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">SAMRAI::hier::VariableContext</a> &gt; ctx=<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">SAMRAI::hier::VariableContext</a> &gt;(nullptr), const <a class="el" href="classbool.html">bool</a> register_for_restart=true)</td></tr>
<tr class="separator:aade8a368e03183d51d470c8d98c3c742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff41aa031a85b31866aa1bd7c832cb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a6ff41aa031a85b31866aa1bd7c832cb9">registerGhostfillRefineAlgorithm</a> (const std::string &amp;name, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; NDIM &gt; &gt; ghostfill_alg, std::unique_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a>&lt; NDIM &gt; &gt; ghostfill_patch_strategy=nullptr)</td></tr>
<tr class="separator:a6ff41aa031a85b31866aa1bd7c832cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765846726a9e33a0b31e0549b699515f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a765846726a9e33a0b31e0549b699515f">registerProlongRefineAlgorithm</a> (const std::string &amp;name, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; NDIM &gt; &gt; prolong_alg, std::unique_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a>&lt; NDIM &gt; &gt; prolong_patch_strategy=nullptr)</td></tr>
<tr class="separator:a765846726a9e33a0b31e0549b699515f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4217ccceea177b4109b528a85c383a2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a4217ccceea177b4109b528a85c383a2b">registerCoarsenAlgorithm</a> (const std::string &amp;name, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html">SAMRAI::xfer::CoarsenAlgorithm</a>&lt; NDIM &gt; &gt; coarsen_alg, std::unique_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html">SAMRAI::xfer::CoarsenPatchStrategy</a>&lt; NDIM &gt; &gt; coarsen_patch_strategy=nullptr)</td></tr>
<tr class="separator:a4217ccceea177b4109b528a85c383a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b456e15f5214d3bfe529372ad346c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a08b456e15f5214d3bfe529372ad346c6">getGhostfillRefineAlgorithm</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:a08b456e15f5214d3bfe529372ad346c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1cd6f821e6a0e6a82c2a91577fa331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#aac1cd6f821e6a0e6a82c2a91577fa331">getProlongRefineAlgorithm</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:aac1cd6f821e6a0e6a82c2a91577fa331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed62275cf737a96421674efa382cde2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html">SAMRAI::xfer::CoarsenAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a1ed62275cf737a96421674efa382cde2">getCoarsenAlgorithm</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:a1ed62275cf737a96421674efa382cde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ca1b192c934db6db9cc266ff5fc1f0"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#ac9ca1b192c934db6db9cc266ff5fc1f0">getGhostfillRefineSchedules</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:ac9ca1b192c934db6db9cc266ff5fc1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4567af6f8f85c8fc935e3cf90933710"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#ac4567af6f8f85c8fc935e3cf90933710">getProlongRefineSchedules</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:ac4567af6f8f85c8fc935e3cf90933710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff556dcdcf10f9a7b04d8aae07dd7b6d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#aff556dcdcf10f9a7b04d8aae07dd7b6d">getCoarsenSchedules</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:aff556dcdcf10f9a7b04d8aae07dd7b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a408f40c60a8b93e2a8968e857ece4df8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a408f40c60a8b93e2a8968e857ece4df8">setup_system_vectors</a> (libMesh::EquationSystems *equation_systems, const std::vector&lt; std::string &gt; &amp;system_names, const std::vector&lt; std::string &gt; &amp;vector_names)</td></tr>
<tr class="separator:a408f40c60a8b93e2a8968e857ece4df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90281c5dbea5a8ff9e1a63bd08844961"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a90281c5dbea5a8ff9e1a63bd08844961">setup_system_vector</a> (libMesh::System &amp;system, const std::string &amp;vector_name)</td></tr>
<tr class="separator:a90281c5dbea5a8ff9e1a63bd08844961"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a70902840be3aa61d3797138d819a6f33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a70902840be3aa61d3797138d819a6f33">d_fe_data_manager_db</a></td></tr>
<tr class="separator:a70902840be3aa61d3797138d819a6f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af475cd16c825edddad3d0d5abd6b7829"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#af475cd16c825edddad3d0d5abd6b7829">d_source_system_name</a></td></tr>
<tr class="memdesc:af475cd16c825edddad3d0d5abd6b7829"><td class="mdescLeft">&#160;</td><td class="mdescRight">System names for key variables.  <a href="classIBAMR_1_1IBFEMethod.html#af475cd16c825edddad3d0d5abd6b7829">More...</a><br /></td></tr>
<tr class="separator:af475cd16c825edddad3d0d5abd6b7829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4928a9db1ed48208ec0878c7332a91e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a4928a9db1ed48208ec0878c7332a91e8">d_skip_initial_workload_log</a> = false</td></tr>
<tr class="separator:a4928a9db1ed48208ec0878c7332a91e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfc661159c028247f8e0628e108af24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#abcfc661159c028247f8e0628e108af24">d_started_time_integration</a> = false</td></tr>
<tr class="separator:abcfc661159c028247f8e0628e108af24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f3fd3541f49dc16f44c71ed6091273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a19f3fd3541f49dc16f44c71ed6091273">d_use_scratch_hierarchy</a> = false</td></tr>
<tr class="separator:a19f3fd3541f49dc16f44c71ed6091273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13aa22a9be802d10049f67d40e59e66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ad13aa22a9be802d10049f67d40e59e66">d_hierarchy</a></td></tr>
<tr class="separator:ad13aa22a9be802d10049f67d40e59e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f9ba56e0f7484585f99b73a3e0c6c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#af5f9ba56e0f7484585f99b73a3e0c6c9">d_gridding_alg</a></td></tr>
<tr class="separator:af5f9ba56e0f7484585f99b73a3e0c6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27eee58496ffcb52a02bfd8dbbdd1642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a27eee58496ffcb52a02bfd8dbbdd1642">d_is_initialized</a> = false</td></tr>
<tr class="separator:a27eee58496ffcb52a02bfd8dbbdd1642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7815e089eae935d5ac862b1b585cfb33"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classIBTK_1_1SAMRAIDataCache.html">IBTK::SAMRAIDataCache</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a7815e089eae935d5ac862b1b585cfb33">d_eulerian_data_cache</a></td></tr>
<tr class="separator:a7815e089eae935d5ac862b1b585cfb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832bab3dbef0579511da54df87481a3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a832bab3dbef0579511da54df87481a3f">d_lagrangian_workload_current_idx</a> = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td></tr>
<tr class="separator:a832bab3dbef0579511da54df87481a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb55e6d03dcd724b003e471f1e39a92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a5cb55e6d03dcd724b003e471f1e39a92">d_lagrangian_workload_new_idx</a> = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td></tr>
<tr class="separator:a5cb55e6d03dcd724b003e471f1e39a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcdf661e05dbddefb8c1bfd01165b17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a6fcdf661e05dbddefb8c1bfd01165b17">d_lagrangian_workload_scratch_idx</a> = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td></tr>
<tr class="separator:a6fcdf661e05dbddefb8c1bfd01165b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70e432b42021a9ef9439044eb17712e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ac70e432b42021a9ef9439044eb17712e">d_lagrangian_workload_var</a></td></tr>
<tr class="separator:ac70e432b42021a9ef9439044eb17712e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c6c8d79e57cb3854fdffd05cbf6bf6"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#af5c6c8d79e57cb3854fdffd05cbf6bf6">d_lagrangian_workload_coarsen_type</a> = &quot;CONSERVATIVE_COARSEN&quot;</td></tr>
<tr class="separator:af5c6c8d79e57cb3854fdffd05cbf6bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527d026005223f2972fa80890cd3651c"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a527d026005223f2972fa80890cd3651c">d_lagrangian_workload_refine_type</a> = &quot;CONSERVATIVE_LINEAR_REFINE&quot;</td></tr>
<tr class="separator:a527d026005223f2972fa80890cd3651c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c599bcfcedbc7576e92a07c8fc0bf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a67c599bcfcedbc7576e92a07c8fc0bf9">d_max_level_number</a> = <a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">IBTK::invalid_level_number</a></td></tr>
<tr class="separator:a67c599bcfcedbc7576e92a07c8fc0bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6a07f04dcd6c258e1751b42c04b32f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a2b6a07f04dcd6c258e1751b42c04b32f">d_patch_association_cfl</a> = 0.75</td></tr>
<tr class="separator:a2b6a07f04dcd6c258e1751b42c04b32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1325c6c9e2019537356ca82fb2a3cb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a2a1325c6c9e2019537356ca82fb2a3cb">d_part_is_active</a> { true }</td></tr>
<tr class="separator:a2a1325c6c9e2019537356ca82fb2a3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f651fc2de5a11c9989ad8d40b78123c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIBTK_1_1FEDataManager.html">IBTK::FEDataManager</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a6f651fc2de5a11c9989ad8d40b78123c">d_primary_fe_data_managers</a></td></tr>
<tr class="separator:a6f651fc2de5a11c9989ad8d40b78123c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b641354628b04baf0ab7c0c35cedc7b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIBTK_1_1FEDataManager.html">IBTK::FEDataManager</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a5b641354628b04baf0ab7c0c35cedc7b">d_scratch_fe_data_managers</a></td></tr>
<tr class="separator:a5b641354628b04baf0ab7c0c35cedc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39cffd776f9be31da9c69c786191e6b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIBTK_1_1FEDataManager.html">IBTK::FEDataManager</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ad39cffd776f9be31da9c69c786191e6b">d_active_fe_data_managers</a></td></tr>
<tr class="separator:ad39cffd776f9be31da9c69c786191e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f23e5e904a79c441e8ca88fffe908b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classIBTK_1_1SAMRAIGhostDataAccumulator.html">IBTK::SAMRAIGhostDataAccumulator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a52f23e5e904a79c441e8ca88fffe908b">d_ghost_data_accumulator</a></td></tr>
<tr class="memdesc:a52f23e5e904a79c441e8ca88fffe908b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to object used to accumulate forces during spreading.  <a href="classIBAMR_1_1IBFEMethod.html#a52f23e5e904a79c441e8ca88fffe908b">More...</a><br /></td></tr>
<tr class="separator:a52f23e5e904a79c441e8ca88fffe908b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95090469df737a843f7df48b70eef58"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::pair&lt; <a class="el" href="classint.html">int</a>, std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt; &gt;, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ad95090469df737a843f7df48b70eef58">d_prolongation_schedules</a></td></tr>
<tr class="separator:ad95090469df737a843f7df48b70eef58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1fe0de6f7c9e118b0608ea41834805"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a9c1fe0de6f7c9e118b0608ea41834805">d_ghosts</a> = 0</td></tr>
<tr class="memdesc:a9c1fe0de6f7c9e118b0608ea41834805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum ghost cell width.  <a href="classIBAMR_1_1IBFEMethod.html#a9c1fe0de6f7c9e118b0608ea41834805">More...</a><br /></td></tr>
<tr class="separator:a9c1fe0de6f7c9e118b0608ea41834805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fee7da573eebd030472119b8fcb8ce"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::ExplicitSystem * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a79fee7da573eebd030472119b8fcb8ce">d_Q_systems</a></td></tr>
<tr class="separator:a79fee7da573eebd030472119b8fcb8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74e1788a37827b9d1d664f8bdd283c7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classIBTK_1_1LibMeshSystemVectors.html">IBTK::LibMeshSystemVectors</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#aa74e1788a37827b9d1d664f8bdd283c7">d_Q_vecs</a></td></tr>
<tr class="separator:aa74e1788a37827b9d1d664f8bdd283c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58a540ada9319a90fa16ee265251382"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classIBTK_1_1LibMeshSystemIBVectors.html">IBTK::LibMeshSystemIBVectors</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#af58a540ada9319a90fa16ee265251382">d_X_IB_vecs</a></td></tr>
<tr class="separator:af58a540ada9319a90fa16ee265251382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22421beb05aa334d30438a631ae3944"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classIBTK_1_1LibMeshSystemIBVectors.html">IBTK::LibMeshSystemIBVectors</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ab22421beb05aa334d30438a631ae3944">d_U_IB_vecs</a></td></tr>
<tr class="separator:ab22421beb05aa334d30438a631ae3944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8ecb246892dd0b3f7cae22a06fcf48"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classIBTK_1_1LibMeshSystemIBVectors.html">IBTK::LibMeshSystemIBVectors</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#aed8ecb246892dd0b3f7cae22a06fcf48">d_F_IB_vecs</a></td></tr>
<tr class="separator:aed8ecb246892dd0b3f7cae22a06fcf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4cf94f6e039e50a33712c3e6263674"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classIBTK_1_1LibMeshSystemIBVectors.html">IBTK::LibMeshSystemIBVectors</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#aed4cf94f6e039e50a33712c3e6263674">d_Q_IB_vecs</a></td></tr>
<tr class="separator:aed4cf94f6e039e50a33712c3e6263674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2351db7d18e3f0bab789ee1a895208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">IBTK::FEDataManager::InterpSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a4b2351db7d18e3f0bab789ee1a895208">d_default_interp_spec</a></td></tr>
<tr class="separator:a4b2351db7d18e3f0bab789ee1a895208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d6b308db258730b3bdbe0583fe05de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">IBTK::FEDataManager::SpreadSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a47d6b308db258730b3bdbe0583fe05de">d_default_spread_spec</a></td></tr>
<tr class="separator:a47d6b308db258730b3bdbe0583fe05de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89ccb95c318a52f767a1e65be3b0509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structIBTK_1_1FEDataManager_1_1WorkloadSpec.html">IBTK::FEDataManager::WorkloadSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#aa89ccb95c318a52f767a1e65be3b0509">d_default_workload_spec</a></td></tr>
<tr class="separator:aa89ccb95c318a52f767a1e65be3b0509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d2ff0b4f1a17233bfddbc73fba9add"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structIBTK_1_1FEDataManager_1_1WorkloadSpec.html">IBTK::FEDataManager::WorkloadSpec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ad3d2ff0b4f1a17233bfddbc73fba9add">d_workload_spec</a></td></tr>
<tr class="separator:ad3d2ff0b4f1a17233bfddbc73fba9add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56c3a20e1af0c3c1c09feb46afba78d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">IBTK::FEDataManager::InterpSpec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#aa56c3a20e1af0c3c1c09feb46afba78d">d_interp_spec</a></td></tr>
<tr class="separator:aa56c3a20e1af0c3c1c09feb46afba78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d00cc6c57a09296fe84d972e16ad3d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">IBTK::FEDataManager::SpreadSpec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a47d00cc6c57a09296fe84d972e16ad3d">d_spread_spec</a></td></tr>
<tr class="separator:a47d00cc6c57a09296fe84d972e16ad3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0791dd616691a6c9a69f9ebd03a2cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a0f0791dd616691a6c9a69f9ebd03a2cc">d_split_normal_force</a> = false</td></tr>
<tr class="separator:a0f0791dd616691a6c9a69f9ebd03a2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46270df95673276b2241bdf33591de2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#af46270df95673276b2241bdf33591de2">d_split_tangential_force</a> = false</td></tr>
<tr class="separator:af46270df95673276b2241bdf33591de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edb74126decfd10594c2e78fffc493a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a2edb74126decfd10594c2e78fffc493a">d_use_jump_conditions</a> = false</td></tr>
<tr class="separator:a2edb74126decfd10594c2e78fffc493a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef71f911e3cee9e5e1336229b639c4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a8ef71f911e3cee9e5e1336229b639c4a">d_epsilon</a> = 0.0</td></tr>
<tr class="separator:a8ef71f911e3cee9e5e1336229b639c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51560beee559ef60657eff3625573f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a51560beee559ef60657eff3625573f39">d_has_stress_normalization_parts</a> = false</td></tr>
<tr class="separator:a51560beee559ef60657eff3625573f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81c84ad162c71f755a4be2058c946fb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ab81c84ad162c71f755a4be2058c946fb">d_stress_normalization_part</a></td></tr>
<tr class="separator:ab81c84ad162c71f755a4be2058c946fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48036a31611bbfe97005c541b3dbce69"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBAMR_1_1IBFEDirectForcingKinematics.html">IBAMR::IBFEDirectForcingKinematics</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a48036a31611bbfe97005c541b3dbce69">d_direct_forcing_kinematics_data</a></td></tr>
<tr class="separator:a48036a31611bbfe97005c541b3dbce69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11ad4ff4587cd58b39ff7a018b21571"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ad11ad4ff4587cd58b39ff7a018b21571">d_has_lag_body_source_parts</a> = false</td></tr>
<tr class="separator:ad11ad4ff4587cd58b39ff7a018b21571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686d58ab1dae79397c57166c1292829e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a686d58ab1dae79397c57166c1292829e">d_lag_body_source_part</a></td></tr>
<tr class="separator:a686d58ab1dae79397c57166c1292829e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c43be477e9a577ee51edcdc572e197"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structIBAMR_1_1IBFEMethod_1_1LagBodySourceFcnData.html">LagBodySourceFcnData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a07c43be477e9a577ee51edcdc572e197">d_lag_body_source_fcn_data</a></td></tr>
<tr class="separator:a07c43be477e9a577ee51edcdc572e197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2499e4dd50b618cd731f436bb945cd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classIBTK_1_1SecondaryHierarchy.html">IBTK::SecondaryHierarchy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a6c2499e4dd50b618cd731f436bb945cd">d_secondary_hierarchy</a></td></tr>
<tr class="separator:a6c2499e4dd50b618cd731f436bb945cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4522824af486b0b40fcb2943f859c24c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a4522824af486b0b40fcb2943f859c24c">d_multistep_n_previous_steps</a> = 0</td></tr>
<tr class="separator:a4522824af486b0b40fcb2943f859c24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35bf9fa7f88035a1aec714f478137a0"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#ad35bf9fa7f88035a1aec714f478137a0">d_dt_old</a></td></tr>
<tr class="separator:ad35bf9fa7f88035a1aec714f478137a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1716ee970c4af06c105a6c5738fd3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a2f1716ee970c4af06c105a6c5738fd3c">d_fe_projector_db</a></td></tr>
<tr class="separator:a2f1716ee970c4af06c105a6c5738fd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7498fcf3ccb999ebdac344214f5598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a5e7498fcf3ccb999ebdac344214f5598">d_do_log</a> = false</td></tr>
<tr class="separator:a5e7498fcf3ccb999ebdac344214f5598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7dcd81d3fbe901e4a469ef1dfeec48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aea7dcd81d3fbe901e4a469ef1dfeec48">d_current_time</a> = std::numeric_limits&lt;<a class="el" href="classdouble.html">double</a>&gt;::quiet_NaN()</td></tr>
<tr class="separator:aea7dcd81d3fbe901e4a469ef1dfeec48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acbd009bb11b810d3bccb0b9b8771f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a7acbd009bb11b810d3bccb0b9b8771f4">d_new_time</a> = std::numeric_limits&lt;<a class="el" href="classdouble.html">double</a>&gt;::quiet_NaN()</td></tr>
<tr class="separator:a7acbd009bb11b810d3bccb0b9b8771f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d3cb85fb0c81198639bbc23a0b94f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a26d3cb85fb0c81198639bbc23a0b94f9">d_half_time</a> = std::numeric_limits&lt;<a class="el" href="classdouble.html">double</a>&gt;::quiet_NaN()</td></tr>
<tr class="separator:a26d3cb85fb0c81198639bbc23a0b94f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8617acdb69b7e0906ee2bb2b3c20886d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::MeshBase * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a8617acdb69b7e0906ee2bb2b3c20886d">d_meshes</a></td></tr>
<tr class="separator:a8617acdb69b7e0906ee2bb2b3c20886d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cd8f9c422d5bb5004b61a2d061f22b"><td class="memItemLeft" align="right" valign="top">libMesh::CouplingMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#ad3cd8f9c422d5bb5004b61a2d061f22b">d_diagonal_system_coupling</a></td></tr>
<tr class="separator:ad3cd8f9c422d5bb5004b61a2d061f22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2faf21a6f31d637fe78eb03df7388b1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; libMesh::EquationSystems &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aa2faf21a6f31d637fe78eb03df7388b1">d_equation_systems</a></td></tr>
<tr class="separator:aa2faf21a6f31d637fe78eb03df7388b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e536dad25c20a5cbdf9ca71192210f"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#ac9e536dad25c20a5cbdf9ca71192210f">d_current_coordinates_system_name</a></td></tr>
<tr class="memdesc:ac9e536dad25c20a5cbdf9ca71192210f"><td class="mdescLeft">&#160;</td><td class="mdescRight">System names for key variables.  <a href="classIBAMR_1_1FEMechanicsBase.html#ac9e536dad25c20a5cbdf9ca71192210f">More...</a><br /></td></tr>
<tr class="separator:ac9e536dad25c20a5cbdf9ca71192210f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b1143941fdacf51a19b39d978744d7"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a79b1143941fdacf51a19b39d978744d7">d_displacement_system_name</a></td></tr>
<tr class="separator:a79b1143941fdacf51a19b39d978744d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072def49b4a83ac732b8d9ab482ecfd4"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a072def49b4a83ac732b8d9ab482ecfd4">d_force_system_name</a></td></tr>
<tr class="separator:a072def49b4a83ac732b8d9ab482ecfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d84f03f21e8404377d35a1bcd374b20"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a3d84f03f21e8404377d35a1bcd374b20">d_pressure_system_name</a></td></tr>
<tr class="separator:a3d84f03f21e8404377d35a1bcd374b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edad6dbc9a4f0b43e9126c3901df6f2"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a2edad6dbc9a4f0b43e9126c3901df6f2">d_velocity_system_name</a></td></tr>
<tr class="separator:a2edad6dbc9a4f0b43e9126c3901df6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627864dfae227b6ad8e0d43bd4a2ee49"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classIBTK_1_1FEData.html">IBTK::FEData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a627864dfae227b6ad8e0d43bd4a2ee49">d_fe_data</a></td></tr>
<tr class="memdesc:a627864dfae227b6ad8e0d43bd4a2ee49"><td class="mdescLeft">&#160;</td><td class="mdescRight">FEData objects provide key FE data management.  <a href="classIBAMR_1_1FEMechanicsBase.html#a627864dfae227b6ad8e0d43bd4a2ee49">More...</a><br /></td></tr>
<tr class="separator:a627864dfae227b6ad8e0d43bd4a2ee49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9fad4f4b4267bbfe55b920b4c07e0f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classIBTK_1_1FEProjector.html">IBTK::FEProjector</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#abf9fad4f4b4267bbfe55b920b4c07e0f">d_fe_projectors</a></td></tr>
<tr class="memdesc:abf9fad4f4b4267bbfe55b920b4c07e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">FEProjector objects provide L2 projection functionality.  <a href="classIBAMR_1_1FEMechanicsBase.html#abf9fad4f4b4267bbfe55b920b4c07e0f">More...</a><br /></td></tr>
<tr class="separator:abf9fad4f4b4267bbfe55b920b4c07e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94094a6ff8972a7ff9cbfafccfce904"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::ExplicitSystem * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#ac94094a6ff8972a7ff9cbfafccfce904">d_X_systems</a></td></tr>
<tr class="separator:ac94094a6ff8972a7ff9cbfafccfce904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c1f623ddde5b5935c1d629e15a0c67"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::ExplicitSystem * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#ad0c1f623ddde5b5935c1d629e15a0c67">d_U_systems</a></td></tr>
<tr class="separator:ad0c1f623ddde5b5935c1d629e15a0c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb8428c2ac87a4004499076e8d035ce"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::ExplicitSystem * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a6bb8428c2ac87a4004499076e8d035ce">d_F_systems</a></td></tr>
<tr class="separator:a6bb8428c2ac87a4004499076e8d035ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46e7ebbf381be1b2e82f85da81df600"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::ExplicitSystem * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#ad46e7ebbf381be1b2e82f85da81df600">d_P_systems</a></td></tr>
<tr class="separator:ad46e7ebbf381be1b2e82f85da81df600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd95057168d3fd62470a66278e564e2b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classIBTK_1_1LibMeshSystemVectors.html">IBTK::LibMeshSystemVectors</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#afd95057168d3fd62470a66278e564e2b">d_X_vecs</a></td></tr>
<tr class="separator:afd95057168d3fd62470a66278e564e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61b0b724451de7c82d80aec13151c3b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classIBTK_1_1LibMeshSystemVectors.html">IBTK::LibMeshSystemVectors</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#af61b0b724451de7c82d80aec13151c3b">d_U_vecs</a></td></tr>
<tr class="separator:af61b0b724451de7c82d80aec13151c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744adde5b22cfd0125ce35c69e8569e9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classIBTK_1_1LibMeshSystemVectors.html">IBTK::LibMeshSystemVectors</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a744adde5b22cfd0125ce35c69e8569e9">d_F_vecs</a></td></tr>
<tr class="separator:a744adde5b22cfd0125ce35c69e8569e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08355808cc8e38538911f7e9752ba17d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classIBTK_1_1LibMeshSystemVectors.html">IBTK::LibMeshSystemVectors</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a08355808cc8e38538911f7e9752ba17d">d_P_vecs</a></td></tr>
<tr class="separator:a08355808cc8e38538911f7e9752ba17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5cabca2acaf985c6693069d6171cb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a5a5cabca2acaf985c6693069d6171cb7">d_fe_equation_systems_initialized</a> = false</td></tr>
<tr class="separator:a5a5cabca2acaf985c6693069d6171cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649b51e103095b44415401d7530467d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a649b51e103095b44415401d7530467d8">d_fe_data_initialized</a> = false</td></tr>
<tr class="separator:a649b51e103095b44415401d7530467d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2503963809669d118078e9c9cc6bd33f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIBAMR.html#ad62923877ca089bebe86fae9330c3807">LibmeshPartitionerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a2503963809669d118078e9c9cc6bd33f">d_libmesh_partitioner_type</a> = <a class="el" href="namespaceIBAMR.html#ad62923877ca089bebe86fae9330c3807a297f1e08f7f28b4772400836c62e9af4">LIBMESH_DEFAULT</a></td></tr>
<tr class="separator:a2503963809669d118078e9c9cc6bd33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43567ca42c8328ec8d63f1610b24aa1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a43567ca42c8328ec8d63f1610b24aa1f">d_libmesh_use_amr</a> = false</td></tr>
<tr class="separator:a43567ca42c8328ec8d63f1610b24aa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6667bc6a5cf02558031104282220f55"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::Order &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#ac6667bc6a5cf02558031104282220f55">d_fe_order_position</a></td></tr>
<tr class="separator:ac6667bc6a5cf02558031104282220f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5a6053d140420f027b2a031ee6777c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::Order &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#adf5a6053d140420f027b2a031ee6777c">d_fe_order_force</a></td></tr>
<tr class="separator:adf5a6053d140420f027b2a031ee6777c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9acc0478130f740019f21f2ae6861e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::Order &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#abc9acc0478130f740019f21f2ae6861e">d_fe_order_pressure</a></td></tr>
<tr class="separator:abc9acc0478130f740019f21f2ae6861e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacba715ba554133101b2cb8626085801"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::FEFamily &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aacba715ba554133101b2cb8626085801">d_fe_family_position</a></td></tr>
<tr class="separator:aacba715ba554133101b2cb8626085801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3d9d8d2bf45e1a95f1a5a133f79850"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::FEFamily &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#abc3d9d8d2bf45e1a95f1a5a133f79850">d_fe_family_force</a></td></tr>
<tr class="separator:abc3d9d8d2bf45e1a95f1a5a133f79850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c72e0ba5f6da3aa245373984ee6a230"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::FEFamily &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a7c72e0ba5f6da3aa245373984ee6a230">d_fe_family_pressure</a></td></tr>
<tr class="separator:a7c72e0ba5f6da3aa245373984ee6a230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad5bb9aba0c86ed05f944ecc352a778"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::QuadratureType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a4ad5bb9aba0c86ed05f944ecc352a778">d_default_quad_type_stress</a></td></tr>
<tr class="separator:a4ad5bb9aba0c86ed05f944ecc352a778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec956bdffab0c544189715b536f811de"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::QuadratureType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aec956bdffab0c544189715b536f811de">d_default_quad_type_force</a></td></tr>
<tr class="separator:aec956bdffab0c544189715b536f811de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f80fe33d70a19af8571a47ac877a10"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::QuadratureType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a16f80fe33d70a19af8571a47ac877a10">d_default_quad_type_pressure</a></td></tr>
<tr class="separator:a16f80fe33d70a19af8571a47ac877a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ead02bbea07b0e7f029d91b8b71df15"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::Order &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a9ead02bbea07b0e7f029d91b8b71df15">d_default_quad_order_stress</a></td></tr>
<tr class="separator:a9ead02bbea07b0e7f029d91b8b71df15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628ca8d48ac4caf6a24224d986784a82"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::Order &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a628ca8d48ac4caf6a24224d986784a82">d_default_quad_order_force</a></td></tr>
<tr class="separator:a628ca8d48ac4caf6a24224d986784a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c93a5f7579e56255dce86c6fc3de0cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::Order &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a6c93a5f7579e56255dce86c6fc3de0cc">d_default_quad_order_pressure</a></td></tr>
<tr class="separator:a6c93a5f7579e56255dce86c6fc3de0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35c42840b1a84d1065334ddb3b6010a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#ae35c42840b1a84d1065334ddb3b6010a">d_use_consistent_mass_matrix</a> = true</td></tr>
<tr class="separator:ae35c42840b1a84d1065334ddb3b6010a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e022ad60a097e6d6125abd9ec032853"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a4e022ad60a097e6d6125abd9ec032853">d_allow_rules_with_negative_weights</a> = true</td></tr>
<tr class="separator:a4e022ad60a097e6d6125abd9ec032853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc4d2ea5fd557b3a9cb0e49fb999f9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#acfc4d2ea5fd557b3a9cb0e49fb999f9b">d_include_normal_stress_in_weak_form</a> = false</td></tr>
<tr class="separator:acfc4d2ea5fd557b3a9cb0e49fb999f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2232db4e50667e0a9199fb692fee10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#ace2232db4e50667e0a9199fb692fee10">d_include_tangential_stress_in_weak_form</a> = false</td></tr>
<tr class="separator:ace2232db4e50667e0a9199fb692fee10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e39e59152a7f6230ef460fdb747921"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a67e39e59152a7f6230ef460fdb747921">d_include_normal_surface_forces_in_weak_form</a> = true</td></tr>
<tr class="separator:a67e39e59152a7f6230ef460fdb747921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45b754515bb10ffde788e19d04b279b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#ae45b754515bb10ffde788e19d04b279b">d_include_tangential_surface_forces_in_weak_form</a> = true</td></tr>
<tr class="separator:ae45b754515bb10ffde788e19d04b279b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8050743623cbfb44ec07706ec46b89"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1CoordinateMappingFcnData.html">CoordinateMappingFcnData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a2a8050743623cbfb44ec07706ec46b89">d_coordinate_mapping_fcn_data</a></td></tr>
<tr class="separator:a2a8050743623cbfb44ec07706ec46b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7c6fc0d3cf3452b7c5909fd6519972"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1InitialVelocityFcnData.html">InitialVelocityFcnData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aac7c6fc0d3cf3452b7c5909fd6519972">d_initial_velocity_fcn_data</a></td></tr>
<tr class="separator:aac7c6fc0d3cf3452b7c5909fd6519972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2119c71b12fea4d6f8fc429acbd6e596"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1PK1StressFcnData.html">PK1StressFcnData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a2119c71b12fea4d6f8fc429acbd6e596">d_PK1_stress_fcn_data</a></td></tr>
<tr class="separator:a2119c71b12fea4d6f8fc429acbd6e596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3ce916ade64b95185668ce212405b9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagBodyForceFcnData.html">LagBodyForceFcnData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#acd3ce916ade64b95185668ce212405b9">d_lag_body_force_fcn_data</a></td></tr>
<tr class="separator:acd3ce916ade64b95185668ce212405b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a44f6ee40db6c0cc1ddfd8cb93b36eb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagSurfacePressureFcnData.html">LagSurfacePressureFcnData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a5a44f6ee40db6c0cc1ddfd8cb93b36eb">d_lag_surface_pressure_fcn_data</a></td></tr>
<tr class="separator:a5a44f6ee40db6c0cc1ddfd8cb93b36eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbe44e107204bc13058a3e06b8d1944"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagSurfaceForceFcnData.html">LagSurfaceForceFcnData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a3fbe44e107204bc13058a3e06b8d1944">d_lag_surface_force_fcn_data</a></td></tr>
<tr class="separator:a3fbe44e107204bc13058a3e06b8d1944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f95bc19d2ffae5f4787f427f8170b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aa4f95bc19d2ffae5f4787f427f8170b8">d_static_pressure_kappa</a> = 0.0</td></tr>
<tr class="separator:aa4f95bc19d2ffae5f4787f427f8170b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939d3d7e33c6b5c803e70d723e7408c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a939d3d7e33c6b5c803e70d723e7408c4">d_static_pressure_stab_param</a> = 0.0</td></tr>
<tr class="separator:a939d3d7e33c6b5c803e70d723e7408c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ff40202d9365ad81274ae9bd4340fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a23ff40202d9365ad81274ae9bd4340fd">d_has_static_pressure_parts</a> = false</td></tr>
<tr class="separator:a23ff40202d9365ad81274ae9bd4340fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4ca8ebfe43db5e54e30a6e666e1f6a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a1b4ca8ebfe43db5e54e30a6e666e1f6a">d_static_pressure_part</a></td></tr>
<tr class="separator:a1b4ca8ebfe43db5e54e30a6e666e1f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ca6f074bec7031ec601d78a6467f6f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceIBAMR.html#a62309df2b45664a6805692d7ed20e3a9">PressureProjectionType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a40ca6f074bec7031ec601d78a6467f6f">d_static_pressure_proj_type</a></td></tr>
<tr class="separator:a40ca6f074bec7031ec601d78a6467f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec84a2b4ee0f0f55242c4bc84b12be2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aeda305fe47cf0aa2699cff49769fe49e">VolumetricEnergyDerivativeFcn</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a1ec84a2b4ee0f0f55242c4bc84b12be2">d_static_pressure_dU_dJ_fcn</a></td></tr>
<tr class="separator:a1ec84a2b4ee0f0f55242c4bc84b12be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aeaa3c6538ec86103a924114e4896c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a0aeaa3c6538ec86103a924114e4896c2">d_dynamic_pressure_kappa</a> = 0.0</td></tr>
<tr class="separator:a0aeaa3c6538ec86103a924114e4896c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816711fb1658133a8942bde4ab9c1d92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a816711fb1658133a8942bde4ab9c1d92">d_dynamic_pressure_stab_param</a> = 0.0</td></tr>
<tr class="separator:a816711fb1658133a8942bde4ab9c1d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ab267bca6e8600e772790da3809902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#ac6ab267bca6e8600e772790da3809902">d_has_dynamic_pressure_parts</a> = false</td></tr>
<tr class="separator:ac6ab267bca6e8600e772790da3809902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9879a265bf94ba77d319fc4b81bd205b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a9879a265bf94ba77d319fc4b81bd205b">d_dynamic_pressure_part</a></td></tr>
<tr class="separator:a9879a265bf94ba77d319fc4b81bd205b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccfecd03b1edcf42f60c3146382f0e4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceIBAMR.html#a62309df2b45664a6805692d7ed20e3a9">PressureProjectionType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a8ccfecd03b1edcf42f60c3146382f0e4">d_dynamic_pressure_proj_type</a></td></tr>
<tr class="separator:a8ccfecd03b1edcf42f60c3146382f0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dc173bf45d43eddf7af4d7cc18da02"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aeda305fe47cf0aa2699cff49769fe49e">VolumetricEnergyDerivativeFcn</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#ac0dc173bf45d43eddf7af4d7cc18da02">d_dynamic_pressure_d2U_dJ2_fcn</a></td></tr>
<tr class="separator:ac0dc173bf45d43eddf7af4d7cc18da02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f586abd18a6284f8ebad0a92bbf1c2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#ac6f586abd18a6284f8ebad0a92bbf1c2">d_object_name</a></td></tr>
<tr class="separator:ac6f586abd18a6284f8ebad0a92bbf1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1f861aa28fc6f0b5249947993e014a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a8b1f861aa28fc6f0b5249947993e014a">d_registered_for_restart</a></td></tr>
<tr class="separator:a8b1f861aa28fc6f0b5249947993e014a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c38f9e1cb13af873206424e70bc9b0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a97c38f9e1cb13af873206424e70bc9b0">d_libmesh_restart_read_dir</a></td></tr>
<tr class="separator:a97c38f9e1cb13af873206424e70bc9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5026673edcae1d5b0185078058c5ccbd"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a5026673edcae1d5b0185078058c5ccbd">d_libmesh_restart_restore_number</a></td></tr>
<tr class="separator:a5026673edcae1d5b0185078058c5ccbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4848c4b2be0cd61c9a4cbe1f36f4a5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a3e4848c4b2be0cd61c9a4cbe1f36f4a5">d_libmesh_restart_file_extension</a></td></tr>
<tr class="separator:a3e4848c4b2be0cd61c9a4cbe1f36f4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b7435788a1ff68e5f6f54496341011"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html">IBHierarchyIntegrator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#aa3b7435788a1ff68e5f6f54496341011">d_ib_solver</a> = nullptr</td></tr>
<tr class="separator:aa3b7435788a1ff68e5f6f54496341011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c7fcd98c652f7e3f4b17e0bc59388d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a56c7fcd98c652f7e3f4b17e0bc59388d">d_use_fixed_coupling_ops</a> = false</td></tr>
<tr class="separator:a56c7fcd98c652f7e3f4b17e0bc59388d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0511ec5c6005d72dea466e84aba05244"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a0511ec5c6005d72dea466e84aba05244">commonConstructor</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; &amp;input_db, <a class="el" href="classint.html">int</a> max_levels)</td></tr>
<tr class="separator:a0511ec5c6005d72dea466e84aba05244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a544ffc1059f511966b5e76fc358cc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a3a544ffc1059f511966b5e76fc358cc3">getFromInput</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; &amp;db, <a class="el" href="classbool.html">bool</a> is_from_restart)</td></tr>
<tr class="separator:a3a544ffc1059f511966b5e76fc358cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3f1d9fe3e21a6faeffe3333cd05a16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a0b3f1d9fe3e21a6faeffe3333cd05a16">getFromRestart</a> ()</td></tr>
<tr class="separator:a0b3f1d9fe3e21a6faeffe3333cd05a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8396a62282c87f72c7abd79a77442b4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#a8396a62282c87f72c7abd79a77442b4e">assertStructureOnFinestLevel</a> () const</td></tr>
<tr class="separator:a8396a62282c87f72c7abd79a77442b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ad590435a995066141c22f5cf2b50b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBFEMethod.html#af1ad590435a995066141c22f5cf2b50b">reinitElementMappings</a> ()</td></tr>
<tr class="separator:af1ad590435a995066141c22f5cf2b50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>By default, the <a class="el" href="namespacelibMesh.html">libMesh</a> data is partitioned once at the beginning of the computation by <a class="el" href="namespacelibMesh.html">libMesh</a>'s default partitioner.</p>
<h2>Options Controlling Interpolation and Spreading</h2>
<p>Like other classes inheriting from <a class="el" href="classIBAMR_1_1IBStrategy.html" title="Class IBStrategy provides a generic interface for specifying the implementation details of a particul...">IBStrategy</a>, most options regarding the actual IB method implementation can be specified with the provided input database. Parameters starting with <code>IB_</code> set and override those with the same name starting with <code>interp_</code> or <code>spread_</code>: e.g., <code>IB_delta_fcn</code> overrides both <code>interp_delta_fcn</code> and <code>spread_delta_fcn</code>. </p><ul>
<li>
<code>interp_quad_type</code>: Quadrature type for interpolation, provided as a string. Can be any quadrature type known to <a class="el" href="namespacelibMesh.html">libMesh</a>. Defaults to <code>"QGAUSS"</code>. </li>
<li>
<code>spread_quad_type</code>: Quadrature type for spreading, provided as a string. Parsed in the same was as <code>interp_quad_type</code>. </li>
<li>
<code>IB_quad_type</code>: overriding alias for the two previous entries - has the same default. </li>
<li>
<code>interp_use_adaptive_quadrature</code>: Whether or not the current deformation of each element should be considered when determining which quadrature rule to use. Defaults to <code>TRUE</code>. </li>
<li>
<code>interp_point_density</code>: Multiplier on the number of points to use for doing IB calculations. Defaults to <code>2</code>. </li>
<li>
<code>spread_point_density</code>: Same as above, but for spreading. </li>
<li>
<code>IB_point_density</code>: overriding alias for the previous entry - has the same default. </li>
<li>
<code>interp_point_density</code>: Parameter for adaptively computing the number of quadrature points in a quadrature rule. Defaults to <code>2.0</code>. See <a class="el" href="namespaceIBTK.html#a492518a5170b5fa7e076f6634a7a935b">IBTK::getQuadratureKey()</a> for a detailed description. </li>
<li>
<code>spread_point_density</code>: Same as above, but for spreading. </li>
<li>
<code>IB_point_density</code>: overriding alias for the two previous entries - has the same default. </li>
<li>
<code>interp_use_consistent_mass_matrix</code>: Whether or not mass lumping should be applied when solving the L2 projection for computing the velocity of the structure. Defaults to FALSE. Note that no linear system is solved when computing forces so this parameter does not have a spreading equivalent. </li>
<li>
<code>use_consistent_mass_matrix</code>: Overriding alias of the previous entry. </li>
<li>
<code>IB_use_consistent_mass_matrix</code>: Overriding alias of the previous entry. </li>
<li>
<code>interp_use_nodal_quadrature</code>: Whether or not nodal quadrature should be used, which is essentially interpolation instead of projection. This is an experimental feature. Defaults to <code>FALSE</code>. </li>
<li>
<code>spread_use_nodal_quadrature</code>: Same as above, but for spreading. </li>
<li>
<code>IB_use_nodal_quadrature</code>: overriding alias for the two previous entries - has the same default. </li>
</ul>
<h2>Options Controlling <a class="el" href="namespacelibMesh.html">libMesh</a> Partitioning</h2>
<p><em>This feature is experimental: at the present time the default settings have the best performance and are the correct choice.</em></p>
<p>This class can repartition <a class="el" href="namespacelibMesh.html">libMesh</a> data in a way that matches <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>'s distribution of patches; put another way, if a certain region of space on the finest level is assigned to processor N, then all <a class="el" href="namespacelibMesh.html">libMesh</a> nodes and elements within that region will also be assigned to processor N. The actual partitioning here is done by the <a class="el" href="classIBTK_1_1BoxPartitioner.html" title="A libMesh partitioner that partitions a mesh based on PartitioningBox objects owned by each processor...">IBTK::BoxPartitioner</a> class. See the discussion in <a class="el" href="classIBTK_1_1HierarchyIntegrator.html" title="Class HierarchyIntegrator provides an abstract interface for a time integrator for a system of equati...">IBTK::HierarchyIntegrator</a> and <a class="el" href="classIBTK_1_1FEDataManager.html" title="Class FEDataManager coordinates data required for Lagrangian-Eulerian interaction between a Lagrangia...">IBTK::FEDataManager</a> for descriptions on how this partitioning is performed.</p>
<p>The choice of <a class="el" href="namespacelibMesh.html">libMesh</a> partitioner depends on the libmesh_partitioner_type parameter in the input database: </p><ul>
<li>
<p class="startli">If <code>libmesh_partitioner_type</code> is <code>LIBMESH_DEFAULT</code> then this class will never repartition <a class="el" href="namespacelibMesh.html">libMesh</a> data, since the default <a class="el" href="namespacelibMesh.html">libMesh</a> partitioner is already used at the beginning of the computation and, since no degrees of freedom are added or removed, any subsequent partitioning would have no effect.</p>
<p class="endli"></p>
</li>
<li>
If <code>libmesh_partitioner_type</code> is <code>SAMRAI_BOX</code> then this class will always repartition the <a class="el" href="namespacelibMesh.html">libMesh</a> data with <a class="el" href="classIBTK_1_1BoxPartitioner.html" title="A libMesh partitioner that partitions a mesh based on PartitioningBox objects owned by each processor...">IBTK::BoxPartitioner</a> every time the Eulerian data is regridded. </li>
</ul>
<p>The default value for <code>libmesh_partitioner_type</code> is <code>LIBMESH_DEFAULT</code>. The intent of these choices is to automatically use the fairest (that is, partitioning based on equal work when computing force densities and L2 projections) partitioner.</p>
<h2>Options Controlling IB Data Partitioning</h2>
<p>The main computational expenses of this class are <a class="el" href="classIBAMR_1_1IBFEMethod.html#a26fd1b2a7066e20b67b9e1a06f529b5b">IBFEMethod::interpolateVelocity()</a> and <a class="el" href="classIBAMR_1_1IBFEMethod.html#a52ad97cfb324cbc9af905fcf0675ebaa">IBFEMethod::spreadForce()</a>. These two methods compute at IB points placed inside the patches owned on the current processor: i.e., they use the Eulerian partitioning of the domain. This partitioning scales very poorly at higher processor counts with some Lagrangian geometries since the Eulerian partitioning places equal number of cells, which do not necessarily coincide with IB points, on different processors: i.e., some processors will have a large number of IB points and some may have zero.</p>
<p>To get around this, this class can optionally work with a different partitioning of the Eulerian data that is partitioned so that each processor has roughly the same number of IB points, or some more elaborate partitioning scheme that takes into account the number of mesh nodes as well. This class will set up this scratch hierarchy and manage its state (see IBFEMethod::d_scratch_hierarchy). The scratch hierarchy can be set up by adding the following parameters to the input database:</p>
<div class="fragment"><div class="line"><a class="code" href="classIBAMR_1_1IBFEMethod.html#ab87c905b3cad88a84e2d1e159999b7b1">IBFEMethod</a> {</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Place whatever database entries you typically use with IBFEMethod here,</span></div>
<div class="line">   <span class="comment">// e.g., define IB_delta_fcn, split_forces, use_consistent_mass_matrix etc.</span></div>
<div class="line">   <span class="comment">// as usual. The parameters listed below solely pertain to the scratch</span></div>
<div class="line">   <span class="comment">// hierarchy.</span></div>
<div class="line"> </div>
<div class="line">   use_scratch_hierarchy = TRUE</div>
<div class="line">   workload_quad_point_weight = 1.0</div>
<div class="line">   workload_duplicated_node_weight = 0.8</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The values supplied here should usually be the same as those provided to</span></div>
<div class="line">   <span class="comment">// the top-level GriddingAlgorithm.</span></div>
<div class="line">   GriddingAlgorithm</div>
<div class="line">   {</div>
<div class="line">       max_levels = MAX_LEVELS</div>
<div class="line">       ratio_to_coarser</div>
<div class="line">       {</div>
<div class="line">           level_1 = REF_RATIO,REF_RATIO</div>
<div class="line">       }</div>
<div class="line"> </div>
<div class="line">       largest_patch_size</div>
<div class="line">       {</div>
<div class="line">           <span class="comment">// We recommend using very large values here: large patches</span></div>
<div class="line">           <span class="comment">// are more efficient, especially with the merging load balancer.</span></div>
<div class="line">           level_0 = 512,512</div>
<div class="line">       }</div>
<div class="line"> </div>
<div class="line">       smallest_patch_size</div>
<div class="line">       {</div>
<div class="line">           <span class="comment">// on the other hand, smaller patch sizes here typically enable</span></div>
<div class="line">           <span class="comment">// better load balancing at the cost of creating more total work</span></div>
<div class="line">           <span class="comment">// due to an increased number of ghost cells (and, therefore,</span></div>
<div class="line">           <span class="comment">// an increased number of elements in more than one patch).</span></div>
<div class="line">           <span class="comment">// We recommend adjusting this number to be as large as possible</span></div>
<div class="line">           <span class="comment">// by examining log output - if higher-rank processors do not have</span></div>
<div class="line">           <span class="comment">// enough work then it should be slightly decreased. 8 x 8 is usually</span></div>
<div class="line">           <span class="comment">// too small, but 16 x 16 is reasonable for many setups.</span></div>
<div class="line">           level_0 = 16, 16</div>
<div class="line">       }</div>
<div class="line"> </div>
<div class="line">       efficiency_tolerance = 0.80e0</div>
<div class="line">       combine_efficiency   = 0.80e0</div>
<div class="line">       coalesce_boxes = TRUE</div>
<div class="line">       allow_patches_smaller_than_minimum_size_to_prevent_overlaps = TRUE</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Smaller workload factors improve load balancing but increase the total</span></div>
<div class="line">   <span class="comment">// amount of work since more elements will end up on multiple patches.</span></div>
<div class="line">   <span class="comment">// This value is a good compromise.</span></div>
<div class="line">   <span class="comment">// Similarly, since intraprocessor patch communication is less of a concern</span></div>
<div class="line">   <span class="comment">// here than in the fluid solver, we recommend using the greedy load</span></div>
<div class="line">   <span class="comment">// balancer bin packing method.</span></div>
<div class="line">   LoadBalancer</div>
<div class="line">   {</div>
<div class="line">      type                = <span class="stringliteral">&quot;MERGING&quot;</span></div>
<div class="line">      bin_pack_method     = <span class="stringliteral">&quot;GREEDY&quot;</span></div>
<div class="line">      max_workload_factor = 0.5</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p>i.e., providing <code>use_scratch_hierarchy = TRUE</code> (the default is <code>FALSE</code>) turns on the scratch hierarchy and the remaining parameters determine how patches are generated and load balanced. The extra argument <code>type</code> to <code>LoadBalancer</code> specifies whether an <a class="el" href="classIBTK_1_1MergingLoadBalancer.html" title="Class MergingLoadBalancer merges the boxes generated by a load balancer in a final step to decrease t...">IBTK::MergingLoadBalancer</a> (chosen by <code>"MERGING"</code>) or the default <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> LoadBalancer (chosen by <code>"DEFAULT"</code>) is used. Since <a class="el" href="classIBTK_1_1MergingLoadBalancer.html" title="Class MergingLoadBalancer merges the boxes generated by a load balancer in a final step to decrease t...">IBTK::MergingLoadBalancer</a> is usually what one wants <code>"MERGING"</code> is the default. The merging option is better since it reduces the total number of elements which end up in patch ghost regions since some patches will be merged together.</p>
<p>The parameter <code>workload_quad_point_weight</code> is the multiplier assigned to an IB point when calculating the work per processor. Similarly, the parameter <code>workload_duplicated_node_weight</code> is the multiplier assigned to each node of every element (i.e., each node is counted more than once): see <a class="el" href="structIBTK_1_1FEDataManager_1_1WorkloadSpec.html" title="Struct WorkloadSpec encapsulates the parameters used to calculate workload estimates (i....">IBTK::FEDataManager::WorkloadSpec</a> for more information.</p>
<p>For efficiency reasons this class only associates elements with patches if they can interact with the patches (e.g., the points used for velocity interpolation can lie inside the patch). Hence, over time, this association needs to change as the structure moves. The frequency of reassociation is controlled by two things: </p><ol>
<li>
The rate at which the hierarchy is regridded, as if the hierarchy itself changes then we must recompute the association. </li>
<li>
The value d_patch_association_cfl, which determines how frequently we regrid purely based on the displacement of the structure. This parameter can be set by providing <code>patch_association_cfl</code> to the input database. </li>
</ol>
<p>If you set IBHierarchyIntegrator::d_regrid_cfl_interval to a value larger than 1 and use AMR this class may not work correctly since, in that case, elements may move outside the patch level they are associated with before new cells are tagged to be on that level.</p>
<h2>Options Controlling Logging</h2>
<p>The logging options set by this class are propagated to the owned <a class="el" href="classIBTK_1_1FEDataManager.html" title="Class FEDataManager coordinates data required for Lagrangian-Eulerian interaction between a Lagrangia...">IBTK::FEDataManager</a> objects. </p><ol>
<li>
<code>enable_logging</code>: set to <code>TRUE</code> to enable logging.. Defaults to <code>false</code>. </li>
<li>
<code>skip_initial_workload_log</code>: For testing purposes (see d_skip_initial_workload_log) it is necessary to disable some output: this option disables logging of workload data (quadrature point counts, etc.) before the first time step if set to <code>TRUE</code>. Defaults to <code>false</code>. </li>
</ol>
<h2>Using <a class="el" href="classIBAMR_1_1IBFEMethod.html" title="Class IBFEMethod is an implementation of the abstract base class IBStrategy that provides functionali...">IBFEMethod</a> with your own <a class="el" href="namespacelibMesh.html">libMesh</a> System objects</h2>
<p>It is often useful to add your own <a class="el" href="namespacelibMesh.html">libMesh</a> data to the EquationSystems object used by <a class="el" href="namespaceIBAMR.html">IBAMR</a> objects. One such example would be defining fields of fibers to give direction to add anisotropy to solid models. Since a <a class="el" href="namespacelibMesh.html">libMesh</a> Mesh object also stores all the degrees of freedom of all the systems, there can only be one EquationSystems object for each Mesh object. If you set up your own systems in this way then they will be automatically saved and loaded from restart data.</p>
<p>Since initialization of this class occurs in multiple stages and <a class="el" href="classIBAMR_1_1IBFEMethod.html" title="Class IBFEMethod is an implementation of the abstract base class IBStrategy that provides functionali...">IBFEMethod</a> assumes that it is ultimately responsible for setting up the EquationSystems object (by calling <code>EquationSystems::init()</code>) other <a class="el" href="namespacelibMesh.html">libMesh</a> Systems must be added in a specific order. Additionally, some parts must only be set up if restart information is not available.</p>
<p>This code is based on an IBFE example and assumes that the <a class="el" href="namespaceIBAMR.html">IBAMR</a> objects objects are already set up in the usual way.</p>
<div class="fragment"><div class="line"><span class="comment">// Actually create the EquationSystems objects.</span></div>
<div class="line">ib_method_ops-&gt;initializeFEEquationSystems();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code assumes we only have one part, so there is only one</span></div>
<div class="line"><span class="comment">// EquationSystems object.</span></div>
<div class="line">libMesh::EquationSystems *equation_systems =</div>
<div class="line">    ib_method_ops-&gt;getFEDataManager()-&gt;getEquationSystems();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> from_restart = RestartManager::getManager()-&gt;isFromRestart();</div>
<div class="line"><span class="comment">// Set up the external System. It is not necessary to create the System</span></div>
<div class="line"><span class="comment">// if restart data is available, since in that case libMesh will create</span></div>
<div class="line"><span class="comment">// the system itself from loaded data.</span></div>
<div class="line"><span class="keywordflow">if</span> (!from_restart)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span>&amp; fiber =</div>
<div class="line">        equation_systems-&gt;add_system&lt;ExplicitSystem&gt;(<span class="stringliteral">&quot;fiber&quot;</span>);</div>
<div class="line">    fiber.add_variable(<span class="stringliteral">&quot;f_0&quot;</span>);</div>
<div class="line">    fiber.add_variable(<span class="stringliteral">&quot;f_1&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// do not call init here - the IBFEMethod object will do that itself</span></div>
<div class="line">    <span class="comment">// later in the call to initializeFEData().</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// do more initialization of IBAMR objects here...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// IBFEMethod::initializeFEData() will initialize all System objects in each</span></div>
<div class="line"><span class="comment">// EquationSystems object: i.e., libMesh will fail with an assertion check if</span></div>
<div class="line"><span class="comment">// you added your own System to that EquationSystems object and initialized it</span></div>
<div class="line"><span class="comment">// it before this point. Since this includes all Systems, i.e., also</span></div>
<div class="line"><span class="comment">// external systems, any data vectors you added to the System will be</span></div>
<div class="line"><span class="comment">// loaded in from the same restart file as the rest of IBAMR&#39;s data.</span></div>
<div class="line">ib_method_ops-&gt;initializeFEData();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// initialize the patch hierarchy, postprocessor, etc. here too, as usual.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Continue configuring the external system. Like before, its not necessary</span></div>
<div class="line"><span class="comment">// to add vectors if restart data is available, since in that case libMesh</span></div>
<div class="line"><span class="comment">// will already know the vectors exist.</span></div>
<div class="line"><span class="keywordflow">if</span> (!from_restart)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span>&amp; fiber =</div>
<div class="line">        equation_systems-&gt;get_system&lt;ExplicitSystem&gt;(<span class="stringliteral">&quot;fiber&quot;</span>);</div>
<div class="line">    fiber.add_vector(<span class="stringliteral">&quot;NF&quot;</span>);</div>
<div class="line">    NumericVector&lt;double&gt; &amp;vec = fiber.get_vector(<span class="stringliteral">&quot;NF&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    vec = 42.0;</div>
<div class="line">    vec.close();</div>
<div class="line">}</div>
<div class="line"><span class="comment">// For testing purposes, lets make sure that on a restarted run we have the</span></div>
<div class="line"><span class="comment">// correct system and vector available:</span></div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span>&amp; fiber =</div>
<div class="line">        equation_systems-&gt;get_system&lt;ExplicitSystem&gt;(<span class="stringliteral">&quot;fiber&quot;</span>);</div>
<div class="line">    <a class="code" href="namespaceSAMRAI_1_1tbox.html#ab84041705493761fb17a8127e3a2dca2">plog</a> &lt;&lt; <span class="stringliteral">&quot;number of variables: &quot;</span> &lt;&lt; fiber.n_vars() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    NumericVector&lt;double&gt; &amp;vec = fiber.get_vector(<span class="stringliteral">&quot;NF&quot;</span>);</div>
<div class="line">    <span class="comment">// This will print the vector to plog: since each entry is 42 we know</span></div>
<div class="line">    <span class="comment">// that the vector was loaded correctly.</span></div>
<div class="line">    vec.print(<a class="code" href="namespaceSAMRAI_1_1tbox.html#ab84041705493761fb17a8127e3a2dca2">plog</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Passing Data to the FEDataManager class</h2>
<p><a class="el" href="classIBAMR_1_1IBFEMethod.html" title="Class IBFEMethod is an implementation of the abstract base class IBStrategy that provides functionali...">IBFEMethod</a> uses <a class="el" href="classIBTK_1_1FEDataManager.html" title="Class FEDataManager coordinates data required for Lagrangian-Eulerian interaction between a Lagrangia...">IBTK::FEDataManager</a> to actually perform IB calculations with the finite element mesh. <a class="el" href="classIBTK_1_1FEDataManager.html" title="Class FEDataManager coordinates data required for Lagrangian-Eulerian interaction between a Lagrangia...">IBTK::FEDataManager</a> objects are configured by setting spreading and interpolation parameters in the usual way (i.e., by providing the parameters described above in the input database). Options specific to the behavior of FEDataManager can be set by defining a database named <code>FEDataManager</code> inside the database provided to this class - see the documentation of FEDataManager for more information.</p>
<h2>Handling Restart Data</h2>
<p>The caching of the IBFE restart data is not managed by <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>'s <a class="el" href="classSAMRAI_1_1tbox_1_1RestartManager.html">SAMRAI::tbox::RestartManager</a>. It is instead handled by <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a2d85468b535a473316d2f86bd47aafa5">FEMechanicsBase::writeFEDataToRestartFile()</a> given a restart_dump_dirname and time_step_number. Each instance of <a class="el" href="classIBAMR_1_1IBFEMethod.html" title="Class IBFEMethod is an implementation of the abstract base class IBStrategy that provides functionali...">IBFEMethod</a> is registered for restart by default, but the this option can be turned off. During a restart, the data is handled by the <a class="el" href="classSAMRAI_1_1tbox_1_1RestartManager.html">SAMRAI::tbox::RestartManager</a> automatically to reinitiate the <a class="el" href="classIBAMR_1_1IBFEMethod.html" title="Class IBFEMethod is an implementation of the abstract base class IBStrategy that provides functionali...">IBFEMethod</a>. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a6516bc3b0fe1cb7cc939f599d6938cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6516bc3b0fe1cb7cc939f599d6938cbf">&#9670;&nbsp;</a></span>LagBodySourceFcnPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIBAMR_1_1IBFEMethod.html#a6516bc3b0fe1cb7cc939f599d6938cbf">IBAMR::IBFEMethod::LagBodySourceFcnPtr</a> =  <a class="el" href="namespaceIBTK.html#a3f04732f2606c4a49ff92ca5b3c514b9">IBTK::ScalarMeshFcnPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef specifying interface for Lagrangian mass source/sink distribution function. </p>

</div>
</div>
<a id="a98dc8aeb4a300f9f33a83c35084ce477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98dc8aeb4a300f9f33a83c35084ce477">&#9670;&nbsp;</a></span>CoordinateMappingFcnPtr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a98dc8aeb4a300f9f33a83c35084ce477">IBAMR::FEMechanicsBase::CoordinateMappingFcnPtr</a> =  void (*)(libMesh::Point&amp; x, const libMesh::Point&amp; X, void* ctx)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef specifying interface for coordinate mapping function. </p>

</div>
</div>
<a id="aaac964e673a98fe643de584a8878a100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac964e673a98fe643de584a8878a100">&#9670;&nbsp;</a></span>InitialVelocityFcnPtr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aaac964e673a98fe643de584a8878a100">IBAMR::FEMechanicsBase::InitialVelocityFcnPtr</a> =  void (*)(<a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; U0, const libMesh::Point&amp; X0, void* ctx)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef specifying interface for initial velocity specification function. </p>

</div>
</div>
<a id="acd3914db70c54c7409c974d1092523fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3914db70c54c7409c974d1092523fd">&#9670;&nbsp;</a></span>PK1StressFcnPtr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#acd3914db70c54c7409c974d1092523fd">IBAMR::FEMechanicsBase::PK1StressFcnPtr</a> =  <a class="el" href="namespaceIBTK.html#a2047e8d6003cdf2c5017d741cad69907">IBTK::TensorMeshFcnPtr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef specifying interface for PK1 stress tensor function. </p>

</div>
</div>
<a id="a80b15d9db97ca4029e8a907b49e7903b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b15d9db97ca4029e8a907b49e7903b">&#9670;&nbsp;</a></span>LagBodyForceFcnPtr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a80b15d9db97ca4029e8a907b49e7903b">IBAMR::FEMechanicsBase::LagBodyForceFcnPtr</a> =  <a class="el" href="namespaceIBTK.html#a503cb21b0cf0bd3e1ed168623b674d8e">IBTK::VectorMeshFcnPtr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef specifying interface for Lagrangian body force distribution function. </p>

</div>
</div>
<a id="a03f12aaeafdc62afba92f41096b775f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f12aaeafdc62afba92f41096b775f1">&#9670;&nbsp;</a></span>LagSurfacePressureFcnPtr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a03f12aaeafdc62afba92f41096b775f1">IBAMR::FEMechanicsBase::LagSurfacePressureFcnPtr</a> =  <a class="el" href="namespaceIBTK.html#a0828e2d557e67a201c8526a7c9b761b0">IBTK::ScalarSurfaceFcnPtr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef specifying interface for Lagrangian pressure force distribution function. </p>

</div>
</div>
<a id="a82a022d74675df32bc5e0b5c4a81d332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a022d74675df32bc5e0b5c4a81d332">&#9670;&nbsp;</a></span>LagSurfaceForceFcnPtr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a82a022d74675df32bc5e0b5c4a81d332">IBAMR::FEMechanicsBase::LagSurfaceForceFcnPtr</a> =  <a class="el" href="namespaceIBTK.html#a45007c53f48bbf752259fcec0884767c">IBTK::VectorSurfaceFcnPtr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef specifying interface for Lagrangian surface force distribution function. </p>

</div>
</div>
<a id="aeda305fe47cf0aa2699cff49769fe49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda305fe47cf0aa2699cff49769fe49e">&#9670;&nbsp;</a></span>VolumetricEnergyDerivativeFcn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aeda305fe47cf0aa2699cff49769fe49e">IBAMR::FEMechanicsBase::VolumetricEnergyDerivativeFcn</a> =  <a class="el" href="classdouble.html">double</a> (*)(<a class="el" href="classdouble.html">double</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function signature for specifying the energy functional that determines the pressure. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1ed9494267dc54802972b735ac05e6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed9494267dc54802972b735ac05e6c4">&#9670;&nbsp;</a></span>IBFEMethod() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IBAMR::IBFEMethod::IBFEMethod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libMesh::MeshBase *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_levels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>register_for_restart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>restart_read_dirname</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>restart_restore_number</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e84d18910a720e1319af00b58def614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e84d18910a720e1319af00b58def614">&#9670;&nbsp;</a></span>IBFEMethod() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IBAMR::IBFEMethod::IBFEMethod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; libMesh::MeshBase * &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_levels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>register_for_restart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>restart_read_dirname</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>restart_restore_number</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab87c905b3cad88a84e2d1e159999b7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87c905b3cad88a84e2d1e159999b7b1">&#9670;&nbsp;</a></span>IBFEMethod() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IBAMR::IBFEMethod::IBFEMethod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0970830b1f97bde9ba7ac1e4305acd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0970830b1f97bde9ba7ac1e4305acd06">&#9670;&nbsp;</a></span>IBFEMethod() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IBAMR::IBFEMethod::IBFEMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIBAMR_1_1IBFEMethod.html">IBFEMethod</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a345284bdac89d5af1297a18b74d29e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345284bdac89d5af1297a18b74d29e8c">&#9670;&nbsp;</a></span>~IBFEMethod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IBAMR::IBFEMethod::~IBFEMethod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="affe3cae033d94492eaed326e973f0e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe3cae033d94492eaed326e973f0e4b">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBAMR_1_1IBFEMethod.html">IBFEMethod</a>&amp; IBAMR::IBFEMethod::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIBAMR_1_1IBFEMethod.html">IBFEMethod</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4809678660681d026b8c13e5c6968397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4809678660681d026b8c13e5c6968397">&#9670;&nbsp;</a></span>getSourceSystemName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; IBAMR::IBFEMethod::getSourceSystemName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the source system name. </p>

</div>
</div>
<a id="ae917dca7c529cd37fc1617edcd037bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae917dca7c529cd37fc1617edcd037bce">&#9670;&nbsp;</a></span>getFEDataManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBTK_1_1FEDataManager.html">IBTK::FEDataManager</a>* IBAMR::IBFEMethod::getFEDataManager </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the finite element data manager object for the specified part. </p>

</div>
</div>
<a id="ac379e9514ee73a499dc012cd9d6873a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac379e9514ee73a499dc012cd9d6873a3">&#9670;&nbsp;</a></span>registerStaticPressurePart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBFEMethod::registerStaticPressurePart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceIBAMR.html#a62309df2b45664a6805692d7ed20e3a9">PressureProjectionType</a>&#160;</td>
          <td class="paramname"><em>projection_type</em> = <code><a class="el" href="namespaceIBAMR.html#a62309df2b45664a6805692d7ed20e3a9a9c4964d505893bc3fa1c1d50cb4edd9b">CONSISTENT_PROJECTION</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aeda305fe47cf0aa2699cff49769fe49e">FEMechanicsBase::VolumetricEnergyDerivativeFcn</a>&#160;</td>
          <td class="paramname"><em>U_prime_fcn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate that a part should include a static pressure.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a5dd3e2c1eab919c24ed47040ea751ad2">FEMechanicsBase::registerStaticPressurePart</a> for more details.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A given part cannot be registered both for stress normalization and also to have a static pressure. Attempting to do so will generate a fatal error. </dd></dl>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a5dd3e2c1eab919c24ed47040ea751ad2">IBAMR::FEMechanicsBase</a>.</p>

</div>
</div>
<a id="ac5f90394bbfd586569f698add87e06db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f90394bbfd586569f698add87e06db">&#9670;&nbsp;</a></span>registerStressNormalizationPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBFEMethod::registerStressNormalizationPart </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate that a part should use stress normalization.</p>
<dl class="section note"><dt>Note</dt><dd>A given part cannot be registered both for stress normalization and also to have a static pressure. Attempting to do so will generate a fatal error. </dd></dl>

</div>
</div>
<a id="ac0cedd4f91763a8709be18493c072897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cedd4f91763a8709be18493c072897">&#9670;&nbsp;</a></span>registerLagBodySourceFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBFEMethod::registerLagBodySourceFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIBAMR_1_1IBFEMethod_1_1LagBodySourceFcnData.html">LagBodySourceFcnData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register the (optional) function to compute a mass source/sink distribution on the Lagrangian finite element mesh. </p>

</div>
</div>
<a id="ac47ed582982fa1e1e475f429c0190bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47ed582982fa1e1e475f429c0190bc8">&#9670;&nbsp;</a></span>getLagBodySourceFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structIBAMR_1_1IBFEMethod_1_1LagBodySourceFcnData.html">LagBodySourceFcnData</a> IBAMR::IBFEMethod::getLagBodySourceFunction </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the Lagrangian body source function data. </p>

</div>
</div>
<a id="ac921c32e680078b72255b2a27542a376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac921c32e680078b72255b2a27542a376">&#9670;&nbsp;</a></span>registerDirectForcingKinematics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBFEMethod::registerDirectForcingKinematics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBAMR_1_1IBFEDirectForcingKinematics.html">IBAMR::IBFEDirectForcingKinematics</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register the (optional) direct forcing kinematics object with the finite element mesh. </p>

</div>
</div>
<a id="a44945b50230b3deb2906d196f25ea807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44945b50230b3deb2906d196f25ea807">&#9670;&nbsp;</a></span>getMinimumGhostCellWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt;NDIM&gt;&amp; IBAMR::IBFEMethod::getMinimumGhostCellWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of ghost cells required by the Lagrangian-Eulerian interaction routines. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBStrategy.html#a4eccd737f9f717fbf7b5c3c5ff87f626">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a2cf2016743693e3c6a37277181eee3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf2016743693e3c6a37277181eee3f3">&#9670;&nbsp;</a></span>setupTagBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::setupTagBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">SAMRAI::tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>gridding_alg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Setup the tag buffer. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a4ae1682579a77ae302441ae085803325">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a69e2f33d8a990ca6435ac8320e774c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e2f33d8a990ca6435ac8320e774c35">&#9670;&nbsp;</a></span>getMaxPointDisplacement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> IBAMR::IBFEMethod::getMaxPointDisplacement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as the base class. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a548e6766815734ca76353d18d781db92">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a200b1b8997e92a13df67fb9833602c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200b1b8997e92a13df67fb9833602c11">&#9670;&nbsp;</a></span>inactivateLagrangianStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBFEMethod::inactivateLagrangianStructure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>structure_number</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em> = <code>std::numeric_limits&lt;&#160;<a class="el" href="classint.html">int</a>&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inactivate a structure/part. See <a class="el" href="classIBAMR_1_1IBStrategy.html#ab2a042363dca682c158d89dcde9c7cad">IBAMR::IBStrategy::inactivateLagrangianStructure()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Since this class assumes that structures live on the finest grid level the second argument is ignored. </dd></dl>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#ab2a042363dca682c158d89dcde9c7cad">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="aea7ed02ad7dd6ca8ffe8c12ca40ab477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7ed02ad7dd6ca8ffe8c12ca40ab477">&#9670;&nbsp;</a></span>activateLagrangianStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBFEMethod::activateLagrangianStructure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>structure_number</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em> = <code>std::numeric_limits&lt;&#160;<a class="el" href="classint.html">int</a>&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Activate a previously inactivated structure/part to be used again in FSI calculations. See <a class="el" href="classIBAMR_1_1IBStrategy.html#ac7f5e1149acbaeb298a94eddb4a2b855">IBAMR::IBStrategy::activateLagrangianStructure()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Since this class assumes that structures live on the finest grid level the second argument is ignored. </dd></dl>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#ac7f5e1149acbaeb298a94eddb4a2b855">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a922aa7278e9f214b63cbc1151cafaea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922aa7278e9f214b63cbc1151cafaea5">&#9670;&nbsp;</a></span>getLagrangianStructureIsActivated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> IBAMR::IBFEMethod::getLagrangianStructureIsActivated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>structure_number</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em> = <code>std::numeric_limits&lt;&#160;<a class="el" href="classint.html">int</a>&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine whether or not the given structure or part is currently activated. See <a class="el" href="classIBAMR_1_1IBStrategy.html#a9d0d8e6216b3208f738e3a48d44ebcd9">IBAMR::IBStrategy::getLagrangianStructureIsActivated()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Since this class assumes that structures live on the finest grid level the second argument is ignored. </dd></dl>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a9d0d8e6216b3208f738e3a48d44ebcd9">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a29507964e0fb82f935ca7d9a49569cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29507964e0fb82f935ca7d9a49569cd2">&#9670;&nbsp;</a></span>preprocessIntegrateData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::preprocessIntegrateData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method to prepare to advance data from current_time to new_time. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a82e915527a890ba2c0242713a9bc1f76">IBAMR::FEMechanicsBase</a>.</p>

</div>
</div>
<a id="a8cf49eb718d9b0b9dc17b711eb9ccfe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf49eb718d9b0b9dc17b711eb9ccfe0">&#9670;&nbsp;</a></span>postprocessIntegrateData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::postprocessIntegrateData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method to clean up data following call(s) to integrateHierarchy(). </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#acc194896332a3a7fa16bbefaff3fe098">IBAMR::FEMechanicsBase</a>.</p>

</div>
</div>
<a id="a26fd1b2a7066e20b67b9e1a06f529b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26fd1b2a7066e20b67b9e1a06f529b5b">&#9670;&nbsp;</a></span>interpolateVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::interpolateVelocity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>u_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_synch_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_ghost_fill_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Interpolate the Eulerian velocity to the curvilinear mesh at the specified time within the current time interval. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBStrategy.html#a5d7d2f79ab629e93a808becc43706d5b">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="ae406c44c5285a9935aa064a77062b729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae406c44c5285a9935aa064a77062b729">&#9670;&nbsp;</a></span>setUseMultistepTimeStepping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::setUseMultistepTimeStepping </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_previous_steps</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate that multistep time stepping will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_previous_steps</td><td>Number of previous solution values that can be used by the multistep scheme. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a3df419c05fac15f60839ac01aa2ab197">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="af38332aad4b7478c644ba5d93c97eedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38332aad4b7478c644ba5d93c97eedf">&#9670;&nbsp;</a></span>forwardEulerStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::forwardEulerStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance the positions of the Lagrangian structure using the forward Euler method. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBStrategy.html#ada6b78bba869c8f042d51a44bf3593af">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a7d14d0844040c5e88d7ab81b4c3a8898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d14d0844040c5e88d7ab81b4c3a8898">&#9670;&nbsp;</a></span>backwardEulerStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::backwardEulerStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance the positions of the Lagrangian structure using the (explicit) backward Euler method. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a8230ec99b293ccda726061e4b5c05c1e">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="add10641d74d05d57159a952f44d8899f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add10641d74d05d57159a952f44d8899f">&#9670;&nbsp;</a></span>midpointStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::midpointStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance the positions of the Lagrangian structure using the (explicit) midpoint rule. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBStrategy.html#adf7fad570f9f4757b7818ba14e5f0b66">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a2781619cd7540db983ee9715027bea5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2781619cd7540db983ee9715027bea5d">&#9670;&nbsp;</a></span>trapezoidalStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::trapezoidalStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance the positions of the Lagrangian structure using the (explicit) trapezoidal rule. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBStrategy.html#a426420e5ab54e4a19763eb1f13d45949">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="abcab93d9b8db4efb7b959a19f82f0c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcab93d9b8db4efb7b959a19f82f0c79">&#9670;&nbsp;</a></span>AB2Step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::AB2Step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance the positions of the Lagrangian structure using the standard 2nd-order Adams-Bashforth rule. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#abbe374a56735ab5730f6e6dcbb26de6d">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a22cb110886698f4c239f0dbab461a4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cb110886698f4c239f0dbab461a4d9">&#9670;&nbsp;</a></span>computeLagrangianForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::computeLagrangianForce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Lagrangian force at the specified time within the current time interval. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBStrategy.html#aec6e7fc096c898aab511e8149940618a">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a52ad97cfb324cbc9af905fcf0675ebaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ad97cfb324cbc9af905fcf0675ebaa">&#9670;&nbsp;</a></span>spreadForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::spreadForce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">IBTK::RobinPhysBdryPatchStrategy</a> *&#160;</td>
          <td class="paramname"><em>f_phys_bdry_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_prolongation_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Spread the Lagrangian force to the Cartesian grid at the specified time within the current time interval. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBStrategy.html#a01e52f894bcd549503fe20f58dfbd08a">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a09f46b84c04db987dee05672c81c0bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f46b84c04db987dee05672c81c0bec">&#9670;&nbsp;</a></span>hasFluidSources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBFEMethod::hasFluidSources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate whether there are any internal fluid sources/sinks. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#ad4cc6d3e4a980f86e3cab783e86c5521">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a6390dba78691fcc64fee8a51cdcae44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6390dba78691fcc64fee8a51cdcae44f">&#9670;&nbsp;</a></span>computeLagrangianFluidSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::computeLagrangianFluidSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Lagrangian source/sink density at the specified time within the current time interval. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a945b2b9c0014ea3a231644dcae4cf80e">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a0d2819f1c6a98a728c6ee0906da62be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2819f1c6a98a728c6ee0906da62be8">&#9670;&nbsp;</a></span>spreadFluidSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::spreadFluidSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">IBTK::RobinPhysBdryPatchStrategy</a> *&#160;</td>
          <td class="paramname"><em>q_phys_bdry_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_prolongation_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Spread the Lagrangian source/sink density to the Cartesian grid at the specified time within the current time interval. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#ae9105414b159821a57fd09469de45c97">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a15851f70dd152079dc05487f9c4d55bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15851f70dd152079dc05487f9c4d55bd">&#9670;&nbsp;</a></span>getDefaultInterpSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">IBTK::FEDataManager::InterpSpec</a> IBAMR::IBFEMethod::getDefaultInterpSpec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the default interpolation spec object used by the class. </p>

</div>
</div>
<a id="ae29931b1b6941d078dad969e57bc3f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29931b1b6941d078dad969e57bc3f60">&#9670;&nbsp;</a></span>getDefaultSpreadSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">IBTK::FEDataManager::SpreadSpec</a> IBAMR::IBFEMethod::getDefaultSpreadSpec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the default spread spec object used by the class. </p>

</div>
</div>
<a id="a17ae4c5f1c67d9b283b8fa057c241c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ae4c5f1c67d9b283b8fa057c241c1e">&#9670;&nbsp;</a></span>setWorkloadSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::setWorkloadSpec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIBTK_1_1FEDataManager_1_1WorkloadSpec.html">IBTK::FEDataManager::WorkloadSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>workload_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the workload spec object used with a particular mesh part. </p>

</div>
</div>
<a id="a84fe231a402d36d8bd1ea6b0fab26914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fe231a402d36d8bd1ea6b0fab26914">&#9670;&nbsp;</a></span>setInterpSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::setInterpSpec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">IBTK::FEDataManager::InterpSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>interp_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the interpolation spec object used with a particular mesh part. </p>

</div>
</div>
<a id="a13bed9afd40f2991a3e203bc3661e95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bed9afd40f2991a3e203bc3661e95b">&#9670;&nbsp;</a></span>setSpreadSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::setSpreadSpec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">IBTK::FEDataManager::SpreadSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>spread_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the spread spec object used with a particular mesh part. </p>

</div>
</div>
<a id="a3efe212b70056f71d887e3f173432d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3efe212b70056f71d887e3f173432d42">&#9670;&nbsp;</a></span>registerEulerianVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::registerEulerianVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a749a277f7c88ce504736463db4b439a9">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="ae90a6f1603d1806f04094e303f8b1d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90a6f1603d1806f04094e303f8b1d37">&#9670;&nbsp;</a></span>initializePatchHierarchy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::initializePatchHierarchy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>gridding_alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>u_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_synch_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_ghost_fill_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>integrator_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>init_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize Lagrangian data corresponding to the given AMR patch hierarchy at the start of a computation. If the computation is begun from a restart file, data may be read from the restart databases.</p>
<p>A patch data descriptor is provided for the Eulerian velocity in case initialization requires interpolating Eulerian data. Ghost cells for Eulerian data will be filled upon entry to this function. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a2857c2753274413a8c0a3f1c9b2074d0">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a9abd4174181183da4113048fba4eec53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abd4174181183da4113048fba4eec53">&#9670;&nbsp;</a></span>addWorkloadEstimate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::addWorkloadEstimate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>workload_data_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add the estimated computational work from the current object (i.e., the work required by the owned Lagrangian objects) per cell into the specified <code>workload_data_idx</code>. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a7b56cdde81a82aa9e274f6787c16168a">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="aa435f674667775eca22ef8fac79ca238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa435f674667775eca22ef8fac79ca238">&#9670;&nbsp;</a></span>beginDataRedistribution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::beginDataRedistribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>gridding_alg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin redistributing Lagrangian data prior to regridding the patch hierarchy. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#ab642751b30ab47992895a22e026ba672">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="ae22ac9c1888e9d44351a68b456fda604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22ac9c1888e9d44351a68b456fda604">&#9670;&nbsp;</a></span>endDataRedistribution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::endDataRedistribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>gridding_alg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Complete redistributing Lagrangian data following regridding the patch hierarchy. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a1de1731a81d3204c0caf301e0a5f2736">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a295652bc060179b8cb5d730649e133dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295652bc060179b8cb5d730649e133dd">&#9670;&nbsp;</a></span>initializeLevelData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::initializeLevelData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>init_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>can_be_refined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>old_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allocate_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>this function only exists for compatibility with the base class and does nothing: data reinitialization is handled by <a class="el" href="classIBAMR_1_1IBFEMethod.html#ae22ac9c1888e9d44351a68b456fda604">endDataRedistribution()</a> instead.</p>
<p>The reasoning is this: since this class stores data only on particular levels (at the present time, the structure is always on the finest level) setting up level data is nontrivial when generating the initial grid (i.e., when tagging cells that contain interaction points for refinement). In a sense there is no level data to compute until we are done regridding.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#af8f31cfe38a0690a629fcbeb7ad89888">SAMRAI::mesh::StandardTagAndInitStrategy::initializeLevelData</a> </dd></dl>

</div>
</div>
<a id="a0dd4f8a28b0cfebfe8ec7b7302bb627d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd4f8a28b0cfebfe8ec7b7302bb627d">&#9670;&nbsp;</a></span>resetHierarchyConfiguration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::resetHierarchyConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset cached hierarchy dependent data.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a6f8d89482d4bdafc824307cc21c728c9">SAMRAI::mesh::StandardTagAndInitStrategy::resetHierarchyConfiguration</a> </dd></dl>

</div>
</div>
<a id="a1032e0a37c2d874a18403a8ceb534d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1032e0a37c2d874a18403a8ceb534d1d">&#9670;&nbsp;</a></span>applyGradientDetector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::applyGradientDetector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>uses_richardson_extrapolation_too</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set integer tags to "one" in cells where refinement of the given level should occur according to user-supplied feature detection criteria.</p>
<p>The name here is misleading, but <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> expects us to use one of two tagging methods to refine the grid, and <a class="el" href="namespaceIBAMR.html">IBAMR</a> consistently uses gradient detection: hence this function has the same name but tags cells in a different way.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#ac201b9cd28087aa92f9c1370f147667a">SAMRAI::mesh::StandardTagAndInitStrategy::applyGradientDetector</a> </dd></dl>

</div>
</div>
<a id="aed478d4d5214191cd99a63f221537fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed478d4d5214191cd99a63f221537fbf">&#9670;&nbsp;</a></span>putToDatabase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::putToDatabase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt;&#160;</td>
          <td class="paramname"><em>db</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write out object state to the given database. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a9a2d08a5622d5f463f9fb797a3b5ead3">IBAMR::FEMechanicsBase</a>.</p>

</div>
</div>
<a id="a01dc5f5d00ef3d13479e72e274b389b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01dc5f5d00ef3d13479e72e274b389b6">&#9670;&nbsp;</a></span>getScratchHierarchy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt;NDIM&gt; &gt; IBAMR::IBFEMethod::getScratchHierarchy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the scratch hierarchy used by this object. See the main documentation of this class for more information. </p>

</div>
</div>
<a id="a3827116ee9e47c50e65c17104e4cb145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3827116ee9e47c50e65c17104e4cb145">&#9670;&nbsp;</a></span>doInitializeFEEquationSystems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBFEMethod::doInitializeFEEquationSystems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do the actual work in initializeFEEquationSystems. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a7b32e042755863d076c7519e39dfd755">IBAMR::FEMechanicsBase</a>.</p>

</div>
</div>
<a id="a0f207371be2997586424ff392cb1aa1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f207371be2997586424ff392cb1aa1c">&#9670;&nbsp;</a></span>doInitializeFESystemVectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::doInitializeFESystemVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do the actual work of setting up <a class="el" href="namespacelibMesh.html">libMesh</a> system vectors. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#acf7e6e1c750c11a633efeb5a7a10795c">IBAMR::FEMechanicsBase</a>.</p>

</div>
</div>
<a id="adb98f3ce7d42f41d32c2daf6c35f1c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb98f3ce7d42f41d32c2daf6c35f1c88">&#9670;&nbsp;</a></span>doInitializeFEData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBFEMethod::doInitializeFEData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_present_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do the actual work in reinitializeFEData and initializeFEData. if <code>use_present_data</code> is <code>true</code> then the current content of the solution vectors is used: more exactly, the coordinates and velocities (computed by initializeCoordinates and initializeVelocity) are considered as being up to date, as is the direct forcing kinematic data. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#ae2ce94444027f6a4c0a2c0fe4d917542">IBAMR::FEMechanicsBase</a>.</p>

</div>
</div>
<a id="ad5f7249277522ae1fb237026b6bafbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f7249277522ae1fb237026b6bafbc3">&#9670;&nbsp;</a></span>computeStressNormalization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::computeStressNormalization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>P_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a9855d31db62b5372486bf2db1c9812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9855d31db62b5372486bf2db1c9812">&#9670;&nbsp;</a></span>spreadTransmissionForceDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::spreadTransmissionForceDensity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_ghost_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af6b21ebfb951f37d4c927785db0b64ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b21ebfb951f37d4c927785db0b64ab">&#9670;&nbsp;</a></span>imposeJumpConditions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::imposeJumpConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_ghost_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_ghost_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0657212e71dffd646ca626bcd27b628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0657212e71dffd646ca626bcd27b628">&#9670;&nbsp;</a></span>getCoarsestPatchLevelNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBAMR::IBFEMethod::getCoarsestPatchLevelNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the coarsest patch level number on which elements (including all parts) are assigned. </p>

</div>
</div>
<a id="a0485d2574dc145caee6e10d6437d6869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0485d2574dc145caee6e10d6437d6869">&#9670;&nbsp;</a></span>getFinestPatchLevelNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBAMR::IBFEMethod::getFinestPatchLevelNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the finest patch level number on which elements (including all parts) are assigned. </p>

</div>
</div>
<a id="a76927ac238c5f10110801e0949d6444e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76927ac238c5f10110801e0949d6444e">&#9670;&nbsp;</a></span>getProlongationSchedule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;NDIM&gt;&amp; IBAMR::IBFEMethod::getProlongationSchedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarse_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fine_data_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the schedule used to prolong force values. Data is read from <code>coarse_data_idx</code> on level <code>level_number</code> and written into fine_data_idx on level level_number + 1. </p>

</div>
</div>
<a id="a0511ec5c6005d72dea466e84aba05244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0511ec5c6005d72dea466e84aba05244">&#9670;&nbsp;</a></span>commonConstructor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::commonConstructor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_levels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of class constructor. </p>

</div>
</div>
<a id="a3a544ffc1059f511966b5e76fc358cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a544ffc1059f511966b5e76fc358cc3">&#9670;&nbsp;</a></span>getFromInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::getFromInput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_from_restart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read input values from a given database. </p>

</div>
</div>
<a id="a0b3f1d9fe3e21a6faeffe3333cd05a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3f1d9fe3e21a6faeffe3333cd05a16">&#9670;&nbsp;</a></span>getFromRestart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::getFromRestart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read object state from the restart file and initialize class data members. </p>

</div>
</div>
<a id="a8396a62282c87f72c7abd79a77442b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8396a62282c87f72c7abd79a77442b4e">&#9670;&nbsp;</a></span>assertStructureOnFinestLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::assertStructureOnFinestLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>At the present time this class and FEDataManager assume that the finite element mesh is always on the finest grid level. This function explicitly asserts that this condition is met. </p>

</div>
</div>
<a id="af1ad590435a995066141c22f5cf2b50b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ad590435a995066141c22f5cf2b50b">&#9670;&nbsp;</a></span>reinitElementMappings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBFEMethod::reinitElementMappings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function that reinitializes the patch-to-element mappings on all relevant FEDataManagers (i.e., for all parts and, if enabled, on the scratch hierarchy). </p>

</div>
</div>
<a id="afbcaefbb8b7b260e9f4c5d3705d81235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbcaefbb8b7b260e9f4c5d3705d81235">&#9670;&nbsp;</a></span>getEquationSystems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::EquationSystems* IBAMR::FEMechanicsBase::getEquationSystems </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the equations system object for the specified part. </p>

</div>
</div>
<a id="a194ac6be6d209938221062d2686b6f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194ac6be6d209938221062d2686b6f5d">&#9670;&nbsp;</a></span>getCurrentCoordinatesSystemName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; IBAMR::FEMechanicsBase::getCurrentCoordinatesSystemName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the current coordinates system name. </p>

</div>
</div>
<a id="aaad6f4fc0a3765900ce78a8f2890708e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad6f4fc0a3765900ce78a8f2890708e">&#9670;&nbsp;</a></span>getDisplacementSystemName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; IBAMR::FEMechanicsBase::getDisplacementSystemName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the displacement system name. </p>

</div>
</div>
<a id="a203ced8a9e9954ec5c5738643765dd4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203ced8a9e9954ec5c5738643765dd4c">&#9670;&nbsp;</a></span>getForceSystemName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; IBAMR::FEMechanicsBase::getForceSystemName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the force system name. </p>

</div>
</div>
<a id="a48fbc454a4ea1175714bf9b592561c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fbc454a4ea1175714bf9b592561c5b">&#9670;&nbsp;</a></span>getPressureSystemName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; IBAMR::FEMechanicsBase::getPressureSystemName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the pressure system name. </p>

</div>
</div>
<a id="a807fad09e25de8a24ba473e0cd2f58e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807fad09e25de8a24ba473e0cd2f58e3">&#9670;&nbsp;</a></span>getVelocitySystemName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; IBAMR::FEMechanicsBase::getVelocitySystemName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the velocity system name. </p>

</div>
</div>
<a id="a880841f755dc28200c88eb89e4cba980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880841f755dc28200c88eb89e4cba980">&#9670;&nbsp;</a></span>getFEData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classIBTK_1_1FEData.html">IBTK::FEData</a>&gt; IBAMR::FEMechanicsBase::getFEData </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the FEData object for the specified part. </p>

</div>
</div>
<a id="a3eb9b35ba376f3bbb5d8e8909c319fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb9b35ba376f3bbb5d8e8909c319fd6">&#9670;&nbsp;</a></span>registerInitialCoordinateMappingFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::FEMechanicsBase::registerInitialCoordinateMappingFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1CoordinateMappingFcnData.html">CoordinateMappingFcnData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register the (optional) function used to initialize the physical coordinates from the Lagrangian coordinates.</p>
<dl class="section note"><dt>Note</dt><dd>If no function is provided, the initial physical coordinates are taken to be the same as the Lagrangian coordinate system, i.e., the initial coordinate mapping is assumed to be the identity mapping. </dd></dl>

</div>
</div>
<a id="a855edc9bb5296689bb2dffe7764c01ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855edc9bb5296689bb2dffe7764c01ae">&#9670;&nbsp;</a></span>getInitialCoordinateMappingFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1CoordinateMappingFcnData.html">CoordinateMappingFcnData</a> IBAMR::FEMechanicsBase::getInitialCoordinateMappingFunction </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the initial coordinate mapping function data. </p>

</div>
</div>
<a id="abd03b04f7716af955f2819ae951adebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd03b04f7716af955f2819ae951adebf">&#9670;&nbsp;</a></span>registerInitialVelocityFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::FEMechanicsBase::registerInitialVelocityFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1InitialVelocityFcnData.html">InitialVelocityFcnData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register the (optional) function used to initialize the velocity of the solid mesh.</p>
<dl class="section note"><dt>Note</dt><dd>If no function is provided, the initial velocity is taken to be zero. </dd></dl>

</div>
</div>
<a id="aa5ebae1b8e0a35e523355bd3d49b867e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ebae1b8e0a35e523355bd3d49b867e">&#9670;&nbsp;</a></span>getInitialVelocityFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1InitialVelocityFcnData.html">InitialVelocityFcnData</a> IBAMR::FEMechanicsBase::getInitialVelocityFunction </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the initial velocity function data. </p>

</div>
</div>
<a id="adfaa59d187a7ea211d5a0fbc0ea989ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfaa59d187a7ea211d5a0fbc0ea989ff">&#9670;&nbsp;</a></span>registerPK1StressFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::FEMechanicsBase::registerPK1StressFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1PK1StressFcnData.html">PK1StressFcnData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register the (optional) function to compute the first Piola-Kirchhoff stress tensor, used to compute the forces on the Lagrangian finite element mesh.</p>
<dl class="section note"><dt>Note</dt><dd>It is possible to register multiple PK1 stress functions with this class. This is intended to be used to implement selective reduced integration. </dd></dl>

</div>
</div>
<a id="ad875ff499ae980e1052d1059384fadb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad875ff499ae980e1052d1059384fadb4">&#9670;&nbsp;</a></span>getPK1StressFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1PK1StressFcnData.html">PK1StressFcnData</a>&gt; IBAMR::FEMechanicsBase::getPK1StressFunction </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the PK1 stress function data. </p>

</div>
</div>
<a id="a5048e9b39e6cac0adb4e673863eb5eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5048e9b39e6cac0adb4e673863eb5eda">&#9670;&nbsp;</a></span>registerLagBodyForceFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::FEMechanicsBase::registerLagBodyForceFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagBodyForceFcnData.html">LagBodyForceFcnData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register the (optional) function to compute body force distributions on the Lagrangian finite element mesh.</p>
<dl class="section note"><dt>Note</dt><dd>It is <em>NOT</em> possible to register multiple body force functions with this class. </dd></dl>

</div>
</div>
<a id="a71c45608c439a009c6da0062aa4f9be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c45608c439a009c6da0062aa4f9be2">&#9670;&nbsp;</a></span>getLagBodyForceFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagBodyForceFcnData.html">LagBodyForceFcnData</a> IBAMR::FEMechanicsBase::getLagBodyForceFunction </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the Lagrangian body force function data. </p>

</div>
</div>
<a id="a060ab8bb4ffff3d4cdef1102b45d238e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060ab8bb4ffff3d4cdef1102b45d238e">&#9670;&nbsp;</a></span>registerLagSurfacePressureFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::FEMechanicsBase::registerLagSurfacePressureFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagSurfacePressureFcnData.html">LagSurfacePressureFcnData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register the (optional) function to compute surface pressure distributions on the Lagrangian finite element mesh.</p>
<dl class="section note"><dt>Note</dt><dd>It is <em>NOT</em> possible to register multiple pressure functions with this class. </dd></dl>

</div>
</div>
<a id="a2384671da762544379cd2af88367ceb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2384671da762544379cd2af88367ceb3">&#9670;&nbsp;</a></span>getLagSurfacePressureFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagSurfacePressureFcnData.html">LagSurfacePressureFcnData</a> IBAMR::FEMechanicsBase::getLagSurfacePressureFunction </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the Lagrangian surface pressure function data. </p>

</div>
</div>
<a id="a19a59d9fd6d76f75b6c95feab1ca4841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a59d9fd6d76f75b6c95feab1ca4841">&#9670;&nbsp;</a></span>registerLagSurfaceForceFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::FEMechanicsBase::registerLagSurfaceForceFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagSurfaceForceFcnData.html">LagSurfaceForceFcnData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register the (optional) function to compute surface force distributions on the Lagrangian finite element mesh.</p>
<dl class="section note"><dt>Note</dt><dd>It is <em>NOT</em> possible to register multiple surface force functions with this class. </dd></dl>

</div>
</div>
<a id="af16d68cf6a92d90ab5a20f3576470ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16d68cf6a92d90ab5a20f3576470ecf">&#9670;&nbsp;</a></span>getLagSurfaceForceFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagSurfaceForceFcnData.html">LagSurfaceForceFcnData</a> IBAMR::FEMechanicsBase::getLagSurfaceForceFunction </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the Lagrangian surface force function data. </p>

</div>
</div>
<a id="a2a4a3651cef38c65b761cbbe43a2a8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4a3651cef38c65b761cbbe43a2a8ef">&#9670;&nbsp;</a></span>registerDynamicPressurePart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::FEMechanicsBase::registerDynamicPressurePart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceIBAMR.html#a62309df2b45664a6805692d7ed20e3a9">PressureProjectionType</a>&#160;</td>
          <td class="paramname"><em>projection_type</em> = <code><a class="el" href="namespaceIBAMR.html#a62309df2b45664a6805692d7ed20e3a9a9c4964d505893bc3fa1c1d50cb4edd9b">CONSISTENT_PROJECTION</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aeda305fe47cf0aa2699cff49769fe49e">VolumetricEnergyDerivativeFcn</a>&#160;</td>
          <td class="paramname"><em>d2U_dJ2_fcn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate that a part should include a dynamic pressure.</p>
<p>The pressure is determined via (P-dot, Q) = (J U''(J) (FF : Grad U), Q), using either a consistent or lumped mass matrix, or via a locally stabilized projection of the form (P, Q) + epsilon (P - Pi P, Q - Pi Q) = (U'(J), Q), in which P is the pressure and Q is an arbitrary test function.</p>
<p>Users can provide a function to evaluate U''(J). If no function is provided, we default to using U(J) = -kappa (J ln(J)  J + 1), so that U'(J) = -kappa ln J and U''(J) = -kappa J^{-1}. (Ref: C.H. Liu, G. Hofstetter, H.A. Mang, 3D finite element analysis of rubber-like materials at finite strains, Eng. Comput. 11 (2) (1994) 111128.)</p>
<p>The sign convention used in the implementation generates a PK1 stress of the form PP = -J P FF^{-T}.</p>
<dl class="section note"><dt>Note</dt><dd>The same part cannot have both static and dynamic pressures.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classIBAMR_1_1IBFEMethod.html#ac379e9514ee73a499dc012cd9d6873a3">registerStaticPressurePart</a> </dd></dl>

</div>
</div>
<a id="a50d7ddb594b68ac84410f85919e6980a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d7ddb594b68ac84410f85919e6980a">&#9670;&nbsp;</a></span>partHasPressure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::FEMechanicsBase::partHasPressure </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate whether there is a static or dynamic pressure associated with the specified FE mesh part. </p>

</div>
</div>
<a id="ae155fd7b769e6b4e3abd5df93e3b1bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae155fd7b769e6b4e3abd5df93e3b1bfc">&#9670;&nbsp;</a></span>initializeFEEquationSystems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::FEMechanicsBase::initializeFEEquationSystems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize the FE equation systems objects. This method must be called prior to calling <a class="el" href="classIBAMR_1_1FEMechanicsBase.html#a7f06e81bec3bc4f9cb5faaea0a5f76cf">initializeFEData()</a>. </p>

</div>
</div>
<a id="a7f06e81bec3bc4f9cb5faaea0a5f76cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f06e81bec3bc4f9cb5faaea0a5f76cf">&#9670;&nbsp;</a></span>initializeFEData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::FEMechanicsBase::initializeFEData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize FE data. This method must be called prior to calling <a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html#a8eab8e8e0267b1887abea0770d486958">IBHierarchyIntegrator::initializePatchHierarchy()</a>. </p>

</div>
</div>
<a id="a5356c7d2ef6e07b10f843334841652de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5356c7d2ef6e07b10f843334841652de">&#9670;&nbsp;</a></span>reinitializeFEData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::FEMechanicsBase::reinitializeFEData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reinitialize FE data by calling <code>reinit</code> on each part's EquationSystem, reassembling the system matrices, and setting boundary conditions. </p>

</div>
</div>
<a id="a2d85468b535a473316d2f86bd47aafa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d85468b535a473316d2f86bd47aafa5">&#9670;&nbsp;</a></span>writeFEDataToRestartFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::FEMechanicsBase::writeFEDataToRestartFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>restart_dump_dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>time_step_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For technical reasons this class does not use <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>'s RestartManager, so restart files must be separately written for the FE objects. This function saves the solutions to the defined EquationSystems in an xdr file in restart_dump_dirname for each FE part. An example snippet is included below to show the distinct FE restart data saving step. The data will then be automatically read back into the system along with the RestartManager data during restart.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (dump_restart_data &amp;&amp; (iteration_num % restart_dump_interval == 0 || last_step))</div>
<div class="line">{</div>
<div class="line">    RestartManager::getManager()-&gt;writeRestartFile(restart_dump_dirname, iteration_num);</div>
<div class="line">    fe_mechanics_base-&gt;writeFEDataToRestartFile(restart_dump_dirname, iteration_num);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a11c06b9300d48ddccef246ff043b94bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c06b9300d48ddccef246ff043b94bc">&#9670;&nbsp;</a></span>computeStaticPressure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::FEMechanicsBase::computeStaticPressure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>P_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac86e47012e4d7a442e6299b169b40107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86e47012e4d7a442e6299b169b40107">&#9670;&nbsp;</a></span>computeDynamicPressureRateOfChange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::FEMechanicsBase::computeDynamicPressureRateOfChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dP_dt_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>U_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a41b28b5a38bc1ad1e56719f7ce3a0bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b28b5a38bc1ad1e56719f7ce3a0bf5">&#9670;&nbsp;</a></span>assembleInteriorForceDensityRHS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::FEMechanicsBase::assembleInteriorForceDensityRHS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_rhs_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>P_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assemble the RHS for the interior elastic density, possibly splitting off the normal component of the transmission force along the physical boundary of the Lagrangian structure. </p>

</div>
</div>
<a id="a212f20bcd9adf419e84a78bb43796e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212f20bcd9adf419e84a78bb43796e62">&#9670;&nbsp;</a></span>initializeCoordinates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::FEMechanicsBase::initializeCoordinates </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize the physical coordinates using the supplied coordinate mapping function. If no function is provided, the initial coordinates are taken to be the Lagrangian coordinates. </p>

</div>
</div>
<a id="a3f1aac515040cc4b3ec8a3136190f3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1aac515040cc4b3ec8a3136190f3f9">&#9670;&nbsp;</a></span>updateCoordinateMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::FEMechanicsBase::updateCoordinateMapping </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute dX = x - X, useful mainly for visualization purposes. </p>

</div>
</div>
<a id="a1cd0f67d11edf17c6375334200afbb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd0f67d11edf17c6375334200afbb28">&#9670;&nbsp;</a></span>initializeVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::FEMechanicsBase::initializeVelocity </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize the velocity field using the supplied initial velocity specification function. If no function is provided, the initial velocity is taken to be zero. </p>

</div>
</div>
<a id="a73f224564ea5405ff8ce12b7272d70e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f224564ea5405ff8ce12b7272d70e5">&#9670;&nbsp;</a></span>getLibMeshRestartFileName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string IBAMR::FEMechanicsBase::getLibMeshRestartFileName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>restart_dump_dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>time_step_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <a class="el" href="namespacelibMesh.html">libMesh</a> restart file name. </p>

</div>
</div>
<a id="a408f40c60a8b93e2a8968e857ece4df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408f40c60a8b93e2a8968e857ece4df8">&#9670;&nbsp;</a></span>setup_system_vectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IBAMR::FEMechanicsBase::setup_system_vectors </td>
          <td>(</td>
          <td class="paramtype">libMesh::EquationSystems *&#160;</td>
          <td class="paramname"><em>equation_systems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>system_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function to setup system vectors and, if necessary, convert PARALLEL vectors into GHOSTED vectors for a collection of Systems.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>use <a class="el" href="namespaceIBTK.html#a4b41be6d36de9d935548318a7c6dfacf">IBTK::setup_system_vectors</a> instead. </dd></dl>

</div>
</div>
<a id="a90281c5dbea5a8ff9e1a63bd08844961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90281c5dbea5a8ff9e1a63bd08844961">&#9670;&nbsp;</a></span>setup_system_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IBAMR::FEMechanicsBase::setup_system_vector </td>
          <td>(</td>
          <td class="paramtype">libMesh::System &amp;&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vector_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function to setup a system vector and, if necessary, convert a PARALLEL vector into a GHOSTED vector.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>use <a class="el" href="namespaceIBTK.html#a18c7364c1bce910e24678a0db1cbe084">IBTK::setup_system_vector</a> instead. </dd></dl>

</div>
</div>
<a id="ab98445ef8b9ff1d190847323663f6a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98445ef8b9ff1d190847323663f6a27">&#9670;&nbsp;</a></span>registerIBHierarchyIntegrator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBStrategy::registerIBHierarchyIntegrator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html">IBHierarchyIntegrator</a> *&#160;</td>
          <td class="paramname"><em>ib_solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register the <a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html" title="Class IBHierarchyIntegrator provides an abstract interface for a time integrator for various versions...">IBHierarchyIntegrator</a> object that is using this strategy class. </p>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1IBLevelSetMethod.html#ac365e72120a0f957b5765dd3fa7942cc">IBAMR::IBLevelSetMethod</a>, and <a class="el" href="classIBAMR_1_1IBStrategySet.html#a28e2cbe4047d5c35c2e16f994e75015e">IBAMR::IBStrategySet</a>.</p>

</div>
</div>
<a id="aec18a1b78a640c600e80aec1059418b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec18a1b78a640c600e80aec1059418b8">&#9670;&nbsp;</a></span>registerEulerianCommunicationAlgorithms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBStrategy::registerEulerianCommunicationAlgorithms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register Eulerian refinement or coarsening algorithms with the parent <a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html" title="Class IBHierarchyIntegrator provides an abstract interface for a time integrator for various versions...">IBHierarchyIntegrator</a> using the two versions of the protected methods <a class="el" href="classIBAMR_1_1IBStrategy.html#a6ff41aa031a85b31866aa1bd7c832cb9">IBStrategy::registerGhostfillRefineAlgorithm()</a>, <a class="el" href="classIBAMR_1_1IBStrategy.html#a765846726a9e33a0b31e0549b699515f">IBStrategy::registerProlongRefineAlgorithm()</a>, and <a class="el" href="classIBAMR_1_1IBStrategy.html#a4217ccceea177b4109b528a85c383a2b">IBStrategy::registerCoarsenAlgorithm()</a>.</p>
<p>An empty default implementation is provided. </p>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#a5f369c438fd90b1cf4799c5810609e6a">IBAMR::CIBMethod</a>, <a class="el" href="classIBAMR_1_1IBLevelSetMethod.html#a65c8df25deee9fe24e787c928e257dac">IBAMR::IBLevelSetMethod</a>, <a class="el" href="classIBAMR_1_1IBInterpolantMethod.html#a4278854a0722db6dec7ce3462ce07770">IBAMR::IBInterpolantMethod</a>, <a class="el" href="classIBAMR_1_1IBStrategySet.html#affbc513b5eb1ef2c63427ba5a77b2cec">IBAMR::IBStrategySet</a>, and <a class="el" href="classIBAMR_1_1GeneralizedIBMethod.html#a63860ee5aa1481734752e9ea7813db2e">IBAMR::GeneralizedIBMethod</a>.</p>

</div>
</div>
<a id="a7c0bace52c4d76fd7fe2ca073734a50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0bace52c4d76fd7fe2ca073734a50d">&#9670;&nbsp;</a></span>setUseFixedLEOperators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBStrategy::setUseFixedLEOperators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_fixed_coupling_ops</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate whether "fixed" interpolation and spreading operators should be used during Lagrangian-Eulerian interaction. </p>

</div>
</div>
<a id="ad14fe8b8584832721a1c0017e5b8443b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14fe8b8584832721a1c0017e5b8443b">&#9670;&nbsp;</a></span>updateFixedLEOperators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBStrategy::updateFixedLEOperators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the positions used for the "fixed" interpolation and spreading operators.</p>
<p>A default implementation is provided that emits an unrecoverable exception. </p>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1IBMethod.html#a1ae42ac41bb6037769f1c14ccb883b13">IBAMR::IBMethod</a>, <a class="el" href="classIBAMR_1_1IBLevelSetMethod.html#a1bf44247b707c3858dac984adca25464">IBAMR::IBLevelSetMethod</a>, and <a class="el" href="classIBAMR_1_1IBStrategySet.html#aab1899164f775ba205169adaeaafec20">IBAMR::IBStrategySet</a>.</p>

</div>
</div>
<a id="ac269b2985aa6a7c55c5ff015c5e337eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac269b2985aa6a7c55c5ff015c5e337eb">&#9670;&nbsp;</a></span>interpolatePressure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBStrategy::interpolatePressure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_synch_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_ghost_fill_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the pressures at the positions of any distributed internal fluid sources or sinks.</p>
<p>An empty default implementation is provided. </p>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1IBMethod.html#a1b72875d25a3ab6dc51eaa8044d95d16">IBAMR::IBMethod</a>, <a class="el" href="classIBAMR_1_1IBLevelSetMethod.html#a1cc14d03c9a52482b80e583bc496a462">IBAMR::IBLevelSetMethod</a>, and <a class="el" href="classIBAMR_1_1IBStrategySet.html#a4af7e7b14a59c77e338bd5569cbcfafc">IBAMR::IBStrategySet</a>.</p>

</div>
</div>
<a id="ad1d056e5284c58ba29315433c45154d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d056e5284c58ba29315433c45154d3">&#9670;&nbsp;</a></span>preprocessSolveFluidEquations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBStrategy::preprocessSolveFluidEquations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cycle_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute user-defined routines just before solving the fluid equations.</p>
<p>An empty default implementation is provided. </p>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1IBLevelSetMethod.html#ab04e6b8e0b388f649264d4290582a8ae">IBAMR::IBLevelSetMethod</a>, <a class="el" href="classIBAMR_1_1IBStrategySet.html#a27ce40b12c02554347eed9cbbd1b55f1">IBAMR::IBStrategySet</a>, <a class="el" href="classIBAMR_1_1CIBMethod.html#aff0d67fbc16f0c938ada431136e2f4c7">IBAMR::CIBMethod</a>, and <a class="el" href="classIBAMR_1_1ConstraintIBMethod.html#a7805957819aab0365155ea27d5f78ba5">IBAMR::ConstraintIBMethod</a>.</p>

</div>
</div>
<a id="abc6165a233879d675b6782790e6f4c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6165a233879d675b6782790e6f4c05">&#9670;&nbsp;</a></span>postprocessSolveFluidEquations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBStrategy::postprocessSolveFluidEquations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cycle_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute user-defined routines just after solving the fluid equations.</p>
<p>An empty default implementation is provided. </p>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1IBLevelSetMethod.html#ad6e520e94837ec3797d52cf8fd733538">IBAMR::IBLevelSetMethod</a>, <a class="el" href="classIBAMR_1_1IBStrategySet.html#af1641359e25e824ee4bbe52f8c867137">IBAMR::IBStrategySet</a>, and <a class="el" href="classIBAMR_1_1ConstraintIBMethod.html#a58058ffecfee54b5b0acf694c58f6082">IBAMR::ConstraintIBMethod</a>.</p>

</div>
</div>
<a id="aedb319577288b037592afe728e29258e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb319577288b037592afe728e29258e">&#9670;&nbsp;</a></span>postprocessData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBStrategy::postprocessData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute user-defined post-processing operations.</p>
<p>An empty default implementation is provided. </p>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1IBMethod.html#afca342dbf9b3629c719befd3bfc5254d">IBAMR::IBMethod</a>, <a class="el" href="classIBAMR_1_1IBLevelSetMethod.html#a01b602f11706692b87c111226f9ae7a0">IBAMR::IBLevelSetMethod</a>, and <a class="el" href="classIBAMR_1_1IBStrategySet.html#a8866535a42c0d6cb64db4e22273f667b">IBAMR::IBStrategySet</a>.</p>

</div>
</div>
<a id="a41e996bc402231206232370c2e442c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e996bc402231206232370c2e442c64">&#9670;&nbsp;</a></span>registerLoadBalancer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBStrategy::registerLoadBalancer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalancer.html">SAMRAI::mesh::LoadBalancer</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>load_balancer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>workload_data_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a load balancer and work load patch data index with the IB strategy object.</p>
<p>An empty default implementation is provided.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>This method is no longer necessary with the current workload estimation scheme. </dd></dl>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1IBMethod.html#a2b6847ad81e8d1f24acab882f950c9a6">IBAMR::IBMethod</a>, <a class="el" href="classIBAMR_1_1IBStrategySet.html#a749fda0218e78d16ae96b939a32ddc07">IBAMR::IBStrategySet</a>, and <a class="el" href="classIBAMR_1_1IMPMethod.html#a4972dae87ff8f57ff819cf6b9247dad6">IBAMR::IMPMethod</a>.</p>

</div>
</div>
<a id="af8f31cfe38a0690a629fcbeb7ad89888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f31cfe38a0690a629fcbeb7ad89888">&#9670;&nbsp;</a></span>initializeLevelData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::initializeLevelData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>init_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>can_be_refined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>old_level</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt;DIM&gt;&#160;&gt;(NULL)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allocate_data</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize data on a new level after it is inserted into an AMR patch hierarchy by the gridding algorithm. The level number indicates that of the new level.</p>
<p>Generally, when data is set, it is interpolated from coarser levels in the hierarchy. If the old level pointer in the argument list is non-null, then data is copied from the old level to the new level on regions of intersection between those levels before interpolation occurs. In this case, the level number must match that of the old level. The specific operations that occur when initializing level data are determined by the particular solution methods in use; i.e., in the subclass of this abstract base class.</p>
<p>The boolean argument initial_time indicates whether the level is being introduced for the first time (i.e., at initialization time), or after some regrid process during the calculation beyond the initial hierarchy construction. This information is provided since the initialization of the data may be different in each of those circumstances. The can_be_refined boolean argument indicates whether the level is the finest allowable level in the hierarchy. </p>

</div>
</div>
<a id="a6f8d89482d4bdafc824307cc21c728c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8d89482d4bdafc824307cc21c728c9">&#9670;&nbsp;</a></span>resetHierarchyConfiguration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::resetHierarchyConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After hierarchy levels have changed and data has been initialized on the new levels, this routine can be used to reset any information needed by the solution method that is particular to the hierarchy configuration. For example, the solution procedure may cache communication schedules to amortize the cost of data movement on the AMR patch hierarchy. This function will be called by the gridding algorithm after the initialization occurs so that the algorithm-specific subclass can reset such things. Also, if the solution method must make the solution consistent across multiple levels after the hierarchy is changed, this process may be invoked by this routine. Of course the details of these processes are determined by the particular solution methods in use.</p>
<p>The level number arguments indicate the coarsest and finest levels in the current hierarchy configuration that have changed. It should be assumed that all intermediate levels have changed as well. </p>

</div>
</div>
<a id="ac201b9cd28087aa92f9c1370f147667a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac201b9cd28087aa92f9c1370f147667a">&#9670;&nbsp;</a></span>applyGradientDetector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::applyGradientDetector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>uses_richardson_extrapolation_too</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set integer tags to "one" in cells where refinement of the given level should occur according to some user-supplied gradient criteria. The double time argument is the regrid time. The integer "tag_index" argument is the patch descriptor index of the cell-centered integer tag array on each patch in the hierarchy. The boolean argument initial_time indicates whether the level is being subject to refinement at the initial simulation time. If it is false, then the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. Typically, this information is passed to the user's patch tagging routines since the error estimator or gradient detector may be different in each case.</p>
<p>The boolean uses_richardson_extrapolation_too is true when Richardson extrapolation error estimation is used in addition to the gradient detector, and false otherwise. This argument helps the user to manage multiple regridding criteria.</p>
<p>This routine is only when gradient detector is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="aaf8528c130bfe5261e668c29e79d70f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8528c130bfe5261e668c29e79d70f8">&#9670;&nbsp;</a></span>getINSHierarchyIntegrator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBAMR_1_1INSHierarchyIntegrator.html">INSHierarchyIntegrator</a>* IBAMR::IBStrategy::getINSHierarchyIntegrator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the <a class="el" href="classIBAMR_1_1INSHierarchyIntegrator.html" title="Class INSHierarchyIntegrator provides an abstract interface for a time integrator for the incompressi...">INSHierarchyIntegrator</a> object being used with the <a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html" title="Class IBHierarchyIntegrator provides an abstract interface for a time integrator for various versions...">IBHierarchyIntegrator</a> class registered with this <a class="el" href="classIBAMR_1_1IBStrategy.html" title="Class IBStrategy provides a generic interface for specifying the implementation details of a particul...">IBStrategy</a> object. </p>

</div>
</div>
<a id="ad93b6eb627f166c20aaae098ccd50865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93b6eb627f166c20aaae098ccd50865">&#9670;&nbsp;</a></span>getVelocityHierarchyDataOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsReal.html">SAMRAI::math::HierarchyDataOpsReal</a>&lt;NDIM, <a class="el" href="classdouble.html">double</a>&gt; &gt; IBAMR::IBStrategy::getVelocityHierarchyDataOps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the HierarchyDataOpsReal object associated with velocity-like variables. </p>

</div>
</div>
<a id="a142514561f6e1ad3fc61751baafd1627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142514561f6e1ad3fc61751baafd1627">&#9670;&nbsp;</a></span>getPressureHierarchyDataOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsReal.html">SAMRAI::math::HierarchyDataOpsReal</a>&lt;NDIM, <a class="el" href="classdouble.html">double</a>&gt; &gt; IBAMR::IBStrategy::getPressureHierarchyDataOps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the HierarchyDataOpsReal object associated with pressure-like variables. </p>

</div>
</div>
<a id="ad4042917a2e54b8829948cb09f10e793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4042917a2e54b8829948cb09f10e793">&#9670;&nbsp;</a></span>getHierarchyMathOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1HierarchyMathOps.html">IBTK::HierarchyMathOps</a>&gt; IBAMR::IBStrategy::getHierarchyMathOps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to a HierarchyMathOps object. </p>

</div>
</div>
<a id="acb81b46bc281abe474cfad82551e176b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb81b46bc281abe474cfad82551e176b">&#9670;&nbsp;</a></span>registerVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBStrategy::registerVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>current_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>new_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>scratch_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_ghosts</em> = <code><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt;&#160;NDIM&#160;&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>coarsen_name</em> = <code>&quot;NO_COARSEN&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>refine_name</em> = <code>&quot;NO_REFINE&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1CartGridFunction.html">IBTK::CartGridFunction</a> &gt;&#160;</td>
          <td class="paramname"><em>init_fcn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>register_for_restart</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a state variable with the integrator. When a refine operator is specified, the data for the variable are automatically maintained as the patch hierarchy evolves.</p>
<p>All state variables are registered with three contexts: current, new, and scratch. The current context of a state variable is maintained from time step to time step and, if the necessary coarsen and refine operators are specified, as the patch hierarchy evolves. </p>

</div>
</div>
<a id="aade8a368e03183d51d470c8d98c3c742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade8a368e03183d51d470c8d98c3c742">&#9670;&nbsp;</a></span>registerVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBStrategy::registerVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghosts</em> = <code><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt;&#160;NDIM&#160;&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">SAMRAI::hier::VariableContext</a> &gt;&#160;</td>
          <td class="paramname"><em>ctx</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">SAMRAI::hier::VariableContext</a>&#160;&gt;(nullptr)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>register_for_restart</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a variable with the integrator that may not be maintained from time step to time step.</p>
<p>By default, variables are registered with the scratch context, which is deallocated after each time step. </p>

</div>
</div>
<a id="a6ff41aa031a85b31866aa1bd7c832cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff41aa031a85b31866aa1bd7c832cb9">&#9670;&nbsp;</a></span>registerGhostfillRefineAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBStrategy::registerGhostfillRefineAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>ghostfill_alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>ghostfill_patch_strategy</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a ghost cell-filling refine algorithm. </p>

</div>
</div>
<a id="a765846726a9e33a0b31e0549b699515f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765846726a9e33a0b31e0549b699515f">&#9670;&nbsp;</a></span>registerProlongRefineAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBStrategy::registerProlongRefineAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>prolong_alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>prolong_patch_strategy</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a data-prolonging refine algorithm. </p>

</div>
</div>
<a id="a4217ccceea177b4109b528a85c383a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4217ccceea177b4109b528a85c383a2b">&#9670;&nbsp;</a></span>registerCoarsenAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBStrategy::registerCoarsenAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html">SAMRAI::xfer::CoarsenAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>coarsen_alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html">SAMRAI::xfer::CoarsenPatchStrategy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>coarsen_patch_strategy</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a coarsen algorithm. </p>

</div>
</div>
<a id="a08b456e15f5214d3bfe529372ad346c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b456e15f5214d3bfe529372ad346c6">&#9670;&nbsp;</a></span>getGhostfillRefineAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt;NDIM&gt; &gt; IBAMR::IBStrategy::getGhostfillRefineAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get ghost cell-filling refine algorithm. </p>

</div>
</div>
<a id="aac1cd6f821e6a0e6a82c2a91577fa331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1cd6f821e6a0e6a82c2a91577fa331">&#9670;&nbsp;</a></span>getProlongRefineAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt;NDIM&gt; &gt; IBAMR::IBStrategy::getProlongRefineAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get data-prolonging refine algorithm. </p>

</div>
</div>
<a id="a1ed62275cf737a96421674efa382cde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed62275cf737a96421674efa382cde2">&#9670;&nbsp;</a></span>getCoarsenAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html">SAMRAI::xfer::CoarsenAlgorithm</a>&lt;NDIM&gt; &gt; IBAMR::IBStrategy::getCoarsenAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get coarsen algorithm. </p>

</div>
</div>
<a id="ac9ca1b192c934db6db9cc266ff5fc1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ca1b192c934db6db9cc266ff5fc1f0">&#9670;&nbsp;</a></span>getGhostfillRefineSchedules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;NDIM&gt; &gt; &gt;&amp; IBAMR::IBStrategy::getGhostfillRefineSchedules </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get ghost cell-filling refine schedules. </p>

</div>
</div>
<a id="ac4567af6f8f85c8fc935e3cf90933710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4567af6f8f85c8fc935e3cf90933710">&#9670;&nbsp;</a></span>getProlongRefineSchedules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;NDIM&gt; &gt; &gt;&amp; IBAMR::IBStrategy::getProlongRefineSchedules </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get data-prolonging refine schedules.</p>
<dl class="section note"><dt>Note</dt><dd>These schedules are allocated only for level numbers &gt;= 1. </dd></dl>

</div>
</div>
<a id="aff556dcdcf10f9a7b04d8aae07dd7b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff556dcdcf10f9a7b04d8aae07dd7b6d">&#9670;&nbsp;</a></span>getCoarsenSchedules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt;NDIM&gt; &gt; &gt;&amp; IBAMR::IBStrategy::getCoarsenSchedules </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get coarsen schedules.</p>
<dl class="section note"><dt>Note</dt><dd>These schedules are allocated only for level numbers &gt;= 1. </dd></dl>

</div>
</div>
<a id="a5263bfe8622e41d1a2df35f9803a5ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5263bfe8622e41d1a2df35f9803a5ca1">&#9670;&nbsp;</a></span>getLevelDt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::getLevelDt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dt_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine time increment to advance data on level. The recompute_dt option specifies whether to compute the timestep using the current level data or to return the value stored by the time integrator. The default true setting means the timestep will be computed if no value is supplied. <br  />
</p>
<p>This routine is only when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="a9e4e8a35a6b5ab6ec7e14f040e718adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4e8a35a6b5ab6ec7e14f040e718adf">&#9670;&nbsp;</a></span>advanceLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::advanceLevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>first_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>last_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>regrid_advance</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance data on all patches on specified patch level from current time (current_time) to new time (new_time). This routine is called only during time-dependent regridding procedures, such as Richardson extrapolation. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. The boolean arguments are used to determine the state of the algorithm and the data when the advance routine is called. Note that this advance function is also used during normal time integration steps.</p>
<p>When this function is called, the level data required to begin the advance must be allocated and be defined appropriately. Typically, this is equivalent to what is needed to initialize a new level after regridding. Upon exiting this routine, both current and new data may exist on the level. This data is needed until level synchronization occurs, in general. Current and new data may be reset by calling the member function <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a97641642baa1b5c67749fada52b12341">resetTimeDependentData()</a>.</p>
<p>This routine is called from two different points within the Richardson exptrapolation process: to advance a temporary level that is coarser than the hierarchy level on which error estimation is performed, and to advance the hierarchy level itself. In the first case, the values of the boolean flags are:</p>
<ul>
<li><b>first_step</b> = true.</li>
<li><b>last_step</b> = true.</li>
<li><b>regrid_advance</b> = true.</li>
</ul>
<p>In the second case, the values of the boolean flags are:</p>
<ul>
<li><b>first_step</b> (when regridding during time integration sequence) = true when the level is not coarsest level to synchronize immediately before the regridding process; else, false. (when generating initial hierarchy construction) = true, even though there may be multiple advance steps.</li>
<li><b>last_step</b> = true when the advance is the last in the Richardson extrapolation step sequence; else false.</li>
<li><b>regrid_advance</b> = true. </li>
</ul>

</div>
</div>
<a id="a97641642baa1b5c67749fada52b12341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97641642baa1b5c67749fada52b12341">&#9670;&nbsp;</a></span>resetTimeDependentData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::resetTimeDependentData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>can_be_refined</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset time-dependent data storage for the specified patch level.</p>
<p>This routine only applies when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="af6f563618437d3a5231d35eb6937fcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f563618437d3a5231d35eb6937fcd1">&#9670;&nbsp;</a></span>resetDataToPreadvanceState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::resetDataToPreadvanceState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset data on the patch level by destroying all patch data other than that which is needed to initialize the solution on that level. In other words, this is the data needed to begin a time integration step on the level.</p>
<p>This routine is only when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="a81e5b7b5d98eaf7221b5088b0d12a2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e5b7b5d98eaf7221b5088b0d12a2a8">&#9670;&nbsp;</a></span>applyRichardsonExtrapolation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::applyRichardsonExtrapolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>deltat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>error_coarsen_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>uses_gradient_detector_too</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set integer tags to "one" in cells where refinement of the given level should occur according to some user-supplied Richardson extrapolation criteria. The "error_data_time" argument is the regrid time. The "deltat" argument is the time increment to advance the solution on the level to be refined. Note that that level is finer than the level in the argument list, in general. The ratio between the argument level and the actual hierarchy level is given by the integer "coarsen ratio".</p>
<p>The integer "tag_index" argument is the patch descriptor index of the cell-centered integer tag array on each patch in the hierarchy.</p>
<p>The boolean argument initial_time indicates whether the level is being subject to refinement at the initial simulation time. If it is false, then the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. Typically, this information is passed to the user's patch tagging routines since the application of the Richardson extrapolation process may be different in each case.</p>
<p>The boolean uses_gradient_detector_too is true when a gradient detector procedure is used in addition to Richardson extrapolation, and false otherwise. This argument helps the user to manage multiple regridding criteria.</p>
<p>This routine is only when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="a9e3ec75cca71a27c6599a48ac6cd37ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3ec75cca71a27c6599a48ac6cd37ea">&#9670;&nbsp;</a></span>coarsenDataForRichardsonExtrapolation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::coarsenDataForRichardsonExtrapolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>coarsen_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>before_advance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen solution data from level to coarse_level for Richardson extrapolation. Note that this routine will be called twice during the Richardson extrapolation error estimation process, once to set data on the coarser level and once to coarsen data from after advancing the fine level. The init_coarse_level boolean argument indicates whether data is set on the coarse level by coarsening the "old" time level solution or by coarsening the "new" solution on the fine level (i.e., after it has been advanced).</p>
<p>This routine is only when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afcb64a0ec7ff2fe5daf3f9a25b5d1a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb64a0ec7ff2fe5daf3f9a25b5d1a1f">&#9670;&nbsp;</a></span>SOURCE_SYSTEM_NAME</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBAMR::IBFEMethod::SOURCE_SYSTEM_NAME</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70902840be3aa61d3797138d819a6f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70902840be3aa61d3797138d819a6f33">&#9670;&nbsp;</a></span>d_fe_data_manager_db</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a>&gt; IBAMR::IBFEMethod::d_fe_data_manager_db</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cached input databases. </p>

</div>
</div>
<a id="af475cd16c825edddad3d0d5abd6b7829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af475cd16c825edddad3d0d5abd6b7829">&#9670;&nbsp;</a></span>d_source_system_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBAMR::IBFEMethod::d_source_system_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4928a9db1ed48208ec0878c7332a91e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4928a9db1ed48208ec0878c7332a91e8">&#9670;&nbsp;</a></span>d_skip_initial_workload_log</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBFEMethod::d_skip_initial_workload_log = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether or not the initial (i.e., before the regrid prior to timestepping) workload calculations should be logged. This output is generally not stable between machines and so this is usually disabled in tests. </p>

</div>
</div>
<a id="abcfc661159c028247f8e0628e108af24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfc661159c028247f8e0628e108af24">&#9670;&nbsp;</a></span>d_started_time_integration</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBFEMethod::d_started_time_integration = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether or not we have started time integration. This is only used to determine whether or not we print some initial logging output: see d_skip_initial_workload_log for more information. </p>

</div>
</div>
<a id="a19f3fd3541f49dc16f44c71ed6091273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f3fd3541f49dc16f44c71ed6091273">&#9670;&nbsp;</a></span>d_use_scratch_hierarchy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBFEMethod::d_use_scratch_hierarchy = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Boolean controlling whether or not the scratch hierarchy should be used. </p>

</div>
</div>
<a id="ad13aa22a9be802d10049f67d40e59e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13aa22a9be802d10049f67d40e59e66">&#9670;&nbsp;</a></span>d_hierarchy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt;NDIM&gt; &gt; IBAMR::IBFEMethod::d_hierarchy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointers to the patch hierarchy and gridding algorithm objects associated with this object. </p>

</div>
</div>
<a id="af5f9ba56e0f7484585f99b73a3e0c6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f9ba56e0f7484585f99b73a3e0c6c9">&#9670;&nbsp;</a></span>d_gridding_alg</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt;NDIM&gt; &gt; IBAMR::IBFEMethod::d_gridding_alg</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a27eee58496ffcb52a02bfd8dbbdd1642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27eee58496ffcb52a02bfd8dbbdd1642">&#9670;&nbsp;</a></span>d_is_initialized</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBFEMethod::d_is_initialized = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7815e089eae935d5ac862b1b585cfb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7815e089eae935d5ac862b1b585cfb33">&#9670;&nbsp;</a></span>d_eulerian_data_cache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classIBTK_1_1SAMRAIDataCache.html">IBTK::SAMRAIDataCache</a>&gt; IBAMR::IBFEMethod::d_eulerian_data_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scratch data caching object. Used both by this class and the FEDataManager objects responsible for working on the primary partitioning. </p>

</div>
</div>
<a id="a832bab3dbef0579511da54df87481a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832bab3dbef0579511da54df87481a3f">&#9670;&nbsp;</a></span>d_lagrangian_workload_current_idx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBAMR::IBFEMethod::d_lagrangian_workload_current_idx = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cb55e6d03dcd724b003e471f1e39a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb55e6d03dcd724b003e471f1e39a92">&#9670;&nbsp;</a></span>d_lagrangian_workload_new_idx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBAMR::IBFEMethod::d_lagrangian_workload_new_idx = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fcdf661e05dbddefb8c1bfd01165b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fcdf661e05dbddefb8c1bfd01165b17">&#9670;&nbsp;</a></span>d_lagrangian_workload_scratch_idx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBAMR::IBFEMethod::d_lagrangian_workload_scratch_idx = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac70e432b42021a9ef9439044eb17712e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70e432b42021a9ef9439044eb17712e">&#9670;&nbsp;</a></span>d_lagrangian_workload_var</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a>&lt;NDIM&gt; &gt; IBAMR::IBFEMethod::d_lagrangian_workload_var</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5c6c8d79e57cb3854fdffd05cbf6bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c6c8d79e57cb3854fdffd05cbf6bf6">&#9670;&nbsp;</a></span>d_lagrangian_workload_coarsen_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBAMR::IBFEMethod::d_lagrangian_workload_coarsen_type = &quot;CONSERVATIVE_COARSEN&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a527d026005223f2972fa80890cd3651c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527d026005223f2972fa80890cd3651c">&#9670;&nbsp;</a></span>d_lagrangian_workload_refine_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBAMR::IBFEMethod::d_lagrangian_workload_refine_type = &quot;CONSERVATIVE_LINEAR_REFINE&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a67c599bcfcedbc7576e92a07c8fc0bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c599bcfcedbc7576e92a07c8fc0bf9">&#9670;&nbsp;</a></span>d_max_level_number</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBAMR::IBFEMethod::d_max_level_number = <a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">IBTK::invalid_level_number</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum level number in the patch hierarchy. </p>

</div>
</div>
<a id="a2b6a07f04dcd6c258e1751b42c04b32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6a07f04dcd6c258e1751b42c04b32f">&#9670;&nbsp;</a></span>d_patch_association_cfl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBAMR::IBFEMethod::d_patch_association_cfl = 0.75</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>CFL-like number used to determine when we should call <a class="el" href="classIBAMR_1_1IBFEMethod.html#af1ad590435a995066141c22f5cf2b50b">reinitElementMappings()</a> based on maximum structure point displacement. More exactly: this class will call that function if the maximum displacement of the structure (calculated by comparing the position vector as of the last reassociation to the current position vector) exceeds dx * d_patch_association_cfl, where dx is the smallest Eulerian cell width.</p>
<p>Note that this is not a regridding, in the sense that the grid changes: instead only the association between patches and elements changes.</p>
<p>@seealso IBHierarchyIntegrator::d_regrid_cfl_interval</p>
<dl class="section note"><dt>Note</dt><dd>Most applications use a fluid solver regrid value of 0.5 - i.e., the default value given here is a conservative choice. </dd></dl>

</div>
</div>
<a id="a2a1325c6c9e2019537356ca82fb2a3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1325c6c9e2019537356ca82fb2a3cb">&#9670;&nbsp;</a></span>d_part_is_active</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; IBAMR::IBFEMethod::d_part_is_active { true }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indexing information determining whether a given part is active or not. The default state for each part is to be active. Parts are active unless inactivated via <a class="el" href="classIBAMR_1_1IBFEMethod.html#a200b1b8997e92a13df67fb9833602c11">inactivateLagrangianStructure()</a>. </p>

</div>
</div>
<a id="a6f651fc2de5a11c9989ad8d40b78123c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f651fc2de5a11c9989ad8d40b78123c">&#9670;&nbsp;</a></span>d_primary_fe_data_managers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classIBTK_1_1FEDataManager.html">IBTK::FEDataManager</a>*&gt; IBAMR::IBFEMethod::d_primary_fe_data_managers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>FEDataManager objects associated with the primary hierarchy (i.e., d_hierarchy). These are used by some other objects (such as <a class="el" href="classIBAMR_1_1IBFEPostProcessor.html" title="Class IBFEPostProcessor is a generic interface for specifying the implementation details of a particu...">IBFEPostProcessor</a>); <a class="el" href="classIBAMR_1_1IBFEMethod.html" title="Class IBFEMethod is an implementation of the abstract base class IBStrategy that provides functionali...">IBFEMethod</a> keeps them up to date (i.e., reinitializing data after regrids). </p>

</div>
</div>
<a id="a5b641354628b04baf0ab7c0c35cedc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b641354628b04baf0ab7c0c35cedc7b">&#9670;&nbsp;</a></span>d_scratch_fe_data_managers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classIBTK_1_1FEDataManager.html">IBTK::FEDataManager</a>*&gt; IBAMR::IBFEMethod::d_scratch_fe_data_managers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>FEDataManager objects that use the scratch hierarchy instead of d_hierarchy. These are only used internally by <a class="el" href="classIBAMR_1_1IBFEMethod.html" title="Class IBFEMethod is an implementation of the abstract base class IBStrategy that provides functionali...">IBFEMethod</a> and are not intended to be accessed by any other object. </p>

</div>
</div>
<a id="ad39cffd776f9be31da9c69c786191e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39cffd776f9be31da9c69c786191e6b">&#9670;&nbsp;</a></span>d_active_fe_data_managers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classIBTK_1_1FEDataManager.html">IBTK::FEDataManager</a>*&gt; IBAMR::IBFEMethod::d_active_fe_data_managers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The FEDataManager objects that are actually used in computations. This vector will be equal to either d_primary_fe_data_managers or d_scratch_fe_data_managers, dependent on which is actually used in IB calculations. </p>

</div>
</div>
<a id="a52f23e5e904a79c441e8ca88fffe908b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f23e5e904a79c441e8ca88fffe908b">&#9670;&nbsp;</a></span>d_ghost_data_accumulator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classIBTK_1_1SAMRAIGhostDataAccumulator.html">IBTK::SAMRAIGhostDataAccumulator</a>&gt; IBAMR::IBFEMethod::d_ghost_data_accumulator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad95090469df737a843f7df48b70eef58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95090469df737a843f7df48b70eef58">&#9670;&nbsp;</a></span>d_prolongation_schedules</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::pair&lt;<a class="el" href="classint.html">int</a>, std::pair&lt;<a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>&gt; &gt;, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;NDIM&gt; &gt; &gt; IBAMR::IBFEMethod::d_prolongation_schedules</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Schedules for prolonging data during spreading. The keys are the level number, the patch data index for the coarse level data, and the patch data index which will be filled with fine level data. </p>

</div>
</div>
<a id="a9c1fe0de6f7c9e118b0608ea41834805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1fe0de6f7c9e118b0608ea41834805">&#9670;&nbsp;</a></span>d_ghosts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt;NDIM&gt; IBAMR::IBFEMethod::d_ghosts = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a79fee7da573eebd030472119b8fcb8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fee7da573eebd030472119b8fcb8ce">&#9670;&nbsp;</a></span>d_Q_systems</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::ExplicitSystem*&gt; IBAMR::IBFEMethod::d_Q_systems</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Vectors of pointers to the systems for each part (for sources; other systems are handled by the base class). </p>

</div>
</div>
<a id="aa74e1788a37827b9d1d664f8bdd283c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74e1788a37827b9d1d664f8bdd283c7">&#9670;&nbsp;</a></span>d_Q_vecs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classIBTK_1_1LibMeshSystemVectors.html">IBTK::LibMeshSystemVectors</a>&gt; IBAMR::IBFEMethod::d_Q_vecs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Object managing access to <a class="el" href="namespacelibMesh.html">libMesh</a> system vectors for the source/sink strength. </p>

</div>
</div>
<a id="af58a540ada9319a90fa16ee265251382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58a540ada9319a90fa16ee265251382">&#9670;&nbsp;</a></span>d_X_IB_vecs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classIBTK_1_1LibMeshSystemIBVectors.html">IBTK::LibMeshSystemIBVectors</a>&gt; IBAMR::IBFEMethod::d_X_IB_vecs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Object managing access to <a class="el" href="namespacelibMesh.html">libMesh</a> system vectors for the position that include IB ghosting information. </p>

</div>
</div>
<a id="ab22421beb05aa334d30438a631ae3944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22421beb05aa334d30438a631ae3944">&#9670;&nbsp;</a></span>d_U_IB_vecs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classIBTK_1_1LibMeshSystemIBVectors.html">IBTK::LibMeshSystemIBVectors</a>&gt; IBAMR::IBFEMethod::d_U_IB_vecs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Object managing access to <a class="el" href="namespacelibMesh.html">libMesh</a> system vectors for the velocity that include IB ghosting information. </p>

</div>
</div>
<a id="aed8ecb246892dd0b3f7cae22a06fcf48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8ecb246892dd0b3f7cae22a06fcf48">&#9670;&nbsp;</a></span>d_F_IB_vecs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classIBTK_1_1LibMeshSystemIBVectors.html">IBTK::LibMeshSystemIBVectors</a>&gt; IBAMR::IBFEMethod::d_F_IB_vecs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Object managing access to <a class="el" href="namespacelibMesh.html">libMesh</a> system vectors for the force that include IB ghosting information. </p>

</div>
</div>
<a id="aed4cf94f6e039e50a33712c3e6263674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4cf94f6e039e50a33712c3e6263674">&#9670;&nbsp;</a></span>d_Q_IB_vecs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classIBTK_1_1LibMeshSystemIBVectors.html">IBTK::LibMeshSystemIBVectors</a>&gt; IBAMR::IBFEMethod::d_Q_IB_vecs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Object managing access to <a class="el" href="namespacelibMesh.html">libMesh</a> system vectors for the source/sink strength that include IB ghosting information. </p>

</div>
</div>
<a id="a4b2351db7d18e3f0bab789ee1a895208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2351db7d18e3f0bab789ee1a895208">&#9670;&nbsp;</a></span>d_default_interp_spec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">IBTK::FEDataManager::InterpSpec</a> IBAMR::IBFEMethod::d_default_interp_spec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>IBFE method parameters. </p>

</div>
</div>
<a id="a47d6b308db258730b3bdbe0583fe05de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d6b308db258730b3bdbe0583fe05de">&#9670;&nbsp;</a></span>d_default_spread_spec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">IBTK::FEDataManager::SpreadSpec</a> IBAMR::IBFEMethod::d_default_spread_spec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa89ccb95c318a52f767a1e65be3b0509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89ccb95c318a52f767a1e65be3b0509">&#9670;&nbsp;</a></span>d_default_workload_spec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structIBTK_1_1FEDataManager_1_1WorkloadSpec.html">IBTK::FEDataManager::WorkloadSpec</a> IBAMR::IBFEMethod::d_default_workload_spec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3d2ff0b4f1a17233bfddbc73fba9add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d2ff0b4f1a17233bfddbc73fba9add">&#9670;&nbsp;</a></span>d_workload_spec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structIBTK_1_1FEDataManager_1_1WorkloadSpec.html">IBTK::FEDataManager::WorkloadSpec</a>&gt; IBAMR::IBFEMethod::d_workload_spec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa56c3a20e1af0c3c1c09feb46afba78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56c3a20e1af0c3c1c09feb46afba78d">&#9670;&nbsp;</a></span>d_interp_spec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">IBTK::FEDataManager::InterpSpec</a>&gt; IBAMR::IBFEMethod::d_interp_spec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47d00cc6c57a09296fe84d972e16ad3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d00cc6c57a09296fe84d972e16ad3d">&#9670;&nbsp;</a></span>d_spread_spec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">IBTK::FEDataManager::SpreadSpec</a>&gt; IBAMR::IBFEMethod::d_spread_spec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f0791dd616691a6c9a69f9ebd03a2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0791dd616691a6c9a69f9ebd03a2cc">&#9670;&nbsp;</a></span>d_split_normal_force</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBFEMethod::d_split_normal_force = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af46270df95673276b2241bdf33591de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46270df95673276b2241bdf33591de2">&#9670;&nbsp;</a></span>d_split_tangential_force</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBFEMethod::d_split_tangential_force = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2edb74126decfd10594c2e78fffc493a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2edb74126decfd10594c2e78fffc493a">&#9670;&nbsp;</a></span>d_use_jump_conditions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBFEMethod::d_use_jump_conditions = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ef71f911e3cee9e5e1336229b639c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef71f911e3cee9e5e1336229b639c4a">&#9670;&nbsp;</a></span>d_epsilon</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBAMR::IBFEMethod::d_epsilon = 0.0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Data related to handling stress normalization. </p>

</div>
</div>
<a id="a51560beee559ef60657eff3625573f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51560beee559ef60657eff3625573f39">&#9670;&nbsp;</a></span>d_has_stress_normalization_parts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBFEMethod::d_has_stress_normalization_parts = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab81c84ad162c71f755a4be2058c946fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81c84ad162c71f755a4be2058c946fb">&#9670;&nbsp;</a></span>d_stress_normalization_part</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; IBAMR::IBFEMethod::d_stress_normalization_part</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48036a31611bbfe97005c541b3dbce69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48036a31611bbfe97005c541b3dbce69">&#9670;&nbsp;</a></span>d_direct_forcing_kinematics_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBAMR_1_1IBFEDirectForcingKinematics.html">IBAMR::IBFEDirectForcingKinematics</a>&gt; &gt; IBAMR::IBFEMethod::d_direct_forcing_kinematics_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Objects used to impose direct forcing kinematics. </p>

</div>
</div>
<a id="ad11ad4ff4587cd58b39ff7a018b21571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11ad4ff4587cd58b39ff7a018b21571">&#9670;&nbsp;</a></span>d_has_lag_body_source_parts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBFEMethod::d_has_lag_body_source_parts = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions used to compute source/sink strength on the Lagrangian mesh. </p>

</div>
</div>
<a id="a686d58ab1dae79397c57166c1292829e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686d58ab1dae79397c57166c1292829e">&#9670;&nbsp;</a></span>d_lag_body_source_part</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; IBAMR::IBFEMethod::d_lag_body_source_part</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07c43be477e9a577ee51edcdc572e197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c43be477e9a577ee51edcdc572e197">&#9670;&nbsp;</a></span>d_lag_body_source_fcn_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structIBAMR_1_1IBFEMethod_1_1LagBodySourceFcnData.html">LagBodySourceFcnData</a>&gt; IBAMR::IBFEMethod::d_lag_body_source_fcn_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c2499e4dd50b618cd731f436bb945cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2499e4dd50b618cd731f436bb945cd">&#9670;&nbsp;</a></span>d_secondary_hierarchy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classIBTK_1_1SecondaryHierarchy.html">IBTK::SecondaryHierarchy</a>&gt; IBAMR::IBFEMethod::d_secondary_hierarchy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The optional second (i.e., scratch) hierarchy. This hierarchy is only used for evaluation of IB terms, i.e., in <a class="el" href="classIBAMR_1_1IBFEMethod.html#a26fd1b2a7066e20b67b9e1a06f529b5b">IBFEMethod::interpolateVelocity()</a>, <a class="el" href="classIBAMR_1_1IBFEMethod.html#a52ad97cfb324cbc9af905fcf0675ebaa">IBFEMethod::spreadForce()</a>, and <a class="el" href="classIBAMR_1_1IBFEMethod.html#a0d2819f1c6a98a728c6ee0906da62be8">IBFEMethod::spreadFluidSource()</a>. </p>

</div>
</div>
<a id="a4522824af486b0b40fcb2943f859c24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4522824af486b0b40fcb2943f859c24c">&#9670;&nbsp;</a></span>d_multistep_n_previous_steps</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> IBAMR::IBFEMethod::d_multistep_n_previous_steps = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Data related to multistep time stepping. </p>

</div>
</div>
<a id="ad35bf9fa7f88035a1aec714f478137a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35bf9fa7f88035a1aec714f478137a0">&#9670;&nbsp;</a></span>d_dt_old</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;<a class="el" href="classdouble.html">double</a>&gt; IBAMR::IBFEMethod::d_dt_old</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94a8b50c601d72471b975714c26b0420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a8b50c601d72471b975714c26b0420">&#9670;&nbsp;</a></span>COORDS_SYSTEM_NAME</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBAMR::FEMechanicsBase::COORDS_SYSTEM_NAME</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af83bca3983fbb85eb52c466f4af4b3cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83bca3983fbb85eb52c466f4af4b3cf">&#9670;&nbsp;</a></span>COORD_MAPPING_SYSTEM_NAME</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBAMR::FEMechanicsBase::COORD_MAPPING_SYSTEM_NAME</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d73bec1cb016396b79a7fdffbdf2480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d73bec1cb016396b79a7fdffbdf2480">&#9670;&nbsp;</a></span>FORCE_SYSTEM_NAME</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBAMR::FEMechanicsBase::FORCE_SYSTEM_NAME</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a247dfe4fc17cfaa19a9ff2ab9cb1f187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247dfe4fc17cfaa19a9ff2ab9cb1f187">&#9670;&nbsp;</a></span>PRESSURE_SYSTEM_NAME</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBAMR::FEMechanicsBase::PRESSURE_SYSTEM_NAME</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abbb7feb349b6d4ffa42aac3badce66a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb7feb349b6d4ffa42aac3badce66a2">&#9670;&nbsp;</a></span>VELOCITY_SYSTEM_NAME</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBAMR::FEMechanicsBase::VELOCITY_SYSTEM_NAME</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f1716ee970c4af06c105a6c5738fd3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1716ee970c4af06c105a6c5738fd3c">&#9670;&nbsp;</a></span>d_fe_projector_db</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a>&gt; IBAMR::FEMechanicsBase::d_fe_projector_db</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cached input databases. </p>

</div>
</div>
<a id="a5e7498fcf3ccb999ebdac344214f5598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7498fcf3ccb999ebdac344214f5598">&#9670;&nbsp;</a></span>d_do_log</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::FEMechanicsBase::d_do_log = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates whether the integrator should output logging messages. </p>

</div>
</div>
<a id="aea7dcd81d3fbe901e4a469ef1dfeec48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7dcd81d3fbe901e4a469ef1dfeec48">&#9670;&nbsp;</a></span>d_current_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBAMR::FEMechanicsBase::d_current_time = std::numeric_limits&lt;<a class="el" href="classdouble.html">double</a>&gt;::quiet_NaN()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7acbd009bb11b810d3bccb0b9b8771f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acbd009bb11b810d3bccb0b9b8771f4">&#9670;&nbsp;</a></span>d_new_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBAMR::FEMechanicsBase::d_new_time = std::numeric_limits&lt;<a class="el" href="classdouble.html">double</a>&gt;::quiet_NaN()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a26d3cb85fb0c81198639bbc23a0b94f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d3cb85fb0c81198639bbc23a0b94f9">&#9670;&nbsp;</a></span>d_half_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBAMR::FEMechanicsBase::d_half_time = std::numeric_limits&lt;<a class="el" href="classdouble.html">double</a>&gt;::quiet_NaN()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8617acdb69b7e0906ee2bb2b3c20886d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8617acdb69b7e0906ee2bb2b3c20886d">&#9670;&nbsp;</a></span>d_meshes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::MeshBase*&gt; IBAMR::FEMechanicsBase::d_meshes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Meshes provided to this object. These are set up and managed outside this class. These meshes are modified by <a class="el" href="classIBAMR_1_1FEMechanicsBase.html" title="Class FEMechanicsBase provides core finite element mechanics functionality and data management.">FEMechanicsBase</a> since this class creates several <a class="el" href="namespacelibMesh.html">libMesh</a> Systems (and hence stores DoF information in these meshes). </p>

</div>
</div>
<a id="ad3cd8f9c422d5bb5004b61a2d061f22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3cd8f9c422d5bb5004b61a2d061f22b">&#9670;&nbsp;</a></span>d_diagonal_system_coupling</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::CouplingMatrix IBAMR::FEMechanicsBase::d_diagonal_system_coupling</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="namespacelibMesh.html">libMesh</a> Systems set up by this system (for example, for velocity projection) consist of one variable per spatial component. By default, <a class="el" href="namespacelibMesh.html">libMesh</a> assumes that all variables in a given System couple to each other which, since we only ever solve projection problems in this class, is not the case. Hence we can save some memory by explicitly informing <a class="el" href="namespacelibMesh.html">libMesh</a> that the variables in a system only couple to themselves by providing a diagonal coupling matrix to each System. </p>

</div>
</div>
<a id="aa2faf21a6f31d637fe78eb03df7388b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2faf21a6f31d637fe78eb03df7388b1">&#9670;&nbsp;</a></span>d_equation_systems</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::unique_ptr&lt;libMesh::EquationSystems&gt; &gt; IBAMR::FEMechanicsBase::d_equation_systems</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>EquationSystems objects, one per part. These contain the actual matrices and solution vectors for each relevant <a class="el" href="namespacelibMesh.html">libMesh</a> system. </p>

</div>
</div>
<a id="ac9e536dad25c20a5cbdf9ca71192210f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e536dad25c20a5cbdf9ca71192210f">&#9670;&nbsp;</a></span>d_current_coordinates_system_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBAMR::FEMechanicsBase::d_current_coordinates_system_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a79b1143941fdacf51a19b39d978744d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b1143941fdacf51a19b39d978744d7">&#9670;&nbsp;</a></span>d_displacement_system_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBAMR::FEMechanicsBase::d_displacement_system_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a072def49b4a83ac732b8d9ab482ecfd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072def49b4a83ac732b8d9ab482ecfd4">&#9670;&nbsp;</a></span>d_force_system_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBAMR::FEMechanicsBase::d_force_system_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d84f03f21e8404377d35a1bcd374b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d84f03f21e8404377d35a1bcd374b20">&#9670;&nbsp;</a></span>d_pressure_system_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBAMR::FEMechanicsBase::d_pressure_system_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2edad6dbc9a4f0b43e9126c3901df6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2edad6dbc9a4f0b43e9126c3901df6f2">&#9670;&nbsp;</a></span>d_velocity_system_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBAMR::FEMechanicsBase::d_velocity_system_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a627864dfae227b6ad8e0d43bd4a2ee49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627864dfae227b6ad8e0d43bd4a2ee49">&#9670;&nbsp;</a></span>d_fe_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classIBTK_1_1FEData.html">IBTK::FEData</a>&gt; &gt; IBAMR::FEMechanicsBase::d_fe_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf9fad4f4b4267bbfe55b920b4c07e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9fad4f4b4267bbfe55b920b4c07e0f">&#9670;&nbsp;</a></span>d_fe_projectors</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classIBTK_1_1FEProjector.html">IBTK::FEProjector</a>&gt; &gt; IBAMR::FEMechanicsBase::d_fe_projectors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac94094a6ff8972a7ff9cbfafccfce904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94094a6ff8972a7ff9cbfafccfce904">&#9670;&nbsp;</a></span>d_X_systems</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::ExplicitSystem*&gt; IBAMR::FEMechanicsBase::d_X_systems</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Vectors of pointers to the systems for each part (for position, velocity, force, and pressure). </p>

</div>
</div>
<a id="ad0c1f623ddde5b5935c1d629e15a0c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c1f623ddde5b5935c1d629e15a0c67">&#9670;&nbsp;</a></span>d_U_systems</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::ExplicitSystem*&gt; IBAMR::FEMechanicsBase::d_U_systems</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6bb8428c2ac87a4004499076e8d035ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb8428c2ac87a4004499076e8d035ce">&#9670;&nbsp;</a></span>d_F_systems</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::ExplicitSystem*&gt; IBAMR::FEMechanicsBase::d_F_systems</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad46e7ebbf381be1b2e82f85da81df600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46e7ebbf381be1b2e82f85da81df600">&#9670;&nbsp;</a></span>d_P_systems</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::ExplicitSystem*&gt; IBAMR::FEMechanicsBase::d_P_systems</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd95057168d3fd62470a66278e564e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd95057168d3fd62470a66278e564e2b">&#9670;&nbsp;</a></span>d_X_vecs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classIBTK_1_1LibMeshSystemVectors.html">IBTK::LibMeshSystemVectors</a>&gt; IBAMR::FEMechanicsBase::d_X_vecs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Object managing access to <a class="el" href="namespacelibMesh.html">libMesh</a> system vectors for the position. </p>

</div>
</div>
<a id="af61b0b724451de7c82d80aec13151c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61b0b724451de7c82d80aec13151c3b">&#9670;&nbsp;</a></span>d_U_vecs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classIBTK_1_1LibMeshSystemVectors.html">IBTK::LibMeshSystemVectors</a>&gt; IBAMR::FEMechanicsBase::d_U_vecs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Object managing access to <a class="el" href="namespacelibMesh.html">libMesh</a> system vectors for the velocity. </p>

</div>
</div>
<a id="a744adde5b22cfd0125ce35c69e8569e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744adde5b22cfd0125ce35c69e8569e9">&#9670;&nbsp;</a></span>d_F_vecs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classIBTK_1_1LibMeshSystemVectors.html">IBTK::LibMeshSystemVectors</a>&gt; IBAMR::FEMechanicsBase::d_F_vecs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Object managing access to <a class="el" href="namespacelibMesh.html">libMesh</a> system vectors for the force. </p>

</div>
</div>
<a id="a08355808cc8e38538911f7e9752ba17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08355808cc8e38538911f7e9752ba17d">&#9670;&nbsp;</a></span>d_P_vecs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classIBTK_1_1LibMeshSystemVectors.html">IBTK::LibMeshSystemVectors</a>&gt; IBAMR::FEMechanicsBase::d_P_vecs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Object managing access to <a class="el" href="namespacelibMesh.html">libMesh</a> system vectors for the pressure. </p>

</div>
</div>
<a id="a5a5cabca2acaf985c6693069d6171cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5cabca2acaf985c6693069d6171cb7">&#9670;&nbsp;</a></span>d_fe_equation_systems_initialized</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::FEMechanicsBase::d_fe_equation_systems_initialized = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether or not the <a class="el" href="namespacelibMesh.html">libMesh</a> equation systems objects have been initialized (i.e., whether or not initializeFEEquationSystems has been called). </p>

</div>
</div>
<a id="a649b51e103095b44415401d7530467d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649b51e103095b44415401d7530467d8">&#9670;&nbsp;</a></span>d_fe_data_initialized</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::FEMechanicsBase::d_fe_data_initialized = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether or not all finite element data (including that initialized by initializeFEEquationSystems), such system matrices, is available. </p>

</div>
</div>
<a id="a2503963809669d118078e9c9cc6bd33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2503963809669d118078e9c9cc6bd33f">&#9670;&nbsp;</a></span>d_libmesh_partitioner_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIBAMR.html#ad62923877ca089bebe86fae9330c3807">LibmeshPartitionerType</a> IBAMR::FEMechanicsBase::d_libmesh_partitioner_type = <a class="el" href="namespaceIBAMR.html#ad62923877ca089bebe86fae9330c3807a297f1e08f7f28b4772400836c62e9af4">LIBMESH_DEFAULT</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of partitioner to use. See the main documentation of this class for more information. </p>

</div>
</div>
<a id="a43567ca42c8328ec8d63f1610b24aa1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43567ca42c8328ec8d63f1610b24aa1f">&#9670;&nbsp;</a></span>d_libmesh_use_amr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::FEMechanicsBase::d_libmesh_use_amr = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether or not to use AMR in the finite element discretization. This feature is not yet implemented and currently defaults to false. </p>

</div>
</div>
<a id="ac6667bc6a5cf02558031104282220f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6667bc6a5cf02558031104282220f55">&#9670;&nbsp;</a></span>d_fe_order_position</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::Order&gt; IBAMR::FEMechanicsBase::d_fe_order_position</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method parameters. </p>

</div>
</div>
<a id="adf5a6053d140420f027b2a031ee6777c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5a6053d140420f027b2a031ee6777c">&#9670;&nbsp;</a></span>d_fe_order_force</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::Order&gt; IBAMR::FEMechanicsBase::d_fe_order_force</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc9acc0478130f740019f21f2ae6861e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9acc0478130f740019f21f2ae6861e">&#9670;&nbsp;</a></span>d_fe_order_pressure</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::Order&gt; IBAMR::FEMechanicsBase::d_fe_order_pressure</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aacba715ba554133101b2cb8626085801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacba715ba554133101b2cb8626085801">&#9670;&nbsp;</a></span>d_fe_family_position</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::FEFamily&gt; IBAMR::FEMechanicsBase::d_fe_family_position</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc3d9d8d2bf45e1a95f1a5a133f79850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3d9d8d2bf45e1a95f1a5a133f79850">&#9670;&nbsp;</a></span>d_fe_family_force</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::FEFamily&gt; IBAMR::FEMechanicsBase::d_fe_family_force</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c72e0ba5f6da3aa245373984ee6a230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c72e0ba5f6da3aa245373984ee6a230">&#9670;&nbsp;</a></span>d_fe_family_pressure</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::FEFamily&gt; IBAMR::FEMechanicsBase::d_fe_family_pressure</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ad5bb9aba0c86ed05f944ecc352a778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad5bb9aba0c86ed05f944ecc352a778">&#9670;&nbsp;</a></span>d_default_quad_type_stress</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::QuadratureType&gt; IBAMR::FEMechanicsBase::d_default_quad_type_stress</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec956bdffab0c544189715b536f811de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec956bdffab0c544189715b536f811de">&#9670;&nbsp;</a></span>d_default_quad_type_force</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::QuadratureType&gt; IBAMR::FEMechanicsBase::d_default_quad_type_force</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a16f80fe33d70a19af8571a47ac877a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f80fe33d70a19af8571a47ac877a10">&#9670;&nbsp;</a></span>d_default_quad_type_pressure</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::QuadratureType&gt; IBAMR::FEMechanicsBase::d_default_quad_type_pressure</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ead02bbea07b0e7f029d91b8b71df15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ead02bbea07b0e7f029d91b8b71df15">&#9670;&nbsp;</a></span>d_default_quad_order_stress</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::Order&gt; IBAMR::FEMechanicsBase::d_default_quad_order_stress</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a628ca8d48ac4caf6a24224d986784a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628ca8d48ac4caf6a24224d986784a82">&#9670;&nbsp;</a></span>d_default_quad_order_force</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::Order&gt; IBAMR::FEMechanicsBase::d_default_quad_order_force</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c93a5f7579e56255dce86c6fc3de0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c93a5f7579e56255dce86c6fc3de0cc">&#9670;&nbsp;</a></span>d_default_quad_order_pressure</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::Order&gt; IBAMR::FEMechanicsBase::d_default_quad_order_pressure</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae35c42840b1a84d1065334ddb3b6010a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35c42840b1a84d1065334ddb3b6010a">&#9670;&nbsp;</a></span>d_use_consistent_mass_matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::FEMechanicsBase::d_use_consistent_mass_matrix = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e022ad60a097e6d6125abd9ec032853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e022ad60a097e6d6125abd9ec032853">&#9670;&nbsp;</a></span>d_allow_rules_with_negative_weights</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::FEMechanicsBase::d_allow_rules_with_negative_weights = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acfc4d2ea5fd557b3a9cb0e49fb999f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc4d2ea5fd557b3a9cb0e49fb999f9b">&#9670;&nbsp;</a></span>d_include_normal_stress_in_weak_form</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::FEMechanicsBase::d_include_normal_stress_in_weak_form = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ace2232db4e50667e0a9199fb692fee10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2232db4e50667e0a9199fb692fee10">&#9670;&nbsp;</a></span>d_include_tangential_stress_in_weak_form</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::FEMechanicsBase::d_include_tangential_stress_in_weak_form = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a67e39e59152a7f6230ef460fdb747921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e39e59152a7f6230ef460fdb747921">&#9670;&nbsp;</a></span>d_include_normal_surface_forces_in_weak_form</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::FEMechanicsBase::d_include_normal_surface_forces_in_weak_form = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae45b754515bb10ffde788e19d04b279b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45b754515bb10ffde788e19d04b279b">&#9670;&nbsp;</a></span>d_include_tangential_surface_forces_in_weak_form</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::FEMechanicsBase::d_include_tangential_surface_forces_in_weak_form = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a8050743623cbfb44ec07706ec46b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8050743623cbfb44ec07706ec46b89">&#9670;&nbsp;</a></span>d_coordinate_mapping_fcn_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1CoordinateMappingFcnData.html">CoordinateMappingFcnData</a>&gt; IBAMR::FEMechanicsBase::d_coordinate_mapping_fcn_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions used to compute the initial coordinates of the Lagrangian mesh. </p>

</div>
</div>
<a id="aac7c6fc0d3cf3452b7c5909fd6519972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7c6fc0d3cf3452b7c5909fd6519972">&#9670;&nbsp;</a></span>d_initial_velocity_fcn_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1InitialVelocityFcnData.html">InitialVelocityFcnData</a>&gt; IBAMR::FEMechanicsBase::d_initial_velocity_fcn_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions used to compute the initial coordinates of the Lagrangian mesh. </p>

</div>
</div>
<a id="a2119c71b12fea4d6f8fc429acbd6e596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2119c71b12fea4d6f8fc429acbd6e596">&#9670;&nbsp;</a></span>d_PK1_stress_fcn_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1PK1StressFcnData.html">PK1StressFcnData</a>&gt; &gt; IBAMR::FEMechanicsBase::d_PK1_stress_fcn_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions used to compute the first Piola-Kirchhoff stress tensor. </p>

</div>
</div>
<a id="acd3ce916ade64b95185668ce212405b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3ce916ade64b95185668ce212405b9">&#9670;&nbsp;</a></span>d_lag_body_force_fcn_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagBodyForceFcnData.html">LagBodyForceFcnData</a>&gt; IBAMR::FEMechanicsBase::d_lag_body_force_fcn_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions used to compute additional body and surface forces on the Lagrangian mesh. </p>

</div>
</div>
<a id="a5a44f6ee40db6c0cc1ddfd8cb93b36eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a44f6ee40db6c0cc1ddfd8cb93b36eb">&#9670;&nbsp;</a></span>d_lag_surface_pressure_fcn_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagSurfacePressureFcnData.html">LagSurfacePressureFcnData</a>&gt; IBAMR::FEMechanicsBase::d_lag_surface_pressure_fcn_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fbe44e107204bc13058a3e06b8d1944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbe44e107204bc13058a3e06b8d1944">&#9670;&nbsp;</a></span>d_lag_surface_force_fcn_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structIBAMR_1_1FEMechanicsBase_1_1LagSurfaceForceFcnData.html">LagSurfaceForceFcnData</a>&gt; IBAMR::FEMechanicsBase::d_lag_surface_force_fcn_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4f95bc19d2ffae5f4787f427f8170b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f95bc19d2ffae5f4787f427f8170b8">&#9670;&nbsp;</a></span>d_static_pressure_kappa</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBAMR::FEMechanicsBase::d_static_pressure_kappa = 0.0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Data related to handling static pressures. </p>

</div>
</div>
<a id="a939d3d7e33c6b5c803e70d723e7408c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939d3d7e33c6b5c803e70d723e7408c4">&#9670;&nbsp;</a></span>d_static_pressure_stab_param</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBAMR::FEMechanicsBase::d_static_pressure_stab_param = 0.0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a23ff40202d9365ad81274ae9bd4340fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ff40202d9365ad81274ae9bd4340fd">&#9670;&nbsp;</a></span>d_has_static_pressure_parts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::FEMechanicsBase::d_has_static_pressure_parts = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b4ca8ebfe43db5e54e30a6e666e1f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4ca8ebfe43db5e54e30a6e666e1f6a">&#9670;&nbsp;</a></span>d_static_pressure_part</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; IBAMR::FEMechanicsBase::d_static_pressure_part</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a40ca6f074bec7031ec601d78a6467f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ca6f074bec7031ec601d78a6467f6f">&#9670;&nbsp;</a></span>d_static_pressure_proj_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceIBAMR.html#a62309df2b45664a6805692d7ed20e3a9">PressureProjectionType</a>&gt; IBAMR::FEMechanicsBase::d_static_pressure_proj_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ec84a2b4ee0f0f55242c4bc84b12be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec84a2b4ee0f0f55242c4bc84b12be2">&#9670;&nbsp;</a></span>d_static_pressure_dU_dJ_fcn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aeda305fe47cf0aa2699cff49769fe49e">VolumetricEnergyDerivativeFcn</a>&gt; IBAMR::FEMechanicsBase::d_static_pressure_dU_dJ_fcn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0aeaa3c6538ec86103a924114e4896c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aeaa3c6538ec86103a924114e4896c2">&#9670;&nbsp;</a></span>d_dynamic_pressure_kappa</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBAMR::FEMechanicsBase::d_dynamic_pressure_kappa = 0.0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Data related to handling dynamic pressures. </p>

</div>
</div>
<a id="a816711fb1658133a8942bde4ab9c1d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816711fb1658133a8942bde4ab9c1d92">&#9670;&nbsp;</a></span>d_dynamic_pressure_stab_param</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBAMR::FEMechanicsBase::d_dynamic_pressure_stab_param = 0.0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6ab267bca6e8600e772790da3809902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ab267bca6e8600e772790da3809902">&#9670;&nbsp;</a></span>d_has_dynamic_pressure_parts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::FEMechanicsBase::d_has_dynamic_pressure_parts = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9879a265bf94ba77d319fc4b81bd205b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9879a265bf94ba77d319fc4b81bd205b">&#9670;&nbsp;</a></span>d_dynamic_pressure_part</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; IBAMR::FEMechanicsBase::d_dynamic_pressure_part</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ccfecd03b1edcf42f60c3146382f0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ccfecd03b1edcf42f60c3146382f0e4">&#9670;&nbsp;</a></span>d_dynamic_pressure_proj_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceIBAMR.html#a62309df2b45664a6805692d7ed20e3a9">PressureProjectionType</a>&gt; IBAMR::FEMechanicsBase::d_dynamic_pressure_proj_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0dc173bf45d43eddf7af4d7cc18da02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0dc173bf45d43eddf7af4d7cc18da02">&#9670;&nbsp;</a></span>d_dynamic_pressure_d2U_dJ2_fcn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classIBAMR_1_1FEMechanicsBase.html#aeda305fe47cf0aa2699cff49769fe49e">VolumetricEnergyDerivativeFcn</a>&gt; IBAMR::FEMechanicsBase::d_dynamic_pressure_d2U_dJ2_fcn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6f586abd18a6284f8ebad0a92bbf1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f586abd18a6284f8ebad0a92bbf1c2">&#9670;&nbsp;</a></span>d_object_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string IBAMR::FEMechanicsBase::d_object_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object name is used as a handle to databases stored in restart files and for error reporting purposes. </p>

</div>
</div>
<a id="a8b1f861aa28fc6f0b5249947993e014a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1f861aa28fc6f0b5249947993e014a">&#9670;&nbsp;</a></span>d_registered_for_restart</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::FEMechanicsBase::d_registered_for_restart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A boolean value indicating whether the class is registered with the restart database. </p>

</div>
</div>
<a id="a97c38f9e1cb13af873206424e70bc9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c38f9e1cb13af873206424e70bc9b0">&#9670;&nbsp;</a></span>d_libmesh_restart_read_dir</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string IBAMR::FEMechanicsBase::d_libmesh_restart_read_dir</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Directory and time step number to use when restarting. </p>

</div>
</div>
<a id="a5026673edcae1d5b0185078058c5ccbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5026673edcae1d5b0185078058c5ccbd">&#9670;&nbsp;</a></span>d_libmesh_restart_restore_number</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> IBAMR::FEMechanicsBase::d_libmesh_restart_restore_number</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e4848c4b2be0cd61c9a4cbe1f36f4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4848c4b2be0cd61c9a4cbe1f36f4a5">&#9670;&nbsp;</a></span>d_libmesh_restart_file_extension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string IBAMR::FEMechanicsBase::d_libmesh_restart_file_extension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Restart file type for <a class="el" href="namespacelibMesh.html">libMesh</a> equation systems (e.g. xda or xdr). </p>

</div>
</div>
<a id="aa3b7435788a1ff68e5f6f54496341011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b7435788a1ff68e5f6f54496341011">&#9670;&nbsp;</a></span>d_ib_solver</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html">IBHierarchyIntegrator</a>* IBAMR::IBStrategy::d_ib_solver = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html" title="Class IBHierarchyIntegrator provides an abstract interface for a time integrator for various versions...">IBHierarchyIntegrator</a> object that is using this strategy class. </p>

</div>
</div>
<a id="a56c7fcd98c652f7e3f4b17e0bc59388d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c7fcd98c652f7e3f4b17e0bc59388d">&#9670;&nbsp;</a></span>d_use_fixed_coupling_ops</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBStrategy::d_use_fixed_coupling_ops = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to use "fixed" Lagrangian-Eulerian coupling operators. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ibamr/<a class="el" href="IBFEMethod_8h.html">IBFEMethod.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassIBAMR_1_1IBFEMethod_html_ab87c905b3cad88a84e2d1e159999b7b1"><div class="ttname"><a href="classIBAMR_1_1IBFEMethod.html#ab87c905b3cad88a84e2d1e159999b7b1">IBAMR::IBFEMethod::IBFEMethod</a></div><div class="ttdeci">IBFEMethod()=delete</div><div class="ttdoc">Deleted default constructor.</div></div>
<div class="ttc" id="anamespaceSAMRAI_1_1tbox_html_ab84041705493761fb17a8127e3a2dca2"><div class="ttname"><a href="namespaceSAMRAI_1_1tbox.html#ab84041705493761fb17a8127e3a2dca2">SAMRAI::tbox::plog</a></div><div class="ttdeci">std::ostream plog</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
