<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: SAMRAI::hier::LayerEdgeSet&lt; DIM &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IBAMR
   &#160;<span id="projectnumber">IBAMR version 0.18.</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a></li><li class="navelem"><a class="el" href="namespaceSAMRAI_1_1hier.html">hier</a></li><li class="navelem"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSAMRAI_1_1hier_1_1LayerEdgeSet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SAMRAI::hier::LayerEdgeSet&lt; DIM &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulates a set of DLBG edges that connect two <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html" title="Encapsulates a set of LayerNode objects on the same index space.">LayerNodeSet</a> objects.  
 <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#details">More...</a></p>

<p><code>#include &lt;LayerEdgeSet.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1LayerEdgeSet_1_1CommunicationStruct.html">CommunicationStruct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data sorted by a hash.  <a href="structSAMRAI_1_1hier_1_1LayerEdgeSet_1_1CommunicationStruct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a16c7a3e816245aac62eda5fa36354ce4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a16c7a3e816245aac62eda5fa36354ce4">ParallelState</a> { <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a16c7a3e816245aac62eda5fa36354ce4adf2cc0623667ffde880ac3dc86f3021e">DISTRIBUTED</a>, 
<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a16c7a3e816245aac62eda5fa36354ce4a12c9c038f8596fbf43346a8a45541c3b">GLOBALIZED</a>
 }</td></tr>
<tr class="memdesc:a16c7a3e816245aac62eda5fa36354ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Names of parallel states.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a16c7a3e816245aac62eda5fa36354ce4">More...</a><br /></td></tr>
<tr class="separator:a16c7a3e816245aac62eda5fa36354ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c27bde9bfa42a11c1e9467be03fc9b4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1hier_1_1LayerNode.html">LayerNode</a>&lt; DIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a9c27bde9bfa42a11c1e9467be03fc9b4">Node</a></td></tr>
<tr class="separator:a9c27bde9bfa42a11c1e9467be03fc9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585fead0a5477f20a132c56d64f8d371"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1hier_1_1LayerNode.html#a7119fea22553e2e6a399f862fcd83606">Node::LocalIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a585fead0a5477f20a132c56d64f8d371">LocalIndex</a></td></tr>
<tr class="separator:a585fead0a5477f20a132c56d64f8d371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9c7ecdb5c4e0da6faa38807252324a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a></td></tr>
<tr class="memdesc:a4e9c7ecdb5c4e0da6faa38807252324a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for nodes.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4e9c7ecdb5c4e0da6faa38807252324a">More...</a><br /></td></tr>
<tr class="separator:a4e9c7ecdb5c4e0da6faa38807252324a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bff8b71e87a5ece283b9ecb18064d9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ac7bff8b71e87a5ece283b9ecb18064d9">NabrContainer</a></td></tr>
<tr class="memdesc:ac7bff8b71e87a5ece283b9ecb18064d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for neighbors.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ac7bff8b71e87a5ece283b9ecb18064d9">More...</a><br /></td></tr>
<tr class="separator:ac7bff8b71e87a5ece283b9ecb18064d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92056ee8a1bfc452f200b7793f71e4bb"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a585fead0a5477f20a132c56d64f8d371">LocalIndex</a>, <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ac7bff8b71e87a5ece283b9ecb18064d9">NabrContainer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a></td></tr>
<tr class="memdesc:a92056ee8a1bfc452f200b7793f71e4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connectivity data between two node layers.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">More...</a><br /></td></tr>
<tr class="separator:a92056ee8a1bfc452f200b7793f71e4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeb90c4d886792bf0b2879cf975c7a633"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#aeb90c4d886792bf0b2879cf975c7a633">LayerEdgeSet</a> ()</td></tr>
<tr class="memdesc:aeb90c4d886792bf0b2879cf975c7a633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#aeb90c4d886792bf0b2879cf975c7a633">More...</a><br /></td></tr>
<tr class="separator:aeb90c4d886792bf0b2879cf975c7a633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9bb616bf538d7dc6ced7976316f7f2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4b9bb616bf538d7dc6ced7976316f7f2">~LayerEdgeSet</a> (void)</td></tr>
<tr class="memdesc:a4b9bb616bf538d7dc6ced7976316f7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4b9bb616bf538d7dc6ced7976316f7f2">More...</a><br /></td></tr>
<tr class="separator:a4b9bb616bf538d7dc6ced7976316f7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7663ebeb643ca18d4692d02bd864cf3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ae7663ebeb643ca18d4692d02bd864cf3">getNodeContainer</a> (const <a class="el" href="classint.html">int</a> rank=-1) const</td></tr>
<tr class="separator:ae7663ebeb643ca18d4692d02bd864cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcacef8e09af28010219b6cf4a8560b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a2dcacef8e09af28010219b6cf4a8560b">getConnectivity</a> (const <a class="el" href="classint.html">int</a> rank=-1) const</td></tr>
<tr class="separator:a2dcacef8e09af28010219b6cf4a8560b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d988a8c62db1b88cd71aa4b78ec13c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a31d988a8c62db1b88cd71aa4b78ec13c">getBaseRefinementRatio</a> () const</td></tr>
<tr class="separator:a31d988a8c62db1b88cd71aa4b78ec13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961f129dbd11549a3ba42105ec3e13bb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a961f129dbd11549a3ba42105ec3e13bb">getHeadRefinementRatio</a> () const</td></tr>
<tr class="separator:a961f129dbd11549a3ba42105ec3e13bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5926ce17da6c6f571c200f60b5d81bd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a5926ce17da6c6f571c200f60b5d81bd8">attachPartner</a> (<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;partner)</td></tr>
<tr class="memdesc:a5926ce17da6c6f571c200f60b5d81bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutually attach to another layer-edge object to create a bi-directional set of edges.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a5926ce17da6c6f571c200f60b5d81bd8">More...</a><br /></td></tr>
<tr class="separator:a5926ce17da6c6f571c200f60b5d81bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9c8b04b73913fcbfdfaea6a55831d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#adf9c8b04b73913fcbfdfaea6a55831d5">createPartner</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;partner_base, const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> *partner_connectivity=NULL)</td></tr>
<tr class="separator:adf9c8b04b73913fcbfdfaea6a55831d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97fe570fd415cab278885d87879458c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ab97fe570fd415cab278885d87879458c">getPartner</a> ()</td></tr>
<tr class="memdesc:ab97fe570fd415cab278885d87879458c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the attached partner.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ab97fe570fd415cab278885d87879458c">More...</a><br /></td></tr>
<tr class="separator:ab97fe570fd415cab278885d87879458c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bac83443f14d8b67ccd0ba9e2a21ad9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a1bac83443f14d8b67ccd0ba9e2a21ad9">getPartner</a> () const</td></tr>
<tr class="memdesc:a1bac83443f14d8b67ccd0ba9e2a21ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the attached partner.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a1bac83443f14d8b67ccd0ba9e2a21ad9">More...</a><br /></td></tr>
<tr class="separator:a1bac83443f14d8b67ccd0ba9e2a21ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2759591af37611b264a535126585eed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ad2759591af37611b264a535126585eed">initialize</a> (<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a16c7a3e816245aac62eda5fa36354ce4">ParallelState</a> parallel_state, const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;base_layer, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;head_refinement_ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;gcw=<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt;(1), const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> *connectivity=NULL)</td></tr>
<tr class="memdesc:ad2759591af37611b264a535126585eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data defining the edge set.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ad2759591af37611b264a535126585eed">More...</a><br /></td></tr>
<tr class="separator:ad2759591af37611b264a535126585eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf4901643516469ac33a23db872ccbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#aaaf4901643516469ac33a23db872ccbe">operator=</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;r)</td></tr>
<tr class="memdesc:aaaf4901643516469ac33a23db872ccbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator duplicates edge data and reference to layer node set and sets up a similar partner relationship and parallel mode.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#aaaf4901643516469ac33a23db872ccbe">More...</a><br /></td></tr>
<tr class="separator:aaaf4901643516469ac33a23db872ccbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Algorithms for computing edge data</h2></td></tr>
<tr class="memitem:a4920ba061b955a5ab6fa49133397fd50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4920ba061b955a5ab6fa49133397fd50">findEdges</a> ()</td></tr>
<tr class="memdesc:a4920ba061b955a5ab6fa49133397fd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover and add edges between self and partner.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4920ba061b955a5ab6fa49133397fd50">More...</a><br /></td></tr>
<tr class="separator:a4920ba061b955a5ab6fa49133397fd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadc62d54f9ffc29446af95d0cf34714"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#acadc62d54f9ffc29446af95d0cf34714">bridge</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;edge_to_head, const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;edge_to_base)</td></tr>
<tr class="memdesc:acadc62d54f9ffc29446af95d0cf34714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the layer edge data by bridging the heads of two layer edges whose base nodes are identical to each other.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#acadc62d54f9ffc29446af95d0cf34714">More...</a><br /></td></tr>
<tr class="separator:acadc62d54f9ffc29446af95d0cf34714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93466b9b9c1cfa51e16733dd1205c5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ae93466b9b9c1cfa51e16733dd1205c5b">replaceNodes</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;map)</td></tr>
<tr class="memdesc:ae93466b9b9c1cfa51e16733dd1205c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace some nodes with others.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ae93466b9b9c1cfa51e16733dd1205c5b">More...</a><br /></td></tr>
<tr class="separator:ae93466b9b9c1cfa51e16733dd1205c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82333be5c13f66297d2a69a161eab592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a82333be5c13f66297d2a69a161eab592">setParallelState</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a16c7a3e816245aac62eda5fa36354ce4">ParallelState</a> parallel_state)</td></tr>
<tr class="memdesc:a82333be5c13f66297d2a69a161eab592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the parallel distribution state.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a82333be5c13f66297d2a69a161eab592">More...</a><br /></td></tr>
<tr class="separator:a82333be5c13f66297d2a69a161eab592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05141f3b5a3ab8ce366439b9b66f964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a16c7a3e816245aac62eda5fa36354ce4">ParallelState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ac05141f3b5a3ab8ce366439b9b66f964">getParallelState</a> () const</td></tr>
<tr class="separator:ac05141f3b5a3ab8ce366439b9b66f964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4f16febdef841a55c17fef1b6f9a13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#aeb4f16febdef841a55c17fef1b6f9a13">deallocateData</a> ()</td></tr>
<tr class="memdesc:aeb4f16febdef841a55c17fef1b6f9a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate internal data on nodes and neighbors.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#aeb4f16febdef841a55c17fef1b6f9a13">More...</a><br /></td></tr>
<tr class="separator:aeb4f16febdef841a55c17fef1b6f9a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff4abf0f084c7727f47cb362fde4bc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4ff4abf0f084c7727f47cb362fde4bc3">setMaxGhostCellWidth</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;gcw)</td></tr>
<tr class="memdesc:a4ff4abf0f084c7727f47cb362fde4bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the max ghost cell width used to check for box intersections.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4ff4abf0f084c7727f47cb362fde4bc3">More...</a><br /></td></tr>
<tr class="separator:a4ff4abf0f084c7727f47cb362fde4bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0333b77f7250b94e930f2525abe5244f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a0333b77f7250b94e930f2525abe5244f">getMaxGhostCellWidth</a> () const</td></tr>
<tr class="separator:a0333b77f7250b94e930f2525abe5244f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048caf45cfd1f43a8ae72d651ecc1457"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a048caf45cfd1f43a8ae72d651ecc1457">findEdges</a> (<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;a, <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;b)</td></tr>
<tr class="separator:a048caf45cfd1f43a8ae72d651ecc1457"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
For outputs, error checking and debugging.</h2></td></tr>
<tr class="memitem:a1f33d3f154233ff4ecc4010f4d5bf30a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a1f33d3f154233ff4ecc4010f4d5bf30a">d_gcw</a></td></tr>
<tr class="memdesc:a1f33d3f154233ff4ecc4010f4d5bf30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max ghost cell width.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a1f33d3f154233ff4ecc4010f4d5bf30a">More...</a><br /></td></tr>
<tr class="separator:a1f33d3f154233ff4ecc4010f4d5bf30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1224f37733f80e1bc131a7c95afd2df1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a1224f37733f80e1bc131a7c95afd2df1">d_head_ratio</a></td></tr>
<tr class="memdesc:a1224f37733f80e1bc131a7c95afd2df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Head layer refinement ratio.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a1224f37733f80e1bc131a7c95afd2df1">More...</a><br /></td></tr>
<tr class="separator:a1224f37733f80e1bc131a7c95afd2df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e383c6e5dbc9ccae2a6296aa365e430"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a6e383c6e5dbc9ccae2a6296aa365e430">d_base</a></td></tr>
<tr class="memdesc:a6e383c6e5dbc9ccae2a6296aa365e430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the base layer of nodes.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a6e383c6e5dbc9ccae2a6296aa365e430">More...</a><br /></td></tr>
<tr class="separator:a6e383c6e5dbc9ccae2a6296aa365e430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cfff8ecec6b220515af078a595e0d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a50cfff8ecec6b220515af078a595e0d8">d_cnect</a></td></tr>
<tr class="memdesc:a50cfff8ecec6b220515af078a595e0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor data.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a50cfff8ecec6b220515af078a595e0d8">More...</a><br /></td></tr>
<tr class="separator:a50cfff8ecec6b220515af078a595e0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee62ca839d1a7b0edfe23845bd1fdcac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a16c7a3e816245aac62eda5fa36354ce4">ParallelState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#aee62ca839d1a7b0edfe23845bd1fdcac">d_parallel_state</a></td></tr>
<tr class="memdesc:aee62ca839d1a7b0edfe23845bd1fdcac"><td class="mdescLeft">&#160;</td><td class="mdescRight">State flag.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#aee62ca839d1a7b0edfe23845bd1fdcac">More...</a><br /></td></tr>
<tr class="separator:aee62ca839d1a7b0edfe23845bd1fdcac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb588a17507174a5f83edaf56a591b1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#aeb588a17507174a5f83edaf56a591b1e">d_partner</a></td></tr>
<tr class="separator:aeb588a17507174a5f83edaf56a591b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f4f0b58746c0a0996deca83805ac2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a13f4f0b58746c0a0996deca83805ac2f">d_partner_is_managed</a></td></tr>
<tr class="memdesc:a13f4f0b58746c0a0996deca83805ac2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether partner is internally created and managed.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a13f4f0b58746c0a0996deca83805ac2f">More...</a><br /></td></tr>
<tr class="separator:a13f4f0b58746c0a0996deca83805ac2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c653b899eb84048f32aba081cc0e548"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4c653b899eb84048f32aba081cc0e548">d_rank</a></td></tr>
<tr class="separator:a4c653b899eb84048f32aba081cc0e548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebb33c4c1929073ab0ce39cdde3fd9a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#acebb33c4c1929073ab0ce39cdde3fd9a">d_nprocs</a></td></tr>
<tr class="separator:acebb33c4c1929073ab0ce39cdde3fd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0030ac61e4d5c53ddb214091476a5763"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a0030ac61e4d5c53ddb214091476a5763">printClassData</a> (std::ostream &amp;co, <a class="el" href="classint.html">int</a> debase_depth=0) const</td></tr>
<tr class="separator:a0030ac61e4d5c53ddb214091476a5763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da61184d137e2ba54a91b2a76254350"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a1da61184d137e2ba54a91b2a76254350">printEdgeStats</a> (std::ostream &amp;co) const</td></tr>
<tr class="separator:a1da61184d137e2ba54a91b2a76254350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53c6f3fa7718a0ca96697b7ea1a9b66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ae53c6f3fa7718a0ca96697b7ea1a9b66">checkNodeNabrCorrespondance</a> () const</td></tr>
<tr class="memdesc:ae53c6f3fa7718a0ca96697b7ea1a9b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the node and neighbor containers have a one-to-one correspondance.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ae53c6f3fa7718a0ca96697b7ea1a9b66">More...</a><br /></td></tr>
<tr class="separator:ae53c6f3fa7718a0ca96697b7ea1a9b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099ddfaa536ecbb2c12be9e88189f03b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a099ddfaa536ecbb2c12be9e88189f03b">checkNodeConsistency</a> () const</td></tr>
<tr class="memdesc:a099ddfaa536ecbb2c12be9e88189f03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the node referenced by connectivity match those in the partner's base <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html" title="Encapsulates a set of LayerNode objects on the same index space.">LayerNodeSet</a>.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a099ddfaa536ecbb2c12be9e88189f03b">More...</a><br /></td></tr>
<tr class="separator:a099ddfaa536ecbb2c12be9e88189f03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edd4f938a40d9e2fc1cb1c10451d3c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a5edd4f938a40d9e2fc1cb1c10451d3c6">checkConnectivity</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;head) const</td></tr>
<tr class="separator:a5edd4f938a40d9e2fc1cb1c10451d3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcde2d1f59377fe23991ede51281f51a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#adcde2d1f59377fe23991ede51281f51a">checkNodeConsistency</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a> &amp;local_nodes, const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> &amp;cnect, const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;head_layer)</td></tr>
<tr class="memdesc:adcde2d1f59377fe23991ede51281f51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that nodes referenced by a given connectivity object match nodes in the given node containers.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#adcde2d1f59377fe23991ede51281f51a">More...</a><br /></td></tr>
<tr class="separator:adcde2d1f59377fe23991ede51281f51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783aecea34b36549d341e4879e720483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a783aecea34b36549d341e4879e720483">getConnectivity</a> (const <a class="el" href="classint.html">int</a> rank=-1)</td></tr>
<tr class="separator:a783aecea34b36549d341e4879e720483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ed9a7bb90888680582eac2f8ee9fcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ad9ed9a7bb90888680582eac2f8ee9fcc">deallocateDataSelf</a> ()</td></tr>
<tr class="memdesc:ad9ed9a7bb90888680582eac2f8ee9fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate internal data but do not touch partner's data.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ad9ed9a7bb90888680582eac2f8ee9fcc">More...</a><br /></td></tr>
<tr class="separator:ad9ed9a7bb90888680582eac2f8ee9fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c78a6a79147d094009582bf3d8aabf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a9c78a6a79147d094009582bf3d8aabf3">allocateConnectivity</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a> &amp;node_container, <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> &amp;cnect) const</td></tr>
<tr class="memdesc:a9c78a6a79147d094009582bf3d8aabf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a list of neighbors for every node in a given node container.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a9c78a6a79147d094009582bf3d8aabf3">More...</a><br /></td></tr>
<tr class="separator:a9c78a6a79147d094009582bf3d8aabf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8c3300ab82104c50224e1af540d8dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a6f8c3300ab82104c50224e1af540d8dc">bridge_discoverEdges</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;edge_to_head, const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;edge_to_base, std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a585fead0a5477f20a132c56d64f8d371">LocalIndex</a>, <a class="el" href="structSAMRAI_1_1hier_1_1LayerEdgeSet_1_1CommunicationStruct.html">CommunicationStruct</a> &gt; &amp;mesg_to_owners, const <a class="el" href="classbool.html">bool</a> ignore_self_overlap)</td></tr>
<tr class="memdesc:a6f8c3300ab82104c50224e1af540d8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover phase of bridging.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a6f8c3300ab82104c50224e1af540d8dc">More...</a><br /></td></tr>
<tr class="separator:a6f8c3300ab82104c50224e1af540d8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8946fda2213a23a302a741f591a4c806"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a8946fda2213a23a302a741f591a4c806">bridge_shareEdges</a> (std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a585fead0a5477f20a132c56d64f8d371">LocalIndex</a>, <a class="el" href="structSAMRAI_1_1hier_1_1LayerEdgeSet_1_1CommunicationStruct.html">CommunicationStruct</a> &gt; &amp;mesg_to_owners)</td></tr>
<tr class="memdesc:a8946fda2213a23a302a741f591a4c806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Share phase of bridging.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a8946fda2213a23a302a741f591a4c806">More...</a><br /></td></tr>
<tr class="separator:a8946fda2213a23a302a741f591a4c806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed723e1e58affa56f25bbb3b1286de0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a7ed723e1e58affa56f25bbb3b1286de0">findEdges_serial</a> (<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;other)</td></tr>
<tr class="memdesc:a7ed723e1e58affa56f25bbb3b1286de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover and add edges between self and another, including remote edges.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a7ed723e1e58affa56f25bbb3b1286de0">More...</a><br /></td></tr>
<tr class="separator:a7ed723e1e58affa56f25bbb3b1286de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658e6e3737e0a5fc5b82f02fc431c247"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a658e6e3737e0a5fc5b82f02fc431c247">findEdges_quadratic</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> &amp;other)</td></tr>
<tr class="memdesc:a658e6e3737e0a5fc5b82f02fc431c247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover and add edges between self and another, including remote edges.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a658e6e3737e0a5fc5b82f02fc431c247">More...</a><br /></td></tr>
<tr class="separator:a658e6e3737e0a5fc5b82f02fc431c247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977dfad3c51904a701d87b521ac27fa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a977dfad3c51904a701d87b521ac27fa2">findEdges_rbbt</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;head, const <a class="el" href="classbool.html">bool</a> ignore_self_overlap=false)</td></tr>
<tr class="memdesc:a977dfad3c51904a701d87b521ac27fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover and add edges from base and externally provided head layer.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a977dfad3c51904a701d87b521ac27fa2">More...</a><br /></td></tr>
<tr class="separator:a977dfad3c51904a701d87b521ac27fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f520440c154bb37f3127ae0db8749ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a3f520440c154bb37f3127ae0db8749ca">getNabrOwnerSet</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> &amp;cnect, std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;owners) const</td></tr>
<tr class="memdesc:a3f520440c154bb37f3127ae0db8749ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of owners of neighbors.  <a href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a3f520440c154bb37f3127ae0db8749ca">More...</a><br /></td></tr>
<tr class="separator:a3f520440c154bb37f3127ae0db8749ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3c97cb6c8ed85cbebec9e17335b9ac"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a5d3c97cb6c8ed85cbebec9e17335b9ac">copyAndGlobalize</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;r)</td></tr>
<tr class="separator:a5d3c97cb6c8ed85cbebec9e17335b9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int DIM&gt;<br />
class SAMRAI::hier::LayerEdgeSet&lt; DIM &gt;</h3>

<p><b>Distributed</b> <b>Layered</b> <b>Box-graph</b> (DLBG):</p>
<p>A box-graph is a graph where the <b>nodes</b> correspond to boxes and <b>edges</b> connect neighboring nodes. Two nodes are <b>neighbors</b> if their boxes <b>overlap</b> when one is grown by some nominal <b>ghost-cell-width</b>. Each edge is defined by the two nodes it connects. The box-graph is useful in SAMR because it shows which boxes directly interact with each other.</p>
<p>We can organize nodes of a box-graph into groups of boxes defined on the same index space. When sorted from coarsest to finest index spaces, the nodes fall into distinct <b>layers</b>. A "layer" is similar to a level in the hierarchy in that patches in a level share the same index space. We use layer instead of level to differentiate the graph from the hierarchy and because a layer does not necessarily have a one-to-one association with a level.</p>
<p>For convenience, we define</p><ul>
<li><b>layer-node</b>: A set of nodes in same layer (defined on the same index space). This is encapsulated in the class <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html" title="Encapsulates a set of LayerNode objects on the same index space.">LayerNodeSet</a>.</li>
<li><b>layer-edge</b>: Set of edges incident from a layer-node. This is encapsulated in the class <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html" title="Encapsulates a set of DLBG edges that connect two LayerNodeSet objects.">LayerEdgeSet</a>.</li>
</ul>
<p>An edge is directional, like an arrow, starting at a <b>base</b> node and ending at a <b>head</b> node. Each pair of neighboring nodes has two edges, pointing in opposite directions. This goes also for <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html" title="Encapsulates a set of LayerNode objects on the same index space.">LayerNodeSet</a> and <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html" title="Encapsulates a set of DLBG edges that connect two LayerNodeSet objects.">LayerEdgeSet</a> objects. A single <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html" title="Encapsulates a set of DLBG edges that connect two LayerNodeSet objects.">LayerEdgeSet</a> object represents a set of directed edges incident from one base <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html" title="Encapsulates a set of LayerNode objects on the same index space.">LayerNodeSet</a> to one head <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html" title="Encapsulates a set of LayerNode objects on the same index space.">LayerNodeSet</a>. The edges pointing in the oposite direction are stored in a separate <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html" title="Encapsulates a set of DLBG edges that connect two LayerNodeSet objects.">LayerEdgeSet</a> object.</p>
<p>An object of this class can be <em>partnered</em> with another object that represents the directed edges in the opposite direction. The head of one partner is the base of the other. The partner does not provide additional information but it does organize the information differently. If the edge data is represented as a matrix, then one partner is the transpose of the other. A partnership allows both objects to be modified simultaneously so that their data is consistent. This avoids having to modify one after the other, which is problematic because the second modification begins with inconsistent data.</p>
<p>Two layers may contain edges in opposite directions and not be attached; but they would not be automatically coordinated in that case.</p>
<p>In parallel, a <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html" title="Encapsulates a set of LayerNode objects on the same index space.">LayerNodeSet</a> can also be in distributed or globalized (see <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html" title="Encapsulates a set of LayerNode objects on the same index space.">LayerNodeSet</a>). A locally-owned node is called a local node. Nodes owned by other processors are remote notes. Remote nodes are stilled called remote nodes when the <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html" title="Encapsulates a set of LayerNode objects on the same index space.">LayerNodeSet</a> is globalized. Local knowledge of a remote node does not make it local.</p>
<p>In parallel, we may partition the layer-edge and store it across many processors. The edge are classified as follows:</p><ul>
<li><b>Local</b> <b>edges</b> are incident from a local base and incident to two local head.</li>
<li><b>Semi-local</b> <b>edges</b> are incident from a local base and incident to a remote head.</li>
<li><b>Remote</b> <b>edges</b> connect two remote nodes.</li>
</ul>
<p>The <b>parallel</b> <b>state</b> of a <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html" title="Encapsulates a set of DLBG edges that connect two LayerNodeSet objects.">LayerEdgeSet</a> object can be:</p><ol type="1">
<li><b>DISTRIBUTED:</b> An object in this state stores only edges incident from local nodes.</li>
<li><b>GLOBALIZED:</b> In this state, the edges are globally duplicated on all processors.</li>
</ol>
<p>The distribution state is changed by <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a82333be5c13f66297d2a69a161eab592" title="Set the parallel distribution state.">setParallelState()</a>. Going to a more distributed state primarily means deallocating data, but going to a more serial state requires sharing of data (communicating). Currently, collected state for <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html" title="Encapsulates a set of DLBG edges that connect two LayerNodeSet objects.">LayerEdgeSet</a> objects seems to be unneeded.</p>
<p>The general attributes of a <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html" title="Encapsulates a set of DLBG edges that connect two LayerNodeSet objects.">LayerEdgeSet</a> are:</p><ul>
<li>the base <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html" title="Encapsulates a set of LayerNode objects on the same index space.">LayerNodeSet</a> (a reference to an external object).</li>
<li>the ghost cell width to grow the base nodes when checking overlaps.</li>
<li>the connectivity (table of neighbors for nodes in the base <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html" title="Encapsulates a set of LayerNode objects on the same index space.">LayerNodeSet</a>).</li>
<li>the attached partner, if any.</li>
<li>the parallel state.</li>
</ul>
<p>The connectivity depends on the base <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html" title="Encapsulates a set of LayerNode objects on the same index space.">LayerNodeSet</a> and the ghost-cell-width, so it is discarded when either of these is manually changed. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9c27bde9bfa42a11c1e9467be03fc9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c27bde9bfa42a11c1e9467be03fc9b4">&#9670;&nbsp;</a></span>Node</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1hier_1_1LayerNode.html">LayerNode</a>&lt;DIM&gt; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a9c27bde9bfa42a11c1e9467be03fc9b4">Node</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a585fead0a5477f20a132c56d64f8d371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585fead0a5477f20a132c56d64f8d371">&#9670;&nbsp;</a></span>LocalIndex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1hier_1_1LayerNode.html#a7119fea22553e2e6a399f862fcd83606">Node::LocalIndex</a> <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a585fead0a5477f20a132c56d64f8d371">LocalIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e9c7ecdb5c4e0da6faa38807252324a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9c7ecdb5c4e0da6faa38807252324a">&#9670;&nbsp;</a></span>NodeContainer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt;DIM&gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a> <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a sorted container so that it can be compared without expensive searches. A node can be removed or added without changing the indices of existing nodes. </p>

</div>
</div>
<a id="ac7bff8b71e87a5ece283b9ecb18064d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7bff8b71e87a5ece283b9ecb18064d9">&#9670;&nbsp;</a></span>NabrContainer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt;DIM&gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a> <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ac7bff8b71e87a5ece283b9ecb18064d9">NabrContainer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92056ee8a1bfc452f200b7793f71e4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92056ee8a1bfc452f200b7793f71e4bb">&#9670;&nbsp;</a></span>Connectivity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a585fead0a5477f20a132c56d64f8d371">LocalIndex</a>,<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ac7bff8b71e87a5ece283b9ecb18064d9">NabrContainer</a>&gt; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The connectivity <code>m</code> maps a node with index <code>i</code> to a set of nodes <code>m</code>[i], usually its neighbors. (The neighbors data is a container of nodes.)</p>
<p>Because Connectivity is indexed by the LocalIndex instead of a combined owner and LocalIndex, each Connectivity object is implicitly associated with just one owner process. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a16c7a3e816245aac62eda5fa36354ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c7a3e816245aac62eda5fa36354ce4">&#9670;&nbsp;</a></span>ParallelState</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a16c7a3e816245aac62eda5fa36354ce4">SAMRAI::hier::LayerEdgeSet::ParallelState</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a16c7a3e816245aac62eda5fa36354ce4adf2cc0623667ffde880ac3dc86f3021e"></a>DISTRIBUTED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a16c7a3e816245aac62eda5fa36354ce4a12c9c038f8596fbf43346a8a45541c3b"></a>GLOBALIZED&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aeb90c4d886792bf0b2879cf975c7a633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb90c4d886792bf0b2879cf975c7a633">&#9670;&nbsp;</a></span>LayerEdgeSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default constructor creates empty object in distributed state. </p>

</div>
</div>
<a id="a4b9bb616bf538d7dc6ced7976316f7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9bb616bf538d7dc6ced7976316f7f2">&#9670;&nbsp;</a></span>~LayerEdgeSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deallocate internal data. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae7663ebeb643ca18d4692d02bd864cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7663ebeb643ca18d4692d02bd864cf3">&#9670;&nbsp;</a></span>getNodeContainer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a>&amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getNodeContainer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rank</em> = <code>-1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2dcacef8e09af28010219b6cf4a8560b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dcacef8e09af28010219b6cf4a8560b">&#9670;&nbsp;</a></span>getConnectivity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a>&amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getConnectivity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rank</em> = <code>-1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31d988a8c62db1b88cd71aa4b78ec13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d988a8c62db1b88cd71aa4b78ec13c">&#9670;&nbsp;</a></span>getBaseRefinementRatio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;DIM&gt;&amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getBaseRefinementRatio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a961f129dbd11549a3ba42105ec3e13bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961f129dbd11549a3ba42105ec3e13bb">&#9670;&nbsp;</a></span>getHeadRefinementRatio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;DIM&gt;&amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getHeadRefinementRatio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5926ce17da6c6f571c200f60b5d81bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5926ce17da6c6f571c200f60b5d81bd8">&#9670;&nbsp;</a></span>attachPartner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::attachPartner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>partner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Preconditions</b> on the partner and this object:</p><ol type="1">
<li>The base refinement ratio of one partner and the head ratio of the other must be equal, and vice versa.</li>
<li>The product of the base refinement ratio and the ghost-cell-width musb be the same for the partners. This ensures that the overlap check gives the same result regardless of the layer whose boxes are grown for the overlap check. For the extent of the partnership, this requirement must be met. Resetting the ghost-cell-width of one partner forces the ghost-cell-width of the partner to change to meet this requirement.</li>
</ol>
<p>Both objects must be in the same parallel state. Their parallel states will change together for the the duration of the partnership.</p>
<p>Both objects are modified to reference each other as mutual partners. Both objects must be unpartnered. Multiple partners are not allowed. Once two layer edges objects are attached, they are synchronized when either calls a synchronizing method. Synchronizing means making all edges between them seen by both objects. (This does not mean that remote edges are seen in DISTRIBUTED modes though.)</p>
<p>The relationship between two attached objects is symmetric, that is, <code>a.attach(b)</code> has the same effect as <code>b.attach(a)</code>. It is permissible to pass *this in for partner, which is how peer edges are set up.</p>
<p>Since the partner is not created internally, it is NOT explicitly deleted when this object goes out of scope. It will simply be detached. This is in contrast to <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#adf9c8b04b73913fcbfdfaea6a55831d5">createPartner()</a>. </p>

</div>
</div>
<a id="adf9c8b04b73913fcbfdfaea6a55831d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9c8b04b73913fcbfdfaea6a55831d5">&#9670;&nbsp;</a></span>createPartner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::createPartner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>partner_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> *&#160;</td>
          <td class="paramname"><em>partner_connectivity</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab97fe570fd415cab278885d87879458c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97fe570fd415cab278885d87879458c">&#9670;&nbsp;</a></span>getPartner() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getPartner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Error if no partner is attached. </p>

</div>
</div>
<a id="a1bac83443f14d8b67ccd0ba9e2a21ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bac83443f14d8b67ccd0ba9e2a21ad9">&#9670;&nbsp;</a></span>getPartner() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getPartner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Error if no partner is attached. </p>

</div>
</div>
<a id="ad2759591af37611b264a535126585eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2759591af37611b264a535126585eed">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a16c7a3e816245aac62eda5fa36354ce4">ParallelState</a>&#160;</td>
          <td class="paramname"><em>parallel_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>base_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>head_refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>gcw</em> = <code><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;&#160;DIM&#160;&gt;(1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> *&#160;</td>
          <td class="paramname"><em>connectivity</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The object must not be attached to a partner. This method resets enough data to make coordination with partners irrelevant. You must detach the partner (if any) before calling this method. There should be no reason to use this method while attached.</p>
<p>A reference is made to the given <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html" title="Encapsulates a set of LayerNode objects on the same index space.">LayerNodeSet</a>. The ghost cell width is copied. If <code>connectivity</code> is given, a copy is made from it. This is meant for use when you have an external means for computing the connectivity data. (The accuracy and consistency of the connectivity is not checked!) If <code>connectivity</code> is not given, it should be created using <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4920ba061b955a5ab6fa49133397fd50" title="Discover and add edges between self and partner.">findEdges()</a> before calling a method that uses it.</p>
<p>The parallel state is initialized to the given <code>parallel_state</code>. If state is GLOBALIZED:</p><ul>
<li><code>base_layer</code> must be in GLOBALIZED mode.</li>
<li>connectivity (if given) must be an array the length of the number of processes, describing the local and semi-local edges for each process.</li>
</ul>
<p>A reference is made to the given <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html" title="Encapsulates a set of LayerNode objects on the same index space.">LayerNodeSet</a>, replacing the current node reference.</p>
<p>When debug is enabled, some checks are made to assert that base_layer and connectivity are consistent with each other. </p>

</div>
</div>
<a id="aaaf4901643516469ac33a23db872ccbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf4901643516469ac33a23db872ccbe">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <code>r</code> is attached to itself, self-attach. If <code>r</code> is attached but not to itself, create a duplicate partner and attach to it.</p>
<p>All other data is directly copied. </p>

</div>
</div>
<a id="a4920ba061b955a5ab6fa49133397fd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4920ba061b955a5ab6fa49133397fd50">&#9670;&nbsp;</a></span>findEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::findEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obviously, a partner must be attached. Neighbor information on both the object and its partner is modified. The effect is the same as if <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4920ba061b955a5ab6fa49133397fd50" title="Discover and add edges between self and partner.">findEdges()</a> were called for the partner.</p>
<p>This method simply calls <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a048caf45cfd1f43a8ae72d651ecc1457">findEdges(LayerEdgeSet &amp;a, LayerEdgeSet &amp;b)</a> with the partner in the argument. See that method for communication implications.</p>
<p>If the partner is the same object (finding peer edges), edges between a node and itself will be ignored. </p>

</div>
</div>
<a id="a048caf45cfd1f43a8ae72d651ecc1457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048caf45cfd1f43a8ae72d651ecc1457">&#9670;&nbsp;</a></span>findEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::findEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acadc62d54f9ffc29446af95d0cf34714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acadc62d54f9ffc29446af95d0cf34714">&#9670;&nbsp;</a></span>bridge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::bridge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_to_head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_to_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">   (bridge base)  ------------bridge-------------&gt;  (bridge head)
                  &lt;-------reverse bridge----------        
         ^                                                ^
         |                                                |
         |                                                |
         |                                                |
         +--edge to base-- (middle layer) --edge to head--+</pre><p>The bases of the two given layers are known as the middle layer. For each node in this layer, the two given layers give the sets of neighboring nodes at the head and base layers of the current object. These two sets are checked against each other for node intersections.</p>
<p>Conditions:</p><ol type="1">
<li><code>edge_to_head</code> and <code>edge_to_base</code> must be incident from identical sets of nodes.</li>
<li><code>edge_to_head</code> and <code>edge_to_base</code> must have attached partners.</li>
<li>Any parallel state is allowed, but states must be consistent between all <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html" title="Encapsulates a set of DLBG edges that connect two LayerNodeSet objects.">LayerEdgeSet</a> objects.</li>
<li>At least one of the head or base layers must be completely nested in the middle layer. If neither is nested, some edges may be missed.</li>
</ol>
<p>To find peer edges, use identical layer-edges for the leg to head and leg to base.</p>
<p>A partner must be attached. </p>

</div>
</div>
<a id="ae93466b9b9c1cfa51e16733dd1205c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93466b9b9c1cfa51e16733dd1205c5b">&#9670;&nbsp;</a></span>replaceNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::replaceNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html" title="Encapsulates a set of DLBG edges that connect two LayerNodeSet objects.">LayerEdgeSet</a> object <code>map</code>, which maps some nodes in the head of the current <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html" title="Encapsulates a set of DLBG edges that connect two LayerNodeSet objects.">LayerEdgeSet</a> to new nodes (also in the head), replace each given node in the head layer by its neighbors in the tail of <code>map</code>.</p>
<pre class="fragment">                          map
            (old head) ---------&gt; (new head)
                     ^            ^
                      \          /
edge before mapping -&gt; \        / &lt;- edge after mapping
                        \      /
                         \    /
                         (base)
</pre><p>Representing the map by a <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html" title="Encapsulates a set of DLBG edges that connect two LayerNodeSet objects.">LayerEdgeSet</a> implicitly requires that any set of nodes replacing an old node must overlap the old ones they replace. A special algorithm taking advantage of this restriction is used to update this object. If you want to manipulate the edge data generally, <em>DO</em> <em>NOT</em> use this method.</p>
<p><code>map</code> is a layer edge from nodes to be removed to nodes to be in its place. If any edges in <code>map</code> references nodes not locally owned, communication with the owner is triggered. In these cases, it is <em>CRITICAL</em> that the same mapping is introduced on the owner processes.</p>
<p>We could do the same with a <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#acadc62d54f9ffc29446af95d0cf34714" title="Create the layer edge data by bridging the heads of two layer edges whose base nodes are identical to...">bridge()</a> operation centered at the tail of the map. but that requires that <code>map</code> maps the unchanged nodes in the tail to itself, and it also requires doing work to map unchanged nodes to themselves. This is a lot of extra overhead when map is very small. If <code>map</code> maps each unchanged node to itself, <code>a.replaceNodes(map)</code> is equivalent to <code>a.bridge</code>(map,a.getPartner()).</p>
<p>The partner's base will be replaced by the new head.</p>
<p>Conditions:</p><ol type="1">
<li><code>map</code> must be based at the head of the current object.</li>
<li><code>map</code> and the current object must have attached partners.</li>
<li>Any parallel state is allowed, but states must be consistent between all <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html" title="Encapsulates a set of DLBG edges that connect two LayerNodeSet objects.">LayerEdgeSet</a> objects.</li>
<li><code>map</code> must not map any node outside the range of the node's current box.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>Mapping between old head and new head. A partner must be attached. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82333be5c13f66297d2a69a161eab592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82333be5c13f66297d2a69a161eab592">&#9670;&nbsp;</a></span>setParallelState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::setParallelState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a16c7a3e816245aac62eda5fa36354ce4">ParallelState</a>&#160;</td>
          <td class="paramname"><em>parallel_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Before putting a <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html" title="Encapsulates a set of DLBG edges that connect two LayerNodeSet objects.">LayerEdgeSet</a> in a GLOBALIZED state, The <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html" title="Encapsulates a set of LayerNode objects on the same index space.">LayerNodeSet</a> given in <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#ad2759591af37611b264a535126585eed" title="Set data defining the edge set.">initialize()</a> must already be in GLOBALIZED mode. The layer-node set must always be in GLOBALIZED mode as long as the layer-edge set is.</p>
<p>In GLOBALIZED state, the entire layer is independently duplicated on every process. (For consistency, it is imperative that the layer is operated on uniformly across all processes.) All edges (not just local and semilocal) are found when operations to find them are executed.</p>
<p>This method is not necessarily trivial. More memory is required to store additional parts of the graph.</p>
<p>If a partner is attached, the parallel state of the partner is affected the same way.</p>
<p>Changing parallel state preserves existing neighbor information used by the new parallel state. Neighbor information not used by the new parallel state gets deallocated.</p>
<p>For efficiency reasons, this method NEVER implicitly discovers new neighbor information after going to a GLOBALIZED state. To get this data, call <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4920ba061b955a5ab6fa49133397fd50" title="Discover and add edges between self and partner.">findEdges()</a> explicitly.</p>
<p>For serial (one processor) runs, there is no difference between the parallel states (except for the names), and there is no real cost for switching parallel states. </p>

</div>
</div>
<a id="ac05141f3b5a3ab8ce366439b9b66f964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05141f3b5a3ab8ce366439b9b66f964">&#9670;&nbsp;</a></span>getParallelState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a16c7a3e816245aac62eda5fa36354ce4">ParallelState</a> <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getParallelState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb4f16febdef841a55c17fef1b6f9a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4f16febdef841a55c17fef1b6f9a13">&#9670;&nbsp;</a></span>deallocateData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::deallocateData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If a partner exists, its internal data is deallocated also. This method does <em>NOT</em> detach the partner. </p>

</div>
</div>
<a id="a4ff4abf0f084c7727f47cb362fde4bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff4abf0f084c7727f47cb362fde4bc3">&#9670;&nbsp;</a></span>setMaxGhostCellWidth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::setMaxGhostCellWidth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>gcw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default max ghost cell width is 1. The max ghost cell width affects the overlap comparison, so the old edge data is no longer valid. The old data is discarded. For efficiency reasons, new edge data is not automatically generated. To get this data, call <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4920ba061b955a5ab6fa49133397fd50" title="Discover and add edges between self and partner.">findEdges()</a> explicitly.</p>
<p>For attached <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html" title="Encapsulates a set of DLBG edges that connect two LayerNodeSet objects.">LayerEdgeSet</a> objects, the ratio of the ghost-cell-width of the two partners must be equal to the inverse ratio of their base layer refinement ratios. This ensures that the overlap check gives the same result regardless of the layer whose boxes are grown for the overlap check. If a partner is attached, the partner's ghost-cell-width is automatically changed to satisfy this requirement. </p>

</div>
</div>
<a id="a0333b77f7250b94e930f2525abe5244f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0333b77f7250b94e930f2525abe5244f">&#9670;&nbsp;</a></span>getMaxGhostCellWidth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;DIM&gt;&amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getMaxGhostCellWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0030ac61e4d5c53ddb214091476a5763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0030ac61e4d5c53ddb214091476a5763">&#9670;&nbsp;</a></span>printClassData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::printClassData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>co</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>debase_depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1da61184d137e2ba54a91b2a76254350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da61184d137e2ba54a91b2a76254350">&#9670;&nbsp;</a></span>printEdgeStats()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::printEdgeStats </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>co</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae53c6f3fa7718a0ca96697b7ea1a9b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53c6f3fa7718a0ca96697b7ea1a9b66">&#9670;&nbsp;</a></span>checkNodeNabrCorrespondance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::checkNodeNabrCorrespondance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a099ddfaa536ecbb2c12be9e88189f03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099ddfaa536ecbb2c12be9e88189f03b">&#9670;&nbsp;</a></span>checkNodeConsistency() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::checkNodeConsistency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obviously, the object must have a partner. If the partner's base is not GLOBALIZED, a temporary copy is made and globalized for checking, triggering communication. </p>

</div>
</div>
<a id="adcde2d1f59377fe23991ede51281f51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcde2d1f59377fe23991ede51281f51a">&#9670;&nbsp;</a></span>checkNodeConsistency() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::checkNodeConsistency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a> &amp;&#160;</td>
          <td class="paramname"><em>local_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> &amp;&#160;</td>
          <td class="paramname"><em>cnect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>head_layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_nodes</td><td>A node container. </td></tr>
    <tr><td class="paramname">cnect</td><td>Connectivity data for <code>nodes</code>. </td></tr>
    <tr><td class="paramname">head_layer</td><td><a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html" title="Encapsulates a set of LayerNode objects on the same index space.">LayerNodeSet</a> describing the head with respect to the given connectivity. This object must be in GLOBALIZED state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5edd4f938a40d9e2fc1cb1c10451d3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5edd4f938a40d9e2fc1cb1c10451d3c6">&#9670;&nbsp;</a></span>checkConnectivity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::checkConnectivity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assert that connectivity data is correct for the base and head (partner's base).</p>
<p>This is an expensive operation and should only be used for debugging. It creates a globalized version of the layer-node data (if this data is not already globalized), uses the data to compute the edges and compares the result to the current edges.</p>
<p>The object must be partnered and be in hybrid mode for checking to work.</p>
<p>Checking is done as follows:</p><ul>
<li>Rebuild the edge containers by finding edges in hybrid mode.</li>
<li>Check that the rebuilt containers match the existing containers.</li>
</ul>
<p>Currently, the rebuilt edges are rebuilt using <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4920ba061b955a5ab6fa49133397fd50" title="Discover and add edges between self and partner.">findEdges()</a>. Thus, it may be pointless to use this method as a check for that method. </p>

</div>
</div>
<a id="a783aecea34b36549d341e4879e720483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783aecea34b36549d341e4879e720483">&#9670;&nbsp;</a></span>getConnectivity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a>&amp; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getConnectivity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rank</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9ed9a7bb90888680582eac2f8ee9fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ed9a7bb90888680582eac2f8ee9fcc">&#9670;&nbsp;</a></span>deallocateDataSelf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::deallocateDataSelf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c78a6a79147d094009582bf3d8aabf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c78a6a79147d094009582bf3d8aabf3">&#9670;&nbsp;</a></span>allocateConnectivity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::allocateConnectivity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a4e9c7ecdb5c4e0da6faa38807252324a">NodeContainer</a> &amp;&#160;</td>
          <td class="paramname"><em>node_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> &amp;&#160;</td>
          <td class="paramname"><em>cnect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each <code>node</code> in the <code>node_container</code>, add a corresponding neighbor container that coresponds to index <code>node.getLocalIndex()</code> to <code>cnect</code>. </p>

</div>
</div>
<a id="a5d3c97cb6c8ed85cbebec9e17335b9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3c97cb6c8ed85cbebec9e17335b9ac">&#9670;&nbsp;</a></span>copyAndGlobalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt;DIM&gt;* <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::copyAndGlobalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f8c3300ab82104c50224e1af540d8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8c3300ab82104c50224e1af540d8dc">&#9670;&nbsp;</a></span>bridge_discoverEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::bridge_discoverEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_to_head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_to_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a585fead0a5477f20a132c56d64f8d371">LocalIndex</a>, <a class="el" href="structSAMRAI_1_1hier_1_1LayerEdgeSet_1_1CommunicationStruct.html">CommunicationStruct</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesg_to_owners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>ignore_self_overlap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a set of edges from a "middle" layer to a "head" layer and a set of edges from the same "middle" layer to a "base" layer, discover edges between the head and base.</p>
<ul>
<li>GLOBALIZED state: local, semilocal and remote edges are discovered locally.</li>
<li>DISTRIBUTED state: local, semilocal and remote edges are discovered locally.</li>
</ul>
<p>If partner is self (discovering peer edges), a node's intersection with itself is are disregarded.</p>
<p>Edges connecting nonlocal nodes may be discovered. Such information is appended to messages to be sent to the owners of those nodes. See <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a8946fda2213a23a302a741f591a4c806" title="Share phase of bridging.">bridge_shareEdges()</a>. </p>

</div>
</div>
<a id="a8946fda2213a23a302a741f591a4c806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8946fda2213a23a302a741f591a4c806">&#9670;&nbsp;</a></span>bridge_shareEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::bridge_shareEdges </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a585fead0a5477f20a132c56d64f8d371">LocalIndex</a>, <a class="el" href="structSAMRAI_1_1hier_1_1LayerEdgeSet_1_1CommunicationStruct.html">CommunicationStruct</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesg_to_owners</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Messages are created by <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a6f8c3300ab82104c50224e1af540d8dc" title="Discover phase of bridging.">bridge_discoverEdges()</a>. </p>

</div>
</div>
<a id="a7ed723e1e58affa56f25bbb3b1286de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed723e1e58affa56f25bbb3b1286de0">&#9670;&nbsp;</a></span>findEdges_serial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::findEdges_serial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Neighbor information on both the object and its partner is modified. Edges found are added to appropriate neighbor lists. No edge is removed. If existing edges are invalid, remove them first.</p>
<p>This method is symmetric. </p>

</div>
</div>
<a id="a658e6e3737e0a5fc5b82f02fc431c247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658e6e3737e0a5fc5b82f02fc431c247">&#9670;&nbsp;</a></span>findEdges_quadratic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::findEdges_quadratic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Neighbor information on both the object and its partner is modified. Edges found are added to appropriate neighbor lists. No edge is removed. If existing edges are invalid, remove them first.</p>
<p>This method is not symmetric. </p>

</div>
</div>
<a id="a977dfad3c51904a701d87b521ac27fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977dfad3c51904a701d87b521ac27fa2">&#9670;&nbsp;</a></span>findEdges_rbbt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::findEdges_rbbt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>ignore_self_overlap</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Edges found are added to appropriate neighbor lists. No edge is removed. If existing edges are invalid, remove them first. </p>

</div>
</div>
<a id="a3f520440c154bb37f3127ae0db8749ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f520440c154bb37f3127ae0db8749ca">&#9670;&nbsp;</a></span>getNabrOwnerSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::getNabrOwnerSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a> &amp;&#160;</td>
          <td class="paramname"><em>cnect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>owners</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1f33d3f154233ff4ecc4010f4d5bf30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f33d3f154233ff4ecc4010f4d5bf30a">&#9670;&nbsp;</a></span>d_gcw</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;DIM&gt; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::d_gcw</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When determining intersection of two boxes, the box in the node layer with finer refinement ratio is grown by this amount. If both layers are at the same ratio, it does not matter which is grown. </p>

</div>
</div>
<a id="a1224f37733f80e1bc131a7c95afd2df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1224f37733f80e1bc131a7c95afd2df1">&#9670;&nbsp;</a></span>d_head_ratio</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;DIM&gt; <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::d_head_ratio</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The neighbors in d_cnect correspond to this ratio. The partner (if any) must have a base layer with this ratio. (The base layer refinement ratio is in d_nodes.) </p>

</div>
</div>
<a id="a6e383c6e5dbc9ccae2a6296aa365e430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e383c6e5dbc9ccae2a6296aa365e430">&#9670;&nbsp;</a></span>d_base</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1LayerNodeSet.html">LayerNodeSet</a>&lt;DIM&gt;* <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::d_base</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This pointer references an object that may be shared among many <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html" title="Encapsulates a set of DLBG edges that connect two LayerNodeSet objects.">LayerEdgeSet</a>. Therefore, it will not be modified by this class. </p>

</div>
</div>
<a id="a50cfff8ecec6b220515af078a595e0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50cfff8ecec6b220515af078a595e0d8">&#9670;&nbsp;</a></span>d_cnect</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a92056ee8a1bfc452f200b7793f71e4bb">Connectivity</a>* <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::d_cnect</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In serial mode, this is an array of Connectivity objects, one for each process. In non-serial mode, this is a single Connectivity object for the local process. </p>

</div>
</div>
<a id="aee62ca839d1a7b0edfe23845bd1fdcac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee62ca839d1a7b0edfe23845bd1fdcac">&#9670;&nbsp;</a></span>d_parallel_state</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a16c7a3e816245aac62eda5fa36354ce4">ParallelState</a> <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::d_parallel_state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modified by <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a82333be5c13f66297d2a69a161eab592" title="Set the parallel distribution state.">setParallelState()</a>. </p>

</div>
</div>
<a id="aeb588a17507174a5f83edaf56a591b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb588a17507174a5f83edaf56a591b1e">&#9670;&nbsp;</a></span>d_partner</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">LayerEdgeSet</a>* <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::d_partner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a13f4f0b58746c0a0996deca83805ac2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f4f0b58746c0a0996deca83805ac2f">&#9670;&nbsp;</a></span>d_partner_is_managed</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::d_partner_is_managed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set by <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#a5926ce17da6c6f571c200f60b5d81bd8" title="Mutually attach to another layer-edge object to create a bi-directional set of edges.">attachPartner()</a> and <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html#adf9c8b04b73913fcbfdfaea6a55831d5">createPartner()</a>. </p>

</div>
</div>
<a id="a4c653b899eb84048f32aba081cc0e548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c653b899eb84048f32aba081cc0e548">&#9670;&nbsp;</a></span>d_rank</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classint.html">int</a> <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::d_rank</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acebb33c4c1929073ab0ce39cdde3fd9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebb33c4c1929073ab0ce39cdde3fd9a">&#9670;&nbsp;</a></span>d_nprocs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classint.html">int</a> <a class="el" href="classSAMRAI_1_1hier_1_1LayerEdgeSet.html">SAMRAI::hier::LayerEdgeSet</a>&lt; DIM &gt;::d_nprocs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/samrai/include/<a class="el" href="LayerEdgeSet_8h.html">LayerEdgeSet.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
