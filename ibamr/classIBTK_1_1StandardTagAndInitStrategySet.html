<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: IBTK::StandardTagAndInitStrategySet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IBAMR
   &#160;<span id="projectnumber">IBAMR version 0.19.</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceIBTK.html">IBTK</a></li><li class="navelem"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html">StandardTagAndInitStrategySet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classIBTK_1_1StandardTagAndInitStrategySet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IBTK::StandardTagAndInitStrategySet Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class <a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html" title="Class StandardTagAndInitStrategySet is a utility class that allows multiple SAMRAI::mesh::StandardTag...">StandardTagAndInitStrategySet</a> is a utility class that allows multiple <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a> objects to be employed by a single <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html">SAMRAI::mesh::StandardTagAndInitialize</a> object.  
 <a href="classIBTK_1_1StandardTagAndInitStrategySet.html#details">More...</a></p>

<p><code>#include &lt;ibtk/StandardTagAndInitStrategySet.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IBTK::StandardTagAndInitStrategySet:</div>
<div class="dyncontent">
<div class="center"><img src="classIBTK_1_1StandardTagAndInitStrategySet__inherit__graph.png" border="0" usemap="#IBTK_1_1StandardTagAndInitStrategySet_inherit__map" alt="Inheritance graph"/></div>
<map name="IBTK_1_1StandardTagAndInitStrategySet_inherit__map" id="IBTK_1_1StandardTagAndInitStrategySet_inherit__map">
<area shape="rect" title="Class StandardTagAndInitStrategySet is a utility class that allows multiple SAMRAI::mesh::StandardTag..." alt="" coords="27,276,213,317"/>
<area shape="rect" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html" title=" " alt="" coords="17,185,223,227"/>
<area shape="rect" href="classSAMRAI_1_1tbox_1_1DescribedClass.html" title="Base class for all objects that use run&#45;time type identification (RTTI)." alt="" coords="5,5,224,32"/>
<area shape="rect" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html" title=" " alt="" coords="137,81,343,123"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0bd1d748ceb96053f8ca306c3cdcca13"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a0bd1d748ceb96053f8ca306c3cdcca13"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#a0bd1d748ceb96053f8ca306c3cdcca13">StandardTagAndInitStrategySet</a> (InputIterator first, InputIterator last, <a class="el" href="classbool.html">bool</a> managed=true)</td></tr>
<tr class="memdesc:a0bd1d748ceb96053f8ca306c3cdcca13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classIBTK_1_1StandardTagAndInitStrategySet.html#a0bd1d748ceb96053f8ca306c3cdcca13">More...</a><br /></td></tr>
<tr class="separator:a0bd1d748ceb96053f8ca306c3cdcca13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf967e3f53dc9347af502852f14434c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#a4cf967e3f53dc9347af502852f14434c">~StandardTagAndInitStrategySet</a> ()</td></tr>
<tr class="memdesc:a4cf967e3f53dc9347af502852f14434c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classIBTK_1_1StandardTagAndInitStrategySet.html#a4cf967e3f53dc9347af502852f14434c">More...</a><br /></td></tr>
<tr class="separator:a4cf967e3f53dc9347af502852f14434c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7690d66af8892d5deff4a2de5e292ec2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#a7690d66af8892d5deff4a2de5e292ec2">getLevelDt</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt; level, <a class="el" href="classdouble.html">double</a> dt_time, <a class="el" href="classbool.html">bool</a> initial_time) override</td></tr>
<tr class="separator:a7690d66af8892d5deff4a2de5e292ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70dc8d9c84013394c7321a963c72395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#ae70dc8d9c84013394c7321a963c72395">advanceLevel</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt; level, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time, <a class="el" href="classbool.html">bool</a> first_step, <a class="el" href="classbool.html">bool</a> last_step, <a class="el" href="classbool.html">bool</a> regrid_advance=false) override</td></tr>
<tr class="separator:ae70dc8d9c84013394c7321a963c72395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b655d72e921cbb85fca891d55ec787"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#a57b655d72e921cbb85fca891d55ec787">resetTimeDependentData</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt; level, <a class="el" href="classdouble.html">double</a> new_time, <a class="el" href="classbool.html">bool</a> can_be_refined) override</td></tr>
<tr class="separator:a57b655d72e921cbb85fca891d55ec787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79458abb6c5ab4f4c25c13aa1a7883d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#a79458abb6c5ab4f4c25c13aa1a7883d7">resetDataToPreadvanceState</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt; level) override</td></tr>
<tr class="separator:a79458abb6c5ab4f4c25c13aa1a7883d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b7e370f22498fd6ba7a67c8f926c07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#ac4b7e370f22498fd6ba7a67c8f926c07">initializeLevelData</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classint.html">int</a> level_number, <a class="el" href="classdouble.html">double</a> init_data_time, <a class="el" href="classbool.html">bool</a> can_be_refined, <a class="el" href="classbool.html">bool</a> initial_time, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt; old_level=<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt;(nullptr), <a class="el" href="classbool.html">bool</a> allocate_data=true) override</td></tr>
<tr class="separator:ac4b7e370f22498fd6ba7a67c8f926c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfd33353f186348bfe7d9569f130ff2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#a0cfd33353f186348bfe7d9569f130ff2">resetHierarchyConfiguration</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classint.html">int</a> coarsest_level, <a class="el" href="classint.html">int</a> finest_level) override</td></tr>
<tr class="separator:a0cfd33353f186348bfe7d9569f130ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23d0d6ca861dd31aa09bd96f554954f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#ac23d0d6ca861dd31aa09bd96f554954f">applyGradientDetector</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classint.html">int</a> level_number, <a class="el" href="classdouble.html">double</a> error_data_time, <a class="el" href="classint.html">int</a> tag_index, <a class="el" href="classbool.html">bool</a> initial_time, <a class="el" href="classbool.html">bool</a> uses_richardson_extrapolation_too) override</td></tr>
<tr class="separator:ac23d0d6ca861dd31aa09bd96f554954f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388ba31b7d316274a98e4510384d0cc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#a388ba31b7d316274a98e4510384d0cc4">applyRichardsonExtrapolation</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a>&lt; NDIM &gt; &gt; level, <a class="el" href="classdouble.html">double</a> error_data_time, <a class="el" href="classint.html">int</a> tag_index, <a class="el" href="classdouble.html">double</a> deltat, <a class="el" href="classint.html">int</a> error_coarsen_ratio, <a class="el" href="classbool.html">bool</a> initial_time, <a class="el" href="classbool.html">bool</a> uses_gradient_detector_too) override</td></tr>
<tr class="separator:a388ba31b7d316274a98e4510384d0cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad788b867aa0ed8cd2d72901e58868536"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#ad788b867aa0ed8cd2d72901e58868536">coarsenDataForRichardsonExtrapolation</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classint.html">int</a> level_number, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a>&lt; NDIM &gt; &gt; coarser_level, <a class="el" href="classdouble.html">double</a> coarsen_data_time, <a class="el" href="classbool.html">bool</a> before_advance) override</td></tr>
<tr class="separator:ad788b867aa0ed8cd2d72901e58868536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5263bfe8622e41d1a2df35f9803a5ca1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a5263bfe8622e41d1a2df35f9803a5ca1">getLevelDt</a> (const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level, const <a class="el" href="classdouble.html">double</a> dt_time, const <a class="el" href="classbool.html">bool</a> initial_time)</td></tr>
<tr class="separator:a5263bfe8622e41d1a2df35f9803a5ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e8a35a6b5ab6ec7e14f040e718adf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a9e4e8a35a6b5ab6ec7e14f040e718adf">advanceLevel</a> (const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level, const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classdouble.html">double</a> current_time, const <a class="el" href="classdouble.html">double</a> new_time, const <a class="el" href="classbool.html">bool</a> first_step, const <a class="el" href="classbool.html">bool</a> last_step, const <a class="el" href="classbool.html">bool</a> regrid_advance=false)</td></tr>
<tr class="separator:a9e4e8a35a6b5ab6ec7e14f040e718adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97641642baa1b5c67749fada52b12341"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a97641642baa1b5c67749fada52b12341">resetTimeDependentData</a> (const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level, const <a class="el" href="classdouble.html">double</a> new_time, const <a class="el" href="classbool.html">bool</a> can_be_refined)</td></tr>
<tr class="separator:a97641642baa1b5c67749fada52b12341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f563618437d3a5231d35eb6937fcd1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#af6f563618437d3a5231d35eb6937fcd1">resetDataToPreadvanceState</a> (const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level)</td></tr>
<tr class="separator:af6f563618437d3a5231d35eb6937fcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f31cfe38a0690a629fcbeb7ad89888"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#af8f31cfe38a0690a629fcbeb7ad89888">initializeLevelData</a> (const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> level_number, const <a class="el" href="classdouble.html">double</a> init_data_time, const <a class="el" href="classbool.html">bool</a> can_be_refined, const <a class="el" href="classbool.html">bool</a> initial_time, const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; old_level=tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt;(NULL), const <a class="el" href="classbool.html">bool</a> allocate_data=true)=0</td></tr>
<tr class="separator:af8f31cfe38a0690a629fcbeb7ad89888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8d89482d4bdafc824307cc21c728c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a6f8d89482d4bdafc824307cc21c728c9">resetHierarchyConfiguration</a> (const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> coarsest_level, const <a class="el" href="classint.html">int</a> finest_level)=0</td></tr>
<tr class="separator:a6f8d89482d4bdafc824307cc21c728c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac201b9cd28087aa92f9c1370f147667a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#ac201b9cd28087aa92f9c1370f147667a">applyGradientDetector</a> (const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> level_number, const <a class="el" href="classdouble.html">double</a> error_data_time, const <a class="el" href="classint.html">int</a> tag_index, const <a class="el" href="classbool.html">bool</a> initial_time, const <a class="el" href="classbool.html">bool</a> uses_richardson_extrapolation_too)</td></tr>
<tr class="separator:ac201b9cd28087aa92f9c1370f147667a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e5b7b5d98eaf7221b5088b0d12a2a8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a81e5b7b5d98eaf7221b5088b0d12a2a8">applyRichardsonExtrapolation</a> (const tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; level, const <a class="el" href="classdouble.html">double</a> error_data_time, const <a class="el" href="classint.html">int</a> tag_index, const <a class="el" href="classdouble.html">double</a> deltat, const <a class="el" href="classint.html">int</a> error_coarsen_ratio, const <a class="el" href="classbool.html">bool</a> initial_time, const <a class="el" href="classbool.html">bool</a> uses_gradient_detector_too)</td></tr>
<tr class="separator:a81e5b7b5d98eaf7221b5088b0d12a2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3ec75cca71a27c6599a48ac6cd37ea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a9e3ec75cca71a27c6599a48ac6cd37ea">coarsenDataForRichardsonExtrapolation</a> (const tbox::Pointer&lt; hier::PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> level_number, const tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; coarser_level, const <a class="el" href="classdouble.html">double</a> coarsen_data_time, const <a class="el" href="classbool.html">bool</a> before_advance)</td></tr>
<tr class="separator:a9e3ec75cca71a27c6599a48ac6cd37ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3af710d0089b58b5cc087df5b258daec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#a3af710d0089b58b5cc087df5b258daec">StandardTagAndInitStrategySet</a> ()=delete</td></tr>
<tr class="memdesc:a3af710d0089b58b5cc087df5b258daec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classIBTK_1_1StandardTagAndInitStrategySet.html#a3af710d0089b58b5cc087df5b258daec">More...</a><br /></td></tr>
<tr class="separator:a3af710d0089b58b5cc087df5b258daec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec57c36125aa9d4690424b95b023c347"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#aec57c36125aa9d4690424b95b023c347">StandardTagAndInitStrategySet</a> (const <a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html">StandardTagAndInitStrategySet</a> &amp;from)=delete</td></tr>
<tr class="memdesc:aec57c36125aa9d4690424b95b023c347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classIBTK_1_1StandardTagAndInitStrategySet.html#aec57c36125aa9d4690424b95b023c347">More...</a><br /></td></tr>
<tr class="separator:aec57c36125aa9d4690424b95b023c347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1eb26dab7ceff26c7155b59ec5b5d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html">StandardTagAndInitStrategySet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#a7d1eb26dab7ceff26c7155b59ec5b5d1">operator=</a> (const <a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html">StandardTagAndInitStrategySet</a> &amp;that)=delete</td></tr>
<tr class="memdesc:a7d1eb26dab7ceff26c7155b59ec5b5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classIBTK_1_1StandardTagAndInitStrategySet.html#a7d1eb26dab7ceff26c7155b59ec5b5d1">More...</a><br /></td></tr>
<tr class="separator:a7d1eb26dab7ceff26c7155b59ec5b5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa303191faf9a1455a2f627dd180d566d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; NDIM &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#aa303191faf9a1455a2f627dd180d566d">d_strategy_set</a></td></tr>
<tr class="memdesc:aa303191faf9a1455a2f627dd180d566d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of <a class="el" href="namespaceSAMRAI_1_1xfer.html">SAMRAI::xfer</a>:StandardTagAndInitStrategy objects.  <a href="classIBTK_1_1StandardTagAndInitStrategySet.html#aa303191faf9a1455a2f627dd180d566d">More...</a><br /></td></tr>
<tr class="separator:aa303191faf9a1455a2f627dd180d566d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb77070050e657eff62e9c755815c1b2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#abb77070050e657eff62e9c755815c1b2">d_managed</a></td></tr>
<tr class="memdesc:abb77070050e657eff62e9c755815c1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean value that indicates whether this class should provide memory management for the strategy objects.  <a href="classIBTK_1_1StandardTagAndInitStrategySet.html#abb77070050e657eff62e9c755815c1b2">More...</a><br /></td></tr>
<tr class="separator:abb77070050e657eff62e9c755815c1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is primarily intended to provide a mechanism for allowing user-define tagging criteria.</p>
<dl class="section note"><dt>Note</dt><dd>When the return value of a method is a timestep size, class <a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html" title="Class StandardTagAndInitStrategySet is a utility class that allows multiple SAMRAI::mesh::StandardTag...">StandardTagAndInitStrategySet</a> returns the <em>minimum</em> timestep size computed by the collection of concrete <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a> objects. Consequently, user-defined tagging classes <em>must</em> provide implementations of <a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#a7690d66af8892d5deff4a2de5e292ec2">getLevelDt()</a> and <a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#ae70dc8d9c84013394c7321a963c72395">advanceLevel()</a> which return a large value such as <em>MAX_DOUBLE</em> as the timestep size.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not all concrete implementations of class <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a> will work properly with class <a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html" title="Class StandardTagAndInitStrategySet is a utility class that allows multiple SAMRAI::mesh::StandardTag...">StandardTagAndInitStrategySet</a>. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0bd1d748ceb96053f8ca306c3cdcca13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd1d748ceb96053f8ca306c3cdcca13">&#9670;&nbsp;</a></span>StandardTagAndInitStrategySet() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::StandardTagAndInitStrategySet::StandardTagAndInitStrategySet </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>managed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cf967e3f53dc9347af502852f14434c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf967e3f53dc9347af502852f14434c">&#9670;&nbsp;</a></span>~StandardTagAndInitStrategySet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::StandardTagAndInitStrategySet::~StandardTagAndInitStrategySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3af710d0089b58b5cc087df5b258daec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af710d0089b58b5cc087df5b258daec">&#9670;&nbsp;</a></span>StandardTagAndInitStrategySet() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::StandardTagAndInitStrategySet::StandardTagAndInitStrategySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This constructor is not implemented and should not be used. </dd></dl>

</div>
</div>
<a id="aec57c36125aa9d4690424b95b023c347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec57c36125aa9d4690424b95b023c347">&#9670;&nbsp;</a></span>StandardTagAndInitStrategySet() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::StandardTagAndInitStrategySet::StandardTagAndInitStrategySet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html">StandardTagAndInitStrategySet</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This constructor is not implemented and should not be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The value to copy to this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7690d66af8892d5deff4a2de5e292ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7690d66af8892d5deff4a2de5e292ec2">&#9670;&nbsp;</a></span>getLevelDt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBTK::StandardTagAndInitStrategySet::getLevelDt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dt_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine time increment to advance data on level. </p>

</div>
</div>
<a id="ae70dc8d9c84013394c7321a963c72395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70dc8d9c84013394c7321a963c72395">&#9670;&nbsp;</a></span>advanceLevel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBTK::StandardTagAndInitStrategySet::advanceLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>first_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>last_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>regrid_advance</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance data on all patches on specified patch level from current time (current_time) to new time (new_time). This routine is called only during time-dependent regridding procedures, such as Richardson extrapolation. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. The boolean arguments are used to determine the state of the algorithm and the data when the advance routine is called. Note that this advance function is also used during normal time integration steps.</p>
<p>When this function is called, the level data required to begin the advance must be allocated and be defined appropriately. Typically, this is equivalent to what is needed to initialize a new level after regridding. Upon exiting this routine, both current and new data may exist on the level. This data is needed until level synchronization occurs, in general. Current and new data may be reset by calling the member function <a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#a57b655d72e921cbb85fca891d55ec787">resetTimeDependentData()</a>.</p>
<p>This routine is called from two different points within the Richardson extrapolation process: to advance a temporary level that is coarser than the hierarchy level on which error estimation is performed, and to advance the hierarchy level itself. In the first case, the values of the boolean flags are:</p>
<ul>
<li><b>first_step</b> = true.</li>
<li><b>last_step</b> = true.</li>
<li><b>regrid_advance</b> = true.</li>
</ul>
<p>In the second case, the values of the boolean flags are:</p>
<ul>
<li><b>first_step</b> (when regridding during time integration sequence) = true when the level is not coarsest level to synchronize immediately before the regridding process; else, false. (when generating initial hierarchy construction) = true, even though there may be multiple advance steps.</li>
<li><b>last_step</b> = true when the advance is the last in the Richardson extrapolation step sequence; else false.</li>
<li><b>regrid_advance</b> = true. </li>
</ul>

</div>
</div>
<a id="a57b655d72e921cbb85fca891d55ec787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b655d72e921cbb85fca891d55ec787">&#9670;&nbsp;</a></span>resetTimeDependentData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::StandardTagAndInitStrategySet::resetTimeDependentData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>can_be_refined</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset time-dependent data storage for the specified patch level. </p>

</div>
</div>
<a id="a79458abb6c5ab4f4c25c13aa1a7883d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79458abb6c5ab4f4c25c13aa1a7883d7">&#9670;&nbsp;</a></span>resetDataToPreadvanceState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::StandardTagAndInitStrategySet::resetDataToPreadvanceState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset data on the patch level by destroying all patch data other than that which is needed to initialize the solution on that level. In other words, this is the data needed to begin a time integration step on the level. </p>

</div>
</div>
<a id="ac4b7e370f22498fd6ba7a67c8f926c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b7e370f22498fd6ba7a67c8f926c07">&#9670;&nbsp;</a></span>initializeLevelData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::StandardTagAndInitStrategySet::initializeLevelData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>init_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>can_be_refined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>old_level</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;(nullptr)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allocate_data</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize data on a new level after it is inserted into an AMR patch hierarchy by the gridding algorithm. The level number indicates that of the new level.</p>
<p>Generally, when data is set, it is interpolated from coarser levels in the hierarchy. If the old level pointer in the argument list is non-null, then data is copied from the old level to the new level on regions of intersection between those levels before interpolation occurs. In this case, the level number must match that of the old level. The specific operations that occur when initializing level data are determined by the particular solution methods in use; i.e., in the subclass of this abstract base class.</p>
<p>The boolean argument initial_time indicates whether the level is being introduced for the first time (i.e., at initialization time), or after some regrid process during the calculation beyond the initial hierarchy construction. This information is provided since the initialization of the data may be different in each of those circumstances. The can_be_refined boolean argument indicates whether the level is the finest allowable level in the hierarchy. </p>

</div>
</div>
<a id="a0cfd33353f186348bfe7d9569f130ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfd33353f186348bfe7d9569f130ff2">&#9670;&nbsp;</a></span>resetHierarchyConfiguration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::StandardTagAndInitStrategySet::resetHierarchyConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After hierarchy levels have changed and data has been initialized on the new levels, this routine can be used to reset any information needed by the solution method that is particular to the hierarchy configuration. For example, the solution procedure may cache communication schedules to amortize the cost of data movement on the AMR patch hierarchy. This function will be called by the gridding algorithm after the initialization occurs so that the algorithm-specific subclass can reset such things. Also, if the solution method must make the solution consistent across multiple levels after the hierarchy is changed, this process may be invoked by this routine. Of course the details of these processes are determined by the particular solution methods in use.</p>
<p>The level number arguments indicate the coarsest and finest levels in the current hierarchy configuration that have changed. It should be assumed that all intermediate levels have changed as well. </p>

</div>
</div>
<a id="ac23d0d6ca861dd31aa09bd96f554954f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23d0d6ca861dd31aa09bd96f554954f">&#9670;&nbsp;</a></span>applyGradientDetector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::StandardTagAndInitStrategySet::applyGradientDetector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>uses_richardson_extrapolation_too</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set integer tags to "one" in cells where refinement of the given level should occur according to some user-supplied gradient criteria. The double time argument is the regrid time. The integer "tag_index" argument is the patch descriptor index of the cell-centered integer tag array on each patch in the hierarchy. The boolean argument initial_time indicates whether the level is being subject to refinement at the initial simulation time. If it is false, then the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. Typically, this information is passed to the user's patch tagging routines since the error estimator or gradient detector may be different in each case.</p>
<p>The boolean uses_richardson_extrapolation_too is true when Richardson extrapolation error estimation is used in addition to the gradient detector, and false otherwise. This argument helps the user to manage multiple regridding criteria. </p>

</div>
</div>
<a id="a388ba31b7d316274a98e4510384d0cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388ba31b7d316274a98e4510384d0cc4">&#9670;&nbsp;</a></span>applyRichardsonExtrapolation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::StandardTagAndInitStrategySet::applyRichardsonExtrapolation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>deltat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>error_coarsen_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>uses_gradient_detector_too</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set integer tags to "one" in cells where refinement of the given level should occur according to some user-supplied Richardson extrapolation criteria. The "error_data_time" argument is the regrid time. The "deltat" argument is the time increment to advance the solution on the level to be refined. Note that that level is finer than the level in the argument list, in general. The ratio between the argument level and the actual hierarchy level is given by the integer "coarsen ratio".</p>
<p>The integer "tag_index" argument is the patch descriptor index of the cell-centered integer tag array on each patch in the hierarchy.</p>
<p>The boolean argument initial_time indicates whether the level is being subject to refinement at the initial simulation time. If it is false, then the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. Typically, this information is passed to the user's patch tagging routines since the application of the Richardson extrapolation process may be different in each case.</p>
<p>The boolean uses_gradient_detector_too is true when a gradient detector procedure is used in addition to Richardson extrapolation, and false otherwise. This argument helps the user to manage multiple regridding criteria. </p>

</div>
</div>
<a id="ad788b867aa0ed8cd2d72901e58868536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad788b867aa0ed8cd2d72901e58868536">&#9670;&nbsp;</a></span>coarsenDataForRichardsonExtrapolation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::StandardTagAndInitStrategySet::coarsenDataForRichardsonExtrapolation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>coarsen_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>before_advance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen solution data from level to coarse_level for Richardson extrapolation. Note that this routine will be called twice during the Richardson extrapolation error estimation process, once to set data on the coarser level and once to coarsen data from after advancing the fine level. The init_coarse_level boolean argument indicates whether data is set on the coarse level by coarsening the "old" time level solution or by coarsening the "new" solution on the fine level (i.e., after it has been advanced). </p>

</div>
</div>
<a id="a7d1eb26dab7ceff26c7155b59ec5b5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1eb26dab7ceff26c7155b59ec5b5d1">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html">StandardTagAndInitStrategySet</a>&amp; IBTK::StandardTagAndInitStrategySet::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html">StandardTagAndInitStrategySet</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This operator is not implemented and should not be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>The value to assign to this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<a id="a5263bfe8622e41d1a2df35f9803a5ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5263bfe8622e41d1a2df35f9803a5ca1">&#9670;&nbsp;</a></span>getLevelDt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::getLevelDt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dt_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine time increment to advance data on level. The recompute_dt option specifies whether to compute the timestep using the current level data or to return the value stored by the time integrator. The default true setting means the timestep will be computed if no value is supplied. <br  />
</p>
<p>This routine is only when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="a9e4e8a35a6b5ab6ec7e14f040e718adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4e8a35a6b5ab6ec7e14f040e718adf">&#9670;&nbsp;</a></span>advanceLevel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::advanceLevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>first_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>last_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>regrid_advance</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance data on all patches on specified patch level from current time (current_time) to new time (new_time). This routine is called only during time-dependent regridding procedures, such as Richardson extrapolation. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. The boolean arguments are used to determine the state of the algorithm and the data when the advance routine is called. Note that this advance function is also used during normal time integration steps.</p>
<p>When this function is called, the level data required to begin the advance must be allocated and be defined appropriately. Typically, this is equivalent to what is needed to initialize a new level after regridding. Upon exiting this routine, both current and new data may exist on the level. This data is needed until level synchronization occurs, in general. Current and new data may be reset by calling the member function <a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html#a57b655d72e921cbb85fca891d55ec787">resetTimeDependentData()</a>.</p>
<p>This routine is called from two different points within the Richardson exptrapolation process: to advance a temporary level that is coarser than the hierarchy level on which error estimation is performed, and to advance the hierarchy level itself. In the first case, the values of the boolean flags are:</p>
<ul>
<li><b>first_step</b> = true.</li>
<li><b>last_step</b> = true.</li>
<li><b>regrid_advance</b> = true.</li>
</ul>
<p>In the second case, the values of the boolean flags are:</p>
<ul>
<li><b>first_step</b> (when regridding during time integration sequence) = true when the level is not coarsest level to synchronize immediately before the regridding process; else, false. (when generating initial hierarchy construction) = true, even though there may be multiple advance steps.</li>
<li><b>last_step</b> = true when the advance is the last in the Richardson extrapolation step sequence; else false.</li>
<li><b>regrid_advance</b> = true. </li>
</ul>

</div>
</div>
<a id="a97641642baa1b5c67749fada52b12341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97641642baa1b5c67749fada52b12341">&#9670;&nbsp;</a></span>resetTimeDependentData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::resetTimeDependentData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>can_be_refined</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset time-dependent data storage for the specified patch level.</p>
<p>This routine only applies when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="af6f563618437d3a5231d35eb6937fcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f563618437d3a5231d35eb6937fcd1">&#9670;&nbsp;</a></span>resetDataToPreadvanceState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::resetDataToPreadvanceState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset data on the patch level by destroying all patch data other than that which is needed to initialize the solution on that level. In other words, this is the data needed to begin a time integration step on the level.</p>
<p>This routine is only when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="af8f31cfe38a0690a629fcbeb7ad89888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f31cfe38a0690a629fcbeb7ad89888">&#9670;&nbsp;</a></span>initializeLevelData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::initializeLevelData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>init_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>can_be_refined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>old_level</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt;DIM&gt;&#160;&gt;(NULL)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allocate_data</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize data on a new level after it is inserted into an AMR patch hierarchy by the gridding algorithm. The level number indicates that of the new level.</p>
<p>Generally, when data is set, it is interpolated from coarser levels in the hierarchy. If the old level pointer in the argument list is non-null, then data is copied from the old level to the new level on regions of intersection between those levels before interpolation occurs. In this case, the level number must match that of the old level. The specific operations that occur when initializing level data are determined by the particular solution methods in use; i.e., in the subclass of this abstract base class.</p>
<p>The boolean argument initial_time indicates whether the level is being introduced for the first time (i.e., at initialization time), or after some regrid process during the calculation beyond the initial hierarchy construction. This information is provided since the initialization of the data may be different in each of those circumstances. The can_be_refined boolean argument indicates whether the level is the finest allowable level in the hierarchy. </p>

</div>
</div>
<a id="a6f8d89482d4bdafc824307cc21c728c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8d89482d4bdafc824307cc21c728c9">&#9670;&nbsp;</a></span>resetHierarchyConfiguration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::resetHierarchyConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After hierarchy levels have changed and data has been initialized on the new levels, this routine can be used to reset any information needed by the solution method that is particular to the hierarchy configuration. For example, the solution procedure may cache communication schedules to amortize the cost of data movement on the AMR patch hierarchy. This function will be called by the gridding algorithm after the initialization occurs so that the algorithm-specific subclass can reset such things. Also, if the solution method must make the solution consistent across multiple levels after the hierarchy is changed, this process may be invoked by this routine. Of course the details of these processes are determined by the particular solution methods in use.</p>
<p>The level number arguments indicate the coarsest and finest levels in the current hierarchy configuration that have changed. It should be assumed that all intermediate levels have changed as well. </p>

</div>
</div>
<a id="ac201b9cd28087aa92f9c1370f147667a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac201b9cd28087aa92f9c1370f147667a">&#9670;&nbsp;</a></span>applyGradientDetector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::applyGradientDetector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>uses_richardson_extrapolation_too</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set integer tags to "one" in cells where refinement of the given level should occur according to some user-supplied gradient criteria. The double time argument is the regrid time. The integer "tag_index" argument is the patch descriptor index of the cell-centered integer tag array on each patch in the hierarchy. The boolean argument initial_time indicates whether the level is being subject to refinement at the initial simulation time. If it is false, then the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. Typically, this information is passed to the user's patch tagging routines since the error estimator or gradient detector may be different in each case.</p>
<p>The boolean uses_richardson_extrapolation_too is true when Richardson extrapolation error estimation is used in addition to the gradient detector, and false otherwise. This argument helps the user to manage multiple regridding criteria.</p>
<p>This routine is only when gradient detector is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="a81e5b7b5d98eaf7221b5088b0d12a2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e5b7b5d98eaf7221b5088b0d12a2a8">&#9670;&nbsp;</a></span>applyRichardsonExtrapolation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::applyRichardsonExtrapolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>deltat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>error_coarsen_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>uses_gradient_detector_too</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set integer tags to "one" in cells where refinement of the given level should occur according to some user-supplied Richardson extrapolation criteria. The "error_data_time" argument is the regrid time. The "deltat" argument is the time increment to advance the solution on the level to be refined. Note that that level is finer than the level in the argument list, in general. The ratio between the argument level and the actual hierarchy level is given by the integer "coarsen ratio".</p>
<p>The integer "tag_index" argument is the patch descriptor index of the cell-centered integer tag array on each patch in the hierarchy.</p>
<p>The boolean argument initial_time indicates whether the level is being subject to refinement at the initial simulation time. If it is false, then the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. Typically, this information is passed to the user's patch tagging routines since the application of the Richardson extrapolation process may be different in each case.</p>
<p>The boolean uses_gradient_detector_too is true when a gradient detector procedure is used in addition to Richardson extrapolation, and false otherwise. This argument helps the user to manage multiple regridding criteria.</p>
<p>This routine is only when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="a9e3ec75cca71a27c6599a48ac6cd37ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3ec75cca71a27c6599a48ac6cd37ea">&#9670;&nbsp;</a></span>coarsenDataForRichardsonExtrapolation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::coarsenDataForRichardsonExtrapolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>coarsen_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>before_advance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen solution data from level to coarse_level for Richardson extrapolation. Note that this routine will be called twice during the Richardson extrapolation error estimation process, once to set data on the coarser level and once to coarsen data from after advancing the fine level. The init_coarse_level boolean argument indicates whether data is set on the coarse level by coarsening the "old" time level solution or by coarsening the "new" solution on the fine level (i.e., after it has been advanced).</p>
<p>This routine is only when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa303191faf9a1455a2f627dd180d566d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa303191faf9a1455a2f627dd180d566d">&#9670;&nbsp;</a></span>d_strategy_set</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt;NDIM&gt;*&gt; IBTK::StandardTagAndInitStrategySet::d_strategy_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb77070050e657eff62e9c755815c1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb77070050e657eff62e9c755815c1b2">&#9670;&nbsp;</a></span>d_managed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbool.html">bool</a> IBTK::StandardTagAndInitStrategySet::d_managed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ibtk/include/ibtk/<a class="el" href="StandardTagAndInitStrategySet_8h.html">StandardTagAndInitStrategySet.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
