<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: IBAMR::CIBMethod Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IBAMR
   &#160;<span id="projectnumber">IBAMR version 0.18.</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceIBAMR.html">IBAMR</a></li><li class="navelem"><a class="el" href="classIBAMR_1_1CIBMethod.html">CIBMethod</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classIBAMR_1_1CIBMethod-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IBAMR::CIBMethod Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class <a class="el" href="classIBAMR_1_1CIBMethod.html" title="Class CIBMethod is a concrete CIBStrategy and IBMethod class which implements the motion of rigid bod...">CIBMethod</a> is a concrete <a class="el" href="classIBAMR_1_1CIBStrategy.html" title="Class CIBStrategy is a lightweight abstract strategy class which provides support for constraint base...">CIBStrategy</a> and <a class="el" href="classIBAMR_1_1IBMethod.html" title="Class IBMethod is an implementation of the abstract base class IBImplicitStrategy that provides funct...">IBMethod</a> class which implements the motion of rigid bodies using the constraint formulation. The immersed structure is discretized using standard IB markers.  
</p>

<p><code>#include &lt;ibamr/CIBMethod.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IBAMR::CIBMethod:</div>
<div class="dyncontent">
<div class="center"><img src="classIBAMR_1_1CIBMethod__inherit__graph.png" border="0" usemap="#IBAMR_1_1CIBMethod_inherit__map" alt="Inheritance graph"/></div>
<map name="IBAMR_1_1CIBMethod_inherit__map" id="IBAMR_1_1CIBMethod_inherit__map">
<area shape="rect" title="Class CIBMethod is a concrete CIBStrategy and IBMethod class which implements the motion of rigid bod..." alt="" coords="273,541,417,568"/>
<area shape="rect" href="classIBAMR_1_1IBMethod.html" title="Class IBMethod is an implementation of the abstract base class IBImplicitStrategy that provides funct..." alt="" coords="221,465,356,492"/>
<area shape="rect" href="classIBAMR_1_1IBImplicitStrategy.html" title="Class IBImplicitStrategy provides a generic interface for specifying the implementation details of a ..." alt="" coords="172,389,363,416"/>
<area shape="rect" href="classIBAMR_1_1IBStrategy.html" title="Class IBStrategy provides a generic interface for specifying the implementation details of a particul..." alt="" coords="197,313,338,340"/>
<area shape="rect" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html" title=" " alt="" coords="5,197,212,239"/>
<area shape="rect" href="classSAMRAI_1_1tbox_1_1DescribedClass.html" title="Base class for all objects that use run&#45;time type identification (RTTI)." alt="" coords="170,5,389,32"/>
<area shape="rect" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html" title=" " alt="" coords="71,81,277,123"/>
<area shape="rect" href="classSAMRAI_1_1tbox_1_1Serializable.html" title=" " alt="" coords="186,147,381,173"/>
<area shape="rect" href="classIBAMR_1_1CIBStrategy.html" title="Class CIBStrategy is a lightweight abstract strategy class which provides support for constraint base..." alt="" coords="325,263,476,289"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIBAMR_1_1CIBMethod_1_1ConstrainedVelocityFcnsData.html">ConstrainedVelocityFcnsData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct encapsulating constrained velocity functions data.  <a href="structIBAMR_1_1CIBMethod_1_1ConstrainedVelocityFcnsData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIBAMR_1_1CIBMethod_1_1ExternalForceTorqueFcnData.html">ExternalForceTorqueFcnData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct encapsulating external force and torque function data.  <a href="structIBAMR_1_1CIBMethod_1_1ExternalForceTorqueFcnData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac67ecf6e898013c0c44a74dc6dedab0c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#ac67ecf6e898013c0c44a74dc6dedab0c">ConstrainedNodalVelocityFcnPtr</a> = void(*)(Vec U_k, const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;U, Vec X, const Eigen::Vector3d &amp;X_com, const Eigen::Matrix3d &amp;rotation_mat, <a class="el" href="classdouble.html">double</a> data_time, void *ctx)</td></tr>
<tr class="memdesc:ac67ecf6e898013c0c44a74dc6dedab0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef specifying interface for specifying constrained body velocities.  <a href="classIBAMR_1_1CIBMethod.html#ac67ecf6e898013c0c44a74dc6dedab0c">More...</a><br /></td></tr>
<tr class="separator:ac67ecf6e898013c0c44a74dc6dedab0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fdb3cbddcc7101ddd142bf7a1f6131"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a41fdb3cbddcc7101ddd142bf7a1f6131">ConstrainedCOMVelocityFcnPtr</a> = void(*)(<a class="el" href="classdouble.html">double</a> data_time, Eigen::Vector3d &amp;U_com, Eigen::Vector3d &amp;W_com, void *ctx)</td></tr>
<tr class="separator:a41fdb3cbddcc7101ddd142bf7a1f6131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8f328ae21580abd7a510494b1039c2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a5d8f328ae21580abd7a510494b1039c2">ExternalForceTorqueFcnPtr</a> = void(*)(<a class="el" href="classdouble.html">double</a> data_time, Eigen::Vector3d &amp;F, Eigen::Vector3d &amp;T, void *ctx)</td></tr>
<tr class="memdesc:a5d8f328ae21580abd7a510494b1039c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef specifying interface for specifying net external force and torque on structures.  <a href="classIBAMR_1_1CIBMethod.html#a5d8f328ae21580abd7a510494b1039c2">More...</a><br /></td></tr>
<tr class="separator:a5d8f328ae21580abd7a510494b1039c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d078ef3235314b1f94a2222c8771d1a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a1d078ef3235314b1f94a2222c8771d1a">preprocessSolveFluidEqn_callbackfcn</a> = void(*)(const <a class="el" href="classdouble.html">double</a>, const <a class="el" href="classdouble.html">double</a>, const <a class="el" href="classint.html">int</a>, void *)</td></tr>
<tr class="memdesc:a1d078ef3235314b1f94a2222c8771d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callbacks before INS is integrated.  <a href="classIBAMR_1_1CIBMethod.html#a1d078ef3235314b1f94a2222c8771d1a">More...</a><br /></td></tr>
<tr class="separator:a1d078ef3235314b1f94a2222c8771d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a731cc8f933b63539489dea75a079f7b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a731cc8f933b63539489dea75a079f7b5">CIBMethod</a> (std::string object_name, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; input_db, const <a class="el" href="classint.html">int</a> no_structures=1, <a class="el" href="classbool.html">bool</a> register_for_restart=true)</td></tr>
<tr class="memdesc:a731cc8f933b63539489dea75a079f7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class.  <a href="classIBAMR_1_1CIBMethod.html#a731cc8f933b63539489dea75a079f7b5">More...</a><br /></td></tr>
<tr class="separator:a731cc8f933b63539489dea75a079f7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ec96154b38bbd49bd651caa8017562"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#af3ec96154b38bbd49bd651caa8017562">~CIBMethod</a> ()</td></tr>
<tr class="memdesc:af3ec96154b38bbd49bd651caa8017562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the class.  <a href="classIBAMR_1_1CIBMethod.html#af3ec96154b38bbd49bd651caa8017562">More...</a><br /></td></tr>
<tr class="separator:af3ec96154b38bbd49bd651caa8017562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9b8ad393ec5dacca79bd3f8b7dd854"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#aeb9b8ad393ec5dacca79bd3f8b7dd854">registerConstrainedVelocityFunction</a> (<a class="el" href="classIBAMR_1_1CIBMethod.html#ac67ecf6e898013c0c44a74dc6dedab0c">ConstrainedNodalVelocityFcnPtr</a> nodalvelfcn, <a class="el" href="classIBAMR_1_1CIBMethod.html#a41fdb3cbddcc7101ddd142bf7a1f6131">ConstrainedCOMVelocityFcnPtr</a> comvelfcn, void *ctx=nullptr, unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="memdesc:aeb9b8ad393ec5dacca79bd3f8b7dd854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register user defined constrained velocity functions.  <a href="classIBAMR_1_1CIBMethod.html#aeb9b8ad393ec5dacca79bd3f8b7dd854">More...</a><br /></td></tr>
<tr class="separator:aeb9b8ad393ec5dacca79bd3f8b7dd854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eda7ad8d32c8baf1acfd4601aa1ab28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a0eda7ad8d32c8baf1acfd4601aa1ab28">registerConstrainedVelocityFunction</a> (const <a class="el" href="structIBAMR_1_1CIBMethod_1_1ConstrainedVelocityFcnsData.html">ConstrainedVelocityFcnsData</a> &amp;data, unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="memdesc:a0eda7ad8d32c8baf1acfd4601aa1ab28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register user defined constrained velocity function data.  <a href="classIBAMR_1_1CIBMethod.html#a0eda7ad8d32c8baf1acfd4601aa1ab28">More...</a><br /></td></tr>
<tr class="separator:a0eda7ad8d32c8baf1acfd4601aa1ab28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132bb68d29460c83daca8e99d6b48db0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a132bb68d29460c83daca8e99d6b48db0">registerExternalForceTorqueFunction</a> (<a class="el" href="classIBAMR_1_1CIBMethod.html#a5d8f328ae21580abd7a510494b1039c2">ExternalForceTorqueFcnPtr</a> forcetorquefcn, void *ctx=nullptr, unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="memdesc:a132bb68d29460c83daca8e99d6b48db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an external force and torque function.  <a href="classIBAMR_1_1CIBMethod.html#a132bb68d29460c83daca8e99d6b48db0">More...</a><br /></td></tr>
<tr class="separator:a132bb68d29460c83daca8e99d6b48db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a17518739451320a70907076c8d2c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a25a17518739451320a70907076c8d2c5">registerExternalForceTorqueFunction</a> (const <a class="el" href="structIBAMR_1_1CIBMethod_1_1ExternalForceTorqueFcnData.html">ExternalForceTorqueFcnData</a> &amp;data, unsigned <a class="el" href="classint.html">int</a> part=0)</td></tr>
<tr class="memdesc:a25a17518739451320a70907076c8d2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an external force and torque function data.  <a href="classIBAMR_1_1CIBMethod.html#a25a17518739451320a70907076c8d2c5">More...</a><br /></td></tr>
<tr class="separator:a25a17518739451320a70907076c8d2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e99018652e9df319e180bb51e7806d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a9e99018652e9df319e180bb51e7806d1">getStructuresLevelNumber</a> () const</td></tr>
<tr class="memdesc:a9e99018652e9df319e180bb51e7806d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the level on which the structures reside.  <a href="classIBAMR_1_1CIBMethod.html#a9e99018652e9df319e180bb51e7806d1">More...</a><br /></td></tr>
<tr class="separator:a9e99018652e9df319e180bb51e7806d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73a3c21695b4e042cfd0b9304a14432"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#aa73a3c21695b4e042cfd0b9304a14432">getStructureHandle</a> (const <a class="el" href="classint.html">int</a> lag_idx) const</td></tr>
<tr class="memdesc:aa73a3c21695b4e042cfd0b9304a14432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the structure handle to which this Lagrangian index belongs.  <a href="classIBAMR_1_1CIBMethod.html#aa73a3c21695b4e042cfd0b9304a14432">More...</a><br /></td></tr>
<tr class="separator:aa73a3c21695b4e042cfd0b9304a14432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ab6980def8b2d2d1ff26aef04660f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a23ab6980def8b2d2d1ff26aef04660f2">registerPreProcessSolveFluidEquationsCallBackFcn</a> (<a class="el" href="classIBAMR_1_1CIBMethod.html#a1d078ef3235314b1f94a2222c8771d1a">preprocessSolveFluidEqn_callbackfcn</a> callback, void *ctx)</td></tr>
<tr class="memdesc:a23ab6980def8b2d2d1ff26aef04660f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register any preprocess fluid solve callback functions.  <a href="classIBAMR_1_1CIBMethod.html#a23ab6980def8b2d2d1ff26aef04660f2">More...</a><br /></td></tr>
<tr class="separator:a23ab6980def8b2d2d1ff26aef04660f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0d67fbc16f0c938ada431136e2f4c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#aff0d67fbc16f0c938ada431136e2f4c7">preprocessSolveFluidEquations</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time, <a class="el" href="classint.html">int</a> cycle_num) override</td></tr>
<tr class="memdesc:aff0d67fbc16f0c938ada431136e2f4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate any body forces for INS solver over here.  <a href="classIBAMR_1_1CIBMethod.html#aff0d67fbc16f0c938ada431136e2f4c7">More...</a><br /></td></tr>
<tr class="separator:aff0d67fbc16f0c938ada431136e2f4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdca9dbaa626e5e1654274ef6d5bf578"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#abdca9dbaa626e5e1654274ef6d5bf578">registerEulerianVariables</a> () override</td></tr>
<tr class="memdesc:abdca9dbaa626e5e1654274ef6d5bf578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register Eulerian variables with the parent <a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html" title="Class IBHierarchyIntegrator provides an abstract interface for a time integrator for various versions...">IBHierarchyIntegrator</a>.  <a href="classIBAMR_1_1CIBMethod.html#abdca9dbaa626e5e1654274ef6d5bf578">More...</a><br /></td></tr>
<tr class="separator:abdca9dbaa626e5e1654274ef6d5bf578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f369c438fd90b1cf4799c5810609e6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a5f369c438fd90b1cf4799c5810609e6a">registerEulerianCommunicationAlgorithms</a> () override</td></tr>
<tr class="memdesc:a5f369c438fd90b1cf4799c5810609e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register Eulerian refinement or coarsening algorithms with the parent <a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html" title="Class IBHierarchyIntegrator provides an abstract interface for a time integrator for various versions...">IBHierarchyIntegrator</a>.  <a href="classIBAMR_1_1CIBMethod.html#a5f369c438fd90b1cf4799c5810609e6a">More...</a><br /></td></tr>
<tr class="separator:a5f369c438fd90b1cf4799c5810609e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac534b62ee373d1a8b9bc1871174b78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a8ac534b62ee373d1a8b9bc1871174b78">preprocessIntegrateData</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time, <a class="el" href="classint.html">int</a> num_cycles) override</td></tr>
<tr class="memdesc:a8ac534b62ee373d1a8b9bc1871174b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to prepare to advance data from current_time to new_time.  <a href="classIBAMR_1_1CIBMethod.html#a8ac534b62ee373d1a8b9bc1871174b78">More...</a><br /></td></tr>
<tr class="separator:a8ac534b62ee373d1a8b9bc1871174b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a59b6d2461047316363e77b7315cf64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a7a59b6d2461047316363e77b7315cf64">postprocessIntegrateData</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time, <a class="el" href="classint.html">int</a> num_cycles) override</td></tr>
<tr class="memdesc:a7a59b6d2461047316363e77b7315cf64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to clean up data following call(s) to integrateHierarchy().  <a href="classIBAMR_1_1CIBMethod.html#a7a59b6d2461047316363e77b7315cf64">More...</a><br /></td></tr>
<tr class="separator:a7a59b6d2461047316363e77b7315cf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5a4677e4db9521da8560da1b4bcc2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#acf5a4677e4db9521da8560da1b4bcc2d">initializeLevelData</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classint.html">int</a> level_number, <a class="el" href="classdouble.html">double</a> init_data_time, <a class="el" href="classbool.html">bool</a> can_be_refined, <a class="el" href="classbool.html">bool</a> initial_time, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt; old_level, <a class="el" href="classbool.html">bool</a> allocate_data) override</td></tr>
<tr class="memdesc:acf5a4677e4db9521da8560da1b4bcc2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize data on a new level after it is inserted into an AMR patch hierarchy by the gridding algorithm.  <a href="classIBAMR_1_1CIBMethod.html#acf5a4677e4db9521da8560da1b4bcc2d">More...</a><br /></td></tr>
<tr class="separator:acf5a4677e4db9521da8560da1b4bcc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2df481d2b08356bd3dd86fcd7b6b4bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#ad2df481d2b08356bd3dd86fcd7b6b4bd">initializePatchHierarchy</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt; gridding_alg, <a class="el" href="classint.html">int</a> u_data_idx, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;u_synch_scheds, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;u_ghost_fill_scheds, <a class="el" href="classint.html">int</a> integrator_step, <a class="el" href="classdouble.html">double</a> init_data_time, <a class="el" href="classbool.html">bool</a> initial_time) override</td></tr>
<tr class="memdesc:ad2df481d2b08356bd3dd86fcd7b6b4bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Lagrangian data corresponding to the given AMR patch hierarchy at the start of a computation. If the computation is begun from a restart file, data may be read from the restart databases.  <a href="classIBAMR_1_1CIBMethod.html#ad2df481d2b08356bd3dd86fcd7b6b4bd">More...</a><br /></td></tr>
<tr class="separator:ad2df481d2b08356bd3dd86fcd7b6b4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62cf95c2d79e3a5a61928ec3e873e77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#ab62cf95c2d79e3a5a61928ec3e873e77">interpolateVelocity</a> (<a class="el" href="classint.html">int</a> u_data_idx, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;u_synch_scheds, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;u_ghost_fill_scheds, <a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="memdesc:ab62cf95c2d79e3a5a61928ec3e873e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate the Eulerian velocity to the curvilinear mesh at the specified time within the current time interval.  <a href="classIBAMR_1_1CIBMethod.html#ab62cf95c2d79e3a5a61928ec3e873e77">More...</a><br /></td></tr>
<tr class="separator:ab62cf95c2d79e3a5a61928ec3e873e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5a40e194d6c9b2b2bc4370c06640df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#abf5a40e194d6c9b2b2bc4370c06640df">spreadForce</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">IBTK::RobinPhysBdryPatchStrategy</a> *f_phys_bdry_op, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_prolongation_scheds, <a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="memdesc:abf5a40e194d6c9b2b2bc4370c06640df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spread the Lagrangian force to the Cartesian grid at the specified time within the current time interval.  <a href="classIBAMR_1_1CIBMethod.html#abf5a40e194d6c9b2b2bc4370c06640df">More...</a><br /></td></tr>
<tr class="separator:abf5a40e194d6c9b2b2bc4370c06640df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add31f9b7dce13b22aeb1315d68c506d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#add31f9b7dce13b22aeb1315d68c506d9">forwardEulerStep</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time) override</td></tr>
<tr class="memdesc:add31f9b7dce13b22aeb1315d68c506d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the positions of the Lagrangian structure using the forward Euler method.  <a href="classIBAMR_1_1CIBMethod.html#add31f9b7dce13b22aeb1315d68c506d9">More...</a><br /></td></tr>
<tr class="separator:add31f9b7dce13b22aeb1315d68c506d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bfa4109e46499e7cb176145ad4b524"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a94bfa4109e46499e7cb176145ad4b524">backwardEulerStep</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time) override</td></tr>
<tr class="memdesc:a94bfa4109e46499e7cb176145ad4b524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the positions of the Lagrangian structure using the backward Euler method.  <a href="classIBAMR_1_1CIBMethod.html#a94bfa4109e46499e7cb176145ad4b524">More...</a><br /></td></tr>
<tr class="separator:a94bfa4109e46499e7cb176145ad4b524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c592381045f38c69d0019acddc9653e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a7c592381045f38c69d0019acddc9653e">midpointStep</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time) override</td></tr>
<tr class="memdesc:a7c592381045f38c69d0019acddc9653e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the positions of the Lagrangian structure using the (explicit) midpoint rule.  <a href="classIBAMR_1_1CIBMethod.html#a7c592381045f38c69d0019acddc9653e">More...</a><br /></td></tr>
<tr class="separator:a7c592381045f38c69d0019acddc9653e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e73fc1a58ed983b3f653609f4c0aee2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a8e73fc1a58ed983b3f653609f4c0aee2">trapezoidalStep</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time) override</td></tr>
<tr class="memdesc:a8e73fc1a58ed983b3f653609f4c0aee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the positions of the Lagrangian structure using the trapezoidal rule.  <a href="classIBAMR_1_1CIBMethod.html#a8e73fc1a58ed983b3f653609f4c0aee2">More...</a><br /></td></tr>
<tr class="separator:a8e73fc1a58ed983b3f653609f4c0aee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73e7b840266715988b40f7357b53b42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#af73e7b840266715988b40f7357b53b42">registerVisItDataWriter</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">SAMRAI::appu::VisItDataWriter</a>&lt; NDIM &gt; &gt; visit_writer)</td></tr>
<tr class="memdesc:af73e7b840266715988b40f7357b53b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register VisIt data writer to output data files that may be postprocessed with the VisIt visualization tool.  <a href="classIBAMR_1_1CIBMethod.html#af73e7b840266715988b40f7357b53b42">More...</a><br /></td></tr>
<tr class="separator:af73e7b840266715988b40f7357b53b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0a77e2e1cd58936be7b9f7810e2d4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a4a0a77e2e1cd58936be7b9f7810e2d4c">putToDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; db) override</td></tr>
<tr class="memdesc:a4a0a77e2e1cd58936be7b9f7810e2d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override the putToDatabase method of the base Serializable class.  <a href="classIBAMR_1_1CIBMethod.html#a4a0a77e2e1cd58936be7b9f7810e2d4c">More...</a><br /></td></tr>
<tr class="separator:a4a0a77e2e1cd58936be7b9f7810e2d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b21e4a631bea521aaa8e7bc39707c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#ab5b21e4a631bea521aaa8e7bc39707c3">setConstraintForce</a> (Vec L, const <a class="el" href="classdouble.html">double</a> data_time, const <a class="el" href="classdouble.html">double</a> scale=1.0) override</td></tr>
<tr class="memdesc:ab5b21e4a631bea521aaa8e7bc39707c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the constraint force in the internal data structures of the class.  <a href="classIBAMR_1_1CIBMethod.html#ab5b21e4a631bea521aaa8e7bc39707c3">More...</a><br /></td></tr>
<tr class="separator:ab5b21e4a631bea521aaa8e7bc39707c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45b029cc8728c27286c2bcc694fc310"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#af45b029cc8728c27286c2bcc694fc310">getConstraintForce</a> (Vec *L, const <a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="memdesc:af45b029cc8728c27286c2bcc694fc310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the constraint rigid body force at the specified time within the current time interval.  <a href="classIBAMR_1_1CIBMethod.html#af45b029cc8728c27286c2bcc694fc310">More...</a><br /></td></tr>
<tr class="separator:af45b029cc8728c27286c2bcc694fc310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a22a6c03f6e31c8922651cd1b7946fd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a3a22a6c03f6e31c8922651cd1b7946fd">getFreeRigidVelocities</a> (Vec *U, const <a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="memdesc:a3a22a6c03f6e31c8922651cd1b7946fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the free rigid velocities (DOFs) at the specified time within the current time interval.  <a href="classIBAMR_1_1CIBMethod.html#a3a22a6c03f6e31c8922651cd1b7946fd">More...</a><br /></td></tr>
<tr class="separator:a3a22a6c03f6e31c8922651cd1b7946fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6784590dcd6f5495cc7d4a49eb9b53a8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a6784590dcd6f5495cc7d4a49eb9b53a8">getNetExternalForceTorque</a> (Vec *F, const <a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="memdesc:a6784590dcd6f5495cc7d4a49eb9b53a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get net external force and torque at the specified time within the current time interval.  <a href="classIBAMR_1_1CIBMethod.html#a6784590dcd6f5495cc7d4a49eb9b53a8">More...</a><br /></td></tr>
<tr class="separator:a6784590dcd6f5495cc7d4a49eb9b53a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641234ee6e8d986a5d4d4a8ad72730cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a641234ee6e8d986a5d4d4a8ad72730cd">subtractMeanConstraintForce</a> (Vec L, <a class="el" href="classint.html">int</a> f_data_idx, const <a class="el" href="classdouble.html">double</a> scale=1.0) override</td></tr>
<tr class="memdesc:a641234ee6e8d986a5d4d4a8ad72730cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract the mean of constraint force from the background Eulerian grid.  <a href="classIBAMR_1_1CIBMethod.html#a641234ee6e8d986a5d4d4a8ad72730cd">More...</a><br /></td></tr>
<tr class="separator:a641234ee6e8d986a5d4d4a8ad72730cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71152ec5820e42360c48c63eaeeb408"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#af71152ec5820e42360c48c63eaeeb408">setInterpolatedVelocityVector</a> (Vec V, const <a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="memdesc:af71152ec5820e42360c48c63eaeeb408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the <a class="el" href="classIBAMR_1_1CIBMethod.html" title="Class CIBMethod is a concrete CIBStrategy and IBMethod class which implements the motion of rigid bod...">CIBMethod</a> class to get the interpolated fluid velocity.  <a href="classIBAMR_1_1CIBMethod.html#af71152ec5820e42360c48c63eaeeb408">More...</a><br /></td></tr>
<tr class="separator:af71152ec5820e42360c48c63eaeeb408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed97c5c4495ccd3b4f58dcde10e871e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a0ed97c5c4495ccd3b4f58dcde10e871e">getInterpolatedVelocity</a> (Vec V, const <a class="el" href="classdouble.html">double</a> data_time, const <a class="el" href="classdouble.html">double</a> scale=1.0) override</td></tr>
<tr class="memdesc:a0ed97c5c4495ccd3b4f58dcde10e871e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interpolated velocity from the Eulerian grid.  <a href="classIBAMR_1_1CIBMethod.html#a0ed97c5c4495ccd3b4f58dcde10e871e">More...</a><br /></td></tr>
<tr class="separator:a0ed97c5c4495ccd3b4f58dcde10e871e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a48b1fb791aa8944ac5fcdd0ba40b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a83a48b1fb791aa8944ac5fcdd0ba40b8">computeMobilityRegularization</a> (Vec D, Vec L, const <a class="el" href="classdouble.html">double</a> scale=1.0) override</td></tr>
<tr class="memdesc:a83a48b1fb791aa8944ac5fcdd0ba40b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute regularization vector for the mobility problem.  <a href="classIBAMR_1_1CIBMethod.html#a83a48b1fb791aa8944ac5fcdd0ba40b8">More...</a><br /></td></tr>
<tr class="separator:a83a48b1fb791aa8944ac5fcdd0ba40b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad117216876ac8f3ba82873f9732f7774"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#ad117216876ac8f3ba82873f9732f7774">getNumberOfNodes</a> (const unsigned <a class="el" href="classint.html">int</a> part) const override</td></tr>
<tr class="memdesc:ad117216876ac8f3ba82873f9732f7774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of nodes for a particular structure registered with <a class="el" href="classIBAMR_1_1CIBMethod.html" title="Class CIBMethod is a concrete CIBStrategy and IBMethod class which implements the motion of rigid bod...">CIBMethod</a>.  <a href="classIBAMR_1_1CIBMethod.html#ad117216876ac8f3ba82873f9732f7774">More...</a><br /></td></tr>
<tr class="separator:ad117216876ac8f3ba82873f9732f7774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9098bc848b12dab953743a64fd946f74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a9098bc848b12dab953743a64fd946f74">setRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;U, Vec V) override</td></tr>
<tr class="memdesc:a9098bc848b12dab953743a64fd946f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the rigid body velocity at the nodal points contained in the Vec V.  <a href="classIBAMR_1_1CIBMethod.html#a9098bc848b12dab953743a64fd946f74">More...</a><br /></td></tr>
<tr class="separator:a9098bc848b12dab953743a64fd946f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1351588b3bbeda76d138b1565bec1776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a1351588b3bbeda76d138b1565bec1776">computeNetRigidGeneralizedForce</a> (const unsigned <a class="el" href="classint.html">int</a> part, Vec L, <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;F) override</td></tr>
<tr class="memdesc:a1351588b3bbeda76d138b1565bec1776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute total force and torque on the rigid structure(s).  <a href="classIBAMR_1_1CIBMethod.html#a1351588b3bbeda76d138b1565bec1776">More...</a><br /></td></tr>
<tr class="separator:a1351588b3bbeda76d138b1565bec1776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fefde49aaede47f291596c329e65653"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a2fefde49aaede47f291596c329e65653">copyVecToArray</a> (Vec b, <a class="el" href="classdouble.html">double</a> *array, const std::vector&lt; unsigned &gt; &amp;struct_ids, const <a class="el" href="classint.html">int</a> data_depth, const <a class="el" href="classint.html">int</a> array_rank) override</td></tr>
<tr class="memdesc:a2fefde49aaede47f291596c329e65653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy PETSc Vec to raw array for specified structures.  <a href="classIBAMR_1_1CIBMethod.html#a2fefde49aaede47f291596c329e65653">More...</a><br /></td></tr>
<tr class="separator:a2fefde49aaede47f291596c329e65653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed267e3dc9ec08c21ea8bab8bf4bb7fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#aed267e3dc9ec08c21ea8bab8bf4bb7fd">copyArrayToVec</a> (Vec b, <a class="el" href="classdouble.html">double</a> *array, const std::vector&lt; unsigned &gt; &amp;struct_ids, const <a class="el" href="classint.html">int</a> data_depth, const <a class="el" href="classint.html">int</a> array_rank) override</td></tr>
<tr class="memdesc:aed267e3dc9ec08c21ea8bab8bf4bb7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy raw array to PETSc Vec for specified structures.  <a href="classIBAMR_1_1CIBMethod.html#aed267e3dc9ec08c21ea8bab8bf4bb7fd">More...</a><br /></td></tr>
<tr class="separator:aed267e3dc9ec08c21ea8bab8bf4bb7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6d6ef7fa9cfcc376571763c27f5375"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a7a6d6ef7fa9cfcc376571763c27f5375">constructMobilityMatrix</a> (const std::string &amp;mat_name, <a class="el" href="namespaceIBAMR.html#a591304f336aef144a5ae4595cffc3f70">MobilityMatrixType</a> mat_type, Mat &amp;mobility_mat, const std::vector&lt; unsigned &gt; &amp;prototype_struct_ids, const <a class="el" href="classdouble.html">double</a> *grid_dx, const <a class="el" href="classdouble.html">double</a> *domain_extents, const <a class="el" href="classbool.html">bool</a> initial_time, <a class="el" href="classdouble.html">double</a> rho, <a class="el" href="classdouble.html">double</a> mu, const std::pair&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;scale, <a class="el" href="classdouble.html">double</a> f_periodic_corr, const <a class="el" href="classint.html">int</a> managing_rank) override</td></tr>
<tr class="memdesc:a7a6d6ef7fa9cfcc376571763c27f5375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate dense mobility matrix for the prototypical structures identified by their indices.  <a href="classIBAMR_1_1CIBMethod.html#a7a6d6ef7fa9cfcc376571763c27f5375">More...</a><br /></td></tr>
<tr class="separator:a7a6d6ef7fa9cfcc376571763c27f5375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649e4ca9381f49dc39a90b7411fccd3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a649e4ca9381f49dc39a90b7411fccd3a">constructGeometricMatrix</a> (const std::string &amp;mat_name, Mat &amp;geometric_mat, const std::vector&lt; unsigned &gt; &amp;prototype_struct_ids, const <a class="el" href="classbool.html">bool</a> initial_time, const <a class="el" href="classint.html">int</a> managing_rank) override</td></tr>
<tr class="memdesc:a649e4ca9381f49dc39a90b7411fccd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate block-diagonal geometric matrix for the prototypical structures identified by their indices.  <a href="classIBAMR_1_1CIBMethod.html#a649e4ca9381f49dc39a90b7411fccd3a">More...</a><br /></td></tr>
<tr class="separator:a649e4ca9381f49dc39a90b7411fccd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5361e9c9f9875c55a82c6185886592b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#aa5361e9c9f9875c55a82c6185886592b">rotateArray</a> (<a class="el" href="classdouble.html">double</a> *array, const std::vector&lt; unsigned &gt; &amp;struct_ids, const <a class="el" href="classbool.html">bool</a> use_transpose, const <a class="el" href="classint.html">int</a> managing_rank, const <a class="el" href="classint.html">int</a> depth) override</td></tr>
<tr class="memdesc:aa5361e9c9f9875c55a82c6185886592b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate vector using rotation matrix to/from the reference frame of the structures.  <a href="classIBAMR_1_1CIBMethod.html#aa5361e9c9f9875c55a82c6185886592b">More...</a><br /></td></tr>
<tr class="separator:aa5361e9c9f9875c55a82c6185886592b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc520d581a35ff79d136497ae57b5ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a9cc520d581a35ff79d136497ae57b5ca">flagRegrid</a> () const</td></tr>
<tr class="separator:a9cc520d581a35ff79d136497ae57b5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e90212eedcbb39716457a7e01bd5ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a45e90212eedcbb39716457a7e01bd5ff">setVelocityPhysBdryOp</a> (<a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">IBTK::RobinPhysBdryPatchStrategy</a> *u_phys_bdry_op)</td></tr>
<tr class="separator:a45e90212eedcbb39716457a7e01bd5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b814e860e4713dc9f437f43856a2a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a74b814e860e4713dc9f437f43856a2a0">setRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;U, Vec V)=0</td></tr>
<tr class="separator:a74b814e860e4713dc9f437f43856a2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08097027463a8986efc35a294ab10f4d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a08097027463a8986efc35a294ab10f4d">setRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, Vec U, Vec V)</td></tr>
<tr class="separator:a08097027463a8986efc35a294ab10f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed839bba3c6ae73fe3ceaa6ee548a0a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#aed839bba3c6ae73fe3ceaa6ee548a0a6">setRigidBodyVelocity</a> (Vec U, Vec V, const <a class="el" href="classbool.html">bool</a> only_free_dofs, const <a class="el" href="classbool.html">bool</a> only_imposed_dofs, const <a class="el" href="classbool.html">bool</a> all_dofs=false)</td></tr>
<tr class="separator:aed839bba3c6ae73fe3ceaa6ee548a0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3387134bbce5257db7969ef019a1a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a9f3387134bbce5257db7969ef019a1a2">computeNetRigidGeneralizedForce</a> (const unsigned <a class="el" href="classint.html">int</a> part, Vec L, <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;F)=0</td></tr>
<tr class="separator:a9f3387134bbce5257db7969ef019a1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a54517eaec6816edb0e06cffe8f08d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#ad6a54517eaec6816edb0e06cffe8f08d">computeNetRigidGeneralizedForce</a> (const unsigned <a class="el" href="classint.html">int</a> part, Vec L, Vec F)</td></tr>
<tr class="separator:ad6a54517eaec6816edb0e06cffe8f08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b3429e6b49d50e385af370874acf42"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#ac1b3429e6b49d50e385af370874acf42">computeNetRigidGeneralizedForce</a> (Vec L, Vec F, const <a class="el" href="classbool.html">bool</a> only_free_dofs, const <a class="el" href="classbool.html">bool</a> only_imposed_dofs, const <a class="el" href="classbool.html">bool</a> all_dofs=false)</td></tr>
<tr class="separator:ac1b3429e6b49d50e385af370874acf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80be2819afc59abdee7bb79717709304"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a80be2819afc59abdee7bb79717709304">registerIBLagrangianForceFunction</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBAMR_1_1IBLagrangianForceStrategy.html">IBLagrangianForceStrategy</a> &gt; ib_force_fcn)</td></tr>
<tr class="separator:a80be2819afc59abdee7bb79717709304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fdade3f34c2bd820878628b65a3a83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a12fdade3f34c2bd820878628b65a3a83">registerIBLagrangianSourceFunction</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBAMR_1_1IBLagrangianSourceStrategy.html">IBLagrangianSourceStrategy</a> &gt; ib_source_fcn)</td></tr>
<tr class="separator:a12fdade3f34c2bd820878628b65a3a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e2d69dca4c9e92fe9ad598033cbc69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#ae7e2d69dca4c9e92fe9ad598033cbc69">registerLInitStrategy</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LInitStrategy.html">IBTK::LInitStrategy</a> &gt; l_initializer)</td></tr>
<tr class="separator:ae7e2d69dca4c9e92fe9ad598033cbc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf75e5e82f4f1962796dd5c625257639"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#aaf75e5e82f4f1962796dd5c625257639">freeLInitStrategy</a> ()</td></tr>
<tr class="separator:aaf75e5e82f4f1962796dd5c625257639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a68aaa64d935433c8a0fee80d286cbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a7a68aaa64d935433c8a0fee80d286cbf">registerIBMethodPostProcessor</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBAMR_1_1IBMethodPostProcessStrategy.html">IBMethodPostProcessStrategy</a> &gt; post_processor)</td></tr>
<tr class="separator:a7a68aaa64d935433c8a0fee80d286cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d60d88d173796c3f2b806eee8011e61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBTK_1_1LDataManager.html">IBTK::LDataManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a9d60d88d173796c3f2b806eee8011e61">getLDataManager</a> () const</td></tr>
<tr class="separator:a9d60d88d173796c3f2b806eee8011e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e3b35da07a55364dc82aeaa2bc05f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBAMR_1_1IBInstrumentPanel.html">IBInstrumentPanel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a33e3b35da07a55364dc82aeaa2bc05f4">getIBInstrumentPanel</a> () const</td></tr>
<tr class="separator:a33e3b35da07a55364dc82aeaa2bc05f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b1cd845cd4bb0ce96aa3baf6f3c683"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a42b1cd845cd4bb0ce96aa3baf6f3c683">registerLSiloDataWriter</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LSiloDataWriter.html">IBTK::LSiloDataWriter</a> &gt; silo_writer)</td></tr>
<tr class="separator:a42b1cd845cd4bb0ce96aa3baf6f3c683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cd0f1a69472b600268a490233ff929"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#aa9cd0f1a69472b600268a490233ff929">getMinimumGhostCellWidth</a> () const override</td></tr>
<tr class="separator:aa9cd0f1a69472b600268a490233ff929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a30dbb933f491ce2357db91b19c62d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#ab2a30dbb933f491ce2357db91b19c62d">setupTagBuffer</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">SAMRAI::tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;tag_buffer, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt; gridding_alg) const override</td></tr>
<tr class="separator:ab2a30dbb933f491ce2357db91b19c62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8a44a8e204539a498668f9375fe2be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#acb8a44a8e204539a498668f9375fe2be">inactivateLagrangianStructure</a> (<a class="el" href="classint.html">int</a> structure_number=0, <a class="el" href="classint.html">int</a> level_number=std::numeric_limits&lt; <a class="el" href="classint.html">int</a> &gt;::max()) override</td></tr>
<tr class="separator:acb8a44a8e204539a498668f9375fe2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa138082063940e29aaf45793421d1317"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#aa138082063940e29aaf45793421d1317">activateLagrangianStructure</a> (<a class="el" href="classint.html">int</a> structure_number=0, <a class="el" href="classint.html">int</a> level_number=std::numeric_limits&lt; <a class="el" href="classint.html">int</a> &gt;::max()) override</td></tr>
<tr class="separator:aa138082063940e29aaf45793421d1317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e99426b240c6f24476f603d99853e8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a81e99426b240c6f24476f603d99853e8">getLagrangianStructureIsActivated</a> (<a class="el" href="classint.html">int</a> structure_number=0, <a class="el" href="classint.html">int</a> level_number=std::numeric_limits&lt; <a class="el" href="classint.html">int</a> &gt;::max()) const override</td></tr>
<tr class="separator:a81e99426b240c6f24476f603d99853e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec17e9417c4f5a34719b0979baf1707f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#aec17e9417c4f5a34719b0979baf1707f">createSolverVecs</a> (Vec *X_vec, Vec *F_vec) override</td></tr>
<tr class="separator:aec17e9417c4f5a34719b0979baf1707f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c8f0dbb72019492721ffdae0d0d419"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a97c8f0dbb72019492721ffdae0d0d419">setupSolverVecs</a> (Vec *X_vec, Vec *F_vec) override</td></tr>
<tr class="separator:a97c8f0dbb72019492721ffdae0d0d419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6fd2e9a8a42c6124f02cab6321e804"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a4c6fd2e9a8a42c6124f02cab6321e804">setUpdatedPosition</a> (Vec &amp;X_new_vec) override</td></tr>
<tr class="separator:a4c6fd2e9a8a42c6124f02cab6321e804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3682a2781eb0871608d0ff942a0ac06f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a3682a2781eb0871608d0ff942a0ac06f">setLinearizedPosition</a> (Vec &amp;X_vec, <a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="separator:a3682a2781eb0871608d0ff942a0ac06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1328e672e674e0b47aaf74bcb8d5b4fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a1328e672e674e0b47aaf74bcb8d5b4fb">computeResidual</a> (Vec &amp;R_vec) override</td></tr>
<tr class="separator:a1328e672e674e0b47aaf74bcb8d5b4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59237a1828785c64c61e96aa4d1c25a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a59237a1828785c64c61e96aa4d1c25a3">computeLinearizedResidual</a> (Vec &amp;X_vec, Vec &amp;R_vec) override</td></tr>
<tr class="separator:a59237a1828785c64c61e96aa4d1c25a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae42ac41bb6037769f1c14ccb883b13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a1ae42ac41bb6037769f1c14ccb883b13">updateFixedLEOperators</a> () override</td></tr>
<tr class="separator:a1ae42ac41bb6037769f1c14ccb883b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab646f9bd552147661a4b1835ad97580e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#ab646f9bd552147661a4b1835ad97580e">interpolateLinearizedVelocity</a> (<a class="el" href="classint.html">int</a> u_data_idx, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;u_synch_scheds, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;u_ghost_fill_scheds, <a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="separator:ab646f9bd552147661a4b1835ad97580e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa343442e57401e2a1c0ac57e66cec2ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#aa343442e57401e2a1c0ac57e66cec2ec">computeLagrangianForce</a> (<a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="separator:aa343442e57401e2a1c0ac57e66cec2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9e4b76abc82cec0212b1121b1c17ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#afb9e4b76abc82cec0212b1121b1c17ea">computeLinearizedLagrangianForce</a> (Vec &amp;X_vec, <a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="separator:afb9e4b76abc82cec0212b1121b1c17ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e51fc104ae15e3c328ce6b48e3ba5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a65e51fc104ae15e3c328ce6b48e3ba5c">constructLagrangianForceJacobian</a> (Mat &amp;A, MatType mat_type, <a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="separator:a65e51fc104ae15e3c328ce6b48e3ba5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51936d064e4a33b0f0afe85fd23266e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#af51936d064e4a33b0f0afe85fd23266e">spreadLinearizedForce</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">IBTK::RobinPhysBdryPatchStrategy</a> *f_phys_bdry_op, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_prolongation_scheds, <a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="separator:af51936d064e4a33b0f0afe85fd23266e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6ddf55ccafdbb65a299be7f1877c10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a5b6ddf55ccafdbb65a299be7f1877c10">constructInterpOp</a> (Mat &amp;J, void(*spread_fnc)(const <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> *), <a class="el" href="classint.html">int</a> stencil_width, const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;num_dofs_per_proc, <a class="el" href="classint.html">int</a> dof_index_idx, <a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="separator:a5b6ddf55ccafdbb65a299be7f1877c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6eab9245e7bf30e4e314a5df205208d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#ae6eab9245e7bf30e4e314a5df205208d">hasFluidSources</a> () const override</td></tr>
<tr class="separator:ae6eab9245e7bf30e4e314a5df205208d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada68cd9beb9dc40be863e9fd0e0cd2de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#ada68cd9beb9dc40be863e9fd0e0cd2de">computeLagrangianFluidSource</a> (<a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="separator:ada68cd9beb9dc40be863e9fd0e0cd2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a96686b499037844057eae92af8777b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a7a96686b499037844057eae92af8777b">spreadFluidSource</a> (<a class="el" href="classint.html">int</a> q_data_idx, <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">IBTK::RobinPhysBdryPatchStrategy</a> *q_phys_bdry_op, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;q_prolongation_scheds, <a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="separator:a7a96686b499037844057eae92af8777b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b72875d25a3ab6dc51eaa8044d95d16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a1b72875d25a3ab6dc51eaa8044d95d16">interpolatePressure</a> (<a class="el" href="classint.html">int</a> p_data_idx, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;p_synch_scheds, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;p_ghost_fill_scheds, <a class="el" href="classdouble.html">double</a> data_time) override</td></tr>
<tr class="separator:a1b72875d25a3ab6dc51eaa8044d95d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca342dbf9b3629c719befd3bfc5254d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#afca342dbf9b3629c719befd3bfc5254d">postprocessData</a> () override</td></tr>
<tr class="separator:afca342dbf9b3629c719befd3bfc5254d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6847ad81e8d1f24acab882f950c9a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a2b6847ad81e8d1f24acab882f950c9a6">registerLoadBalancer</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalancer.html">SAMRAI::mesh::LoadBalancer</a>&lt; NDIM &gt; &gt; load_balancer, <a class="el" href="classint.html">int</a> workload_data_idx) override</td></tr>
<tr class="separator:a2b6847ad81e8d1f24acab882f950c9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7f0c335bdd324bc0e3fed27726d86b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a9b7f0c335bdd324bc0e3fed27726d86b">addWorkloadEstimate</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> workload_data_idx) override</td></tr>
<tr class="separator:a9b7f0c335bdd324bc0e3fed27726d86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0c10bde7af722101eaddf2ddec048c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a3b0c10bde7af722101eaddf2ddec048c">beginDataRedistribution</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt; gridding_alg) override</td></tr>
<tr class="separator:a3b0c10bde7af722101eaddf2ddec048c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96c753f9daa372e9c019dab155bb5d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#ad96c753f9daa372e9c019dab155bb5d5">endDataRedistribution</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt; gridding_alg) override</td></tr>
<tr class="separator:ad96c753f9daa372e9c019dab155bb5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f31cfe38a0690a629fcbeb7ad89888"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#af8f31cfe38a0690a629fcbeb7ad89888">initializeLevelData</a> (const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> level_number, const <a class="el" href="classdouble.html">double</a> init_data_time, const <a class="el" href="classbool.html">bool</a> can_be_refined, const <a class="el" href="classbool.html">bool</a> initial_time, const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; old_level=tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt;(NULL), const <a class="el" href="classbool.html">bool</a> allocate_data=true)=0</td></tr>
<tr class="separator:af8f31cfe38a0690a629fcbeb7ad89888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b69e4d26cad00fd5bed5a5f76120c95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a3b69e4d26cad00fd5bed5a5f76120c95">resetHierarchyConfiguration</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classint.html">int</a> coarsest_level, <a class="el" href="classint.html">int</a> finest_level) override</td></tr>
<tr class="separator:a3b69e4d26cad00fd5bed5a5f76120c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8d89482d4bdafc824307cc21c728c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a6f8d89482d4bdafc824307cc21c728c9">resetHierarchyConfiguration</a> (const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> coarsest_level, const <a class="el" href="classint.html">int</a> finest_level)=0</td></tr>
<tr class="separator:a6f8d89482d4bdafc824307cc21c728c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b00b4f8b8e6e01f2418aa18daab496d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a3b00b4f8b8e6e01f2418aa18daab496d">applyGradientDetector</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classint.html">int</a> level_number, <a class="el" href="classdouble.html">double</a> error_data_time, <a class="el" href="classint.html">int</a> tag_index, <a class="el" href="classbool.html">bool</a> initial_time, <a class="el" href="classbool.html">bool</a> uses_richardson_extrapolation_too) override</td></tr>
<tr class="separator:a3b00b4f8b8e6e01f2418aa18daab496d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac201b9cd28087aa92f9c1370f147667a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#ac201b9cd28087aa92f9c1370f147667a">applyGradientDetector</a> (const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> level_number, const <a class="el" href="classdouble.html">double</a> error_data_time, const <a class="el" href="classint.html">int</a> tag_index, const <a class="el" href="classbool.html">bool</a> initial_time, const <a class="el" href="classbool.html">bool</a> uses_richardson_extrapolation_too)</td></tr>
<tr class="separator:ac201b9cd28087aa92f9c1370f147667a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42927ec87683f4481357b5f368091410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a42927ec87683f4481357b5f368091410">convertTimeEnumToDouble</a> (<a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782">IBTK::TimePoint</a> time_pt)</td></tr>
<tr class="memdesc:a42927ec87683f4481357b5f368091410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the enum TimePoint to it respective value.  <a href="classIBAMR_1_1IBMethod.html#a42927ec87683f4481357b5f368091410">More...</a><br /></td></tr>
<tr class="separator:a42927ec87683f4481357b5f368091410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ca96393cb896e977dc664c2989f4b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a12ca96393cb896e977dc664c2989f4b4">getPositionData</a> (std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **X_data, <a class="el" href="classbool.html">bool</a> **X_needs_ghost_fill, <a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782">IBTK::TimePoint</a> time_pt)</td></tr>
<tr class="memdesc:a12ca96393cb896e977dc664c2989f4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the structure position data at the specified time point.  <a href="classIBAMR_1_1IBMethod.html#a12ca96393cb896e977dc664c2989f4b4">More...</a><br /></td></tr>
<tr class="separator:a12ca96393cb896e977dc664c2989f4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f20794e7326fbc271f21eb66b42901c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a6f20794e7326fbc271f21eb66b42901c">getVelocityData</a> (std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **U_data, <a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782">IBTK::TimePoint</a> time_pt)</td></tr>
<tr class="memdesc:a6f20794e7326fbc271f21eb66b42901c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current structure velocity data at the specified time point.  <a href="classIBAMR_1_1IBMethod.html#a6f20794e7326fbc271f21eb66b42901c">More...</a><br /></td></tr>
<tr class="separator:a6f20794e7326fbc271f21eb66b42901c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345d082bf603a689eab8c1988a283713"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a345d082bf603a689eab8c1988a283713">getForceData</a> (std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **F_data, <a class="el" href="classbool.html">bool</a> **F_needs_ghost_fill, <a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782">IBTK::TimePoint</a> time_pt)</td></tr>
<tr class="memdesc:a345d082bf603a689eab8c1988a283713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current structure force data at the specified time point.  <a href="classIBAMR_1_1IBMethod.html#a345d082bf603a689eab8c1988a283713">More...</a><br /></td></tr>
<tr class="separator:a345d082bf603a689eab8c1988a283713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98445ef8b9ff1d190847323663f6a27"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#ab98445ef8b9ff1d190847323663f6a27">registerIBHierarchyIntegrator</a> (<a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html">IBHierarchyIntegrator</a> *ib_solver)</td></tr>
<tr class="separator:ab98445ef8b9ff1d190847323663f6a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548e6766815734ca76353d18d781db92"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a548e6766815734ca76353d18d781db92">getMaxPointDisplacement</a> () const</td></tr>
<tr class="separator:a548e6766815734ca76353d18d781db92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0bace52c4d76fd7fe2ca073734a50d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a7c0bace52c4d76fd7fe2ca073734a50d">setUseFixedLEOperators</a> (<a class="el" href="classbool.html">bool</a> use_fixed_coupling_ops=true)</td></tr>
<tr class="separator:a7c0bace52c4d76fd7fe2ca073734a50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df419c05fac15f60839ac01aa2ab197"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a3df419c05fac15f60839ac01aa2ab197">setUseMultistepTimeStepping</a> (unsigned <a class="el" href="classint.html">int</a> n_previous_steps=1)</td></tr>
<tr class="separator:a3df419c05fac15f60839ac01aa2ab197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe374a56735ab5730f6e6dcbb26de6d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#abbe374a56735ab5730f6e6dcbb26de6d">AB2Step</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time)</td></tr>
<tr class="separator:abbe374a56735ab5730f6e6dcbb26de6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6165a233879d675b6782790e6f4c05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#abc6165a233879d675b6782790e6f4c05">postprocessSolveFluidEquations</a> (<a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> new_time, <a class="el" href="classint.html">int</a> cycle_num)</td></tr>
<tr class="separator:abc6165a233879d675b6782790e6f4c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5263bfe8622e41d1a2df35f9803a5ca1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a5263bfe8622e41d1a2df35f9803a5ca1">getLevelDt</a> (const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level, const <a class="el" href="classdouble.html">double</a> dt_time, const <a class="el" href="classbool.html">bool</a> initial_time)</td></tr>
<tr class="separator:a5263bfe8622e41d1a2df35f9803a5ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e8a35a6b5ab6ec7e14f040e718adf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a9e4e8a35a6b5ab6ec7e14f040e718adf">advanceLevel</a> (const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level, const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classdouble.html">double</a> current_time, const <a class="el" href="classdouble.html">double</a> new_time, const <a class="el" href="classbool.html">bool</a> first_step, const <a class="el" href="classbool.html">bool</a> last_step, const <a class="el" href="classbool.html">bool</a> regrid_advance=false)</td></tr>
<tr class="separator:a9e4e8a35a6b5ab6ec7e14f040e718adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97641642baa1b5c67749fada52b12341"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a97641642baa1b5c67749fada52b12341">resetTimeDependentData</a> (const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level, const <a class="el" href="classdouble.html">double</a> new_time, const <a class="el" href="classbool.html">bool</a> can_be_refined)</td></tr>
<tr class="separator:a97641642baa1b5c67749fada52b12341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f563618437d3a5231d35eb6937fcd1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#af6f563618437d3a5231d35eb6937fcd1">resetDataToPreadvanceState</a> (const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level)</td></tr>
<tr class="separator:af6f563618437d3a5231d35eb6937fcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e5b7b5d98eaf7221b5088b0d12a2a8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a81e5b7b5d98eaf7221b5088b0d12a2a8">applyRichardsonExtrapolation</a> (const tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; level, const <a class="el" href="classdouble.html">double</a> error_data_time, const <a class="el" href="classint.html">int</a> tag_index, const <a class="el" href="classdouble.html">double</a> deltat, const <a class="el" href="classint.html">int</a> error_coarsen_ratio, const <a class="el" href="classbool.html">bool</a> initial_time, const <a class="el" href="classbool.html">bool</a> uses_gradient_detector_too)</td></tr>
<tr class="separator:a81e5b7b5d98eaf7221b5088b0d12a2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3ec75cca71a27c6599a48ac6cd37ea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a9e3ec75cca71a27c6599a48ac6cd37ea">coarsenDataForRichardsonExtrapolation</a> (const tbox::Pointer&lt; hier::PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> level_number, const tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; coarser_level, const <a class="el" href="classdouble.html">double</a> coarsen_data_time, const <a class="el" href="classbool.html">bool</a> before_advance)</td></tr>
<tr class="separator:a9e3ec75cca71a27c6599a48ac6cd37ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac28b98c635db5889693d71f67456cd8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#aac28b98c635db5889693d71f67456cd8">getNumberOfRigidStructures</a> () const</td></tr>
<tr class="memdesc:aac28b98c635db5889693d71f67456cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of rigid structures registered with this class.  <a href="classIBAMR_1_1CIBStrategy.html#aac28b98c635db5889693d71f67456cd8">More...</a><br /></td></tr>
<tr class="separator:aac28b98c635db5889693d71f67456cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc7a6bedd44f4cd0a06df8af06461a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a0fc7a6bedd44f4cd0a06df8af06461a1">setInitialCenterOfMass</a> (const unsigned <a class="el" href="classint.html">int</a> part, const Eigen::Vector3d &amp;XCOM_0)</td></tr>
<tr class="memdesc:a0fc7a6bedd44f4cd0a06df8af06461a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the initial center of mass location for the structures.  <a href="classIBAMR_1_1CIBStrategy.html#a0fc7a6bedd44f4cd0a06df8af06461a1">More...</a><br /></td></tr>
<tr class="separator:a0fc7a6bedd44f4cd0a06df8af06461a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c84ef0df606bb8dad89923392de5491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a0c84ef0df606bb8dad89923392de5491">setSolveRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, const <a class="el" href="namespaceIBTK.html#ad17100e3633baaf42d5aae6933b8e5db">IBTK::FreeRigidDOFVector</a> &amp;solve_rigid_dofs)</td></tr>
<tr class="memdesc:a0c84ef0df606bb8dad89923392de5491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set what rigid DOFs need to be solved for this particular structure.  <a href="classIBAMR_1_1CIBStrategy.html#a0c84ef0df606bb8dad89923392de5491">More...</a><br /></td></tr>
<tr class="separator:a0c84ef0df606bb8dad89923392de5491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cacbaae5916c93077d50b1c1a36f69"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceIBTK.html#ad17100e3633baaf42d5aae6933b8e5db">IBTK::FreeRigidDOFVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ac8cacbaae5916c93077d50b1c1a36f69">getSolveRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, <a class="el" href="classint.html">int</a> &amp;num_free_dofs) const</td></tr>
<tr class="memdesc:ac8cacbaae5916c93077d50b1c1a36f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query what rigid DOFs need to be solved for.  <a href="classIBAMR_1_1CIBStrategy.html#ac8cacbaae5916c93077d50b1c1a36f69">More...</a><br /></td></tr>
<tr class="separator:ac8cacbaae5916c93077d50b1c1a36f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08097027463a8986efc35a294ab10f4d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a08097027463a8986efc35a294ab10f4d">setRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, Vec U, Vec V)</td></tr>
<tr class="memdesc:a08097027463a8986efc35a294ab10f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the rigid body velocity at the nodal/marker points contained in the Vec <em>V</em>.  <a href="classIBAMR_1_1CIBStrategy.html#a08097027463a8986efc35a294ab10f4d">More...</a><br /></td></tr>
<tr class="separator:a08097027463a8986efc35a294ab10f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed839bba3c6ae73fe3ceaa6ee548a0a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#aed839bba3c6ae73fe3ceaa6ee548a0a6">setRigidBodyVelocity</a> (Vec U, Vec V, const <a class="el" href="classbool.html">bool</a> only_free_dofs, const <a class="el" href="classbool.html">bool</a> only_imposed_dofs, const <a class="el" href="classbool.html">bool</a> all_dofs=false)</td></tr>
<tr class="memdesc:aed839bba3c6ae73fe3ceaa6ee548a0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the rigid body velocity at the nodal/marker points contained in the Vec V.  <a href="classIBAMR_1_1CIBStrategy.html#aed839bba3c6ae73fe3ceaa6ee548a0a6">More...</a><br /></td></tr>
<tr class="separator:aed839bba3c6ae73fe3ceaa6ee548a0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a54517eaec6816edb0e06cffe8f08d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ad6a54517eaec6816edb0e06cffe8f08d">computeNetRigidGeneralizedForce</a> (const unsigned <a class="el" href="classint.html">int</a> part, Vec L, Vec F)</td></tr>
<tr class="memdesc:ad6a54517eaec6816edb0e06cffe8f08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute total force and torque on the structure.  <a href="classIBAMR_1_1CIBStrategy.html#ad6a54517eaec6816edb0e06cffe8f08d">More...</a><br /></td></tr>
<tr class="separator:ad6a54517eaec6816edb0e06cffe8f08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b3429e6b49d50e385af370874acf42"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ac1b3429e6b49d50e385af370874acf42">computeNetRigidGeneralizedForce</a> (Vec L, Vec F, const <a class="el" href="classbool.html">bool</a> only_free_dofs, const <a class="el" href="classbool.html">bool</a> only_imposed_dofs, const <a class="el" href="classbool.html">bool</a> all_dofs=false)</td></tr>
<tr class="memdesc:ac1b3429e6b49d50e385af370874acf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute total force and torque on the structure.  <a href="classIBAMR_1_1CIBStrategy.html#ac1b3429e6b49d50e385af370874acf42">More...</a><br /></td></tr>
<tr class="separator:ac1b3429e6b49d50e385af370874acf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446a8e750171ee90f51658e645fc0bc6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a446a8e750171ee90f51658e645fc0bc6">getNetRigidGeneralizedForce</a> (const unsigned <a class="el" href="classint.html">int</a> part)</td></tr>
<tr class="memdesc:a446a8e750171ee90f51658e645fc0bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total torque and force on the structure at new_time within the current time interval.  <a href="classIBAMR_1_1CIBStrategy.html#a446a8e750171ee90f51658e645fc0bc6">More...</a><br /></td></tr>
<tr class="separator:a446a8e750171ee90f51658e645fc0bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc476b84ad7a6b45321e48474992f7ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#adc476b84ad7a6b45321e48474992f7ff">updateFreeDOFsMapping</a> ()</td></tr>
<tr class="memdesc:adc476b84ad7a6b45321e48474992f7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the mapping of free DOFs for all structures if they are collected in a global vector.  <a href="classIBAMR_1_1CIBStrategy.html#adc476b84ad7a6b45321e48474992f7ff">More...</a><br /></td></tr>
<tr class="separator:adc476b84ad7a6b45321e48474992f7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46aa12a75eec15beeed92da1a05bf297"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a46aa12a75eec15beeed92da1a05bf297">updateNewRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;U)</td></tr>
<tr class="memdesc:a46aa12a75eec15beeed92da1a05bf297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the rigid body velocity obtained from the constraint Stokes solver for free-moving case.  <a href="classIBAMR_1_1CIBStrategy.html#a46aa12a75eec15beeed92da1a05bf297">More...</a><br /></td></tr>
<tr class="separator:a46aa12a75eec15beeed92da1a05bf297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadb163509d0ca86f327fa9e9580b529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#aaadb163509d0ca86f327fa9e9580b529">updateNewRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, Vec U)</td></tr>
<tr class="memdesc:aaadb163509d0ca86f327fa9e9580b529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the rigid body velocity obtained from the constraint Stokes solver for free-moving case.  <a href="classIBAMR_1_1CIBStrategy.html#aaadb163509d0ca86f327fa9e9580b529">More...</a><br /></td></tr>
<tr class="separator:aaadb163509d0ca86f327fa9e9580b529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ba22af2d0b3afde292157273f933ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a01ba22af2d0b3afde292157273f933ff">updateNewRigidBodyVelocity</a> (Vec U, const <a class="el" href="classbool.html">bool</a> only_free_dofs, const <a class="el" href="classbool.html">bool</a> only_imposed_dofs, const <a class="el" href="classbool.html">bool</a> all_dofs=false)</td></tr>
<tr class="memdesc:a01ba22af2d0b3afde292157273f933ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the rigid body velocity obtained from the constraint Stokes solver for free-moving case.  <a href="classIBAMR_1_1CIBStrategy.html#a01ba22af2d0b3afde292157273f933ff">More...</a><br /></td></tr>
<tr class="separator:a01ba22af2d0b3afde292157273f933ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05378698c6caf299c83d5a53e2a16199"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a05378698c6caf299c83d5a53e2a16199">copyFreeDOFsVecToArray</a> (Vec b, <a class="el" href="classdouble.html">double</a> *array, const std::vector&lt; unsigned &gt; &amp;struct_ids, const <a class="el" href="classint.html">int</a> array_rank)</td></tr>
<tr class="memdesc:a05378698c6caf299c83d5a53e2a16199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from distributed PETSc Vec for specified stucture indices to an array defined on a single processor. A default implementation is provided.  <a href="classIBAMR_1_1CIBStrategy.html#a05378698c6caf299c83d5a53e2a16199">More...</a><br /></td></tr>
<tr class="separator:a05378698c6caf299c83d5a53e2a16199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93ce15b714d03af6b80ba23dbaa5c79"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#af93ce15b714d03af6b80ba23dbaa5c79">copyFreeDOFsArrayToVec</a> (Vec b, <a class="el" href="classdouble.html">double</a> *array, const std::vector&lt; unsigned &gt; &amp;struct_ids, const <a class="el" href="classint.html">int</a> array_rank)</td></tr>
<tr class="memdesc:af93ce15b714d03af6b80ba23dbaa5c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from array defined on a single processor for specified stucture indices to distributed PETScVec. A default implementation is provided.  <a href="classIBAMR_1_1CIBStrategy.html#af93ce15b714d03af6b80ba23dbaa5c79">More...</a><br /></td></tr>
<tr class="separator:af93ce15b714d03af6b80ba23dbaa5c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e57bb1d7568e9f2e1ba1954c603eb35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a6e57bb1d7568e9f2e1ba1954c603eb35">getCurrentRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;U)</td></tr>
<tr class="memdesc:a6e57bb1d7568e9f2e1ba1954c603eb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rigid body translational velocity at the beginning of the timestep.  <a href="classIBAMR_1_1CIBStrategy.html#a6e57bb1d7568e9f2e1ba1954c603eb35">More...</a><br /></td></tr>
<tr class="separator:a6e57bb1d7568e9f2e1ba1954c603eb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eff8796b3637e0f4731b32762d9154f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a5eff8796b3637e0f4731b32762d9154f">getNewRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;U)</td></tr>
<tr class="memdesc:a5eff8796b3637e0f4731b32762d9154f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rigid body translational velocity at the end of the timestep.  <a href="classIBAMR_1_1CIBStrategy.html#a5eff8796b3637e0f4731b32762d9154f">More...</a><br /></td></tr>
<tr class="separator:a5eff8796b3637e0f4731b32762d9154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71594fce589c121dc7cb81f0ae8e8ef3"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector3d &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a71594fce589c121dc7cb81f0ae8e8ef3">getCurrentBodyCenterOfMass</a> (const unsigned <a class="el" href="classint.html">int</a> part)</td></tr>
<tr class="memdesc:a71594fce589c121dc7cb81f0ae8e8ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get body center of mass at the current time step.  <a href="classIBAMR_1_1CIBStrategy.html#a71594fce589c121dc7cb81f0ae8e8ef3">More...</a><br /></td></tr>
<tr class="separator:a71594fce589c121dc7cb81f0ae8e8ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a71cf057095365cb0a1bf0cb4ebe486"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector3d &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a8a71cf057095365cb0a1bf0cb4ebe486">getNewBodyCenterOfMass</a> (const unsigned <a class="el" href="classint.html">int</a> part)</td></tr>
<tr class="memdesc:a8a71cf057095365cb0a1bf0cb4ebe486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get body center of mass at half time step.  <a href="classIBAMR_1_1CIBStrategy.html#a8a71cf057095365cb0a1bf0cb4ebe486">More...</a><br /></td></tr>
<tr class="separator:a8a71cf057095365cb0a1bf0cb4ebe486"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a91d5b6beeee95b9e560871e271f0a42f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a91d5b6beeee95b9e560871e271f0a42f">vecToRDV</a> (Vec U, <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;Ur)</td></tr>
<tr class="memdesc:a91d5b6beeee95b9e560871e271f0a42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the DOFs from PETSc Vec <code>U</code> to RigidDOFVector <code>Ur</code>.  <a href="classIBAMR_1_1CIBStrategy.html#a91d5b6beeee95b9e560871e271f0a42f">More...</a><br /></td></tr>
<tr class="separator:a91d5b6beeee95b9e560871e271f0a42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c3fa8472562a4d21f30e3a0a0c69c7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a96c3fa8472562a4d21f30e3a0a0c69c7">rdvToVec</a> (const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;Ur, Vec &amp;U)</td></tr>
<tr class="memdesc:a96c3fa8472562a4d21f30e3a0a0c69c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the DOFs from RigidDOFVector <code>Ur</code> to PETSc Vec <code>U</code>.  <a href="classIBAMR_1_1CIBStrategy.html#a96c3fa8472562a4d21f30e3a0a0c69c7">More...</a><br /></td></tr>
<tr class="separator:a96c3fa8472562a4d21f30e3a0a0c69c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630d7d9172d5a9284235783f238181cb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a630d7d9172d5a9284235783f238181cb">eigenToRDV</a> (const Eigen::Vector3d &amp;U, const Eigen::Vector3d &amp;W, <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;UW)</td></tr>
<tr class="memdesc:a630d7d9172d5a9284235783f238181cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the DOFs from Eigen::Vector3d <code>U</code> and <code>W</code> to RigidDOFVector <code>UW</code>.  <a href="classIBAMR_1_1CIBStrategy.html#a630d7d9172d5a9284235783f238181cb">More...</a><br /></td></tr>
<tr class="separator:a630d7d9172d5a9284235783f238181cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ced3674edd5d2a7609789473496e62"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a06ced3674edd5d2a7609789473496e62">rdvToEigen</a> (const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;UW, Eigen::Vector3d &amp;U, Eigen::Vector3d &amp;W)</td></tr>
<tr class="memdesc:a06ced3674edd5d2a7609789473496e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the DOFs from RigidDOFVector <code>UW</code> to Eigen::Vector3d <code>U</code> and <code>W</code>.  <a href="classIBAMR_1_1CIBStrategy.html#a06ced3674edd5d2a7609789473496e62">More...</a><br /></td></tr>
<tr class="separator:a06ced3674edd5d2a7609789473496e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3918e04a644d5672f1e625e5975af6a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a3918e04a644d5672f1e625e5975af6a3">getPositionData</a> (std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **X_data, <a class="el" href="classbool.html">bool</a> **X_needs_ghost_fill, <a class="el" href="classdouble.html">double</a> data_time)</td></tr>
<tr class="separator:a3918e04a644d5672f1e625e5975af6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ad74f359990098f827396f7509b381"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a35ad74f359990098f827396f7509b381">getVelocityData</a> (std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **U_data, <a class="el" href="classdouble.html">double</a> data_time)</td></tr>
<tr class="separator:a35ad74f359990098f827396f7509b381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4443dbb8b862b96dcaef6714bfb109d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#ab4443dbb8b862b96dcaef6714bfb109d">getForceData</a> (std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **F_data, <a class="el" href="classbool.html">bool</a> **F_needs_ghost_fill, <a class="el" href="classdouble.html">double</a> data_time)</td></tr>
<tr class="separator:ab4443dbb8b862b96dcaef6714bfb109d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e1d3f8856193b21e28b1367167e5e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#ac9e1d3f8856193b21e28b1367167e5e1">getLinearizedPositionData</a> (std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **X_data, <a class="el" href="classbool.html">bool</a> **X_needs_ghost_fill)</td></tr>
<tr class="separator:ac9e1d3f8856193b21e28b1367167e5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f7a43f3bc6e5f3390c186cda124517"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a20f7a43f3bc6e5f3390c186cda124517">getLECouplingPositionData</a> (std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **X_LE_data, <a class="el" href="classbool.html">bool</a> **X_LE_needs_ghost_fill, <a class="el" href="classdouble.html">double</a> data_time)</td></tr>
<tr class="separator:a20f7a43f3bc6e5f3390c186cda124517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12cc945fbdf9ea50858331d2b17b69d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#ad12cc945fbdf9ea50858331d2b17b69d">getLinearizedVelocityData</a> (std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **U_data)</td></tr>
<tr class="separator:ad12cc945fbdf9ea50858331d2b17b69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e716f66635dcd1ea30e511be0b19a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#aa5e716f66635dcd1ea30e511be0b19a0">getLinearizedForceData</a> (std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **F_data, <a class="el" href="classbool.html">bool</a> **F_needs_ghost_fill)</td></tr>
<tr class="separator:aa5e716f66635dcd1ea30e511be0b19a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab050ce36e0f3284b508e02d702ccf5fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#ab050ce36e0f3284b508e02d702ccf5fd">reinitMidpointData</a> (const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; &amp;current_data, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; &amp;new_data, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; &amp;half_data)</td></tr>
<tr class="separator:ab050ce36e0f3284b508e02d702ccf5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938a071fc48d5f7b32bf8f6bd4d4964d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a938a071fc48d5f7b32bf8f6bd4d4964d">resetAnchorPointValues</a> (std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; U_data, <a class="el" href="classint.html">int</a> coarsest_ln, <a class="el" href="classint.html">int</a> finest_ln)</td></tr>
<tr class="separator:a938a071fc48d5f7b32bf8f6bd4d4964d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee47a6927c31d46519bb27d05a3d2395"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#aee47a6927c31d46519bb27d05a3d2395">computeForce</a> (Vec X, Vec F)</td></tr>
<tr class="separator:aee47a6927c31d46519bb27d05a3d2395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8528c130bfe5261e668c29e79d70f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBAMR_1_1INSHierarchyIntegrator.html">INSHierarchyIntegrator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#aaf8528c130bfe5261e668c29e79d70f8">getINSHierarchyIntegrator</a> () const</td></tr>
<tr class="separator:aaf8528c130bfe5261e668c29e79d70f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93b6eb627f166c20aaae098ccd50865"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsReal.html">SAMRAI::math::HierarchyDataOpsReal</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#ad93b6eb627f166c20aaae098ccd50865">getVelocityHierarchyDataOps</a> () const</td></tr>
<tr class="separator:ad93b6eb627f166c20aaae098ccd50865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142514561f6e1ad3fc61751baafd1627"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsReal.html">SAMRAI::math::HierarchyDataOpsReal</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a142514561f6e1ad3fc61751baafd1627">getPressureHierarchyDataOps</a> () const</td></tr>
<tr class="separator:a142514561f6e1ad3fc61751baafd1627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4042917a2e54b8829948cb09f10e793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1HierarchyMathOps.html">IBTK::HierarchyMathOps</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#ad4042917a2e54b8829948cb09f10e793">getHierarchyMathOps</a> () const</td></tr>
<tr class="separator:ad4042917a2e54b8829948cb09f10e793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb81b46bc281abe474cfad82551e176b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#acb81b46bc281abe474cfad82551e176b">registerVariable</a> (<a class="el" href="classint.html">int</a> &amp;current_idx, <a class="el" href="classint.html">int</a> &amp;new_idx, <a class="el" href="classint.html">int</a> &amp;scratch_idx, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a>&lt; NDIM &gt; &gt; variable, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;scratch_ghosts=<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt;(0), const std::string &amp;coarsen_name=&quot;NO_COARSEN&quot;, const std::string &amp;refine_name=&quot;NO_REFINE&quot;, SAMRAI::tbox::Pointer&lt; <a class="el" href="classIBTK_1_1CartGridFunction.html">IBTK::CartGridFunction</a> &gt; init_fcn=nullptr, const <a class="el" href="classbool.html">bool</a> register_for_restart=true)</td></tr>
<tr class="separator:acb81b46bc281abe474cfad82551e176b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade8a368e03183d51d470c8d98c3c742"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#aade8a368e03183d51d470c8d98c3c742">registerVariable</a> (<a class="el" href="classint.html">int</a> &amp;idx, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a>&lt; NDIM &gt; &gt; variable, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;ghosts=<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt;(0), <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">SAMRAI::hier::VariableContext</a> &gt; ctx=<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">SAMRAI::hier::VariableContext</a> &gt;(nullptr), const <a class="el" href="classbool.html">bool</a> register_for_restart=true)</td></tr>
<tr class="separator:aade8a368e03183d51d470c8d98c3c742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff41aa031a85b31866aa1bd7c832cb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a6ff41aa031a85b31866aa1bd7c832cb9">registerGhostfillRefineAlgorithm</a> (const std::string &amp;name, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; NDIM &gt; &gt; ghostfill_alg, std::unique_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a>&lt; NDIM &gt; &gt; ghostfill_patch_strategy=nullptr)</td></tr>
<tr class="separator:a6ff41aa031a85b31866aa1bd7c832cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765846726a9e33a0b31e0549b699515f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a765846726a9e33a0b31e0549b699515f">registerProlongRefineAlgorithm</a> (const std::string &amp;name, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; NDIM &gt; &gt; prolong_alg, std::unique_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a>&lt; NDIM &gt; &gt; prolong_patch_strategy=nullptr)</td></tr>
<tr class="separator:a765846726a9e33a0b31e0549b699515f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4217ccceea177b4109b528a85c383a2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a4217ccceea177b4109b528a85c383a2b">registerCoarsenAlgorithm</a> (const std::string &amp;name, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html">SAMRAI::xfer::CoarsenAlgorithm</a>&lt; NDIM &gt; &gt; coarsen_alg, std::unique_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html">SAMRAI::xfer::CoarsenPatchStrategy</a>&lt; NDIM &gt; &gt; coarsen_patch_strategy=nullptr)</td></tr>
<tr class="separator:a4217ccceea177b4109b528a85c383a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b456e15f5214d3bfe529372ad346c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a08b456e15f5214d3bfe529372ad346c6">getGhostfillRefineAlgorithm</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:a08b456e15f5214d3bfe529372ad346c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1cd6f821e6a0e6a82c2a91577fa331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#aac1cd6f821e6a0e6a82c2a91577fa331">getProlongRefineAlgorithm</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:aac1cd6f821e6a0e6a82c2a91577fa331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed62275cf737a96421674efa382cde2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html">SAMRAI::xfer::CoarsenAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a1ed62275cf737a96421674efa382cde2">getCoarsenAlgorithm</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:a1ed62275cf737a96421674efa382cde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ca1b192c934db6db9cc266ff5fc1f0"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#ac9ca1b192c934db6db9cc266ff5fc1f0">getGhostfillRefineSchedules</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:ac9ca1b192c934db6db9cc266ff5fc1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4567af6f8f85c8fc935e3cf90933710"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#ac4567af6f8f85c8fc935e3cf90933710">getProlongRefineSchedules</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:ac4567af6f8f85c8fc935e3cf90933710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff556dcdcf10f9a7b04d8aae07dd7b6d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#aff556dcdcf10f9a7b04d8aae07dd7b6d">getCoarsenSchedules</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:aff556dcdcf10f9a7b04d8aae07dd7b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087733d93ea9af2d37c730dbb86f83a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a087733d93ea9af2d37c730dbb86f83a2">setRotationMatrix</a> (const std::vector&lt; Eigen::Vector3d &gt; &amp;rot_vel, const std::vector&lt; Eigen::Quaterniond &gt; &amp;q_old, std::vector&lt; Eigen::Quaterniond &gt; &amp;q_new, std::vector&lt; Eigen::Matrix3d &gt; &amp;rot_mat, const <a class="el" href="classdouble.html">double</a> dt)</td></tr>
<tr class="memdesc:a087733d93ea9af2d37c730dbb86f83a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the rotation matrix.  <a href="classIBAMR_1_1CIBStrategy.html#a087733d93ea9af2d37c730dbb86f83a2">More...</a><br /></td></tr>
<tr class="separator:a087733d93ea9af2d37c730dbb86f83a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a07ac2b2fa9561baca4035351e5cca9ce"><td class="memItemLeft" align="right" valign="top">static PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a07ac2b2fa9561baca4035351e5cca9ce">computeForce_SAMRAI</a> (void *ctx, Vec X, Vec F)</td></tr>
<tr class="separator:a07ac2b2fa9561baca4035351e5cca9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9cbe4e99ef963d0f6926e31df2c8b64c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structIBAMR_1_1CIBMethod_1_1ConstrainedVelocityFcnsData.html">ConstrainedVelocityFcnsData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a9cbe4e99ef963d0f6926e31df2c8b64c">d_constrained_velocity_fcns_data</a></td></tr>
<tr class="separator:a9cbe4e99ef963d0f6926e31df2c8b64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb461721f468bcec1fb52111622ad6d1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structIBAMR_1_1CIBMethod_1_1ExternalForceTorqueFcnData.html">ExternalForceTorqueFcnData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#adb461721f468bcec1fb52111622ad6d1">d_ext_force_torque_fcn_data</a></td></tr>
<tr class="separator:adb461721f468bcec1fb52111622ad6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad306212aa46e4dfc5fd955a075fd5dd2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIBAMR_1_1CIBMethod.html#a1d078ef3235314b1f94a2222c8771d1a">preprocessSolveFluidEqn_callbackfcn</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#ad306212aa46e4dfc5fd955a075fd5dd2">d_prefluidsolve_callback_fcns</a></td></tr>
<tr class="separator:ad306212aa46e4dfc5fd955a075fd5dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e71a4711e1e5e2d95ed9b4440a87dbf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a0e71a4711e1e5e2d95ed9b4440a87dbf">d_prefluidsolve_callback_fcns_ctx</a></td></tr>
<tr class="separator:a0e71a4711e1e5e2d95ed9b4440a87dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09a94731272c280e2d878265a2831ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#af09a94731272c280e2d878265a2831ed">d_constraint_force_is_initialized</a> = false</td></tr>
<tr class="separator:af09a94731272c280e2d878265a2831ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914388092b314af99239bd8fe8856a46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a914388092b314af99239bd8fe8856a46">d_lag_velvec_is_initialized</a> = false</td></tr>
<tr class="separator:a914388092b314af99239bd8fe8856a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a73298c80cbc74b93bb604492571b90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a3a73298c80cbc74b93bb604492571b90">d_time_integrator_needs_regrid</a> = false</td></tr>
<tr class="separator:a3a73298c80cbc74b93bb604492571b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f6f1686ce470277bb23c60374b65a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#ae3f6f1686ce470277bb23c60374b65a4">d_eul_lambda_var</a></td></tr>
<tr class="separator:ae3f6f1686ce470277bb23c60374b65a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c521ed6b1ab0def5b8277f21a4f70e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a2c521ed6b1ab0def5b8277f21a4f70e8">d_eul_lambda_idx</a> = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td></tr>
<tr class="separator:a2c521ed6b1ab0def5b8277f21a4f70e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a79b6524910d500c60613ac3f62a0c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a64a79b6524910d500c60613ac3f62a0c">d_struct_lag_idx_range</a></td></tr>
<tr class="separator:a64a79b6524910d500c60613ac3f62a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99393996ad567270b20808d4730bd0e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">SAMRAI::appu::VisItDataWriter</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a99393996ad567270b20808d4730bd0e1">d_visit_writer</a></td></tr>
<tr class="separator:a99393996ad567270b20808d4730bd0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe02ebc9b0bbea7548fa04254b8e235"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a1fe02ebc9b0bbea7548fa04254b8e235">d_output_eul_lambda</a> = false</td></tr>
<tr class="separator:a1fe02ebc9b0bbea7548fa04254b8e235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6b4224208c1a5004ee6ee56abbceda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#adf6b4224208c1a5004ee6ee56abbceda">d_lambda_dump_interval</a> = 0</td></tr>
<tr class="separator:adf6b4224208c1a5004ee6ee56abbceda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e51037ad0d37940c2117ccb23376a7c"><td class="memItemLeft" align="right" valign="top">std::ofstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a8e51037ad0d37940c2117ccb23376a7c">d_lambda_stream</a></td></tr>
<tr class="separator:a8e51037ad0d37940c2117ccb23376a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968383d92d33bbf95679eaaa324f2035"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a968383d92d33bbf95679eaaa324f2035">d_reg_filename</a></td></tr>
<tr class="separator:a968383d92d33bbf95679eaaa324f2035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871fd03018d4e5f5ed90dcaf10e33aa3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a871fd03018d4e5f5ed90dcaf10e33aa3">d_lambda_filename</a></td></tr>
<tr class="separator:a871fd03018d4e5f5ed90dcaf10e33aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7881063615a4908e29c2ee7f35d836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">IBTK::RobinPhysBdryPatchStrategy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a1b7881063615a4908e29c2ee7f35d836">d_u_phys_bdry_op</a> = nullptr</td></tr>
<tr class="separator:a1b7881063615a4908e29c2ee7f35d836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ee663a6ab6e6dc5ac3fc17fafe873c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a28ee663a6ab6e6dc5ac3fc17fafe873c">d_use_steady_stokes</a> = false</td></tr>
<tr class="separator:a28ee663a6ab6e6dc5ac3fc17fafe873c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc67cf48dc84f63fce5814763579b50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a8bc67cf48dc84f63fce5814763579b50">d_do_log</a> = false</td></tr>
<tr class="separator:a8bc67cf48dc84f63fce5814763579b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ce274f57f366503ae87f276f9ed5f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a08ce274f57f366503ae87f276f9ed5f3">d_hierarchy</a></td></tr>
<tr class="separator:a08ce274f57f366503ae87f276f9ed5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872c7766acc7e81232f849cb326f8304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a872c7766acc7e81232f849cb326f8304">d_gridding_alg</a></td></tr>
<tr class="separator:a872c7766acc7e81232f849cb326f8304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf90f36cd311b91889b70b36a392e22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a4bf90f36cd311b91889b70b36a392e22">d_current_time</a> = std::numeric_limits&lt;<a class="el" href="classdouble.html">double</a>&gt;::quiet_NaN()</td></tr>
<tr class="separator:a4bf90f36cd311b91889b70b36a392e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98af6244554f8697e6ee0872fe4aa784"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a98af6244554f8697e6ee0872fe4aa784">d_new_time</a> = std::numeric_limits&lt;<a class="el" href="classdouble.html">double</a>&gt;::quiet_NaN()</td></tr>
<tr class="separator:a98af6244554f8697e6ee0872fe4aa784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c02e28ae4b1653948405a446c0e8f5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a5c02e28ae4b1653948405a446c0e8f5b">d_half_time</a> = std::numeric_limits&lt;<a class="el" href="classdouble.html">double</a>&gt;::quiet_NaN()</td></tr>
<tr class="separator:a5c02e28ae4b1653948405a446c0e8f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c99d72d6be7e5ba7d33f6c05d3347d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a1c99d72d6be7e5ba7d33f6c05d3347d1">d_X_current_needs_ghost_fill</a> = true</td></tr>
<tr class="separator:a1c99d72d6be7e5ba7d33f6c05d3347d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc8b0d6ea5d4b8531faf8de0f3c731b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a2cc8b0d6ea5d4b8531faf8de0f3c731b">d_X_new_needs_ghost_fill</a> = true</td></tr>
<tr class="separator:a2cc8b0d6ea5d4b8531faf8de0f3c731b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3baa4573497508cfae392f29ac9208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a7e3baa4573497508cfae392f29ac9208">d_X_half_needs_ghost_fill</a> = true</td></tr>
<tr class="separator:a7e3baa4573497508cfae392f29ac9208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48ad3795ef748c8e3c2352da39a1c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#ac48ad3795ef748c8e3c2352da39a1c82">d_X_jac_needs_ghost_fill</a> = true</td></tr>
<tr class="separator:ac48ad3795ef748c8e3c2352da39a1c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b698edb4c59aad594c290041e6a7ff0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a2b698edb4c59aad594c290041e6a7ff0">d_X_LE_new_needs_ghost_fill</a> = true</td></tr>
<tr class="separator:a2b698edb4c59aad594c290041e6a7ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d5cdecaf50a8d6b40b8141790a0af7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#ab0d5cdecaf50a8d6b40b8141790a0af7">d_X_LE_half_needs_ghost_fill</a> = true</td></tr>
<tr class="separator:ab0d5cdecaf50a8d6b40b8141790a0af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356432244fdb99c27fb16951b30b4ab1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a356432244fdb99c27fb16951b30b4ab1">d_F_current_needs_ghost_fill</a> = true</td></tr>
<tr class="separator:a356432244fdb99c27fb16951b30b4ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668a8de1aaf6c3768e5b6e8d93992790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a668a8de1aaf6c3768e5b6e8d93992790">d_F_new_needs_ghost_fill</a> = true</td></tr>
<tr class="separator:a668a8de1aaf6c3768e5b6e8d93992790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3b2f0689d8125c5309296eee2021bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a4c3b2f0689d8125c5309296eee2021bc">d_F_half_needs_ghost_fill</a> = true</td></tr>
<tr class="separator:a4c3b2f0689d8125c5309296eee2021bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abc0721b50dabee58a704dba9fbf5cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a5abc0721b50dabee58a704dba9fbf5cb">d_F_jac_needs_ghost_fill</a> = true</td></tr>
<tr class="separator:a5abc0721b50dabee58a704dba9fbf5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514dbf1eb4d147287e0cec73beb9a8ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBTK_1_1LDataManager.html">IBTK::LDataManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a514dbf1eb4d147287e0cec73beb9a8ad">d_l_data_manager</a></td></tr>
<tr class="separator:a514dbf1eb4d147287e0cec73beb9a8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa905f8957596594ebeb000b04e21879f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#aa905f8957596594ebeb000b04e21879f">d_interp_kernel_fcn</a> = &quot;IB_4&quot;</td></tr>
<tr class="separator:aa905f8957596594ebeb000b04e21879f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640371d2efea148cea891f14bcf1ad75"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a640371d2efea148cea891f14bcf1ad75">d_spread_kernel_fcn</a> = &quot;IB_4&quot;</td></tr>
<tr class="separator:a640371d2efea148cea891f14bcf1ad75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b623b7348d129b99c04006060e1afc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a08b623b7348d129b99c04006060e1afc">d_error_if_points_leave_domain</a> = false</td></tr>
<tr class="separator:a08b623b7348d129b99c04006060e1afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d78c0028f20db67ef16fcf481bddfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a17d78c0028f20db67ef16fcf481bddfa">d_ghosts</a></td></tr>
<tr class="separator:a17d78c0028f20db67ef16fcf481bddfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cc326dd6fc84036999dafdf7fa1f39"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a66cc326dd6fc84036999dafdf7fa1f39">d_X_current_data</a></td></tr>
<tr class="separator:a66cc326dd6fc84036999dafdf7fa1f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ac77ae8af8bbcc941c6fc8dd49a8fa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#ad7ac77ae8af8bbcc941c6fc8dd49a8fa">d_X_new_data</a></td></tr>
<tr class="separator:ad7ac77ae8af8bbcc941c6fc8dd49a8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fca1597f7a8160b4aa36aa8470db03e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a4fca1597f7a8160b4aa36aa8470db03e">d_X_half_data</a></td></tr>
<tr class="separator:a4fca1597f7a8160b4aa36aa8470db03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96c9a51ec7a18b20984945239671381"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#ac96c9a51ec7a18b20984945239671381">d_X_jac_data</a></td></tr>
<tr class="separator:ac96c9a51ec7a18b20984945239671381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15840fae7e4b1c57ba11afed101c492a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a15840fae7e4b1c57ba11afed101c492a">d_X_LE_new_data</a></td></tr>
<tr class="separator:a15840fae7e4b1c57ba11afed101c492a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36cfa20dd7f7e7f1984753c82a85f03c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a36cfa20dd7f7e7f1984753c82a85f03c">d_X_LE_half_data</a></td></tr>
<tr class="separator:a36cfa20dd7f7e7f1984753c82a85f03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0c76b1055f8a64b4a3bcf9f5b0d83f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a8b0c76b1055f8a64b4a3bcf9f5b0d83f">d_U_current_data</a></td></tr>
<tr class="separator:a8b0c76b1055f8a64b4a3bcf9f5b0d83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c91fce1d50ade7e1ff9b759365e74f3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a5c91fce1d50ade7e1ff9b759365e74f3">d_U_new_data</a></td></tr>
<tr class="separator:a5c91fce1d50ade7e1ff9b759365e74f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452bf8b8a95d1d83e1baf2fd651c0201"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a452bf8b8a95d1d83e1baf2fd651c0201">d_U_half_data</a></td></tr>
<tr class="separator:a452bf8b8a95d1d83e1baf2fd651c0201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5fc1dfc7a077151f14727b2f50fce3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a9e5fc1dfc7a077151f14727b2f50fce3">d_U_jac_data</a></td></tr>
<tr class="separator:a9e5fc1dfc7a077151f14727b2f50fce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d9653c56859e8fa76ec075116672d9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#ab2d9653c56859e8fa76ec075116672d9">d_F_current_data</a></td></tr>
<tr class="separator:ab2d9653c56859e8fa76ec075116672d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12883030879a4c0ce1ce9aacc8a16c40"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a12883030879a4c0ce1ce9aacc8a16c40">d_F_new_data</a></td></tr>
<tr class="separator:a12883030879a4c0ce1ce9aacc8a16c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e202a13cad1b6e6afec095132c0d64"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#af9e202a13cad1b6e6afec095132c0d64">d_F_half_data</a></td></tr>
<tr class="separator:af9e202a13cad1b6e6afec095132c0d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e62f69464feb38e55a552bdb53d5a7c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a4e62f69464feb38e55a552bdb53d5a7c">d_F_jac_data</a></td></tr>
<tr class="separator:a4e62f69464feb38e55a552bdb53d5a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0a3b36efbe41cd31f52730bd5bfe4f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::set&lt; <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#aab0a3b36efbe41cd31f52730bd5bfe4f">d_anchor_point_local_idxs</a></td></tr>
<tr class="separator:aab0a3b36efbe41cd31f52730bd5bfe4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e01a1093cfe11a79de7a2f31512382"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBAMR_1_1IBInstrumentPanel.html">IBInstrumentPanel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a25e01a1093cfe11a79de7a2f31512382">d_instrument_panel</a></td></tr>
<tr class="separator:a25e01a1093cfe11a79de7a2f31512382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fa9884482b741d77fe91a48e725b1f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#ab7fa9884482b741d77fe91a48e725b1f">d_total_flow_volume</a></td></tr>
<tr class="separator:ab7fa9884482b741d77fe91a48e725b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca7735b056018789b33acfb005c3de6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LInitStrategy.html">IBTK::LInitStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#adca7735b056018789b33acfb005c3de6">d_l_initializer</a></td></tr>
<tr class="separator:adca7735b056018789b33acfb005c3de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6904aabd6b8a24e164e20affcca5df1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBAMR_1_1IBLagrangianForceStrategy.html">IBLagrangianForceStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a6904aabd6b8a24e164e20affcca5df1a">d_ib_force_fcn</a></td></tr>
<tr class="separator:a6904aabd6b8a24e164e20affcca5df1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf794bc472e31c2a374e7b45058a32c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#aabf794bc472e31c2a374e7b45058a32c">d_ib_force_fcn_needs_init</a> = true</td></tr>
<tr class="separator:aabf794bc472e31c2a374e7b45058a32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419b4b2942b297803ab9d0e38baaf0dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBAMR_1_1IBLagrangianSourceStrategy.html">IBLagrangianSourceStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a419b4b2942b297803ab9d0e38baaf0dd">d_ib_source_fcn</a></td></tr>
<tr class="separator:a419b4b2942b297803ab9d0e38baaf0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75594106f13bab817a3ac98cfa95dde2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a75594106f13bab817a3ac98cfa95dde2">d_ib_source_fcn_needs_init</a> = true</td></tr>
<tr class="separator:a75594106f13bab817a3ac98cfa95dde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436000cf6620d690dd5a60fb928fdffc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">IBTK::Point</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a436000cf6620d690dd5a60fb928fdffc">d_X_src</a></td></tr>
<tr class="separator:a436000cf6620d690dd5a60fb928fdffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b34955740a5005e828a785400618e47"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a0b34955740a5005e828a785400618e47">d_r_src</a></td></tr>
<tr class="separator:a0b34955740a5005e828a785400618e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5586552900b8c3b391589e86b299d7d1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a5586552900b8c3b391589e86b299d7d1">d_P_src</a></td></tr>
<tr class="separator:a5586552900b8c3b391589e86b299d7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe55986c63576722e34cefd8be2a8ff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a6fe55986c63576722e34cefd8be2a8ff">d_Q_src</a></td></tr>
<tr class="separator:a6fe55986c63576722e34cefd8be2a8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422b43c41d5cd5f51c4691f706b41108"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a422b43c41d5cd5f51c4691f706b41108">d_n_src</a></td></tr>
<tr class="separator:a422b43c41d5cd5f51c4691f706b41108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8132da309771001ffc45a6af28ef2a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#ad8132da309771001ffc45a6af28ef2a0">d_normalize_source_strength</a> = false</td></tr>
<tr class="separator:ad8132da309771001ffc45a6af28ef2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcc833499d359d885e7cff25bc3f901"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBAMR_1_1IBMethodPostProcessStrategy.html">IBMethodPostProcessStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a5bcc833499d359d885e7cff25bc3f901">d_post_processor</a></td></tr>
<tr class="separator:a5bcc833499d359d885e7cff25bc3f901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937e47773c541ed4a05102b9ac01677e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LSiloDataWriter.html">IBTK::LSiloDataWriter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a937e47773c541ed4a05102b9ac01677e">d_silo_writer</a></td></tr>
<tr class="separator:a937e47773c541ed4a05102b9ac01677e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb9eb6b06e20729d1fb4fe649fa4da5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalancer.html">SAMRAI::mesh::LoadBalancer</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a2fb9eb6b06e20729d1fb4fe649fa4da5">d_load_balancer</a></td></tr>
<tr class="separator:a2fb9eb6b06e20729d1fb4fe649fa4da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e43c73cd8aebc96f3fe80d23ce05e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a52e43c73cd8aebc96f3fe80d23ce05e2">d_workload_idx</a> = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td></tr>
<tr class="separator:a52e43c73cd8aebc96f3fe80d23ce05e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cc6f54c7e2cf452fad35f87f3451b0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a57cc6f54c7e2cf452fad35f87f3451b0">d_object_name</a></td></tr>
<tr class="separator:a57cc6f54c7e2cf452fad35f87f3451b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5a55bef01451516fa6507b113e875a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a7e5a55bef01451516fa6507b113e875a">d_registered_for_restart</a></td></tr>
<tr class="separator:a7e5a55bef01451516fa6507b113e875a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b7435788a1ff68e5f6f54496341011"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html">IBHierarchyIntegrator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#aa3b7435788a1ff68e5f6f54496341011">d_ib_solver</a> = nullptr</td></tr>
<tr class="separator:aa3b7435788a1ff68e5f6f54496341011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c7fcd98c652f7e3f4b17e0bc59388d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBStrategy.html#a56c7fcd98c652f7e3f4b17e0bc59388d">d_use_fixed_coupling_ops</a> = false</td></tr>
<tr class="separator:a56c7fcd98c652f7e3f4b17e0bc59388d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c7b5094d5a3d78ea27f119d13a84cb"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a78c7b5094d5a3d78ea27f119d13a84cb">d_num_rigid_parts</a></td></tr>
<tr class="separator:a78c7b5094d5a3d78ea27f119d13a84cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9605c08a1475a205eff9afe1aa6a6697"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a9605c08a1475a205eff9afe1aa6a6697">d_center_of_mass_initial</a></td></tr>
<tr class="separator:a9605c08a1475a205eff9afe1aa6a6697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe66c1c916ebf8cc41a50e0d176de75a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#abe66c1c916ebf8cc41a50e0d176de75a">d_center_of_mass_current</a></td></tr>
<tr class="separator:abe66c1c916ebf8cc41a50e0d176de75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac8a64acf8f7af721cad92aee80bbb1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a9ac8a64acf8f7af721cad92aee80bbb1">d_center_of_mass_half</a></td></tr>
<tr class="separator:a9ac8a64acf8f7af721cad92aee80bbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c8cc709ffdd9adb602d079665fcf48"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ac7c8cc709ffdd9adb602d079665fcf48">d_center_of_mass_new</a></td></tr>
<tr class="separator:ac7c8cc709ffdd9adb602d079665fcf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b378a544fd6b8a871abe3ec3807d98"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#af5b378a544fd6b8a871abe3ec3807d98">d_compute_center_of_mass_initial</a></td></tr>
<tr class="separator:af5b378a544fd6b8a871abe3ec3807d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0997a2def8f09191bfa55a29e90c969"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Quaterniond &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#af0997a2def8f09191bfa55a29e90c969">d_quaternion_current</a></td></tr>
<tr class="separator:af0997a2def8f09191bfa55a29e90c969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac429d5ed3731531af860043d007aec6a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Quaterniond &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ac429d5ed3731531af860043d007aec6a">d_quaternion_half</a></td></tr>
<tr class="separator:ac429d5ed3731531af860043d007aec6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac219c2dad3198f4452eb91caa19d2d80"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Quaterniond &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ac219c2dad3198f4452eb91caa19d2d80">d_quaternion_new</a></td></tr>
<tr class="separator:ac219c2dad3198f4452eb91caa19d2d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd7755ec6ff2466d39205ba1eb007fe"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceIBTK.html#aac19301c6fd0897bd5254ffad040e24c">IBTK::FRDV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#adfd7755ec6ff2466d39205ba1eb007fe">d_solve_rigid_vel</a></td></tr>
<tr class="separator:adfd7755ec6ff2466d39205ba1eb007fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22ae8b85ca8df0fd9b812fdb4b5692b"><td class="memItemLeft" align="right" valign="top">Vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ab22ae8b85ca8df0fd9b812fdb4b5692b">d_U</a></td></tr>
<tr class="separator:ab22ae8b85ca8df0fd9b812fdb4b5692b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b7f78c9725bab72d66fbe6af279fea"><td class="memItemLeft" align="right" valign="top">Vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a08b7f78c9725bab72d66fbe6af279fea">d_F</a></td></tr>
<tr class="separator:a08b7f78c9725bab72d66fbe6af279fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7fd46d9caa77a2a5c73d300fecc1ac"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a2b7fd46d9caa77a2a5c73d300fecc1ac">d_free_dofs_map</a></td></tr>
<tr class="separator:a2b7fd46d9caa77a2a5c73d300fecc1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07a284a69aeca5ca96bf5b973e79ebf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ab07a284a69aeca5ca96bf5b973e79ebf">d_free_dofs_map_updated</a></td></tr>
<tr class="separator:ab07a284a69aeca5ca96bf5b973e79ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f327733ed226b3dab4570a091b8f320"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a1f327733ed226b3dab4570a091b8f320">d_trans_vel_current</a></td></tr>
<tr class="separator:a1f327733ed226b3dab4570a091b8f320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aec9a253505c8aec29c7fa61d1fb679"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a8aec9a253505c8aec29c7fa61d1fb679">d_trans_vel_half</a></td></tr>
<tr class="separator:a8aec9a253505c8aec29c7fa61d1fb679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72aa507b4762f5e2ab47f04b7c7a975f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a72aa507b4762f5e2ab47f04b7c7a975f">d_trans_vel_new</a></td></tr>
<tr class="separator:a72aa507b4762f5e2ab47f04b7c7a975f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84feb76bf0b3cdfdcbffab8d876cde9f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a84feb76bf0b3cdfdcbffab8d876cde9f">d_rot_vel_current</a></td></tr>
<tr class="separator:a84feb76bf0b3cdfdcbffab8d876cde9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afc85a233ca21712f4ad4e785676083"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a3afc85a233ca21712f4ad4e785676083">d_rot_vel_half</a></td></tr>
<tr class="separator:a3afc85a233ca21712f4ad4e785676083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d45fbba4a53b330b711f8e1eb869dbb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a3d45fbba4a53b330b711f8e1eb869dbb">d_rot_vel_new</a></td></tr>
<tr class="separator:a3d45fbba4a53b330b711f8e1eb869dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a571c74a9f31de87ea505275f416f7e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a8a571c74a9f31de87ea505275f416f7e">d_net_rigid_generalized_force</a></td></tr>
<tr class="separator:a8a571c74a9f31de87ea505275f416f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a2a98ad6628a498f17bbfd9fab1a796a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a2a98ad6628a498f17bbfd9fab1a796a8">getFromInput</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; input_db)</td></tr>
<tr class="memdesc:a2a98ad6628a498f17bbfd9fab1a796a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set additional values from input database.  <a href="classIBAMR_1_1CIBMethod.html#a2a98ad6628a498f17bbfd9fab1a796a8">More...</a><br /></td></tr>
<tr class="separator:a2a98ad6628a498f17bbfd9fab1a796a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fbe4ae1084c29a4d0467ca49f3ba70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a12fbe4ae1084c29a4d0467ca49f3ba70">getFromRestart</a> ()</td></tr>
<tr class="memdesc:a12fbe4ae1084c29a4d0467ca49f3ba70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get values from restart file.  <a href="classIBAMR_1_1CIBMethod.html#a12fbe4ae1084c29a4d0467ca49f3ba70">More...</a><br /></td></tr>
<tr class="separator:a12fbe4ae1084c29a4d0467ca49f3ba70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336d284ab4f11864543a7b5b40a20422"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a336d284ab4f11864543a7b5b40a20422">computeCOMOfStructures</a> (std::vector&lt; Eigen::Vector3d &gt; &amp;center_of_mass, std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; &amp;X_data)</td></tr>
<tr class="memdesc:a336d284ab4f11864543a7b5b40a20422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute center of mass of structures.  <a href="classIBAMR_1_1CIBMethod.html#a336d284ab4f11864543a7b5b40a20422">More...</a><br /></td></tr>
<tr class="separator:a336d284ab4f11864543a7b5b40a20422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae958096e8451d664bd7e02dff50b96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#aaae958096e8451d664bd7e02dff50b96">setRegularizationWeight</a> (const <a class="el" href="classint.html">int</a> level_number)</td></tr>
<tr class="memdesc:aaae958096e8451d664bd7e02dff50b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set regularization weight for Lagrangian markers.  <a href="classIBAMR_1_1CIBMethod.html#aaae958096e8451d664bd7e02dff50b96">More...</a><br /></td></tr>
<tr class="separator:aaae958096e8451d664bd7e02dff50b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03023f5887ba0d0eef6cf60001811f85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBMethod.html#a03023f5887ba0d0eef6cf60001811f85">setInitialLambda</a> (const <a class="el" href="classint.html">int</a> level_number)</td></tr>
<tr class="memdesc:a03023f5887ba0d0eef6cf60001811f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set initial Lambda for Lagrangian markers.  <a href="classIBAMR_1_1CIBMethod.html#a03023f5887ba0d0eef6cf60001811f85">More...</a><br /></td></tr>
<tr class="separator:a03023f5887ba0d0eef6cf60001811f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42eb6888698ddc9f9849442db5e1d3c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a42eb6888698ddc9f9849442db5e1d3c1">resetLagrangianForceFunction</a> (<a class="el" href="classdouble.html">double</a> init_data_time, <a class="el" href="classbool.html">bool</a> initial_time)</td></tr>
<tr class="separator:a42eb6888698ddc9f9849442db5e1d3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0738d342e5b730624f143d60842ef3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a8e0738d342e5b730624f143d60842ef3">resetLagrangianSourceFunction</a> (<a class="el" href="classdouble.html">double</a> init_data_time, <a class="el" href="classbool.html">bool</a> initial_time)</td></tr>
<tr class="separator:a8e0738d342e5b730624f143d60842ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaae6c3ceada7bdca69d9429efc454cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#afaae6c3ceada7bdca69d9429efc454cd">updateIBInstrumentationData</a> (<a class="el" href="classint.html">int</a> timestep_num, <a class="el" href="classdouble.html">double</a> data_time)</td></tr>
<tr class="separator:afaae6c3ceada7bdca69d9429efc454cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a73dd1048f57ee5ceb367c1cd725c0c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a73dd1048f57ee5ceb367c1cd725c0c20">d_force_jac_mffd</a> = false</td></tr>
<tr class="separator:a73dd1048f57ee5ceb367c1cd725c0c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382feb2b531ad4ce8a0312ea043ffe11"><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a382feb2b531ad4ce8a0312ea043ffe11">d_force_jac</a> = nullptr</td></tr>
<tr class="separator:a382feb2b531ad4ce8a0312ea043ffe11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5591836a8557af41e9a2d8027d1f9881"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1IBMethod.html#a5591836a8557af41e9a2d8027d1f9881">d_force_jac_data_time</a></td></tr>
<tr class="separator:a5591836a8557af41e9a2d8027d1f9881"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac67ecf6e898013c0c44a74dc6dedab0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67ecf6e898013c0c44a74dc6dedab0c">&#9670;&nbsp;</a></span>ConstrainedNodalVelocityFcnPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIBAMR_1_1CIBMethod.html#ac67ecf6e898013c0c44a74dc6dedab0c">IBAMR::CIBMethod::ConstrainedNodalVelocityFcnPtr</a> =  void (*)(Vec U_k, const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a>&amp; U, Vec X, const Eigen::Vector3d&amp; X_com, const Eigen::Matrix3d&amp; rotation_mat, <a class="el" href="classdouble.html">double</a> data_time, void* ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41fdb3cbddcc7101ddd142bf7a1f6131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fdb3cbddcc7101ddd142bf7a1f6131">&#9670;&nbsp;</a></span>ConstrainedCOMVelocityFcnPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIBAMR_1_1CIBMethod.html#a41fdb3cbddcc7101ddd142bf7a1f6131">IBAMR::CIBMethod::ConstrainedCOMVelocityFcnPtr</a> =  void (*)(<a class="el" href="classdouble.html">double</a> data_time, Eigen::Vector3d&amp; U_com, Eigen::Vector3d&amp; W_com, void* ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d8f328ae21580abd7a510494b1039c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8f328ae21580abd7a510494b1039c2">&#9670;&nbsp;</a></span>ExternalForceTorqueFcnPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIBAMR_1_1CIBMethod.html#a5d8f328ae21580abd7a510494b1039c2">IBAMR::CIBMethod::ExternalForceTorqueFcnPtr</a> =  void (*)(<a class="el" href="classdouble.html">double</a> data_time, Eigen::Vector3d&amp; F, Eigen::Vector3d&amp; T, void* ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d078ef3235314b1f94a2222c8771d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d078ef3235314b1f94a2222c8771d1a">&#9670;&nbsp;</a></span>preprocessSolveFluidEqn_callbackfcn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIBAMR_1_1CIBMethod.html#a1d078ef3235314b1f94a2222c8771d1a">IBAMR::CIBMethod::preprocessSolveFluidEqn_callbackfcn</a> =  void (*)(const <a class="el" href="classdouble.html">double</a>, const <a class="el" href="classdouble.html">double</a>, const <a class="el" href="classint.html">int</a>, void*)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a731cc8f933b63539489dea75a079f7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731cc8f933b63539489dea75a079f7b5">&#9670;&nbsp;</a></span>CIBMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IBAMR::CIBMethod::CIBMethod </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt;&#160;</td>
          <td class="paramname"><em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>no_structures</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>register_for_restart</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3ec96154b38bbd49bd651caa8017562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ec96154b38bbd49bd651caa8017562">&#9670;&nbsp;</a></span>~CIBMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IBAMR::CIBMethod::~CIBMethod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeb9b8ad393ec5dacca79bd3f8b7dd854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9b8ad393ec5dacca79bd3f8b7dd854">&#9670;&nbsp;</a></span>registerConstrainedVelocityFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::registerConstrainedVelocityFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIBAMR_1_1CIBMethod.html#ac67ecf6e898013c0c44a74dc6dedab0c">ConstrainedNodalVelocityFcnPtr</a>&#160;</td>
          <td class="paramname"><em>nodalvelfcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBAMR_1_1CIBMethod.html#a41fdb3cbddcc7101ddd142bf7a1f6131">ConstrainedCOMVelocityFcnPtr</a>&#160;</td>
          <td class="paramname"><em>comvelfcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0eda7ad8d32c8baf1acfd4601aa1ab28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eda7ad8d32c8baf1acfd4601aa1ab28">&#9670;&nbsp;</a></span>registerConstrainedVelocityFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::registerConstrainedVelocityFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIBAMR_1_1CIBMethod_1_1ConstrainedVelocityFcnsData.html">ConstrainedVelocityFcnsData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a132bb68d29460c83daca8e99d6b48db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132bb68d29460c83daca8e99d6b48db0">&#9670;&nbsp;</a></span>registerExternalForceTorqueFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::registerExternalForceTorqueFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIBAMR_1_1CIBMethod.html#a5d8f328ae21580abd7a510494b1039c2">ExternalForceTorqueFcnPtr</a>&#160;</td>
          <td class="paramname"><em>forcetorquefcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a25a17518739451320a70907076c8d2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a17518739451320a70907076c8d2c5">&#9670;&nbsp;</a></span>registerExternalForceTorqueFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::registerExternalForceTorqueFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIBAMR_1_1CIBMethod_1_1ExternalForceTorqueFcnData.html">ExternalForceTorqueFcnData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e99018652e9df319e180bb51e7806d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e99018652e9df319e180bb51e7806d1">&#9670;&nbsp;</a></span>getStructuresLevelNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBAMR::CIBMethod::getStructuresLevelNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa73a3c21695b4e042cfd0b9304a14432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73a3c21695b4e042cfd0b9304a14432">&#9670;&nbsp;</a></span>getStructureHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBAMR::CIBMethod::getStructureHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>lag_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23ab6980def8b2d2d1ff26aef04660f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ab6980def8b2d2d1ff26aef04660f2">&#9670;&nbsp;</a></span>registerPreProcessSolveFluidEquationsCallBackFcn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::registerPreProcessSolveFluidEquationsCallBackFcn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIBAMR_1_1CIBMethod.html#a1d078ef3235314b1f94a2222c8771d1a">preprocessSolveFluidEqn_callbackfcn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff0d67fbc16f0c938ada431136e2f4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0d67fbc16f0c938ada431136e2f4c7">&#9670;&nbsp;</a></span>preprocessSolveFluidEquations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::preprocessSolveFluidEquations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cycle_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#ad1d056e5284c58ba29315433c45154d3">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="abdca9dbaa626e5e1654274ef6d5bf578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdca9dbaa626e5e1654274ef6d5bf578">&#9670;&nbsp;</a></span>registerEulerianVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::registerEulerianVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a749a277f7c88ce504736463db4b439a9">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a5f369c438fd90b1cf4799c5810609e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f369c438fd90b1cf4799c5810609e6a">&#9670;&nbsp;</a></span>registerEulerianCommunicationAlgorithms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::registerEulerianCommunicationAlgorithms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#aec18a1b78a640c600e80aec1059418b8">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a8ac534b62ee373d1a8b9bc1871174b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac534b62ee373d1a8b9bc1871174b78">&#9670;&nbsp;</a></span>preprocessIntegrateData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::preprocessIntegrateData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a0550682c8f8235ef2f108df1c3a810d8">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a7a59b6d2461047316363e77b7315cf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a59b6d2461047316363e77b7315cf64">&#9670;&nbsp;</a></span>postprocessIntegrateData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::postprocessIntegrateData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a5a5960320bc59256baaa4f918fd02b2c">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="acf5a4677e4db9521da8560da1b4bcc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5a4677e4db9521da8560da1b4bcc2d">&#9670;&nbsp;</a></span>initializeLevelData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::initializeLevelData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>init_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>can_be_refined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>old_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allocate_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#af8f31cfe38a0690a629fcbeb7ad89888">SAMRAI::mesh::StandardTagAndInitStrategy::initializeLevelData</a> </dd></dl>

</div>
</div>
<a id="ad2df481d2b08356bd3dd86fcd7b6b4bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2df481d2b08356bd3dd86fcd7b6b4bd">&#9670;&nbsp;</a></span>initializePatchHierarchy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::initializePatchHierarchy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>gridding_alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>u_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_synch_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_ghost_fill_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>integrator_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>init_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A patch data descriptor is provided for the Eulerian velocity in case initialization requires interpolating Eulerian data. Ghost cells for Eulerian data will be filled upon entry to this function. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a2857c2753274413a8c0a3f1c9b2074d0">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="ab62cf95c2d79e3a5a61928ec3e873e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62cf95c2d79e3a5a61928ec3e873e77">&#9670;&nbsp;</a></span>interpolateVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::interpolateVelocity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>u_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_synch_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_ghost_fill_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classIBAMR_1_1IBStrategy.html#a5d7d2f79ab629e93a808becc43706d5b">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="abf5a40e194d6c9b2b2bc4370c06640df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5a40e194d6c9b2b2bc4370c06640df">&#9670;&nbsp;</a></span>spreadForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::spreadForce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">IBTK::RobinPhysBdryPatchStrategy</a> *&#160;</td>
          <td class="paramname"><em>f_phys_bdry_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_prolongation_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classIBAMR_1_1IBStrategy.html#a01e52f894bcd549503fe20f58dfbd08a">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="add31f9b7dce13b22aeb1315d68c506d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add31f9b7dce13b22aeb1315d68c506d9">&#9670;&nbsp;</a></span>forwardEulerStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::forwardEulerStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classIBAMR_1_1IBStrategy.html#ada6b78bba869c8f042d51a44bf3593af">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a94bfa4109e46499e7cb176145ad4b524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bfa4109e46499e7cb176145ad4b524">&#9670;&nbsp;</a></span>backwardEulerStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::backwardEulerStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a8230ec99b293ccda726061e4b5c05c1e">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a7c592381045f38c69d0019acddc9653e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c592381045f38c69d0019acddc9653e">&#9670;&nbsp;</a></span>midpointStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::midpointStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classIBAMR_1_1IBStrategy.html#adf7fad570f9f4757b7818ba14e5f0b66">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a8e73fc1a58ed983b3f653609f4c0aee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e73fc1a58ed983b3f653609f4c0aee2">&#9670;&nbsp;</a></span>trapezoidalStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::trapezoidalStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classIBAMR_1_1IBStrategy.html#a426420e5ab54e4a19763eb1f13d45949">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="af73e7b840266715988b40f7357b53b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73e7b840266715988b40f7357b53b42">&#9670;&nbsp;</a></span>registerVisItDataWriter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::registerVisItDataWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">SAMRAI::appu::VisItDataWriter</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>visit_writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a0a77e2e1cd58936be7b9f7810e2d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0a77e2e1cd58936be7b9f7810e2d4c">&#9670;&nbsp;</a></span>putToDatabase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::putToDatabase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt;&#160;</td>
          <td class="paramname"><em>db</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classSAMRAI_1_1tbox_1_1Serializable.html#ad90b74ae3fd7af9a7bb9cbf7f3ebc08a">SAMRAI::tbox::Serializable</a>.</p>

</div>
</div>
<a id="ab5b21e4a631bea521aaa8e7bc39707c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b21e4a631bea521aaa8e7bc39707c3">&#9670;&nbsp;</a></span>setConstraintForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::setConstraintForce </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classIBAMR_1_1CIBStrategy.html#a573493dce74f45976fb62db1c4102f17">IBAMR::CIBStrategy</a>.</p>

</div>
</div>
<a id="af45b029cc8728c27286c2bcc694fc310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45b029cc8728c27286c2bcc694fc310">&#9670;&nbsp;</a></span>getConstraintForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::getConstraintForce </td>
          <td>(</td>
          <td class="paramtype">Vec *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classIBAMR_1_1CIBStrategy.html#a4682dd04b56f42e5fb3a12d1ed24efed">IBAMR::CIBStrategy</a>.</p>

</div>
</div>
<a id="a3a22a6c03f6e31c8922651cd1b7946fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a22a6c03f6e31c8922651cd1b7946fd">&#9670;&nbsp;</a></span>getFreeRigidVelocities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBMethod::getFreeRigidVelocities </td>
          <td>(</td>
          <td class="paramtype">Vec *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classIBAMR_1_1CIBStrategy.html#aba5dc4783ab0a540a8768403dfcd5eb1">IBAMR::CIBStrategy</a>.</p>

</div>
</div>
<a id="a6784590dcd6f5495cc7d4a49eb9b53a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6784590dcd6f5495cc7d4a49eb9b53a8">&#9670;&nbsp;</a></span>getNetExternalForceTorque()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBMethod::getNetExternalForceTorque </td>
          <td>(</td>
          <td class="paramtype">Vec *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classIBAMR_1_1CIBStrategy.html#a82e6796cde1fa8582962ae1c0cc63012">IBAMR::CIBStrategy</a>.</p>

</div>
</div>
<a id="a641234ee6e8d986a5d4d4a8ad72730cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641234ee6e8d986a5d4d4a8ad72730cd">&#9670;&nbsp;</a></span>subtractMeanConstraintForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::subtractMeanConstraintForce </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classIBAMR_1_1CIBStrategy.html#ad9d78c835e925b0f5f55b93edadaacfd">IBAMR::CIBStrategy</a>.</p>

</div>
</div>
<a id="af71152ec5820e42360c48c63eaeeb408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71152ec5820e42360c48c63eaeeb408">&#9670;&nbsp;</a></span>setInterpolatedVelocityVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::setInterpolatedVelocityVector </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classIBAMR_1_1CIBStrategy.html#a35a497d05a2db8d13d5a3169bb8d3802">IBAMR::CIBStrategy</a>.</p>

</div>
</div>
<a id="a0ed97c5c4495ccd3b4f58dcde10e871e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed97c5c4495ccd3b4f58dcde10e871e">&#9670;&nbsp;</a></span>getInterpolatedVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::getInterpolatedVelocity </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classIBAMR_1_1CIBStrategy.html#a778c86c5fadf9ea9ea5657b02a2d5ef2">IBAMR::CIBStrategy</a>.</p>

</div>
</div>
<a id="a83a48b1fb791aa8944ac5fcdd0ba40b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a48b1fb791aa8944ac5fcdd0ba40b8">&#9670;&nbsp;</a></span>computeMobilityRegularization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::computeMobilityRegularization </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classIBAMR_1_1CIBStrategy.html#a381066ff0fe88d278f3a0d07d4d3a633">IBAMR::CIBStrategy</a>.</p>

</div>
</div>
<a id="ad117216876ac8f3ba82873f9732f7774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad117216876ac8f3ba82873f9732f7774">&#9670;&nbsp;</a></span>getNumberOfNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> IBAMR::CIBMethod::getNumberOfNodes </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classIBAMR_1_1CIBStrategy.html#af22c5d41e5e385eb7720691e0050b4b0">IBAMR::CIBStrategy</a>.</p>

</div>
</div>
<a id="a9098bc848b12dab953743a64fd946f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9098bc848b12dab953743a64fd946f74">&#9670;&nbsp;</a></span>setRigidBodyVelocity() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::setRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classIBAMR_1_1CIBStrategy.html#a74b814e860e4713dc9f437f43856a2a0">IBAMR::CIBStrategy</a>.</p>

</div>
</div>
<a id="a1351588b3bbeda76d138b1565bec1776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1351588b3bbeda76d138b1565bec1776">&#9670;&nbsp;</a></span>computeNetRigidGeneralizedForce() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::computeNetRigidGeneralizedForce </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classIBAMR_1_1CIBStrategy.html#a9f3387134bbce5257db7969ef019a1a2">IBAMR::CIBStrategy</a>.</p>

</div>
</div>
<a id="a2fefde49aaede47f291596c329e65653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fefde49aaede47f291596c329e65653">&#9670;&nbsp;</a></span>copyVecToArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::copyVecToArray </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>data_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>array_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classIBAMR_1_1CIBStrategy.html#ac5b924ba210e1f10cba28705f94015f2">IBAMR::CIBStrategy</a>.</p>

</div>
</div>
<a id="aed267e3dc9ec08c21ea8bab8bf4bb7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed267e3dc9ec08c21ea8bab8bf4bb7fd">&#9670;&nbsp;</a></span>copyArrayToVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::copyArrayToVec </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>data_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>array_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classIBAMR_1_1CIBStrategy.html#a8da0e483af91e696d6105e5be771c0c4">IBAMR::CIBStrategy</a>.</p>

</div>
</div>
<a id="a7a6d6ef7fa9cfcc376571763c27f5375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6d6ef7fa9cfcc376571763c27f5375">&#9670;&nbsp;</a></span>constructMobilityMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::constructMobilityMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIBAMR.html#a591304f336aef144a5ae4595cffc3f70">MobilityMatrixType</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>mobility_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>prototype_struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>grid_dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>domain_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>f_periodic_corr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>managing_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classIBAMR_1_1CIBStrategy.html#a169be9cab6a1917986d421d29dbe303d">IBAMR::CIBStrategy</a>.</p>

</div>
</div>
<a id="a649e4ca9381f49dc39a90b7411fccd3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649e4ca9381f49dc39a90b7411fccd3a">&#9670;&nbsp;</a></span>constructGeometricMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::constructGeometricMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>geometric_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>prototype_struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>managing_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classIBAMR_1_1CIBStrategy.html#a6ca98046bbb01951fd5cc687148f59c9">IBAMR::CIBStrategy</a>.</p>

</div>
</div>
<a id="aa5361e9c9f9875c55a82c6185886592b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5361e9c9f9875c55a82c6185886592b">&#9670;&nbsp;</a></span>rotateArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::rotateArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_transpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>managing_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classIBAMR_1_1CIBStrategy.html#a37efaea07ac44c8caf881723adc972e4">IBAMR::CIBStrategy</a>.</p>

</div>
</div>
<a id="a9cc520d581a35ff79d136497ae57b5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc520d581a35ff79d136497ae57b5ca">&#9670;&nbsp;</a></span>flagRegrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::CIBMethod::flagRegrid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to determine whether regridding should occur at the current time step. </p>

</div>
</div>
<a id="a45e90212eedcbb39716457a7e01bd5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e90212eedcbb39716457a7e01bd5ff">&#9670;&nbsp;</a></span>setVelocityPhysBdryOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::setVelocityPhysBdryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">IBTK::RobinPhysBdryPatchStrategy</a> *&#160;</td>
          <td class="paramname"><em>u_phys_bdry_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a98ad6628a498f17bbfd9fab1a796a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a98ad6628a498f17bbfd9fab1a796a8">&#9670;&nbsp;</a></span>getFromInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::getFromInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt;&#160;</td>
          <td class="paramname"><em>input_db</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12fbe4ae1084c29a4d0467ca49f3ba70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fbe4ae1084c29a4d0467ca49f3ba70">&#9670;&nbsp;</a></span>getFromRestart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::getFromRestart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a336d284ab4f11864543a7b5b40a20422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336d284ab4f11864543a7b5b40a20422">&#9670;&nbsp;</a></span>computeCOMOfStructures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::computeCOMOfStructures </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>center_of_mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaae958096e8451d664bd7e02dff50b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae958096e8451d664bd7e02dff50b96">&#9670;&nbsp;</a></span>setRegularizationWeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::setRegularizationWeight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03023f5887ba0d0eef6cf60001811f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03023f5887ba0d0eef6cf60001811f85">&#9670;&nbsp;</a></span>setInitialLambda()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBMethod::setInitialLambda </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a74b814e860e4713dc9f437f43856a2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b814e860e4713dc9f437f43856a2a0">&#9670;&nbsp;</a></span>setRigidBodyVelocity() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::setRigidBodyVelocity</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Explicitly use the other overload of this function from the base class. </p>

</div>
</div>
<a id="a08097027463a8986efc35a294ab10f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08097027463a8986efc35a294ab10f4d">&#9670;&nbsp;</a></span>setRigidBodyVelocity() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::setRigidBodyVelocity</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Explicitly use the other overload of this function from the base class. </p>

</div>
</div>
<a id="aed839bba3c6ae73fe3ceaa6ee548a0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed839bba3c6ae73fe3ceaa6ee548a0a6">&#9670;&nbsp;</a></span>setRigidBodyVelocity() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::setRigidBodyVelocity</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Explicitly use the other overload of this function from the base class. </p>

</div>
</div>
<a id="a9f3387134bbce5257db7969ef019a1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3387134bbce5257db7969ef019a1a2">&#9670;&nbsp;</a></span>computeNetRigidGeneralizedForce() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::computeNetRigidGeneralizedForce</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Explicitly use the other overloads of this function from the base class. </p>

</div>
</div>
<a id="ad6a54517eaec6816edb0e06cffe8f08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a54517eaec6816edb0e06cffe8f08d">&#9670;&nbsp;</a></span>computeNetRigidGeneralizedForce() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::computeNetRigidGeneralizedForce</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Explicitly use the other overloads of this function from the base class. </p>

</div>
</div>
<a id="ac1b3429e6b49d50e385af370874acf42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b3429e6b49d50e385af370874acf42">&#9670;&nbsp;</a></span>computeNetRigidGeneralizedForce() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::computeNetRigidGeneralizedForce</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Explicitly use the other overloads of this function from the base class. </p>

</div>
</div>
<a id="a80be2819afc59abdee7bb79717709304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80be2819afc59abdee7bb79717709304">&#9670;&nbsp;</a></span>registerIBLagrangianForceFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::registerIBLagrangianForceFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBAMR_1_1IBLagrangianForceStrategy.html">IBLagrangianForceStrategy</a> &gt;&#160;</td>
          <td class="paramname"><em>ib_force_fcn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Supply a Lagrangian force object. </p>

</div>
</div>
<a id="a12fdade3f34c2bd820878628b65a3a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fdade3f34c2bd820878628b65a3a83">&#9670;&nbsp;</a></span>registerIBLagrangianSourceFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::registerIBLagrangianSourceFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBAMR_1_1IBLagrangianSourceStrategy.html">IBLagrangianSourceStrategy</a> &gt;&#160;</td>
          <td class="paramname"><em>ib_source_fcn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Supply a Lagrangian source object. </p>

</div>
</div>
<a id="ae7e2d69dca4c9e92fe9ad598033cbc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e2d69dca4c9e92fe9ad598033cbc69">&#9670;&nbsp;</a></span>registerLInitStrategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::registerLInitStrategy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LInitStrategy.html">IBTK::LInitStrategy</a> &gt;&#160;</td>
          <td class="paramname"><em>l_initializer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Supply a Lagrangian initialization object. </p>

</div>
</div>
<a id="aaf75e5e82f4f1962796dd5c625257639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf75e5e82f4f1962796dd5c625257639">&#9670;&nbsp;</a></span>freeLInitStrategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::freeLInitStrategy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free references to Lagrangian initialization objects. </p>

</div>
</div>
<a id="a7a68aaa64d935433c8a0fee80d286cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a68aaa64d935433c8a0fee80d286cbf">&#9670;&nbsp;</a></span>registerIBMethodPostProcessor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::registerIBMethodPostProcessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBAMR_1_1IBMethodPostProcessStrategy.html">IBMethodPostProcessStrategy</a> &gt;&#160;</td>
          <td class="paramname"><em>post_processor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Supply a post processor object. </p>

</div>
</div>
<a id="a9d60d88d173796c3f2b806eee8011e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d60d88d173796c3f2b806eee8011e61">&#9670;&nbsp;</a></span>getLDataManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBTK_1_1LDataManager.html">IBTK::LDataManager</a>* IBAMR::IBMethod::getLDataManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the Lagrangian data manager object. </p>

</div>
</div>
<a id="a33e3b35da07a55364dc82aeaa2bc05f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e3b35da07a55364dc82aeaa2bc05f4">&#9670;&nbsp;</a></span>getIBInstrumentPanel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBAMR_1_1IBInstrumentPanel.html">IBInstrumentPanel</a>&gt; IBAMR::IBMethod::getIBInstrumentPanel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the instrumentation manager object. </p>

</div>
</div>
<a id="a42b1cd845cd4bb0ce96aa3baf6f3c683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b1cd845cd4bb0ce96aa3baf6f3c683">&#9670;&nbsp;</a></span>registerLSiloDataWriter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::registerLSiloDataWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LSiloDataWriter.html">IBTK::LSiloDataWriter</a> &gt;&#160;</td>
          <td class="paramname"><em>silo_writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a Lagrangian Silo data writer so this class will write plot files that may be postprocessed with the VisIt visualization tool. </p>

</div>
</div>
<a id="aa9cd0f1a69472b600268a490233ff929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9cd0f1a69472b600268a490233ff929">&#9670;&nbsp;</a></span>getMinimumGhostCellWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt;NDIM&gt;&amp; IBAMR::IBMethod::getMinimumGhostCellWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of ghost cells required by the Lagrangian-Eulerian interaction routines. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBStrategy.html#a4eccd737f9f717fbf7b5c3c5ff87f626">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="ab2a30dbb933f491ce2357db91b19c62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a30dbb933f491ce2357db91b19c62d">&#9670;&nbsp;</a></span>setupTagBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::setupTagBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">SAMRAI::tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>gridding_alg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Setup the tag buffer. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a4ae1682579a77ae302441ae085803325">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="acb8a44a8e204539a498668f9375fe2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8a44a8e204539a498668f9375fe2be">&#9670;&nbsp;</a></span>inactivateLagrangianStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBMethod::inactivateLagrangianStructure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>structure_number</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em> = <code>std::numeric_limits&lt;&#160;<a class="el" href="classint.html">int</a>&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inactivate a structure/part. See <a class="el" href="classIBAMR_1_1IBStrategy.html#ab2a042363dca682c158d89dcde9c7cad">IBAMR::IBStrategy::inactivateLagrangianStructure()</a>. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#ab2a042363dca682c158d89dcde9c7cad">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="aa138082063940e29aaf45793421d1317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa138082063940e29aaf45793421d1317">&#9670;&nbsp;</a></span>activateLagrangianStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBMethod::activateLagrangianStructure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>structure_number</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em> = <code>std::numeric_limits&lt;&#160;<a class="el" href="classint.html">int</a>&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Activate a previously inactivated structure/part to be used again in FSI calculations. See <a class="el" href="classIBAMR_1_1IBStrategy.html#ac7f5e1149acbaeb298a94eddb4a2b855">IBAMR::IBStrategy::activateLagrangianStructure()</a>. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#ac7f5e1149acbaeb298a94eddb4a2b855">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a81e99426b240c6f24476f603d99853e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e99426b240c6f24476f603d99853e8">&#9670;&nbsp;</a></span>getLagrangianStructureIsActivated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::getLagrangianStructureIsActivated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>structure_number</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em> = <code>std::numeric_limits&lt;&#160;<a class="el" href="classint.html">int</a>&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine whether or not the given structure or part is currently activated. See <a class="el" href="classIBAMR_1_1IBStrategy.html#a9d0d8e6216b3208f738e3a48d44ebcd9">IBAMR::IBStrategy::getLagrangianStructureIsActivated()</a>. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a9d0d8e6216b3208f738e3a48d44ebcd9">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="aec17e9417c4f5a34719b0979baf1707f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec17e9417c4f5a34719b0979baf1707f">&#9670;&nbsp;</a></span>createSolverVecs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::createSolverVecs </td>
          <td>(</td>
          <td class="paramtype">Vec *&#160;</td>
          <td class="paramname"><em>X_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec *&#160;</td>
          <td class="paramname"><em>F_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create solution and rhs data on the specified level of the patch hierarchy. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBImplicitStrategy.html#aa23a2f1342fe2d25ce4159e7c962657f">IBAMR::IBImplicitStrategy</a>.</p>

</div>
</div>
<a id="a97c8f0dbb72019492721ffdae0d0d419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c8f0dbb72019492721ffdae0d0d419">&#9670;&nbsp;</a></span>setupSolverVecs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::setupSolverVecs </td>
          <td>(</td>
          <td class="paramtype">Vec *&#160;</td>
          <td class="paramname"><em>X_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec *&#160;</td>
          <td class="paramname"><em>F_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Setup solution and rhs data on the specified level of the patch hierarchy. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBImplicitStrategy.html#a79420195e86ce76e436ce4aa5a9677af">IBAMR::IBImplicitStrategy</a>.</p>

</div>
</div>
<a id="a4c6fd2e9a8a42c6124f02cab6321e804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6fd2e9a8a42c6124f02cab6321e804">&#9670;&nbsp;</a></span>setUpdatedPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::setUpdatedPosition </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>X_new_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the value of the updated position vector. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBImplicitStrategy.html#abdd827f407e056f50e665cbe59c901c8">IBAMR::IBImplicitStrategy</a>.</p>

</div>
</div>
<a id="a3682a2781eb0871608d0ff942a0ac06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3682a2781eb0871608d0ff942a0ac06f">&#9670;&nbsp;</a></span>setLinearizedPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::setLinearizedPosition </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>X_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the value of the intermediate position vector used in evaluating the linearized problem. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBImplicitStrategy.html#a9663a3a6df22d1eb035b9e2f7de74d6b">IBAMR::IBImplicitStrategy</a>.</p>

</div>
</div>
<a id="a1328e672e674e0b47aaf74bcb8d5b4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1328e672e674e0b47aaf74bcb8d5b4fb">&#9670;&nbsp;</a></span>computeResidual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::computeResidual </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>R_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the residual on the specified level of the patch hierarchy. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBImplicitStrategy.html#a61d94e4af3817e6330ece0c88b4e115e">IBAMR::IBImplicitStrategy</a>.</p>

</div>
</div>
<a id="a59237a1828785c64c61e96aa4d1c25a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59237a1828785c64c61e96aa4d1c25a3">&#9670;&nbsp;</a></span>computeLinearizedResidual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::computeLinearizedResidual </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>X_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>R_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the linearized residual for the given intermediate position vector. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBImplicitStrategy.html#adda826da2e8413f53040e8cc98ddff09">IBAMR::IBImplicitStrategy</a>.</p>

</div>
</div>
<a id="a1ae42ac41bb6037769f1c14ccb883b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae42ac41bb6037769f1c14ccb883b13">&#9670;&nbsp;</a></span>updateFixedLEOperators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::updateFixedLEOperators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the positions used for the "fixed" interpolation and spreading operators. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#ad14fe8b8584832721a1c0017e5b8443b">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="ab646f9bd552147661a4b1835ad97580e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab646f9bd552147661a4b1835ad97580e">&#9670;&nbsp;</a></span>interpolateLinearizedVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::interpolateLinearizedVelocity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>u_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_synch_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_ghost_fill_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Interpolate the Eulerian velocity to the curvilinear mesh at the specified time within the current time interval for use in evaluating the residual of the linearized problem. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBImplicitStrategy.html#a716769e239bc524b23fed5f2d0b3b0fd">IBAMR::IBImplicitStrategy</a>.</p>

</div>
</div>
<a id="aa343442e57401e2a1c0ac57e66cec2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa343442e57401e2a1c0ac57e66cec2ec">&#9670;&nbsp;</a></span>computeLagrangianForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::computeLagrangianForce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Lagrangian force at the specified time within the current time interval. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBStrategy.html#aec6e7fc096c898aab511e8149940618a">IBAMR::IBStrategy</a>.</p>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1PenaltyIBMethod.html#a7c9c01ca2255c73691c4a49301e8afc9">IBAMR::PenaltyIBMethod</a>.</p>

</div>
</div>
<a id="afb9e4b76abc82cec0212b1121b1c17ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9e4b76abc82cec0212b1121b1c17ea">&#9670;&nbsp;</a></span>computeLinearizedLagrangianForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::computeLinearizedLagrangianForce </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>X_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Lagrangian force of the linearized problem for the specified configuration of the updated position vector. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBImplicitStrategy.html#a7ccd87e28a4347ee3ffaf2aa3771a391">IBAMR::IBImplicitStrategy</a>.</p>

</div>
</div>
<a id="a65e51fc104ae15e3c328ce6b48e3ba5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e51fc104ae15e3c328ce6b48e3ba5c">&#9670;&nbsp;</a></span>constructLagrangianForceJacobian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::constructLagrangianForceJacobian </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatType&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct the linearized Lagrangian force Jacobian. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBImplicitStrategy.html#a634804e6ee8506a2fc025a5f8a76adc2">IBAMR::IBImplicitStrategy</a>.</p>

</div>
</div>
<a id="af51936d064e4a33b0f0afe85fd23266e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51936d064e4a33b0f0afe85fd23266e">&#9670;&nbsp;</a></span>spreadLinearizedForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::spreadLinearizedForce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">IBTK::RobinPhysBdryPatchStrategy</a> *&#160;</td>
          <td class="paramname"><em>f_phys_bdry_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_prolongation_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Spread the Lagrangian force of the linearized problem to the Cartesian grid at the specified time within the current time interval. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBImplicitStrategy.html#a1cffaa80d9abce4f18b68e498266cee8">IBAMR::IBImplicitStrategy</a>.</p>

</div>
</div>
<a id="a5b6ddf55ccafdbb65a299be7f1877c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6ddf55ccafdbb65a299be7f1877c10">&#9670;&nbsp;</a></span>constructInterpOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::constructInterpOp </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> *)&#160;</td>
          <td class="paramname"><em>spread_fnc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>stencil_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>num_dofs_per_proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_index_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct the IB interpolation operator. </p>

<p>Implements <a class="el" href="classIBAMR_1_1IBImplicitStrategy.html#ad79ec7f6a078956a5f605c3786fe9640">IBAMR::IBImplicitStrategy</a>.</p>

</div>
</div>
<a id="ae6eab9245e7bf30e4e314a5df205208d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6eab9245e7bf30e4e314a5df205208d">&#9670;&nbsp;</a></span>hasFluidSources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::hasFluidSources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate whether there are any internal fluid sources/sinks. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#ad4cc6d3e4a980f86e3cab783e86c5521">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="ada68cd9beb9dc40be863e9fd0e0cd2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada68cd9beb9dc40be863e9fd0e0cd2de">&#9670;&nbsp;</a></span>computeLagrangianFluidSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::computeLagrangianFluidSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Lagrangian source/sink density at the specified time within the current time interval. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a945b2b9c0014ea3a231644dcae4cf80e">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a7a96686b499037844057eae92af8777b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a96686b499037844057eae92af8777b">&#9670;&nbsp;</a></span>spreadFluidSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::spreadFluidSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">IBTK::RobinPhysBdryPatchStrategy</a> *&#160;</td>
          <td class="paramname"><em>q_phys_bdry_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_prolongation_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Spread the Lagrangian source/sink density to the Cartesian grid at the specified time within the current time interval. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#ae9105414b159821a57fd09469de45c97">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a1b72875d25a3ab6dc51eaa8044d95d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b72875d25a3ab6dc51eaa8044d95d16">&#9670;&nbsp;</a></span>interpolatePressure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::interpolatePressure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_synch_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_ghost_fill_scheds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the pressures at the positions of any distributed internal fluid sources or sinks. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#ac269b2985aa6a7c55c5ff015c5e337eb">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="afca342dbf9b3629c719befd3bfc5254d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca342dbf9b3629c719befd3bfc5254d">&#9670;&nbsp;</a></span>postprocessData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::postprocessData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute user-defined post-processing operations. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#aedb319577288b037592afe728e29258e">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a2b6847ad81e8d1f24acab882f950c9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6847ad81e8d1f24acab882f950c9a6">&#9670;&nbsp;</a></span>registerLoadBalancer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::registerLoadBalancer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalancer.html">SAMRAI::mesh::LoadBalancer</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>load_balancer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>workload_data_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a load balancer and work load patch data index with the IB strategy object.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>This method is no longer necessary with the current workload estimation scheme. </dd></dl>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a41e996bc402231206232370c2e442c64">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a9b7f0c335bdd324bc0e3fed27726d86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7f0c335bdd324bc0e3fed27726d86b">&#9670;&nbsp;</a></span>addWorkloadEstimate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::addWorkloadEstimate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>workload_data_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add the estimated computational work from the current object per cell into the specified <code>workload_data_idx</code>. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a7b56cdde81a82aa9e274f6787c16168a">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="a3b0c10bde7af722101eaddf2ddec048c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0c10bde7af722101eaddf2ddec048c">&#9670;&nbsp;</a></span>beginDataRedistribution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::beginDataRedistribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>gridding_alg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin redistributing Lagrangian data prior to regridding the patch hierarchy. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#ab642751b30ab47992895a22e026ba672">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="ad96c753f9daa372e9c019dab155bb5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96c753f9daa372e9c019dab155bb5d5">&#9670;&nbsp;</a></span>endDataRedistribution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::endDataRedistribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>gridding_alg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Complete redistributing Lagrangian data following regridding the patch hierarchy. </p>

<p>Reimplemented from <a class="el" href="classIBAMR_1_1IBStrategy.html#a1de1731a81d3204c0caf301e0a5f2736">IBAMR::IBStrategy</a>.</p>

</div>
</div>
<a id="af8f31cfe38a0690a629fcbeb7ad89888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f31cfe38a0690a629fcbeb7ad89888">&#9670;&nbsp;</a></span>initializeLevelData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::initializeLevelData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>init_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>can_be_refined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>old_level</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt;DIM&gt;&#160;&gt;(NULL)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allocate_data</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize data on a new level after it is inserted into an AMR patch hierarchy by the gridding algorithm. The level number indicates that of the new level.</p>
<p>Generally, when data is set, it is interpolated from coarser levels in the hierarchy. If the old level pointer in the argument list is non-null, then data is copied from the old level to the new level on regions of intersection between those levels before interpolation occurs. In this case, the level number must match that of the old level. The specific operations that occur when initializing level data are determined by the particular solution methods in use; i.e., in the subclass of this abstract base class.</p>
<p>The boolean argument initial_time indicates whether the level is being introduced for the first time (i.e., at initialization time), or after some regrid process during the calculation beyond the initial hierarchy construction. This information is provided since the initialization of the data may be different in each of those circumstances. The can_be_refined boolean argument indicates whether the level is the finest allowable level in the hierarchy. </p>

</div>
</div>
<a id="a3b69e4d26cad00fd5bed5a5f76120c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b69e4d26cad00fd5bed5a5f76120c95">&#9670;&nbsp;</a></span>resetHierarchyConfiguration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::resetHierarchyConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset cached hierarchy dependent data.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a6f8d89482d4bdafc824307cc21c728c9">SAMRAI::mesh::StandardTagAndInitStrategy::resetHierarchyConfiguration</a> </dd></dl>

</div>
</div>
<a id="a6f8d89482d4bdafc824307cc21c728c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8d89482d4bdafc824307cc21c728c9">&#9670;&nbsp;</a></span>resetHierarchyConfiguration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::resetHierarchyConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After hierarchy levels have changed and data has been initialized on the new levels, this routine can be used to reset any information needed by the solution method that is particular to the hierarchy configuration. For example, the solution procedure may cache communication schedules to amortize the cost of data movement on the AMR patch hierarchy. This function will be called by the gridding algorithm after the initialization occurs so that the algorithm-specific subclass can reset such things. Also, if the solution method must make the solution consistent across multiple levels after the hierarchy is changed, this process may be invoked by this routine. Of course the details of these processes are determined by the particular solution methods in use.</p>
<p>The level number arguments indicate the coarsest and finest levels in the current hierarchy configuration that have changed. It should be assumed that all intermediate levels have changed as well. </p>

</div>
</div>
<a id="a3b00b4f8b8e6e01f2418aa18daab496d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b00b4f8b8e6e01f2418aa18daab496d">&#9670;&nbsp;</a></span>applyGradientDetector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::applyGradientDetector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>uses_richardson_extrapolation_too</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set integer tags to "one" in cells where refinement of the given level should occur according to user-supplied feature detection criteria.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#ac201b9cd28087aa92f9c1370f147667a">SAMRAI::mesh::StandardTagAndInitStrategy::applyGradientDetector</a> </dd></dl>

</div>
</div>
<a id="ac201b9cd28087aa92f9c1370f147667a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac201b9cd28087aa92f9c1370f147667a">&#9670;&nbsp;</a></span>applyGradientDetector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::applyGradientDetector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>uses_richardson_extrapolation_too</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set integer tags to "one" in cells where refinement of the given level should occur according to some user-supplied gradient criteria. The double time argument is the regrid time. The integer "tag_index" argument is the patch descriptor index of the cell-centered integer tag array on each patch in the hierarchy. The boolean argument initial_time indicates whether the level is being subject to refinement at the initial simulation time. If it is false, then the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. Typically, this information is passed to the user's patch tagging routines since the error estimator or gradient detector may be different in each case.</p>
<p>The boolean uses_richardson_extrapolation_too is true when Richardson extrapolation error estimation is used in addition to the gradient detector, and false otherwise. This argument helps the user to manage multiple regridding criteria.</p>
<p>This routine is only when gradient detector is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="a42927ec87683f4481357b5f368091410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42927ec87683f4481357b5f368091410">&#9670;&nbsp;</a></span>convertTimeEnumToDouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBAMR::IBMethod::convertTimeEnumToDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782">IBTK::TimePoint</a>&#160;</td>
          <td class="paramname"><em>time_pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If TimePoint is not one of CURRENT_TIME, HALF_TIME, or NEW_TIME, this returns NaN. </p>

</div>
</div>
<a id="a12ca96393cb896e977dc664c2989f4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ca96393cb896e977dc664c2989f4b4">&#9670;&nbsp;</a></span>getPositionData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::getPositionData </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **&#160;</td>
          <td class="paramname"><em>X_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> **&#160;</td>
          <td class="paramname"><em>X_needs_ghost_fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782">IBTK::TimePoint</a>&#160;</td>
          <td class="paramname"><em>time_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The time point should be one of CURRENT_TIME, HALF_TIME, or NEW_TIME. If this condition is met, X_data is set to the data at that respective time, otherwise the X_data pointers are unchanged. </p>

</div>
</div>
<a id="a3918e04a644d5672f1e625e5975af6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3918e04a644d5672f1e625e5975af6a3">&#9670;&nbsp;</a></span>getPositionData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::getPositionData </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **&#160;</td>
          <td class="paramname"><em>X_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> **&#160;</td>
          <td class="paramname"><em>X_needs_ghost_fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the current structure position data.</p>
<p>data_time must be equal to one of current time, new time, or half time. If this condition is met, X_data is set to the data at that respective time, otherwise the X_data pointers are unchanged. </p>

</div>
</div>
<a id="a6f20794e7326fbc271f21eb66b42901c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f20794e7326fbc271f21eb66b42901c">&#9670;&nbsp;</a></span>getVelocityData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::getVelocityData </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **&#160;</td>
          <td class="paramname"><em>U_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782">IBTK::TimePoint</a>&#160;</td>
          <td class="paramname"><em>time_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The time point should be one of CURRENT_TIME, HALF_TIME, or NEW_TIME. If this condition is met, U_data is set to the data at that respective time, otherwise the U_data pointers are unchanged. </p>

</div>
</div>
<a id="a35ad74f359990098f827396f7509b381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ad74f359990098f827396f7509b381">&#9670;&nbsp;</a></span>getVelocityData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::getVelocityData </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **&#160;</td>
          <td class="paramname"><em>U_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the current structure velocity data.</p>
<p>data_time must be equal to one of current time, new time, or half time. If this condition is met, U_data is set to the data at that respective time, otherwise the U_data pointers are unchanged. </p>

</div>
</div>
<a id="a345d082bf603a689eab8c1988a283713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345d082bf603a689eab8c1988a283713">&#9670;&nbsp;</a></span>getForceData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::getForceData </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **&#160;</td>
          <td class="paramname"><em>F_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> **&#160;</td>
          <td class="paramname"><em>F_needs_ghost_fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782">IBTK::TimePoint</a>&#160;</td>
          <td class="paramname"><em>time_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The time point should be one of CURRENT_TIME, HALF_TIME, or NEW_TIME. If this condition is met, F_data is set to the data at that respective time, otherwise the F_data pointers are unchanged. </p>

</div>
</div>
<a id="ab4443dbb8b862b96dcaef6714bfb109d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4443dbb8b862b96dcaef6714bfb109d">&#9670;&nbsp;</a></span>getForceData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::getForceData </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **&#160;</td>
          <td class="paramname"><em>F_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> **&#160;</td>
          <td class="paramname"><em>F_needs_ghost_fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the current structure force data.</p>
<p>data_time must be equal to one of current time, new time, or half time. If this condition is met, F_data is set to the data at that respective time, otherwise the F_data pointers are unchanged. </p>

</div>
</div>
<a id="ac9e1d3f8856193b21e28b1367167e5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e1d3f8856193b21e28b1367167e5e1">&#9670;&nbsp;</a></span>getLinearizedPositionData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::getLinearizedPositionData </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **&#160;</td>
          <td class="paramname"><em>X_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> **&#160;</td>
          <td class="paramname"><em>X_needs_ghost_fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the linearized structure position data.</p>
<p>If the linearized position data does not exist, it will be created. </p>

</div>
</div>
<a id="a20f7a43f3bc6e5f3390c186cda124517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f7a43f3bc6e5f3390c186cda124517">&#9670;&nbsp;</a></span>getLECouplingPositionData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::getLECouplingPositionData </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **&#160;</td>
          <td class="paramname"><em>X_LE_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> **&#160;</td>
          <td class="paramname"><em>X_LE_needs_ghost_fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the current interpolation/spreading position data.</p>
<p>data_time must be equal to one of current time, new time, or half time. If this condition is met, X_LE_data is set to the data at that respective time, otherwise the X_LE_data is unchanged.</p>
<p>If this class is not set up to use fixed coupling, this returns data from <a class="el" href="classIBAMR_1_1IBMethod.html#a12ca96393cb896e977dc664c2989f4b4" title="Get the structure position data at the specified time point.">getPositionData()</a>. </p>

</div>
</div>
<a id="ad12cc945fbdf9ea50858331d2b17b69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12cc945fbdf9ea50858331d2b17b69d">&#9670;&nbsp;</a></span>getLinearizedVelocityData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::getLinearizedVelocityData </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **&#160;</td>
          <td class="paramname"><em>U_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the linearized structure velocity data.</p>
<p>If the linearized velocity data does not exist, it will be created. </p>

</div>
</div>
<a id="aa5e716f66635dcd1ea30e511be0b19a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e716f66635dcd1ea30e511be0b19a0">&#9670;&nbsp;</a></span>getLinearizedForceData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::getLinearizedForceData </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; **&#160;</td>
          <td class="paramname"><em>F_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> **&#160;</td>
          <td class="paramname"><em>F_needs_ghost_fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the linearized structure force data.</p>
<p>If the linearized force data does not exist, it will be created. </p>

</div>
</div>
<a id="ab050ce36e0f3284b508e02d702ccf5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab050ce36e0f3284b508e02d702ccf5fd">&#9670;&nbsp;</a></span>reinitMidpointData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::reinitMidpointData </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>current_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>half_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Interpolate the current and new data to obtain values at the midpoint of the time interval. </p>

</div>
</div>
<a id="a938a071fc48d5f7b32bf8f6bd4d4964d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938a071fc48d5f7b32bf8f6bd4d4964d">&#9670;&nbsp;</a></span>resetAnchorPointValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::resetAnchorPointValues </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>U_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the elements of the Lagrangian vector to zero at anchored nodes of the curvilinear mesh. </p>

</div>
</div>
<a id="a07ac2b2fa9561baca4035351e5cca9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ac2b2fa9561baca4035351e5cca9ce">&#9670;&nbsp;</a></span>computeForce_SAMRAI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PetscErrorCode IBAMR::IBMethod::computeForce_SAMRAI </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aee47a6927c31d46519bb27d05a3d2395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee47a6927c31d46519bb27d05a3d2395">&#9670;&nbsp;</a></span>computeForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode IBAMR::IBMethod::computeForce </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42eb6888698ddc9f9849442db5e1d3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42eb6888698ddc9f9849442db5e1d3c1">&#9670;&nbsp;</a></span>resetLagrangianForceFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::resetLagrangianForceFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>init_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the Lagrangian force function object. </p>

</div>
</div>
<a id="a8e0738d342e5b730624f143d60842ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0738d342e5b730624f143d60842ef3">&#9670;&nbsp;</a></span>resetLagrangianSourceFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::resetLagrangianSourceFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>init_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the Lagrangian source function object. </p>

</div>
</div>
<a id="afaae6c3ceada7bdca69d9429efc454cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaae6c3ceada7bdca69d9429efc454cd">&#9670;&nbsp;</a></span>updateIBInstrumentationData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBMethod::updateIBInstrumentationData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>timestep_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the flow rates and pressures in the internal flow meters and pressure gauges. </p>

</div>
</div>
<a id="ab98445ef8b9ff1d190847323663f6a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98445ef8b9ff1d190847323663f6a27">&#9670;&nbsp;</a></span>registerIBHierarchyIntegrator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBStrategy::registerIBHierarchyIntegrator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html">IBHierarchyIntegrator</a> *&#160;</td>
          <td class="paramname"><em>ib_solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register the <a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html" title="Class IBHierarchyIntegrator provides an abstract interface for a time integrator for various versions...">IBHierarchyIntegrator</a> object that is using this strategy class. </p>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1IBLevelSetMethod.html#ac365e72120a0f957b5765dd3fa7942cc">IBAMR::IBLevelSetMethod</a>, and <a class="el" href="classIBAMR_1_1IBStrategySet.html#a28e2cbe4047d5c35c2e16f994e75015e">IBAMR::IBStrategySet</a>.</p>

</div>
</div>
<a id="a548e6766815734ca76353d18d781db92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548e6766815734ca76353d18d781db92">&#9670;&nbsp;</a></span>getMaxPointDisplacement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> IBAMR::IBStrategy::getMaxPointDisplacement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the ratio of the maximum point displacement of all the structures owned by the current class to the cell width of the grid level on which the structure is assigned. This value is useful for determining if the Eulerian patch hierarchy needs to be regridded.</p>
<dl class="section note"><dt>Note</dt><dd>The process of regridding is distinct, for some <a class="el" href="classIBAMR_1_1IBStrategy.html" title="Class IBStrategy provides a generic interface for specifying the implementation details of a particul...">IBStrategy</a> objects (like <a class="el" href="classIBAMR_1_1IBFEMethod.html" title="Class IBFEMethod is an implementation of the abstract base class IBStrategy that provides functionali...">IBFEMethod</a>), from forming (or reforming) the association between Lagrangian structures and patches. In particular, this function computes the distance between the current position of the structure and the structure at the point of the last regrid, which may not be the same point at which we last rebuilt the structure-to-patch mappings. The reassociation check should be implemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#a7a59b6d2461047316363e77b7315cf64" title="Method to clean up data following call(s) to integrateHierarchy().">postprocessIntegrateData()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1IBFEMethod.html#a69e2f33d8a990ca6435ac8320e774c35">IBAMR::IBFEMethod</a>, and <a class="el" href="classIBAMR_1_1IBStrategySet.html#afb40705e336ec7a3ba1676eb2aa5d60f">IBAMR::IBStrategySet</a>.</p>

</div>
</div>
<a id="a7c0bace52c4d76fd7fe2ca073734a50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0bace52c4d76fd7fe2ca073734a50d">&#9670;&nbsp;</a></span>setUseFixedLEOperators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBStrategy::setUseFixedLEOperators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_fixed_coupling_ops</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate whether "fixed" interpolation and spreading operators should be used during Lagrangian-Eulerian interaction. </p>

</div>
</div>
<a id="a3df419c05fac15f60839ac01aa2ab197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df419c05fac15f60839ac01aa2ab197">&#9670;&nbsp;</a></span>setUseMultistepTimeStepping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBStrategy::setUseMultistepTimeStepping </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_previous_steps</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate that multistep time stepping will be used.</p>
<p>A default implementation is provided that emits an unrecoverable exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_previous_steps</td><td>Number of previous solution values that can be used by the multistep scheme. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1IBFEMethod.html#ae406c44c5285a9935aa064a77062b729">IBAMR::IBFEMethod</a>.</p>

</div>
</div>
<a id="abbe374a56735ab5730f6e6dcbb26de6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe374a56735ab5730f6e6dcbb26de6d">&#9670;&nbsp;</a></span>AB2Step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBStrategy::AB2Step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance the positions of the Lagrangian structure using the standard 2nd-order Adams-Bashforth rule.</p>
<p>A default implementation is provided that emits an unrecoverable exception. </p>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1IBFEMethod.html#abcab93d9b8db4efb7b959a19f82f0c79">IBAMR::IBFEMethod</a>.</p>

</div>
</div>
<a id="abc6165a233879d675b6782790e6f4c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6165a233879d675b6782790e6f4c05">&#9670;&nbsp;</a></span>postprocessSolveFluidEquations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::IBStrategy::postprocessSolveFluidEquations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cycle_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute user-defined routines just after solving the fluid equations.</p>
<p>An empty default implementation is provided. </p>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1IBLevelSetMethod.html#ad6e520e94837ec3797d52cf8fd733538">IBAMR::IBLevelSetMethod</a>, <a class="el" href="classIBAMR_1_1IBStrategySet.html#af1641359e25e824ee4bbe52f8c867137">IBAMR::IBStrategySet</a>, and <a class="el" href="classIBAMR_1_1ConstraintIBMethod.html#a58058ffecfee54b5b0acf694c58f6082">IBAMR::ConstraintIBMethod</a>.</p>

</div>
</div>
<a id="aaf8528c130bfe5261e668c29e79d70f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8528c130bfe5261e668c29e79d70f8">&#9670;&nbsp;</a></span>getINSHierarchyIntegrator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBAMR_1_1INSHierarchyIntegrator.html">INSHierarchyIntegrator</a>* IBAMR::IBStrategy::getINSHierarchyIntegrator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the <a class="el" href="classIBAMR_1_1INSHierarchyIntegrator.html" title="Class INSHierarchyIntegrator provides an abstract interface for a time integrator for the incompressi...">INSHierarchyIntegrator</a> object being used with the <a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html" title="Class IBHierarchyIntegrator provides an abstract interface for a time integrator for various versions...">IBHierarchyIntegrator</a> class registered with this <a class="el" href="classIBAMR_1_1IBStrategy.html" title="Class IBStrategy provides a generic interface for specifying the implementation details of a particul...">IBStrategy</a> object. </p>

</div>
</div>
<a id="ad93b6eb627f166c20aaae098ccd50865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93b6eb627f166c20aaae098ccd50865">&#9670;&nbsp;</a></span>getVelocityHierarchyDataOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsReal.html">SAMRAI::math::HierarchyDataOpsReal</a>&lt;NDIM, <a class="el" href="classdouble.html">double</a>&gt; &gt; IBAMR::IBStrategy::getVelocityHierarchyDataOps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the HierarchyDataOpsReal object associated with velocity-like variables. </p>

</div>
</div>
<a id="a142514561f6e1ad3fc61751baafd1627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142514561f6e1ad3fc61751baafd1627">&#9670;&nbsp;</a></span>getPressureHierarchyDataOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsReal.html">SAMRAI::math::HierarchyDataOpsReal</a>&lt;NDIM, <a class="el" href="classdouble.html">double</a>&gt; &gt; IBAMR::IBStrategy::getPressureHierarchyDataOps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the HierarchyDataOpsReal object associated with pressure-like variables. </p>

</div>
</div>
<a id="ad4042917a2e54b8829948cb09f10e793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4042917a2e54b8829948cb09f10e793">&#9670;&nbsp;</a></span>getHierarchyMathOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1HierarchyMathOps.html">IBTK::HierarchyMathOps</a>&gt; IBAMR::IBStrategy::getHierarchyMathOps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to a HierarchyMathOps object. </p>

</div>
</div>
<a id="acb81b46bc281abe474cfad82551e176b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb81b46bc281abe474cfad82551e176b">&#9670;&nbsp;</a></span>registerVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBStrategy::registerVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>current_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>new_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>scratch_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_ghosts</em> = <code><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt;&#160;NDIM&#160;&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>coarsen_name</em> = <code>&quot;NO_COARSEN&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>refine_name</em> = <code>&quot;NO_REFINE&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1CartGridFunction.html">IBTK::CartGridFunction</a> &gt;&#160;</td>
          <td class="paramname"><em>init_fcn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>register_for_restart</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a state variable with the integrator. When a refine operator is specified, the data for the variable are automatically maintained as the patch hierarchy evolves.</p>
<p>All state variables are registered with three contexts: current, new, and scratch. The current context of a state variable is maintained from time step to time step and, if the necessary coarsen and refine operators are specified, as the patch hierarchy evolves. </p>

</div>
</div>
<a id="aade8a368e03183d51d470c8d98c3c742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade8a368e03183d51d470c8d98c3c742">&#9670;&nbsp;</a></span>registerVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBStrategy::registerVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghosts</em> = <code><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt;&#160;NDIM&#160;&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">SAMRAI::hier::VariableContext</a> &gt;&#160;</td>
          <td class="paramname"><em>ctx</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">SAMRAI::hier::VariableContext</a>&#160;&gt;(nullptr)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>register_for_restart</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a variable with the integrator that may not be maintained from time step to time step.</p>
<p>By default, variables are registered with the scratch context, which is deallocated after each time step. </p>

</div>
</div>
<a id="a6ff41aa031a85b31866aa1bd7c832cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff41aa031a85b31866aa1bd7c832cb9">&#9670;&nbsp;</a></span>registerGhostfillRefineAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBStrategy::registerGhostfillRefineAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>ghostfill_alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>ghostfill_patch_strategy</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a ghost cell-filling refine algorithm. </p>

</div>
</div>
<a id="a765846726a9e33a0b31e0549b699515f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765846726a9e33a0b31e0549b699515f">&#9670;&nbsp;</a></span>registerProlongRefineAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBStrategy::registerProlongRefineAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>prolong_alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>prolong_patch_strategy</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a data-prolonging refine algorithm. </p>

</div>
</div>
<a id="a4217ccceea177b4109b528a85c383a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4217ccceea177b4109b528a85c383a2b">&#9670;&nbsp;</a></span>registerCoarsenAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::IBStrategy::registerCoarsenAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html">SAMRAI::xfer::CoarsenAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>coarsen_alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html">SAMRAI::xfer::CoarsenPatchStrategy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>coarsen_patch_strategy</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a coarsen algorithm. </p>

</div>
</div>
<a id="a08b456e15f5214d3bfe529372ad346c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b456e15f5214d3bfe529372ad346c6">&#9670;&nbsp;</a></span>getGhostfillRefineAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt;NDIM&gt; &gt; IBAMR::IBStrategy::getGhostfillRefineAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get ghost cell-filling refine algorithm. </p>

</div>
</div>
<a id="aac1cd6f821e6a0e6a82c2a91577fa331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1cd6f821e6a0e6a82c2a91577fa331">&#9670;&nbsp;</a></span>getProlongRefineAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt;NDIM&gt; &gt; IBAMR::IBStrategy::getProlongRefineAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get data-prolonging refine algorithm. </p>

</div>
</div>
<a id="a1ed62275cf737a96421674efa382cde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed62275cf737a96421674efa382cde2">&#9670;&nbsp;</a></span>getCoarsenAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html">SAMRAI::xfer::CoarsenAlgorithm</a>&lt;NDIM&gt; &gt; IBAMR::IBStrategy::getCoarsenAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get coarsen algorithm. </p>

</div>
</div>
<a id="ac9ca1b192c934db6db9cc266ff5fc1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ca1b192c934db6db9cc266ff5fc1f0">&#9670;&nbsp;</a></span>getGhostfillRefineSchedules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;NDIM&gt; &gt; &gt;&amp; IBAMR::IBStrategy::getGhostfillRefineSchedules </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get ghost cell-filling refine schedules. </p>

</div>
</div>
<a id="ac4567af6f8f85c8fc935e3cf90933710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4567af6f8f85c8fc935e3cf90933710">&#9670;&nbsp;</a></span>getProlongRefineSchedules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;NDIM&gt; &gt; &gt;&amp; IBAMR::IBStrategy::getProlongRefineSchedules </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get data-prolonging refine schedules.</p>
<dl class="section note"><dt>Note</dt><dd>These schedules are allocated only for level numbers &gt;= 1. </dd></dl>

</div>
</div>
<a id="aff556dcdcf10f9a7b04d8aae07dd7b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff556dcdcf10f9a7b04d8aae07dd7b6d">&#9670;&nbsp;</a></span>getCoarsenSchedules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt;NDIM&gt; &gt; &gt;&amp; IBAMR::IBStrategy::getCoarsenSchedules </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get coarsen schedules.</p>
<dl class="section note"><dt>Note</dt><dd>These schedules are allocated only for level numbers &gt;= 1. </dd></dl>

</div>
</div>
<a id="a5263bfe8622e41d1a2df35f9803a5ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5263bfe8622e41d1a2df35f9803a5ca1">&#9670;&nbsp;</a></span>getLevelDt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::getLevelDt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dt_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine time increment to advance data on level. The recompute_dt option specifies whether to compute the timestep using the current level data or to return the value stored by the time integrator. The default true setting means the timestep will be computed if no value is supplied. <br  />
</p>
<p>This routine is only when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="a9e4e8a35a6b5ab6ec7e14f040e718adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4e8a35a6b5ab6ec7e14f040e718adf">&#9670;&nbsp;</a></span>advanceLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::advanceLevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>first_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>last_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>regrid_advance</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance data on all patches on specified patch level from current time (current_time) to new time (new_time). This routine is called only during time-dependent regridding procedures, such as Richardson extrapolation. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. The boolean arguments are used to determine the state of the algorithm and the data when the advance routine is called. Note that this advance function is also used during normal time integration steps.</p>
<p>When this function is called, the level data required to begin the advance must be allocated and be defined appropriately. Typically, this is equivalent to what is needed to initialize a new level after regridding. Upon exiting this routine, both current and new data may exist on the level. This data is needed until level synchronization occurs, in general. Current and new data may be reset by calling the member function <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a97641642baa1b5c67749fada52b12341">resetTimeDependentData()</a>.</p>
<p>This routine is called from two different points within the Richardson exptrapolation process: to advance a temporary level that is coarser than the hierarchy level on which error estimation is performed, and to advance the hierarchy level itself. In the first case, the values of the boolean flags are:</p>
<ul>
<li><b>first_step</b> = true.</li>
<li><b>last_step</b> = true.</li>
<li><b>regrid_advance</b> = true.</li>
</ul>
<p>In the second case, the values of the boolean flags are:</p>
<ul>
<li><b>first_step</b> (when regridding during time integration sequence) = true when the level is not coarsest level to synchronize immediately before the regridding process; else, false. (when generating initial hierarchy construction) = true, even though there may be multiple advance steps.</li>
<li><b>last_step</b> = true when the advance is the last in the Richardson extrapolation step sequence; else false.</li>
<li><b>regrid_advance</b> = true. </li>
</ul>

</div>
</div>
<a id="a97641642baa1b5c67749fada52b12341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97641642baa1b5c67749fada52b12341">&#9670;&nbsp;</a></span>resetTimeDependentData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::resetTimeDependentData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>can_be_refined</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset time-dependent data storage for the specified patch level.</p>
<p>This routine only applies when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="af6f563618437d3a5231d35eb6937fcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f563618437d3a5231d35eb6937fcd1">&#9670;&nbsp;</a></span>resetDataToPreadvanceState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::resetDataToPreadvanceState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset data on the patch level by destroying all patch data other than that which is needed to initialize the solution on that level. In other words, this is the data needed to begin a time integration step on the level.</p>
<p>This routine is only when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="a81e5b7b5d98eaf7221b5088b0d12a2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e5b7b5d98eaf7221b5088b0d12a2a8">&#9670;&nbsp;</a></span>applyRichardsonExtrapolation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::applyRichardsonExtrapolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>deltat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>error_coarsen_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>uses_gradient_detector_too</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set integer tags to "one" in cells where refinement of the given level should occur according to some user-supplied Richardson extrapolation criteria. The "error_data_time" argument is the regrid time. The "deltat" argument is the time increment to advance the solution on the level to be refined. Note that that level is finer than the level in the argument list, in general. The ratio between the argument level and the actual hierarchy level is given by the integer "coarsen ratio".</p>
<p>The integer "tag_index" argument is the patch descriptor index of the cell-centered integer tag array on each patch in the hierarchy.</p>
<p>The boolean argument initial_time indicates whether the level is being subject to refinement at the initial simulation time. If it is false, then the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. Typically, this information is passed to the user's patch tagging routines since the application of the Richardson extrapolation process may be different in each case.</p>
<p>The boolean uses_gradient_detector_too is true when a gradient detector procedure is used in addition to Richardson extrapolation, and false otherwise. This argument helps the user to manage multiple regridding criteria.</p>
<p>This routine is only when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="a9e3ec75cca71a27c6599a48ac6cd37ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3ec75cca71a27c6599a48ac6cd37ea">&#9670;&nbsp;</a></span>coarsenDataForRichardsonExtrapolation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::coarsenDataForRichardsonExtrapolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>coarsen_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>before_advance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen solution data from level to coarse_level for Richardson extrapolation. Note that this routine will be called twice during the Richardson extrapolation error estimation process, once to set data on the coarser level and once to coarsen data from after advancing the fine level. The init_coarse_level boolean argument indicates whether data is set on the coarse level by coarsening the "old" time level solution or by coarsening the "new" solution on the fine level (i.e., after it has been advanced).</p>
<p>This routine is only when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="aac28b98c635db5889693d71f67456cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac28b98c635db5889693d71f67456cd8">&#9670;&nbsp;</a></span>getNumberOfRigidStructures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> IBAMR::CIBStrategy::getNumberOfRigidStructures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fc7a6bedd44f4cd0a06df8af06461a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc7a6bedd44f4cd0a06df8af06461a1">&#9670;&nbsp;</a></span>setInitialCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::setInitialCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>XCOM_0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The rigid body for which we are setting the initial center of mass position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c84ef0df606bb8dad89923392de5491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c84ef0df606bb8dad89923392de5491">&#9670;&nbsp;</a></span>setSolveRigidBodyVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::setSolveRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#ad17100e3633baaf42d5aae6933b8e5db">IBTK::FreeRigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>solve_rigid_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The rigid body for which we are setting the free DOFs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8cacbaae5916c93077d50b1c1a36f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cacbaae5916c93077d50b1c1a36f69">&#9670;&nbsp;</a></span>getSolveRigidBodyVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceIBTK.html#ad17100e3633baaf42d5aae6933b8e5db">IBTK::FreeRigidDOFVector</a>&amp; IBAMR::CIBStrategy::getSolveRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>num_free_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08097027463a8986efc35a294ab10f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08097027463a8986efc35a294ab10f4d">&#9670;&nbsp;</a></span>setRigidBodyVelocity() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::setRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The rigid part for which velocity needs to be set.</td></tr>
    <tr><td class="paramname">U</td><td>Vec contains the rigid component of velocities. For two-dimensions the vector contains the values \([u,v,\omega_z]\) and for three-dimensions the vector values are \([u,v,w,\omega_x,\omega_y,\omega_z]\). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed839bba3c6ae73fe3ceaa6ee548a0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed839bba3c6ae73fe3ceaa6ee548a0a6">&#9670;&nbsp;</a></span>setRigidBodyVelocity() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::setRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>only_free_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>only_imposed_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>all_dofs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>Vec that contains the rigid component of velocities for the required components. For two-dimensions each sub Vec contains the values \([u,v,\omega_z]\) and for three-dimensions the vector values are \([u,v,w,\omega_x,\omega_y,\omega_z]\).</td></tr>
    <tr><td class="paramname">only_free_dofs</td><td>Boolean indicating if the rigid body velocity is to be set only for free DOFS for all parts. The corresponding size of U_sub would be \( U_{sub} \leq NDIM * (NDIM + 1) / 2 \).</td></tr>
    <tr><td class="paramname">only_imposed_dofs</td><td>Boolean indicating if the rigid body velocity is to be set only for prescribed kinematics dofs for all parts. The corresponding size of U_sub would be \( U_{sub} \leq NDIM * (NDIM + 1) / 2 \).</td></tr>
    <tr><td class="paramname">all_dofs</td><td>Boolean indicating if the rigid body velocity is to be set for all parts. The corresponding size of U_sub would be \( U_{sub} = NDIM * (NDIM + 1) / 2 \).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>User is responsible for setting correct number of subvecs in U that corresponds to the particular combination of booleans. </dd></dl>

</div>
</div>
<a id="ad6a54517eaec6816edb0e06cffe8f08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a54517eaec6816edb0e06cffe8f08d">&#9670;&nbsp;</a></span>computeNetRigidGeneralizedForce() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::computeNetRigidGeneralizedForce </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The structure index.</td></tr>
    <tr><td class="paramname">L</td><td>The Lagrange multiplier vector.</td></tr>
    <tr><td class="paramname">F</td><td>Vec storing the net generalized force. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1b3429e6b49d50e385af370874acf42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b3429e6b49d50e385af370874acf42">&#9670;&nbsp;</a></span>computeNetRigidGeneralizedForce() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::computeNetRigidGeneralizedForce </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>only_free_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>only_imposed_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>all_dofs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The Lagrange multiplier vector. </td></tr>
    <tr><td class="paramname">F</td><td>Vec storing the net generalized force.</td></tr>
    <tr><td class="paramname">only_free_dofs</td><td>Boolean indicating if the net generalized force and torque is to be computed only for free dofs of all bodies.</td></tr>
    <tr><td class="paramname">only_imposed_dofs</td><td>Boolean indicating if the net generalized force and torque is to be computed for imposed dofs of all bodies.</td></tr>
    <tr><td class="paramname">all_dofs</td><td>Boolean indicating if the net generalized force and torque is to be computed for all dofs of all bodies.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>User is responsible for setting correct number of subvecs in F that corresponds to the particular combination of booleans. </dd></dl>

</div>
</div>
<a id="a446a8e750171ee90f51658e645fc0bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446a8e750171ee90f51658e645fc0bc6">&#9670;&nbsp;</a></span>getNetRigidGeneralizedForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a>&amp; IBAMR::CIBStrategy::getNetRigidGeneralizedForce </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The rigid part. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc476b84ad7a6b45321e48474992f7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc476b84ad7a6b45321e48474992f7ff">&#9670;&nbsp;</a></span>updateFreeDOFsMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::updateFreeDOFsMapping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a46aa12a75eec15beeed92da1a05bf297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46aa12a75eec15beeed92da1a05bf297">&#9670;&nbsp;</a></span>updateNewRigidBodyVelocity() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::updateNewRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaadb163509d0ca86f327fa9e9580b529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaadb163509d0ca86f327fa9e9580b529">&#9670;&nbsp;</a></span>updateNewRigidBodyVelocity() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::updateNewRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a01ba22af2d0b3afde292157273f933ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ba22af2d0b3afde292157273f933ff">&#9670;&nbsp;</a></span>updateNewRigidBodyVelocity() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::updateNewRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>only_free_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>only_imposed_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>all_dofs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a05378698c6caf299c83d5a53e2a16199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05378698c6caf299c83d5a53e2a16199">&#9670;&nbsp;</a></span>copyFreeDOFsVecToArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::copyFreeDOFsVecToArray </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>array_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>PETSc Vec to copy from. The Vec stores only free DOFs of <em>all</em> the structures.</td></tr>
    <tr><td class="paramname">array</td><td>Data pointer to copy to. It is a linear array of maximum free DOFs of the passed structure IDs.</td></tr>
    <tr><td class="paramname">struct_ids</td><td>Vector of structure indices.</td></tr>
    <tr><td class="paramname">array_rank</td><td>Rank of the processor on which the array is located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The size of <em>array</em> is assummed to be sum of maximum number of free degrees of freedom of all the structures given in <em>struct_ids</em>. The caller is responsible for allocating and destroying array memory outside of this routine. </dd></dl>

</div>
</div>
<a id="af93ce15b714d03af6b80ba23dbaa5c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93ce15b714d03af6b80ba23dbaa5c79">&#9670;&nbsp;</a></span>copyFreeDOFsArrayToVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::copyFreeDOFsArrayToVec </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>array_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Copy to PETSc Vec. The Vec stores only free DOFs of <em>all</em> the structures.</td></tr>
    <tr><td class="paramname">array</td><td>Copy from data pointer. It is a linear array of maximum free DOFs of the passed structure IDs.</td></tr>
    <tr><td class="paramname">struct_ids</td><td>Vector of structure indices.</td></tr>
    <tr><td class="paramname">array_rank</td><td>Rank of the processor on which the array is located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The size of <em>array</em> is assummed to be sum of maximum number of free degrees of freedom of all the structures given in <em>struct_ids</em>. The caller is responsible for allocating and destroying array memory outside of this routine. </dd></dl>

</div>
</div>
<a id="a91d5b6beeee95b9e560871e271f0a42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d5b6beeee95b9e560871e271f0a42f">&#9670;&nbsp;</a></span>vecToRDV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IBAMR::CIBStrategy::vecToRDV </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Ur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96c3fa8472562a4d21f30e3a0a0c69c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c3fa8472562a4d21f30e3a0a0c69c7">&#9670;&nbsp;</a></span>rdvToVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IBAMR::CIBStrategy::rdvToVec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Ur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a630d7d9172d5a9284235783f238181cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630d7d9172d5a9284235783f238181cb">&#9670;&nbsp;</a></span>eigenToRDV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IBAMR::CIBStrategy::eigenToRDV </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>UW</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06ced3674edd5d2a7609789473496e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ced3674edd5d2a7609789473496e62">&#9670;&nbsp;</a></span>rdvToEigen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IBAMR::CIBStrategy::rdvToEigen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>UW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e57bb1d7568e9f2e1ba1954c603eb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e57bb1d7568e9f2e1ba1954c603eb35">&#9670;&nbsp;</a></span>getCurrentRigidBodyVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::getCurrentRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5eff8796b3637e0f4731b32762d9154f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eff8796b3637e0f4731b32762d9154f">&#9670;&nbsp;</a></span>getNewRigidBodyVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::getNewRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71594fce589c121dc7cb81f0ae8e8ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71594fce589c121dc7cb81f0ae8e8ef3">&#9670;&nbsp;</a></span>getCurrentBodyCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector3d&amp; IBAMR::CIBStrategy::getCurrentBodyCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a71cf057095365cb0a1bf0cb4ebe486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a71cf057095365cb0a1bf0cb4ebe486">&#9670;&nbsp;</a></span>getNewBodyCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector3d&amp; IBAMR::CIBStrategy::getNewBodyCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a087733d93ea9af2d37c730dbb86f83a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087733d93ea9af2d37c730dbb86f83a2">&#9670;&nbsp;</a></span>setRotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::setRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>rot_vel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Quaterniond &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Quaterniond &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Matrix3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>rot_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_old</td><td>Previous applied quaternion. </td></tr>
    <tr><td class="paramname">q_new</td><td>New quaternion to set. </td></tr>
    <tr><td class="paramname">rot_mat</td><td>Matrix to set. </td></tr>
    <tr><td class="paramname">dt</td><td>Time interval of rotation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9cbe4e99ef963d0f6926e31df2c8b64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbe4e99ef963d0f6926e31df2c8b64c">&#9670;&nbsp;</a></span>d_constrained_velocity_fcns_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structIBAMR_1_1CIBMethod_1_1ConstrainedVelocityFcnsData.html">ConstrainedVelocityFcnsData</a>&gt; IBAMR::CIBMethod::d_constrained_velocity_fcns_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions to set constrained velocities of the structures. </p>

</div>
</div>
<a id="adb461721f468bcec1fb52111622ad6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb461721f468bcec1fb52111622ad6d1">&#9670;&nbsp;</a></span>d_ext_force_torque_fcn_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structIBAMR_1_1CIBMethod_1_1ExternalForceTorqueFcnData.html">ExternalForceTorqueFcnData</a>&gt; IBAMR::CIBMethod::d_ext_force_torque_fcn_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions to set net external force and torque on free moving structures. </p>

</div>
</div>
<a id="ad306212aa46e4dfc5fd955a075fd5dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad306212aa46e4dfc5fd955a075fd5dd2">&#9670;&nbsp;</a></span>d_prefluidsolve_callback_fcns</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classIBAMR_1_1CIBMethod.html#a1d078ef3235314b1f94a2222c8771d1a">preprocessSolveFluidEqn_callbackfcn</a>&gt; IBAMR::CIBMethod::d_prefluidsolve_callback_fcns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pre and post fluid solve call back functions and contexts. </p>

</div>
</div>
<a id="a0e71a4711e1e5e2d95ed9b4440a87dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e71a4711e1e5e2d95ed9b4440a87dbf">&#9670;&nbsp;</a></span>d_prefluidsolve_callback_fcns_ctx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;void*&gt; IBAMR::CIBMethod::d_prefluidsolve_callback_fcns_ctx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af09a94731272c280e2d878265a2831ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09a94731272c280e2d878265a2831ed">&#9670;&nbsp;</a></span>d_constraint_force_is_initialized</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::CIBMethod::d_constraint_force_is_initialized = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Booleans to control spreading constraint force and interpolating to Lagrangian velocities. </p>

</div>
</div>
<a id="a914388092b314af99239bd8fe8856a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914388092b314af99239bd8fe8856a46">&#9670;&nbsp;</a></span>d_lag_velvec_is_initialized</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::CIBMethod::d_lag_velvec_is_initialized = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a73298c80cbc74b93bb604492571b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a73298c80cbc74b93bb604492571b90">&#9670;&nbsp;</a></span>d_time_integrator_needs_regrid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::CIBMethod::d_time_integrator_needs_regrid = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Boolean to flag if time integrator needs regriding </p>

</div>
</div>
<a id="ae3f6f1686ce470277bb23c60374b65a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f6f1686ce470277bb23c60374b65a4">&#9670;&nbsp;</a></span>d_eul_lambda_var</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a>&lt;NDIM&gt; &gt; IBAMR::CIBMethod::d_eul_lambda_var</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Eulerian variables. </p>

</div>
</div>
<a id="a2c521ed6b1ab0def5b8277f21a4f70e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c521ed6b1ab0def5b8277f21a4f70e8">&#9670;&nbsp;</a></span>d_eul_lambda_idx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBAMR::CIBMethod::d_eul_lambda_idx = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a64a79b6524910d500c60613ac3f62a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a79b6524910d500c60613ac3f62a0c">&#9670;&nbsp;</a></span>d_struct_lag_idx_range</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;<a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>&gt; &gt; IBAMR::CIBMethod::d_struct_lag_idx_range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Vector of Lagrnagian indices of all structures. </p>

</div>
</div>
<a id="a99393996ad567270b20808d4730bd0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99393996ad567270b20808d4730bd0e1">&#9670;&nbsp;</a></span>d_visit_writer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">SAMRAI::appu::VisItDataWriter</a>&lt;NDIM&gt; &gt; IBAMR::CIBMethod::d_visit_writer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object used to write out data for postprocessing by the visIt visualization tool. </p>

</div>
</div>
<a id="a1fe02ebc9b0bbea7548fa04254b8e235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe02ebc9b0bbea7548fa04254b8e235">&#9670;&nbsp;</a></span>d_output_eul_lambda</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::CIBMethod::d_output_eul_lambda = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Control printing of S[lambda] </p>

</div>
</div>
<a id="adf6b4224208c1a5004ee6ee56abbceda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6b4224208c1a5004ee6ee56abbceda">&#9670;&nbsp;</a></span>d_lambda_dump_interval</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBAMR::CIBMethod::d_lambda_dump_interval = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Input/output. </p>

</div>
</div>
<a id="a8e51037ad0d37940c2117ccb23376a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e51037ad0d37940c2117ccb23376a7c">&#9670;&nbsp;</a></span>d_lambda_stream</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ofstream IBAMR::CIBMethod::d_lambda_stream</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a968383d92d33bbf95679eaaa324f2035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968383d92d33bbf95679eaaa324f2035">&#9670;&nbsp;</a></span>d_reg_filename</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; IBAMR::CIBMethod::d_reg_filename</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a871fd03018d4e5f5ed90dcaf10e33aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871fd03018d4e5f5ed90dcaf10e33aa3">&#9670;&nbsp;</a></span>d_lambda_filename</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; IBAMR::CIBMethod::d_lambda_filename</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b7881063615a4908e29c2ee7f35d836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7881063615a4908e29c2ee7f35d836">&#9670;&nbsp;</a></span>d_u_phys_bdry_op</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">IBTK::RobinPhysBdryPatchStrategy</a>* IBAMR::CIBMethod::d_u_phys_bdry_op = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28ee663a6ab6e6dc5ac3fc17fafe873c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ee663a6ab6e6dc5ac3fc17fafe873c">&#9670;&nbsp;</a></span>d_use_steady_stokes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::CIBMethod::d_use_steady_stokes = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8bc67cf48dc84f63fce5814763579b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc67cf48dc84f63fce5814763579b50">&#9670;&nbsp;</a></span>d_do_log</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::d_do_log = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08ce274f57f366503ae87f276f9ed5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ce274f57f366503ae87f276f9ed5f3">&#9670;&nbsp;</a></span>d_hierarchy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt;NDIM&gt; &gt; IBAMR::IBMethod::d_hierarchy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a872c7766acc7e81232f849cb326f8304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872c7766acc7e81232f849cb326f8304">&#9670;&nbsp;</a></span>d_gridding_alg</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a>&lt;NDIM&gt; &gt; IBAMR::IBMethod::d_gridding_alg</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bf90f36cd311b91889b70b36a392e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf90f36cd311b91889b70b36a392e22">&#9670;&nbsp;</a></span>d_current_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBAMR::IBMethod::d_current_time = std::numeric_limits&lt;<a class="el" href="classdouble.html">double</a>&gt;::quiet_NaN()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a98af6244554f8697e6ee0872fe4aa784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98af6244554f8697e6ee0872fe4aa784">&#9670;&nbsp;</a></span>d_new_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBAMR::IBMethod::d_new_time = std::numeric_limits&lt;<a class="el" href="classdouble.html">double</a>&gt;::quiet_NaN()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c02e28ae4b1653948405a446c0e8f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c02e28ae4b1653948405a446c0e8f5b">&#9670;&nbsp;</a></span>d_half_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBAMR::IBMethod::d_half_time = std::numeric_limits&lt;<a class="el" href="classdouble.html">double</a>&gt;::quiet_NaN()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c99d72d6be7e5ba7d33f6c05d3347d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c99d72d6be7e5ba7d33f6c05d3347d1">&#9670;&nbsp;</a></span>d_X_current_needs_ghost_fill</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::d_X_current_needs_ghost_fill = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cc8b0d6ea5d4b8531faf8de0f3c731b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc8b0d6ea5d4b8531faf8de0f3c731b">&#9670;&nbsp;</a></span>d_X_new_needs_ghost_fill</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::d_X_new_needs_ghost_fill = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e3baa4573497508cfae392f29ac9208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3baa4573497508cfae392f29ac9208">&#9670;&nbsp;</a></span>d_X_half_needs_ghost_fill</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::d_X_half_needs_ghost_fill = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac48ad3795ef748c8e3c2352da39a1c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48ad3795ef748c8e3c2352da39a1c82">&#9670;&nbsp;</a></span>d_X_jac_needs_ghost_fill</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::d_X_jac_needs_ghost_fill = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b698edb4c59aad594c290041e6a7ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b698edb4c59aad594c290041e6a7ff0">&#9670;&nbsp;</a></span>d_X_LE_new_needs_ghost_fill</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::d_X_LE_new_needs_ghost_fill = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0d5cdecaf50a8d6b40b8141790a0af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d5cdecaf50a8d6b40b8141790a0af7">&#9670;&nbsp;</a></span>d_X_LE_half_needs_ghost_fill</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::d_X_LE_half_needs_ghost_fill = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a356432244fdb99c27fb16951b30b4ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356432244fdb99c27fb16951b30b4ab1">&#9670;&nbsp;</a></span>d_F_current_needs_ghost_fill</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::d_F_current_needs_ghost_fill = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a668a8de1aaf6c3768e5b6e8d93992790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668a8de1aaf6c3768e5b6e8d93992790">&#9670;&nbsp;</a></span>d_F_new_needs_ghost_fill</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::d_F_new_needs_ghost_fill = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c3b2f0689d8125c5309296eee2021bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3b2f0689d8125c5309296eee2021bc">&#9670;&nbsp;</a></span>d_F_half_needs_ghost_fill</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::d_F_half_needs_ghost_fill = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5abc0721b50dabee58a704dba9fbf5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5abc0721b50dabee58a704dba9fbf5cb">&#9670;&nbsp;</a></span>d_F_jac_needs_ghost_fill</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::d_F_jac_needs_ghost_fill = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a514dbf1eb4d147287e0cec73beb9a8ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514dbf1eb4d147287e0cec73beb9a8ad">&#9670;&nbsp;</a></span>d_l_data_manager</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBTK_1_1LDataManager.html">IBTK::LDataManager</a>* IBAMR::IBMethod::d_l_data_manager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa905f8957596594ebeb000b04e21879f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa905f8957596594ebeb000b04e21879f">&#9670;&nbsp;</a></span>d_interp_kernel_fcn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string IBAMR::IBMethod::d_interp_kernel_fcn = &quot;IB_4&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a640371d2efea148cea891f14bcf1ad75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640371d2efea148cea891f14bcf1ad75">&#9670;&nbsp;</a></span>d_spread_kernel_fcn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string IBAMR::IBMethod::d_spread_kernel_fcn = &quot;IB_4&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08b623b7348d129b99c04006060e1afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b623b7348d129b99c04006060e1afc">&#9670;&nbsp;</a></span>d_error_if_points_leave_domain</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::d_error_if_points_leave_domain = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a17d78c0028f20db67ef16fcf481bddfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d78c0028f20db67ef16fcf481bddfa">&#9670;&nbsp;</a></span>d_ghosts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt;NDIM&gt; IBAMR::IBMethod::d_ghosts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66cc326dd6fc84036999dafdf7fa1f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66cc326dd6fc84036999dafdf7fa1f39">&#9670;&nbsp;</a></span>d_X_current_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a>&gt; &gt; IBAMR::IBMethod::d_X_current_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7ac77ae8af8bbcc941c6fc8dd49a8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ac77ae8af8bbcc941c6fc8dd49a8fa">&#9670;&nbsp;</a></span>d_X_new_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a>&gt; &gt; IBAMR::IBMethod::d_X_new_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fca1597f7a8160b4aa36aa8470db03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fca1597f7a8160b4aa36aa8470db03e">&#9670;&nbsp;</a></span>d_X_half_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a>&gt; &gt; IBAMR::IBMethod::d_X_half_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac96c9a51ec7a18b20984945239671381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96c9a51ec7a18b20984945239671381">&#9670;&nbsp;</a></span>d_X_jac_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a>&gt; &gt; IBAMR::IBMethod::d_X_jac_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a15840fae7e4b1c57ba11afed101c492a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15840fae7e4b1c57ba11afed101c492a">&#9670;&nbsp;</a></span>d_X_LE_new_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a>&gt; &gt; IBAMR::IBMethod::d_X_LE_new_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36cfa20dd7f7e7f1984753c82a85f03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36cfa20dd7f7e7f1984753c82a85f03c">&#9670;&nbsp;</a></span>d_X_LE_half_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a>&gt; &gt; IBAMR::IBMethod::d_X_LE_half_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b0c76b1055f8a64b4a3bcf9f5b0d83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0c76b1055f8a64b4a3bcf9f5b0d83f">&#9670;&nbsp;</a></span>d_U_current_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a>&gt; &gt; IBAMR::IBMethod::d_U_current_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c91fce1d50ade7e1ff9b759365e74f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c91fce1d50ade7e1ff9b759365e74f3">&#9670;&nbsp;</a></span>d_U_new_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a>&gt; &gt; IBAMR::IBMethod::d_U_new_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a452bf8b8a95d1d83e1baf2fd651c0201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452bf8b8a95d1d83e1baf2fd651c0201">&#9670;&nbsp;</a></span>d_U_half_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a>&gt; &gt; IBAMR::IBMethod::d_U_half_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e5fc1dfc7a077151f14727b2f50fce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5fc1dfc7a077151f14727b2f50fce3">&#9670;&nbsp;</a></span>d_U_jac_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a>&gt; &gt; IBAMR::IBMethod::d_U_jac_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2d9653c56859e8fa76ec075116672d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d9653c56859e8fa76ec075116672d9">&#9670;&nbsp;</a></span>d_F_current_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a>&gt; &gt; IBAMR::IBMethod::d_F_current_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12883030879a4c0ce1ce9aacc8a16c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12883030879a4c0ce1ce9aacc8a16c40">&#9670;&nbsp;</a></span>d_F_new_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a>&gt; &gt; IBAMR::IBMethod::d_F_new_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af9e202a13cad1b6e6afec095132c0d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e202a13cad1b6e6afec095132c0d64">&#9670;&nbsp;</a></span>d_F_half_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a>&gt; &gt; IBAMR::IBMethod::d_F_half_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e62f69464feb38e55a552bdb53d5a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e62f69464feb38e55a552bdb53d5a7c">&#9670;&nbsp;</a></span>d_F_jac_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LData.html">IBTK::LData</a>&gt; &gt; IBAMR::IBMethod::d_F_jac_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab0a3b36efbe41cd31f52730bd5bfe4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0a3b36efbe41cd31f52730bd5bfe4f">&#9670;&nbsp;</a></span>d_anchor_point_local_idxs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::set&lt;<a class="el" href="classint.html">int</a>&gt; &gt; IBAMR::IBMethod::d_anchor_point_local_idxs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a25e01a1093cfe11a79de7a2f31512382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e01a1093cfe11a79de7a2f31512382">&#9670;&nbsp;</a></span>d_instrument_panel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBAMR_1_1IBInstrumentPanel.html">IBInstrumentPanel</a>&gt; IBAMR::IBMethod::d_instrument_panel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7fa9884482b741d77fe91a48e725b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7fa9884482b741d77fe91a48e725b1f">&#9670;&nbsp;</a></span>d_total_flow_volume</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt; IBAMR::IBMethod::d_total_flow_volume</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adca7735b056018789b33acfb005c3de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca7735b056018789b33acfb005c3de6">&#9670;&nbsp;</a></span>d_l_initializer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LInitStrategy.html">IBTK::LInitStrategy</a>&gt; IBAMR::IBMethod::d_l_initializer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6904aabd6b8a24e164e20affcca5df1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6904aabd6b8a24e164e20affcca5df1a">&#9670;&nbsp;</a></span>d_ib_force_fcn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBAMR_1_1IBLagrangianForceStrategy.html">IBLagrangianForceStrategy</a>&gt; IBAMR::IBMethod::d_ib_force_fcn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aabf794bc472e31c2a374e7b45058a32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf794bc472e31c2a374e7b45058a32c">&#9670;&nbsp;</a></span>d_ib_force_fcn_needs_init</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::d_ib_force_fcn_needs_init = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a419b4b2942b297803ab9d0e38baaf0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419b4b2942b297803ab9d0e38baaf0dd">&#9670;&nbsp;</a></span>d_ib_source_fcn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBAMR_1_1IBLagrangianSourceStrategy.html">IBLagrangianSourceStrategy</a>&gt; IBAMR::IBMethod::d_ib_source_fcn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a75594106f13bab817a3ac98cfa95dde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75594106f13bab817a3ac98cfa95dde2">&#9670;&nbsp;</a></span>d_ib_source_fcn_needs_init</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::d_ib_source_fcn_needs_init = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a436000cf6620d690dd5a60fb928fdffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436000cf6620d690dd5a60fb928fdffc">&#9670;&nbsp;</a></span>d_X_src</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">IBTK::Point</a>&gt; &gt; IBAMR::IBMethod::d_X_src</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b34955740a5005e828a785400618e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b34955740a5005e828a785400618e47">&#9670;&nbsp;</a></span>d_r_src</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; IBAMR::IBMethod::d_r_src</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5586552900b8c3b391589e86b299d7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5586552900b8c3b391589e86b299d7d1">&#9670;&nbsp;</a></span>d_P_src</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; IBAMR::IBMethod::d_P_src</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fe55986c63576722e34cefd8be2a8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe55986c63576722e34cefd8be2a8ff">&#9670;&nbsp;</a></span>d_Q_src</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; IBAMR::IBMethod::d_Q_src</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a422b43c41d5cd5f51c4691f706b41108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422b43c41d5cd5f51c4691f706b41108">&#9670;&nbsp;</a></span>d_n_src</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classint.html">int</a>&gt; IBAMR::IBMethod::d_n_src</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8132da309771001ffc45a6af28ef2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8132da309771001ffc45a6af28ef2a0">&#9670;&nbsp;</a></span>d_normalize_source_strength</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::d_normalize_source_strength = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5bcc833499d359d885e7cff25bc3f901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcc833499d359d885e7cff25bc3f901">&#9670;&nbsp;</a></span>d_post_processor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBAMR_1_1IBMethodPostProcessStrategy.html">IBMethodPostProcessStrategy</a>&gt; IBAMR::IBMethod::d_post_processor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a937e47773c541ed4a05102b9ac01677e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937e47773c541ed4a05102b9ac01677e">&#9670;&nbsp;</a></span>d_silo_writer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LSiloDataWriter.html">IBTK::LSiloDataWriter</a>&gt; IBAMR::IBMethod::d_silo_writer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fb9eb6b06e20729d1fb4fe649fa4da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb9eb6b06e20729d1fb4fe649fa4da5">&#9670;&nbsp;</a></span>d_load_balancer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalancer.html">SAMRAI::mesh::LoadBalancer</a>&lt;NDIM&gt; &gt; IBAMR::IBMethod::d_load_balancer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52e43c73cd8aebc96f3fe80d23ce05e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e43c73cd8aebc96f3fe80d23ce05e2">&#9670;&nbsp;</a></span>d_workload_idx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBAMR::IBMethod::d_workload_idx = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57cc6f54c7e2cf452fad35f87f3451b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cc6f54c7e2cf452fad35f87f3451b0">&#9670;&nbsp;</a></span>d_object_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string IBAMR::IBMethod::d_object_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e5a55bef01451516fa6507b113e875a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5a55bef01451516fa6507b113e875a">&#9670;&nbsp;</a></span>d_registered_for_restart</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::d_registered_for_restart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a73dd1048f57ee5ceb367c1cd725c0c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73dd1048f57ee5ceb367c1cd725c0c20">&#9670;&nbsp;</a></span>d_force_jac_mffd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBMethod::d_force_jac_mffd = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Jacobian data. </p>

</div>
</div>
<a id="a382feb2b531ad4ce8a0312ea043ffe11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382feb2b531ad4ce8a0312ea043ffe11">&#9670;&nbsp;</a></span>d_force_jac</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Mat IBAMR::IBMethod::d_force_jac = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5591836a8557af41e9a2d8027d1f9881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5591836a8557af41e9a2d8027d1f9881">&#9670;&nbsp;</a></span>d_force_jac_data_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBAMR::IBMethod::d_force_jac_data_time</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3b7435788a1ff68e5f6f54496341011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b7435788a1ff68e5f6f54496341011">&#9670;&nbsp;</a></span>d_ib_solver</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html">IBHierarchyIntegrator</a>* IBAMR::IBStrategy::d_ib_solver = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="classIBAMR_1_1IBHierarchyIntegrator.html" title="Class IBHierarchyIntegrator provides an abstract interface for a time integrator for various versions...">IBHierarchyIntegrator</a> object that is using this strategy class. </p>

</div>
</div>
<a id="a56c7fcd98c652f7e3f4b17e0bc59388d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c7fcd98c652f7e3f4b17e0bc59388d">&#9670;&nbsp;</a></span>d_use_fixed_coupling_ops</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::IBStrategy::d_use_fixed_coupling_ops = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to use "fixed" Lagrangian-Eulerian coupling operators. </p>

</div>
</div>
<a id="a78c7b5094d5a3d78ea27f119d13a84cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c7b5094d5a3d78ea27f119d13a84cb">&#9670;&nbsp;</a></span>d_num_rigid_parts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> IBAMR::CIBStrategy::d_num_rigid_parts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9605c08a1475a205eff9afe1aa6a6697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9605c08a1475a205eff9afe1aa6a6697">&#9670;&nbsp;</a></span>d_center_of_mass_initial</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_center_of_mass_initial</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Center of mass. </p>

</div>
</div>
<a id="abe66c1c916ebf8cc41a50e0d176de75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe66c1c916ebf8cc41a50e0d176de75a">&#9670;&nbsp;</a></span>d_center_of_mass_current</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_center_of_mass_current</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ac8a64acf8f7af721cad92aee80bbb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac8a64acf8f7af721cad92aee80bbb1">&#9670;&nbsp;</a></span>d_center_of_mass_half</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_center_of_mass_half</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7c8cc709ffdd9adb602d079665fcf48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c8cc709ffdd9adb602d079665fcf48">&#9670;&nbsp;</a></span>d_center_of_mass_new</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_center_of_mass_new</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5b378a544fd6b8a871abe3ec3807d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b378a544fd6b8a871abe3ec3807d98">&#9670;&nbsp;</a></span>d_compute_center_of_mass_initial</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; IBAMR::CIBStrategy::d_compute_center_of_mass_initial</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af0997a2def8f09191bfa55a29e90c969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0997a2def8f09191bfa55a29e90c969">&#9670;&nbsp;</a></span>d_quaternion_current</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Quaterniond&gt; IBAMR::CIBStrategy::d_quaternion_current</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Quaternion of the body. </p>

</div>
</div>
<a id="ac429d5ed3731531af860043d007aec6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac429d5ed3731531af860043d007aec6a">&#9670;&nbsp;</a></span>d_quaternion_half</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Quaterniond&gt; IBAMR::CIBStrategy::d_quaternion_half</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac219c2dad3198f4452eb91caa19d2d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac219c2dad3198f4452eb91caa19d2d80">&#9670;&nbsp;</a></span>d_quaternion_new</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Quaterniond&gt; IBAMR::CIBStrategy::d_quaternion_new</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adfd7755ec6ff2466d39205ba1eb007fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd7755ec6ff2466d39205ba1eb007fe">&#9670;&nbsp;</a></span>d_solve_rigid_vel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceIBTK.html#aac19301c6fd0897bd5254ffad040e24c">IBTK::FRDV</a>&gt; IBAMR::CIBStrategy::d_solve_rigid_vel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab22ae8b85ca8df0fd9b812fdb4b5692b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22ae8b85ca8df0fd9b812fdb4b5692b">&#9670;&nbsp;</a></span>d_U</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vec IBAMR::CIBStrategy::d_U</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08b7f78c9725bab72d66fbe6af279fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b7f78c9725bab72d66fbe6af279fea">&#9670;&nbsp;</a></span>d_F</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vec IBAMR::CIBStrategy::d_F</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b7fd46d9caa77a2a5c73d300fecc1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7fd46d9caa77a2a5c73d300fecc1ac">&#9670;&nbsp;</a></span>d_free_dofs_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;<a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>&gt; &gt; IBAMR::CIBStrategy::d_free_dofs_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab07a284a69aeca5ca96bf5b973e79ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07a284a69aeca5ca96bf5b973e79ebf">&#9670;&nbsp;</a></span>d_free_dofs_map_updated</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::CIBStrategy::d_free_dofs_map_updated</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f327733ed226b3dab4570a091b8f320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f327733ed226b3dab4570a091b8f320">&#9670;&nbsp;</a></span>d_trans_vel_current</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_trans_vel_current</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rigid body velocity of the structures. </p>

</div>
</div>
<a id="a8aec9a253505c8aec29c7fa61d1fb679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aec9a253505c8aec29c7fa61d1fb679">&#9670;&nbsp;</a></span>d_trans_vel_half</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_trans_vel_half</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a72aa507b4762f5e2ab47f04b7c7a975f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aa507b4762f5e2ab47f04b7c7a975f">&#9670;&nbsp;</a></span>d_trans_vel_new</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_trans_vel_new</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a84feb76bf0b3cdfdcbffab8d876cde9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84feb76bf0b3cdfdcbffab8d876cde9f">&#9670;&nbsp;</a></span>d_rot_vel_current</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_rot_vel_current</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3afc85a233ca21712f4ad4e785676083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afc85a233ca21712f4ad4e785676083">&#9670;&nbsp;</a></span>d_rot_vel_half</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_rot_vel_half</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d45fbba4a53b330b711f8e1eb869dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d45fbba4a53b330b711f8e1eb869dbb">&#9670;&nbsp;</a></span>d_rot_vel_new</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_rot_vel_new</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a571c74a9f31de87ea505275f416f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a571c74a9f31de87ea505275f416f7e">&#9670;&nbsp;</a></span>d_net_rigid_generalized_force</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a>&gt; IBAMR::CIBStrategy::d_net_rigid_generalized_force</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ibamr/<a class="el" href="CIBMethod_8h.html">CIBMethod.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
