<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: IBTK Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IBAMR
   &#160;<span id="projectnumber">IBAMR version 0.19.</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">IBTK Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceIBTK_1_1libMeshWrappers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK_1_1libMeshWrappers.html">libMeshWrappers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1AppInitializer.html">AppInitializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1AppInitializer.html" title="Class AppInitializer provides functionality to simplify the initialization code in an application cod...">AppInitializer</a> provides functionality to simplify the initialization code in an application code.  <a href="classIBTK_1_1AppInitializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1BGaussSeidelPreconditioner.html">BGaussSeidelPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1BGaussSeidelPreconditioner.html" title="Class BGaussSeidelPreconditioner is a block Gauss-Seidel preconditioner which implements the abstract...">BGaussSeidelPreconditioner</a> is a block Gauss-Seidel preconditioner which implements the abstract <a class="el" href="classIBTK_1_1LinearSolver.html" title="Class LinearSolver provides an abstract interface for the implementation of solvers for linear proble...">LinearSolver</a> interface.  <a href="classIBTK_1_1BGaussSeidelPreconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1BJacobiPreconditioner.html">BJacobiPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1BJacobiPreconditioner.html" title="Class BJacobiPreconditioner is a block Jacobi preconditioner which implements the abstract LinearSolv...">BJacobiPreconditioner</a> is a block Jacobi preconditioner which implements the abstract <a class="el" href="classIBTK_1_1LinearSolver.html" title="Class LinearSolver provides an abstract interface for the implementation of solvers for linear proble...">LinearSolver</a> interface.  <a href="classIBTK_1_1BJacobiPreconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1BoxPartitioner.html">BoxPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespacelibMesh.html">libMesh</a> partitioner that partitions a mesh based on <a class="el" href="classIBTK_1_1PartitioningBox.html" title="Class PartitioningBox implements an NDIM-dimensional bounding box defined by two points....">PartitioningBox</a> objects owned by each processor.  <a href="classIBTK_1_1BoxPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellDoubleBoundsPreservingConservativeLinearRefine.html">CartCellDoubleBoundsPreservingConservativeLinearRefine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CartCellDoubleBoundsPreservingConservativeLinearRefine.html" title="Class CartCellDoubleBoundsPreservingConservativeLinearRefine is a concrete SAMRAI::xfer::RefineOperat...">CartCellDoubleBoundsPreservingConservativeLinearRefine</a> is a concrete <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">SAMRAI::xfer::RefineOperator</a> object which prolongs cell-centered double precision patch data via conservative linear interpolation with an additional bounds preservation repair step.  <a href="classIBTK_1_1CartCellDoubleBoundsPreservingConservativeLinearRefine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellDoubleCubicCoarsen.html">CartCellDoubleCubicCoarsen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CartCellDoubleCubicCoarsen.html" title="Class CartCellDoubleCubicCoarsen is a concrete SAMRAI::xfer::CoarsenOperator for restricting cell-cen...">CartCellDoubleCubicCoarsen</a> is a concrete <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenOperator.html">SAMRAI::xfer::CoarsenOperator</a> for restricting cell-centered double precision patch data via cubic interpolation.  <a href="classIBTK_1_1CartCellDoubleCubicCoarsen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellDoubleLinearCFInterpolation.html">CartCellDoubleLinearCFInterpolation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CartCellDoubleLinearCFInterpolation.html" title="Class CartCellDoubleLinearCFInterpolation is a concrete SAMRAI::xfer::RefinePatchStrategy which sets ...">CartCellDoubleLinearCFInterpolation</a> is a concrete <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo...">SAMRAI::xfer::RefinePatchStrategy</a> which sets coarse-fine interface ghost cell values for cell-centered double precision patch data via linear interpolation in the normal and tangential directions at coarse-fine interfaces.  <a href="classIBTK_1_1CartCellDoubleLinearCFInterpolation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellDoubleQuadraticCFInterpolation.html">CartCellDoubleQuadraticCFInterpolation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CartCellDoubleQuadraticCFInterpolation.html" title="Class CartCellDoubleQuadraticCFInterpolation is a concrete SAMRAI::xfer::RefinePatchStrategy which se...">CartCellDoubleQuadraticCFInterpolation</a> is a concrete <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo...">SAMRAI::xfer::RefinePatchStrategy</a> which sets coarse-fine interface ghost cell values for cell-centered double precision patch data via quadratic interpolation in the normal and tangential directions at coarse-fine interfaces.  <a href="classIBTK_1_1CartCellDoubleQuadraticCFInterpolation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellDoubleQuadraticRefine.html">CartCellDoubleQuadraticRefine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CartCellDoubleQuadraticRefine.html" title="Class CartCellDoubleQuadraticRefine is a concrete SAMRAI::xfer::RefineOperator object which prolongs ...">CartCellDoubleQuadraticRefine</a> is a concrete <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">SAMRAI::xfer::RefineOperator</a> object which prolongs cell-centered double precision patch data via quadratic interpolation.  <a href="classIBTK_1_1CartCellDoubleQuadraticRefine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html">CartCellRobinPhysBdryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CartCellRobinPhysBdryOp.html" title="Class CartCellRobinPhysBdryOp is a concrete SAMRAI::xfer::RefinePatchStrategy for setting Robin bound...">CartCellRobinPhysBdryOp</a> is a concrete <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo...">SAMRAI::xfer::RefinePatchStrategy</a> for setting Robin boundary conditions at physical boundaries for cell-centered scalar- and vector-valued quantities.  <a href="classIBTK_1_1CartCellRobinPhysBdryOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartExtrapPhysBdryOp.html">CartExtrapPhysBdryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CartExtrapPhysBdryOp.html" title="Class CartExtrapPhysBdryOp is a concrete SAMRAI::xfer::RefinePatchStrategy for setting ghost cell val...">CartExtrapPhysBdryOp</a> is a concrete <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo...">SAMRAI::xfer::RefinePatchStrategy</a> for setting ghost cell values at physical boundaries via constant, linear, or quadratic extrapolation from interior values.  <a href="classIBTK_1_1CartExtrapPhysBdryOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartGridFunction.html">CartGridFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CartGridFunction.html" title="Class CartGridFunction provides an abstract interface for objects for evaluating functions to set val...">CartGridFunction</a> provides an abstract interface for objects for evaluating functions to set values in <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">SAMRAI::hier::PatchData</a> objects.  <a href="classIBTK_1_1CartGridFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartGridFunctionSet.html">CartGridFunctionSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CartGridFunctionSet.html" title="Class CartGridFunctionSet is a concrete CartGridFunction that is used to allow multiple CartGridFunct...">CartGridFunctionSet</a> is a concrete <a class="el" href="classIBTK_1_1CartGridFunction.html" title="Class CartGridFunction provides an abstract interface for objects for evaluating functions to set val...">CartGridFunction</a> that is used to allow multiple <a class="el" href="classIBTK_1_1CartGridFunction.html" title="Class CartGridFunction provides an abstract interface for objects for evaluating functions to set val...">CartGridFunction</a> objects to act as a single function.  <a href="classIBTK_1_1CartGridFunctionSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartSideDoubleCubicCoarsen.html">CartSideDoubleCubicCoarsen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CartSideDoubleCubicCoarsen.html" title="Class CartSideDoubleCubicCoarsen is a concrete SAMRAI::xfer::CoarsenOperator for restricting side-cen...">CartSideDoubleCubicCoarsen</a> is a concrete <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenOperator.html">SAMRAI::xfer::CoarsenOperator</a> for restricting side-centered double precision patch data via cubic interpolation.  <a href="classIBTK_1_1CartSideDoubleCubicCoarsen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartSideDoubleDivPreservingRefine.html">CartSideDoubleDivPreservingRefine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CartSideDoubleDivPreservingRefine.html" title="Class CartSideDoubleDivPreservingRefine is a concrete SAMRAI::xfer::RefinePatchStrategy which prolong...">CartSideDoubleDivPreservingRefine</a> is a concrete <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo...">SAMRAI::xfer::RefinePatchStrategy</a> which prolongs side-centered double precision patch data via conservative linear interpolation with divergence- and curl-preserving corrections.  <a href="classIBTK_1_1CartSideDoubleDivPreservingRefine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartSideDoubleQuadraticCFInterpolation.html">CartSideDoubleQuadraticCFInterpolation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CartSideDoubleQuadraticCFInterpolation.html" title="Class CartSideDoubleQuadraticCFInterpolation is a concrete SAMRAI::xfer::RefinePatchStrategy which se...">CartSideDoubleQuadraticCFInterpolation</a> is a concrete <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo...">SAMRAI::xfer::RefinePatchStrategy</a> which sets coarse-fine interface ghost cell values for side-centered double precision patch data via quadratic interpolation in the normal and tangential directions at coarse-fine interfaces.  <a href="classIBTK_1_1CartSideDoubleQuadraticCFInterpolation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartSideDoubleRT0Coarsen.html">CartSideDoubleRT0Coarsen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CartSideDoubleRT0Coarsen.html" title="Class CartSideDoubleRT0Coarsen is a concrete SAMRAI::xfer::CoarsenOperator for restricting side-cente...">CartSideDoubleRT0Coarsen</a> is a concrete <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenOperator.html">SAMRAI::xfer::CoarsenOperator</a> for restricting side-centered double precision patch data via the adjoint of RT0 interpolation.  <a href="classIBTK_1_1CartSideDoubleRT0Coarsen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartSideDoubleRT0Refine.html">CartSideDoubleRT0Refine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CartSideDoubleRT0Refine.html" title="Class CartSideDoubleRT0Refine is a concrete SAMRAI::xfer::RefineOperator object that prolongs side-ce...">CartSideDoubleRT0Refine</a> is a concrete <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">SAMRAI::xfer::RefineOperator</a> object that prolongs side-centered double precision patch data via RT0-based interpolation.  <a href="classIBTK_1_1CartSideDoubleRT0Refine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartSideDoubleSpecializedLinearRefine.html">CartSideDoubleSpecializedLinearRefine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CartSideDoubleSpecializedLinearRefine.html" title="Class CartSideDoubleSpecializedLinearRefine is a concrete SAMRAI::xfer::RefineOperator object that pr...">CartSideDoubleSpecializedLinearRefine</a> is a concrete <a class="el" href="classSAMRAI_1_1xfer_1_1RefineOperator.html">SAMRAI::xfer::RefineOperator</a> object that prolongs side-centered double precision patch data via linear interpolation in the normal direction and MC-limited piecewise-linear interpolation in the tangential direction.  <a href="classIBTK_1_1CartSideDoubleSpecializedLinearRefine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CartSideRobinPhysBdryOp.html">CartSideRobinPhysBdryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CartSideRobinPhysBdryOp.html" title="Class CartSideRobinPhysBdryOp is a concrete SAMRAI::xfer::RefinePatchStrategy for setting Robin bound...">CartSideRobinPhysBdryOp</a> is a concrete <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo...">SAMRAI::xfer::RefinePatchStrategy</a> for setting Robin boundary conditions at physical boundaries for side-centered vector-valued quantities.  <a href="classIBTK_1_1CartSideRobinPhysBdryOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CCLaplaceOperator.html">CCLaplaceOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CCLaplaceOperator.html" title="Class CCLaplaceOperator is a concrete LaplaceOperator which implements a globally second-order accura...">CCLaplaceOperator</a> is a concrete <a class="el" href="classIBTK_1_1LaplaceOperator.html" title="Class LaplaceOperator is an abstract base class for a Laplace-type operators.">LaplaceOperator</a> which implements a globally second-order accurate cell-centered finite difference discretization of a scalar elliptic operator of the form \( L = C I + \nabla \cdot D \nabla\).  <a href="classIBTK_1_1CCLaplaceOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CCPoissonBoxRelaxationFACOperator.html">CCPoissonBoxRelaxationFACOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CCPoissonBoxRelaxationFACOperator.html" title="Class CCPoissonBoxRelaxationFACOperator is a concrete PoissonFACPreconditionerStrategy for solving el...">CCPoissonBoxRelaxationFACOperator</a> is a concrete <a class="el" href="classIBTK_1_1PoissonFACPreconditionerStrategy.html" title="Class PoissonFACPreconditionerStrategy is an abstract FACPreconditionerStrategy implementing many of ...">PoissonFACPreconditionerStrategy</a> for solving elliptic equations of the form \( \mbox{$L u$} = \mbox{$(C I + \nabla \cdot D \nabla) u$} = f \) using a globally second-order accurate cell-centered finite-volume discretization, with support for Robin and periodic boundary conditions.  <a href="classIBTK_1_1CCPoissonBoxRelaxationFACOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CCPoissonHypreLevelSolver.html">CCPoissonHypreLevelSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CCPoissonHypreLevelSolver.html" title="Class CCPoissonHypreLevelSolver is a concrete LinearSolver for solving elliptic equations of the form...">CCPoissonHypreLevelSolver</a> is a concrete <a class="el" href="classIBTK_1_1LinearSolver.html" title="Class LinearSolver provides an abstract interface for the implementation of solvers for linear proble...">LinearSolver</a> for solving elliptic equations of the form \( \mbox{$L u$} = \mbox{$(C I + \nabla \cdot D \nabla) u$} = f \) on a <em>single</em> <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a> using <a href="https://computation.llnl.gov/casc/linear_solvers/sls_hypre.html">hypre</a>.  <a href="classIBTK_1_1CCPoissonHypreLevelSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CCPoissonLevelRelaxationFACOperator.html">CCPoissonLevelRelaxationFACOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CCPoissonLevelRelaxationFACOperator.html" title="Class CCPoissonLevelRelaxationFACOperator is a concrete PoissonFACPreconditionerStrategy for solving ...">CCPoissonLevelRelaxationFACOperator</a> is a concrete <a class="el" href="classIBTK_1_1PoissonFACPreconditionerStrategy.html" title="Class PoissonFACPreconditionerStrategy is an abstract FACPreconditionerStrategy implementing many of ...">PoissonFACPreconditionerStrategy</a> for solving elliptic equations of the form \( \mbox{$L u$} = \mbox{$(C I + \nabla \cdot D \nabla) u$} = f \) using a globally second-order accurate cell-centered finite-volume discretization, with support for Robin and periodic boundary conditions.  <a href="classIBTK_1_1CCPoissonLevelRelaxationFACOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CCPoissonPETScLevelSolver.html">CCPoissonPETScLevelSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CCPoissonPETScLevelSolver.html" title="Class CCPoissonPETScLevelSolver is a concrete PETScLevelSolver for solving elliptic equations of the ...">CCPoissonPETScLevelSolver</a> is a concrete <a class="el" href="classIBTK_1_1PETScLevelSolver.html" title="Class PETScLevelSolver is an abstract LinearSolver for solving systems of linear equations on a singl...">PETScLevelSolver</a> for solving elliptic equations of the form \( \mbox{$L u$} = \mbox{$(C I + \nabla \cdot D \nabla) u$} = f \) on a <em>single</em> <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a>.  <a href="classIBTK_1_1CCPoissonPETScLevelSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CCPoissonPointRelaxationFACOperator.html">CCPoissonPointRelaxationFACOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CCPoissonPointRelaxationFACOperator.html" title="Class CCPoissonPointRelaxationFACOperator is a concrete PoissonFACPreconditionerStrategy for solving ...">CCPoissonPointRelaxationFACOperator</a> is a concrete <a class="el" href="classIBTK_1_1PoissonFACPreconditionerStrategy.html" title="Class PoissonFACPreconditionerStrategy is an abstract FACPreconditionerStrategy implementing many of ...">PoissonFACPreconditionerStrategy</a> for solving elliptic equations of the form \( \mbox{$L u$} = \mbox{$(C I + \nabla \cdot D \nabla) u$} = f \) using a globally second-order accurate cell-centered finite-volume discretization, with support for Robin and periodic boundary conditions.  <a href="classIBTK_1_1CCPoissonPointRelaxationFACOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CCPoissonSolverManager.html">CCPoissonSolverManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CCPoissonSolverManager.html" title="Class CCPoissonSolverManager is a singleton manager class to provide access to generic cell-centered ...">CCPoissonSolverManager</a> is a singleton manager class to provide access to generic cell-centered <a class="el" href="classIBTK_1_1PoissonSolver.html" title="Class PoissonSolver is an abstract base class for Poisson solvers.">PoissonSolver</a> implementations.  <a href="classIBTK_1_1CCPoissonSolverManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CellNoCornersFillPattern.html">CellNoCornersFillPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class CellCellNoCornersFillPattern is a concrete implementation of the abstract base class <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">SAMRAI::xfer::VariableFillPattern</a>. It is used to calculate overlaps according to a pattern that limits overlaps to the cell-centered ghost region surrounding a patch on the target level, excluding all corners (and, in 3D, patch edges).  <a href="classIBTK_1_1CellNoCornersFillPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CoarseFineBoundaryRefinePatchStrategy.html">CoarseFineBoundaryRefinePatchStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CoarseFineBoundaryRefinePatchStrategy.html" title="Class CoarseFineBoundaryRefinePatchStrategy is a subclass of the abstract base class SAMRAI::xfer::Re...">CoarseFineBoundaryRefinePatchStrategy</a> is a subclass of the abstract base class <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo...">SAMRAI::xfer::RefinePatchStrategy</a> that extends the functionality of <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo...">SAMRAI::xfer::RefinePatchStrategy</a> to facilitate the implementation of coarse-fine interface discretizations.  <a href="classIBTK_1_1CoarseFineBoundaryRefinePatchStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CoarsenPatchStrategySet.html">CoarsenPatchStrategySet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CoarsenPatchStrategySet.html" title="Class CoarsenPatchStrategySet is a utility class that allows multiple SAMRAI::xfer::CoarsenPatchStrat...">CoarsenPatchStrategySet</a> is a utility class that allows multiple <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html" title="Class CoarsenPatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface f...">SAMRAI::xfer::CoarsenPatchStrategy</a> objects to be employed by a single <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html" title="Class CoarsenSchedule&lt;DIM&gt; performs the communication operations to coarsen data from a finer level t...">SAMRAI::xfer::CoarsenSchedule</a>.  <a href="classIBTK_1_1CoarsenPatchStrategySet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CopyToRootSchedule.html">CopyToRootSchedule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CopyToRootSchedule.html" title="Class CopyToRootSchedule is used to communicate distributed patch data to a unified patch data object...">CopyToRootSchedule</a> is used to communicate distributed patch data to a unified patch data object on a root MPI process.  <a href="classIBTK_1_1CopyToRootSchedule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1CopyToRootTransaction.html">CopyToRootTransaction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1CopyToRootTransaction.html" title="Class CopyToRootTransaction is a concrete implementation of the abstract base class SAMRAI::tbox::Tra...">CopyToRootTransaction</a> is a concrete implementation of the abstract base class <a class="el" href="classSAMRAI_1_1tbox_1_1Transaction.html">SAMRAI::tbox::Transaction</a>. It is used to communicate distributed patch data to a unified patch data object on a root MPI process.  <a href="classIBTK_1_1CopyToRootTransaction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1DebuggingUtilities.html">DebuggingUtilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1DebuggingUtilities.html" title="Class DebuggingUtilities provides debugging functionality.">DebuggingUtilities</a> provides debugging functionality.  <a href="classIBTK_1_1DebuggingUtilities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIBTK_1_1DofObjectComp.html">DofObjectComp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1EdgeDataSynchronization.html">EdgeDataSynchronization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1EdgeDataSynchronization.html" title="Class EdgeDataSynchronization encapsulates the operations required to &quot;synchronize&quot; edge-centered val...">EdgeDataSynchronization</a> encapsulates the operations required to "synchronize" edge-centered values defined at patch boundaries.  <a href="classIBTK_1_1EdgeDataSynchronization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1EdgeSynchCopyFillPattern.html">EdgeSynchCopyFillPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class EdgeCellSynchCopyFillPattern is a concrete implementation of the abstract base class <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">SAMRAI::xfer::VariableFillPattern</a>. It is used to calculate overlaps according to a pattern which limits overlaps to the edge-centered ghost region surrounding a patch appropriate for "synchronizing" edge-centered values in an axis-by-axis manner at patch boundaries.  <a href="classIBTK_1_1EdgeSynchCopyFillPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1ExtendedRobinBcCoefStrategy.html">ExtendedRobinBcCoefStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1ExtendedRobinBcCoefStrategy.html" title="Class ExtendedRobinBcCoefStrategy is a subclass of the abstract base class SAMRAI::solv::RobinBcCoefS...">ExtendedRobinBcCoefStrategy</a> is a subclass of the abstract base class <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html" title="Interface for specifying Robin boundary conditions.">SAMRAI::solv::RobinBcCoefStrategy</a> that extends the functionality of <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html" title="Interface for specifying Robin boundary conditions.">SAMRAI::solv::RobinBcCoefStrategy</a> to allow for the specification of patch data descriptor indices that are required for filling, and the specification of whether homogeneous or inhomogeneous boundary data should be set.  <a href="classIBTK_1_1ExtendedRobinBcCoefStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FaceDataSynchronization.html">FaceDataSynchronization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1FaceDataSynchronization.html" title="Class FaceDataSynchronization encapsulates the operations required to &quot;synchronize&quot; face-centered val...">FaceDataSynchronization</a> encapsulates the operations required to "synchronize" face-centered values defined at patch boundaries.  <a href="classIBTK_1_1FaceDataSynchronization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FaceSynchCopyFillPattern.html">FaceSynchCopyFillPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class FaceCellSynchCopyFillPattern is a concrete implementation of the abstract base class <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">SAMRAI::xfer::VariableFillPattern</a>. It is used to calculate overlaps according to a pattern which limits overlaps to the face-centered ghost region surrounding a patch appropriate for "synchronizing" face-centered values at patch boundaries.  <a href="classIBTK_1_1FaceSynchCopyFillPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FACPreconditioner.html">FACPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1FACPreconditioner.html" title="Class FACPreconditioner is a concrete LinearSolver for implementing FAC (multilevel multigrid) precon...">FACPreconditioner</a> is a concrete <a class="el" href="classIBTK_1_1LinearSolver.html" title="Class LinearSolver provides an abstract interface for the implementation of solvers for linear proble...">LinearSolver</a> for implementing FAC (multilevel multigrid) preconditioners.  <a href="classIBTK_1_1FACPreconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FACPreconditionerStrategy.html">FACPreconditionerStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1FACPreconditionerStrategy.html" title="Class FACPreconditionerStrategy provides an interface for specifying the problem-specific operations ...">FACPreconditionerStrategy</a> provides an interface for specifying the problem-specific operations needed to implement a specific FAC preconditioner.  <a href="classIBTK_1_1FACPreconditionerStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FECache.html">FECache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class storing multiple libMesh::FE objects, each corresponding to a different quadrature rule. Each FE object is configured with a quadrature rule corresponding to the provided <code>quad_key</code> parameter.  <a href="classIBTK_1_1FECache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEData.html">FEData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataInterpolation.html">FEDataInterpolation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1FEDataInterpolation.html" title="Class FEDataInterpolation manages data required to evaluate one or more FE field variables at a colle...">FEDataInterpolation</a> manages data required to evaluate one or more FE field variables at a collection of points, possibly (not not necessarily) corresponding to the points of a quadrature rule.  <a href="classIBTK_1_1FEDataInterpolation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html">FEDataManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1FEDataManager.html" title="Class FEDataManager coordinates data required for Lagrangian-Eulerian interaction between a Lagrangia...">FEDataManager</a> coordinates data required for Lagrangian-Eulerian interaction between a Lagrangian finite element (FE) mesh. In particular, the <a class="el" href="classIBTK_1_1FEData.html">FEData</a> member object stores the necessary finite element data while this class stores additional data dependent on the Eulerian grid.  <a href="classIBTK_1_1FEDataManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FELagrangeMapping.html">FELagrangeMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEMapping.html">FEMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEMappingCache.html">FEMappingCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class storing multiple <a class="el" href="classIBTK_1_1FEMapping.html">IBTK::FEMapping</a> objects. We assume that quadrature rules are uniquely determined by the element type, quadrature type, and approximation order. There are several places in <a class="el" href="namespaceIBTK.html">IBTK</a> where we make this assumption, e.g., we will use data from two quadrature rules assumed to be equal (by this metric) to initialize different <a class="el" href="namespacelibMesh.html">libMesh</a> objects.  <a href="classIBTK_1_1FEMappingCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FENodalMapping.html">FENodalMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEProjector.html">FEProjector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1FEProjector.html" title="Class FEProjector coordinates data structures for projecting fields in FE models.">FEProjector</a> coordinates data structures for projecting fields in FE models.  <a href="classIBTK_1_1FEProjector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEValues.html">FEValues</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEValuesBase.html">FEValuesBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FischerGuess.html">FischerGuess</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FixedSizedStream.html">FixedSizedStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1FixedSizedStream.html" title="Class FixedSizedStream provides a fixed-size message buffer used by various communication routines.">FixedSizedStream</a> provides a fixed-size message buffer used by various communication routines.  <a href="classIBTK_1_1FixedSizedStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1GeneralOperator.html">GeneralOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1GeneralOperator.html" title="Class GeneralOperator provides an abstract interface for the specification of general operators to co...">GeneralOperator</a> provides an abstract interface for the specification of general operators to compute \( y=F[x] \) and \( z=F[x]+y \).  <a href="classIBTK_1_1GeneralOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1GeneralSolver.html">GeneralSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1GeneralSolver.html" title="Class GeneralSolver provides an abstract interface for the implementation of linear or nonlinear solv...">GeneralSolver</a> provides an abstract interface for the implementation of linear or nonlinear solvers for systems of equations defined on an AMR patch hierarchy.  <a href="classIBTK_1_1GeneralSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1Hex27Mapping.html">Hex27Mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1HierarchyAveragedDataManager.html">HierarchyAveragedDataManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1HierarchyAveragedDataManager.html" title="Class HierarchyAveragedDataManager provides a method of tracking and determining periodic steady stat...">HierarchyAveragedDataManager</a> provides a method of tracking and determining periodic steady states of fields. In particular, this class can be used to determine the average of a field over several instances, for example determining the mean flow of a turbulent flow field.  <a href="classIBTK_1_1HierarchyAveragedDataManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1HierarchyGhostCellInterpolation.html">HierarchyGhostCellInterpolation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1HierarchyGhostCellInterpolation.html" title="Class HierarchyGhostCellInterpolation encapsulates the operations required to set ghost cell values a...">HierarchyGhostCellInterpolation</a> encapsulates the operations required to set ghost cell values at physical and coarse-fine boundaries across a range of levels of a locally refined patch hierarchy.  <a href="classIBTK_1_1HierarchyGhostCellInterpolation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1HierarchyIntegrator.html">HierarchyIntegrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1HierarchyIntegrator.html" title="Class HierarchyIntegrator provides an abstract interface for a time integrator for a system of equati...">HierarchyIntegrator</a> provides an abstract interface for a time integrator for a system of equations defined on an AMR grid hierarchy, along with basic data management for variables defined on that hierarchy.  <a href="classIBTK_1_1HierarchyIntegrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1HierarchyMathOps.html">HierarchyMathOps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1HierarchyMathOps.html" title="Class HierarchyMathOps provides functionality to perform &quot;composite-grid&quot; mathematical operations on ...">HierarchyMathOps</a> provides functionality to perform "composite-grid" mathematical operations on a range of levels in a <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a> object.  <a href="classIBTK_1_1HierarchyMathOps.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIBTK_1_1IBTK__MPI.html">IBTK_MPI</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides C++ wrapper around MPI routines.  <a href="structIBTK_1_1IBTK__MPI.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1IBTKInit.html">IBTKInit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization for <a class="el" href="namespaceIBAMR.html">IBAMR</a> programs.  <a href="classIBTK_1_1IBTKInit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIBTK_1_1IndexOrder.html">IndexOrder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1IndexUtilities.html">IndexUtilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1IndexUtilities.html" title="Class IndexUtilities is a utility class that defines simple functions such as conversion routines bet...">IndexUtilities</a> is a utility class that defines simple functions such as conversion routines between physical coordinates and Cartesian index space.  <a href="classIBTK_1_1IndexUtilities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1JacobianOperator.html">JacobianOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1JacobianOperator.html" title="Class JacobianOperator provides an abstract interface for the specification of general operators to c...">JacobianOperator</a> provides an abstract interface for the specification of general operators to compute Jacobian-vector products, i.e., \( F&#39;[x]v \).  <a href="classIBTK_1_1JacobianOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1KrylovLinearSolver.html">KrylovLinearSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1KrylovLinearSolver.html" title="Class KrylovLinearSolver provides an abstract interface for the implementation of Krylov subspace sol...">KrylovLinearSolver</a> provides an abstract interface for the implementation of Krylov subspace solvers for linear problems of the form \(Ax=b\).  <a href="classIBTK_1_1KrylovLinearSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1KrylovLinearSolverManager.html">KrylovLinearSolverManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1KrylovLinearSolverManager.html" title="Class KrylovLinearSolverManager is a singleton manager class to provide access to generic KrylovLinea...">KrylovLinearSolverManager</a> is a singleton manager class to provide access to generic <a class="el" href="classIBTK_1_1KrylovLinearSolver.html" title="Class KrylovLinearSolver provides an abstract interface for the implementation of Krylov subspace sol...">KrylovLinearSolver</a> implementations.  <a href="classIBTK_1_1KrylovLinearSolverManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1KrylovLinearSolverPoissonSolverInterface.html">KrylovLinearSolverPoissonSolverInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1KrylovLinearSolverPoissonSolverInterface.html" title="Class KrylovLinearSolverPoissonSolverInterface provides an interface for KrylovLinearSolvers that are...">KrylovLinearSolverPoissonSolverInterface</a> provides an interface for KrylovLinearSolvers that are to be used as Poisson solvers.  <a href="classIBTK_1_1KrylovLinearSolverPoissonSolverInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LaplaceOperator.html">LaplaceOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LaplaceOperator.html" title="Class LaplaceOperator is an abstract base class for a Laplace-type operators.">LaplaceOperator</a> is an abstract base class for a Laplace-type operators.  <a href="classIBTK_1_1LaplaceOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LData.html">LData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LData.html" title="Class LData provides storage for a single scalar- or vector-valued Lagrangian quantity.">LData</a> provides storage for a single scalar- or vector-valued Lagrangian quantity.  <a href="classIBTK_1_1LData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html">LDataManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LDataManager.html" title="Class LDataManager coordinates the irregular distribution of LNode and LData on the patch hierarchy.">LDataManager</a> coordinates the irregular distribution of <a class="el" href="classIBTK_1_1LNode.html" title="Class LNode is the basic element of an LMesh.">LNode</a> and <a class="el" href="classIBTK_1_1LData.html" title="Class LData provides storage for a single scalar- or vector-valued Lagrangian quantity.">LData</a> on the patch hierarchy.  <a href="classIBTK_1_1LDataManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LEInteractor.html">LEInteractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LEInteractor.html" title="Class LEInteractor is a utility class that defines several functions to interpolate data from Euleria...">LEInteractor</a> is a utility class that defines several functions to interpolate data from Eulerian grid patches onto Lagrangian meshes and to spread values (<em>not</em> densities) from Lagrangian meshes to Eulerian grid patches.  <a href="classIBTK_1_1LEInteractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LibMeshSystemIBVectors.html">LibMeshSystemIBVectors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LibMeshSystemIBVectors.html" title="Class LibMeshSystemIBVectors is a convenience class that manages access to libMesh vectors for the sa...">LibMeshSystemIBVectors</a> is a convenience class that manages access to <a class="el" href="namespacelibMesh.html">libMesh</a> vectors for the same system defined on multiple parts. It extends the base class <a class="el" href="classIBTK_1_1LibMeshSystemVectors.html" title="Class LibMeshSystemVectors is a convenience class that manages access to libMesh vectors for the same...">LibMeshSystemVectors</a> to provide access to vectors ghosted with both the Lagrangian partitioning (i.e., <a class="el" href="namespacelibMesh.html">libMesh</a>'s computed partitioning, as in the base class) as well as the IB partitioning (i.e., the partitioning based on the distribution of <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> data).  <a href="classIBTK_1_1LibMeshSystemIBVectors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LibMeshSystemVectors.html">LibMeshSystemVectors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LibMeshSystemVectors.html" title="Class LibMeshSystemVectors is a convenience class that manages access to libMesh vectors for the same...">LibMeshSystemVectors</a> is a convenience class that manages access to <a class="el" href="namespacelibMesh.html">libMesh</a> vectors for the same system defined on multiple parts. This class only supports access to vectors ghosted with the Lagrangian partitioning (i.e., <a class="el" href="namespacelibMesh.html">libMesh</a>'s computed partitioning). The subclass <a class="el" href="classIBTK_1_1LibMeshSystemIBVectors.html" title="Class LibMeshSystemIBVectors is a convenience class that manages access to libMesh vectors for the sa...">LibMeshSystemIBVectors</a> provides access to the IB partitioning (i.e., the partitioning based on the distribution of <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> data).  <a href="classIBTK_1_1LibMeshSystemVectors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LIndexSetData.html">LIndexSetData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LIndexSetData.html" title="Class LIndexSetData is a specialization of the templated class LSetData that is intended to be used w...">LIndexSetData</a> is a specialization of the templated class <a class="el" href="classIBTK_1_1LSetData.html" title="Class LSetData is a specialization of the templated class SAMRAI::pdat::IndexData that provides acces...">LSetData</a> that is intended to be used with Lagrangian data objects that provide Lagrangian and PETSc indexing information.  <a href="classIBTK_1_1LIndexSetData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LIndexSetDataFactory.html">LIndexSetDataFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class LIndexSetPatchDataFactory provides a <a class="el" href="classSAMRAI_1_1hier_1_1PatchDataFactory.html">SAMRAI::hier::PatchDataFactory</a> class corresponding to patch data of type <a class="el" href="classIBTK_1_1LIndexSetData.html" title="Class LIndexSetData is a specialization of the templated class LSetData that is intended to be used w...">LIndexSetData</a>.  <a href="classIBTK_1_1LIndexSetDataFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LIndexSetVariable.html">LIndexSetVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LIndexSetVariable.html" title="Class LIndexSetVariable provides a SAMRAI::hier::Variable class corresponding to patch data of type L...">LIndexSetVariable</a> provides a <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a> class corresponding to patch data of type <a class="el" href="classIBTK_1_1LIndexSetData.html" title="Class LIndexSetData is a specialization of the templated class LSetData that is intended to be used w...">LIndexSetData</a>.  <a href="classIBTK_1_1LIndexSetVariable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LinearOperator.html">LinearOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LinearOperator.html" title="Class LinearOperator provides an abstract interface for the specification of linear operators to comp...">LinearOperator</a> provides an abstract interface for the specification of linear operators to compute \( y=Ax \) and \( z=Ax+y \) and, optionally, \( y=A^{T} x \) and \( z=A^{T}x+y \).  <a href="classIBTK_1_1LinearOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LinearSolver.html">LinearSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LinearSolver.html" title="Class LinearSolver provides an abstract interface for the implementation of solvers for linear proble...">LinearSolver</a> provides an abstract interface for the implementation of solvers for linear problems of the form \(Ax=b\).  <a href="classIBTK_1_1LinearSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LInitStrategy.html">LInitStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LInitStrategy.html" title="Class LInitStrategy provides a mechanism for specifying the initial configuration of the curvilinear ...">LInitStrategy</a> provides a mechanism for specifying the initial configuration of the curvilinear mesh.  <a href="classIBTK_1_1LInitStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LMesh.html">LMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LMesh.html" title="Class LMesh is a collection of LNode objects.">LMesh</a> is a collection of <a class="el" href="classIBTK_1_1LNode.html" title="Class LNode is the basic element of an LMesh.">LNode</a> objects.  <a href="classIBTK_1_1LMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LNode.html">LNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LNode.html" title="Class LNode is the basic element of an LMesh.">LNode</a> is the basic element of an <a class="el" href="classIBTK_1_1LMesh.html" title="Class LMesh is a collection of LNode objects.">LMesh</a>.  <a href="classIBTK_1_1LNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LNodeIndex.html">LNodeIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LNodeIndex.html" title="Class LNodeIndex provides Lagrangian and PETSc indexing information for a single node of a Lagrangian...">LNodeIndex</a> provides Lagrangian and <a href="http://www.mcs.anl.gov/petsc">PETSc</a> indexing information for a single node of a Lagrangian mesh.  <a href="classIBTK_1_1LNodeIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIBTK_1_1LNodeIndexGlobalPETScIndexComp.html">LNodeIndexGlobalPETScIndexComp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor to order on the global PETSc index of the Lagrangian node.  <a href="structIBTK_1_1LNodeIndexGlobalPETScIndexComp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIBTK_1_1LNodeIndexGlobalPETScIndexEqual.html">LNodeIndexGlobalPETScIndexEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor to check for equality between between <a class="el" href="classIBTK_1_1LNodeIndex.html" title="Class LNodeIndex provides Lagrangian and PETSc indexing information for a single node of a Lagrangian...">LNodeIndex</a> objects based on their global PETSc indices.  <a href="structIBTK_1_1LNodeIndexGlobalPETScIndexEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIBTK_1_1LNodeIndexLagrangianIndexComp.html">LNodeIndexLagrangianIndexComp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor to order on the Lagrangian index of the Lagrangian node.  <a href="structIBTK_1_1LNodeIndexLagrangianIndexComp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIBTK_1_1LNodeIndexLagrangianIndexEqual.html">LNodeIndexLagrangianIndexEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor to check for equality between <a class="el" href="classIBTK_1_1LNodeIndex.html" title="Class LNodeIndex provides Lagrangian and PETSc indexing information for a single node of a Lagrangian...">LNodeIndex</a> objects based on their Lagrangian indices.  <a href="structIBTK_1_1LNodeIndexLagrangianIndexEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIBTK_1_1LNodeIndexLocalPETScIndexComp.html">LNodeIndexLocalPETScIndexComp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor to order on the local PETSc index of the Lagrangian node.  <a href="structIBTK_1_1LNodeIndexLocalPETScIndexComp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIBTK_1_1LNodeIndexLocalPETScIndexEqual.html">LNodeIndexLocalPETScIndexEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor to check for equality between <a class="el" href="classIBTK_1_1LNodeIndex.html" title="Class LNodeIndex provides Lagrangian and PETSc indexing information for a single node of a Lagrangian...">LNodeIndex</a> objects based on their local PETSc indices.  <a href="structIBTK_1_1LNodeIndexLocalPETScIndexEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LNodeIndexPosnComp.html">LNodeIndexPosnComp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor to order on the physical location of the Lagrangian node.  <a href="classIBTK_1_1LNodeIndexPosnComp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LNodeIndexPosnEqual.html">LNodeIndexPosnEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functor to check for equality between <a class="el" href="classIBTK_1_1LNodeIndex.html" title="Class LNodeIndex provides Lagrangian and PETSc indexing information for a single node of a Lagrangian...">LNodeIndex</a> objects based on their positions.  <a href="classIBTK_1_1LNodeIndexPosnEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LSet.html">LSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LSet.html" title="Class LSet provides inter-processor communications and database access functionality to a collection ...">LSet</a> provides inter-processor communications and database access functionality to a collection of Lagrangian objects.  <a href="classIBTK_1_1LSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LSetData.html">LSetData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LSetData.html" title="Class LSetData is a specialization of the templated class SAMRAI::pdat::IndexData that provides acces...">LSetData</a> is a specialization of the templated class <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a> that provides access to Lagrangian objects that are embedded in the a Cartesian grid patch.  <a href="classIBTK_1_1LSetData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LSetDataFactory.html">LSetDataFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class LSetPatchDataFactory provides a <a class="el" href="classSAMRAI_1_1hier_1_1PatchDataFactory.html">SAMRAI::hier::PatchDataFactory</a> class corresponding to patch data of type <a class="el" href="classIBTK_1_1LSetData.html" title="Class LSetData is a specialization of the templated class SAMRAI::pdat::IndexData that provides acces...">LSetData</a>.  <a href="classIBTK_1_1LSetDataFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LSetDataIterator.html">LSetDataIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LSetDataIterator.html" title="Class LSetDataIterator is an iterator class which may be used to iterate through LSet objects associa...">LSetDataIterator</a> is an iterator class which may be used to iterate through <a class="el" href="classIBTK_1_1LSet.html" title="Class LSet provides inter-processor communications and database access functionality to a collection ...">LSet</a> objects associated with a specified box in cell-centered index space.  <a href="classIBTK_1_1LSetDataIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LSetVariable.html">LSetVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LSetVariable.html" title="Class LSetVariable provides a SAMRAI::hier::Variable class corresponding to patch data of type LSetDa...">LSetVariable</a> provides a <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a> class corresponding to patch data of type <a class="el" href="classIBTK_1_1LSetData.html" title="Class LSetData is a specialization of the templated class SAMRAI::pdat::IndexData that provides acces...">LSetData</a>.  <a href="classIBTK_1_1LSetVariable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LSiloDataWriter.html">LSiloDataWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LSiloDataWriter.html" title="Class LSiloDataWriter provides functionality to output Lagrangian data for visualization via the VisI...">LSiloDataWriter</a> provides functionality to output Lagrangian data for visualization via the <a href="http://www.llnl.gov/visit">VisIt visualization tool</a> in the Silo data format.  <a href="classIBTK_1_1LSiloDataWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LTransaction.html">LTransaction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1LTransaction.html" title="Class LTransaction represents a communication transaction between two processors or a local data copy...">LTransaction</a> represents a communication transaction between two processors or a local data copy for communicating or copying Lagrangian objects.  <a href="classIBTK_1_1LTransaction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1MarkerPatch.html">MarkerPatch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1MarkerPatchHierarchy.html">MarkerPatchHierarchy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1MergingLoadBalancer.html">MergingLoadBalancer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1MergingLoadBalancer.html" title="Class MergingLoadBalancer merges the boxes generated by a load balancer in a final step to decrease t...">MergingLoadBalancer</a> merges the boxes generated by a load balancer in a final step to decrease the total number of boxes. In essence, it postprocesses the list of boxes generated by its parent class to try and coalesce the set of boxes on each process.  <a href="classIBTK_1_1MergingLoadBalancer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1muParserCartGridFunction.html">muParserCartGridFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1muParserCartGridFunction.html" title="Class muParserCartGridFunction is an implementation of the strategy class CartGridFunction that allow...">muParserCartGridFunction</a> is an implementation of the strategy class <a class="el" href="classIBTK_1_1CartGridFunction.html" title="Class CartGridFunction provides an abstract interface for objects for evaluating functions to set val...">CartGridFunction</a> that allows for the run-time specification of (possibly spatially- and temporally-varying) functions which are used to set double precision values on standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">SAMRAI::hier::PatchData</a> objects.  <a href="classIBTK_1_1muParserCartGridFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1muParserRobinBcCoefs.html">muParserRobinBcCoefs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1muParserRobinBcCoefs.html" title="Class muParserRobinBcCoefs is an implementation of the strategy class SAMRAI::solv::RobinBcCoefStrate...">muParserRobinBcCoefs</a> is an implementation of the strategy class <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html" title="Interface for specifying Robin boundary conditions.">SAMRAI::solv::RobinBcCoefStrategy</a> that allows for the run-time specification of (possibly spatially- and temporally-varying) Robin boundary conditions.  <a href="classIBTK_1_1muParserRobinBcCoefs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1NewtonKrylovSolver.html">NewtonKrylovSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1NewtonKrylovSolver.html" title="Class NewtonKrylovSolver provides an abstract interface for the implementation of inexact Newton-Kryl...">NewtonKrylovSolver</a> provides an abstract interface for the implementation of inexact Newton-Krylov solvers for nonlinear problems of the form \( F[x]=b \).  <a href="classIBTK_1_1NewtonKrylovSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1NewtonKrylovSolverManager.html">NewtonKrylovSolverManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1NewtonKrylovSolverManager.html" title="Class NewtonKrylovSolverManager is a singleton manager class to provide access to generic NewtonKrylo...">NewtonKrylovSolverManager</a> is a singleton manager class to provide access to generic <a class="el" href="classIBTK_1_1NewtonKrylovSolver.html" title="Class NewtonKrylovSolver provides an abstract interface for the implementation of inexact Newton-Kryl...">NewtonKrylovSolver</a> implementations.  <a href="classIBTK_1_1NewtonKrylovSolverManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1NodeDataSynchronization.html">NodeDataSynchronization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1NodeDataSynchronization.html" title="Class NodeDataSynchronization encapsulates the operations required to &quot;synchronize&quot; node-centered val...">NodeDataSynchronization</a> encapsulates the operations required to "synchronize" node-centered values defined at patch boundaries.  <a href="classIBTK_1_1NodeDataSynchronization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1NodeSynchCopyFillPattern.html">NodeSynchCopyFillPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class NodeCellSynchCopyFillPattern is a concrete implementation of the abstract base class <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">SAMRAI::xfer::VariableFillPattern</a>. It is used to calculate overlaps according to a pattern which limits overlaps to the node-centered ghost region surrounding a patch appropriate for "synchronizing" node-centered values in an axis-by-axis manner at patch boundaries.  <a href="classIBTK_1_1NodeSynchCopyFillPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1NormOps.html">NormOps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1NormOps.html" title="Class NormOps provides functionality for computing discrete vector norms.">NormOps</a> provides functionality for computing discrete vector norms.  <a href="classIBTK_1_1NormOps.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1ParallelEdgeMap.html">ParallelEdgeMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1ParallelEdgeMap.html" title="Class ParallelEdgeMap is a utility class for managing edge maps (i.e., maps from vertices to links be...">ParallelEdgeMap</a> is a utility class for managing edge maps (i.e., maps from vertices to links between vertices) in parallel.  <a href="classIBTK_1_1ParallelEdgeMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1ParallelMap.html">ParallelMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1ParallelMap.html" title="Class ParallelMap is a utility class for associating integer keys with arbitrary data items in parall...">ParallelMap</a> is a utility class for associating integer keys with arbitrary data items in parallel.  <a href="classIBTK_1_1ParallelMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1ParallelSet.html">ParallelSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1ParallelSet.html" title="Class ParallelSet is a utility class for storing collections of integer keys in parallel.">ParallelSet</a> is a utility class for storing collections of integer keys in parallel.  <a href="classIBTK_1_1ParallelSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PartitioningBox.html">PartitioningBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PartitioningBox.html" title="Class PartitioningBox implements an NDIM-dimensional bounding box defined by two points....">PartitioningBox</a> implements an NDIM-dimensional bounding box defined by two points. Unlike a standard bounding box, a <a class="el" href="classIBTK_1_1PartitioningBox.html" title="Class PartitioningBox implements an NDIM-dimensional bounding box defined by two points....">PartitioningBox</a> is an <code>NDIM</code>-dimensional tensor product of half-open intervals: i.e., it is a half-open box. This property allows one to partition a domain into a set of boxes.  <a href="classIBTK_1_1PartitioningBox.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PartitioningBoxes.html">PartitioningBoxes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PartitioningBoxes.html" title="Class PartitioningBoxes stores a set of bounding boxes and can check if a point is in the set of part...">PartitioningBoxes</a> stores a set of bounding boxes and can check if a point is in the set of partitioning boxes or not in a more optimized way than just looping over a std::vector&lt;PartitioningBox&gt;.  <a href="classIBTK_1_1PartitioningBoxes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PatchMathOps.html">PatchMathOps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PatchMathOps.html" title="Class PatchMathOps provides functionality to perform mathematical operations on individual SAMRAI::hi...">PatchMathOps</a> provides functionality to perform mathematical operations on <em>individual</em> <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a> objects.  <a href="classIBTK_1_1PatchMathOps.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PETScKrylovLinearSolver.html">PETScKrylovLinearSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PETScKrylovLinearSolver.html" title="Class PETScKrylovLinearSolver provides a KrylovLinearSolver interface for a PETSc Krylov subspace ite...">PETScKrylovLinearSolver</a> provides a <a class="el" href="classIBTK_1_1KrylovLinearSolver.html" title="Class KrylovLinearSolver provides an abstract interface for the implementation of Krylov subspace sol...">KrylovLinearSolver</a> interface for a <a href="http://www.mcs.anl.gov/petsc">PETSc</a> Krylov subspace iterative linear solver (KSP).  <a href="classIBTK_1_1PETScKrylovLinearSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PETScKrylovPoissonSolver.html">PETScKrylovPoissonSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PETScKrylovPoissonSolver.html" title="Class PETScKrylovPoissonSolver is an extension of class PETScKrylovLinearSolver that provides an impl...">PETScKrylovPoissonSolver</a> is an extension of class <a class="el" href="classIBTK_1_1PETScKrylovLinearSolver.html" title="Class PETScKrylovLinearSolver provides a KrylovLinearSolver interface for a PETSc Krylov subspace ite...">PETScKrylovLinearSolver</a> that provides an implementation of the <a class="el" href="classIBTK_1_1PoissonSolver.html" title="Class PoissonSolver is an abstract base class for Poisson solvers.">PoissonSolver</a> interface.  <a href="classIBTK_1_1PETScKrylovPoissonSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PETScLevelSolver.html">PETScLevelSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PETScLevelSolver.html" title="Class PETScLevelSolver is an abstract LinearSolver for solving systems of linear equations on a singl...">PETScLevelSolver</a> is an abstract <a class="el" href="classIBTK_1_1LinearSolver.html" title="Class LinearSolver provides an abstract interface for the implementation of solvers for linear proble...">LinearSolver</a> for solving systems of linear equations on a <em>single</em> <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a> using <a href="http://www.mcs.anl.gov/petsc/petsc-as">PETSc</a>.  <a href="classIBTK_1_1PETScLevelSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PETScMatLOWrapper.html">PETScMatLOWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PETScMatLOWrapper.html" title="Class PETScMatLOWrapper provides a LinearOperator interface for a PETSc Mat object.">PETScMatLOWrapper</a> provides a <a class="el" href="classIBTK_1_1LinearOperator.html" title="Class LinearOperator provides an abstract interface for the specification of linear operators to comp...">LinearOperator</a> interface for a <a href="http://www.mcs.anl.gov/petsc">PETSc</a> Mat object.  <a href="classIBTK_1_1PETScMatLOWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PETScMatUtilities.html">PETScMatUtilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PETScMatUtilities.html" title="Class PETScMatUtilities provides utility functions for PETSc Mat objects.">PETScMatUtilities</a> provides utility functions for <a href="http://www.mcs.anl.gov/petsc">PETSc</a> Mat objects.  <a href="classIBTK_1_1PETScMatUtilities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PETScMFFDJacobianOperator.html">PETScMFFDJacobianOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PETScMFFDJacobianOperator.html" title="Class PETScMFFDJacobianOperator provides a method for computing Jacobian-vector products,...">PETScMFFDJacobianOperator</a> provides a method for computing Jacobian-vector products, i.e., \( F&#39;[x]v \), via a matrix-free finite-difference approach.  <a href="classIBTK_1_1PETScMFFDJacobianOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PETScNewtonKrylovSolver.html">PETScNewtonKrylovSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PETScNewtonKrylovSolver.html" title="Class PETScNewtonKrylovSolver provides a NewtonKrylovSolver interface for a PETSc inexact Newton-Kryl...">PETScNewtonKrylovSolver</a> provides a <a class="el" href="classIBTK_1_1NewtonKrylovSolver.html" title="Class NewtonKrylovSolver provides an abstract interface for the implementation of inexact Newton-Kryl...">NewtonKrylovSolver</a> interface for a <a href="http://www.mcs.anl.gov/petsc">PETSc</a> inexact Newton-Krylov iterative nonlinear solver (SNES).  <a href="classIBTK_1_1PETScNewtonKrylovSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PETScPCLSWrapper.html">PETScPCLSWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PETScPCLSWrapper.html" title="Class PETScPCLSWrapper provides a LinearSolver interface for a PETSc PC object.">PETScPCLSWrapper</a> provides a <a class="el" href="classIBTK_1_1LinearSolver.html" title="Class LinearSolver provides an abstract interface for the implementation of solvers for linear proble...">LinearSolver</a> interface for a <a href="http://www.mcs.anl.gov/petsc">PETSc</a> PC object.  <a href="classIBTK_1_1PETScPCLSWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PETScSAMRAIVectorReal.html">PETScSAMRAIVectorReal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PETScSAMRAIVectorReal.html" title="Class PETScSAMRAIVectorReal is a class for wrapping SAMRAI::solv::SAMRAIVectorReal objects so that th...">PETScSAMRAIVectorReal</a> is a class for wrapping <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a> objects so that they may be used with the <a href="http://www.mcs.anl.gov/petsc">PETSc</a> solver package.  <a href="classIBTK_1_1PETScSAMRAIVectorReal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PETScSNESFunctionGOWrapper.html">PETScSNESFunctionGOWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PETScSNESFunctionGOWrapper.html" title="Class PETScSNESFunctionGOWrapper provides a GeneralOperator interface for a PETSc SNES nonlinear func...">PETScSNESFunctionGOWrapper</a> provides a <a class="el" href="classIBTK_1_1GeneralOperator.html" title="Class GeneralOperator provides an abstract interface for the specification of general operators to co...">GeneralOperator</a> interface for a <a href="http://www.mcs.anl.gov/petsc">PETSc</a> SNES nonlinear function.  <a href="classIBTK_1_1PETScSNESFunctionGOWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PETScSNESJacobianJOWrapper.html">PETScSNESJacobianJOWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PETScSNESJacobianJOWrapper.html" title="Class PETScSNESJacobianJOWrapper provides a JacobianOperator interface for a PETSc SNES Jacobian.">PETScSNESJacobianJOWrapper</a> provides a <a class="el" href="classIBTK_1_1JacobianOperator.html" title="Class JacobianOperator provides an abstract interface for the specification of general operators to c...">JacobianOperator</a> interface for a <a href="http://www.mcs.anl.gov/petsc">PETSc</a> SNES Jacobian.  <a href="classIBTK_1_1PETScSNESJacobianJOWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PETScVecUtilities.html">PETScVecUtilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PETScVecUtilities.html" title="Class PETScVecUtilities provides utility functions for PETSc Vec objects.">PETScVecUtilities</a> provides utility functions for <a href="http://www.mcs.anl.gov/petsc">PETSc</a> Vec objects.  <a href="classIBTK_1_1PETScVecUtilities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PhysicalBoundaryUtilities.html">PhysicalBoundaryUtilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PhysicalBoundaryUtilities.html" title="Class PhysicalBoundaryUtilities is a utility class to organize functions related to setting values at...">PhysicalBoundaryUtilities</a> is a utility class to organize functions related to setting values at physical boundaries.  <a href="classIBTK_1_1PhysicalBoundaryUtilities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PointMap.html">PointMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PoissonFACPreconditioner.html">PoissonFACPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PoissonFACPreconditioner.html" title="Class PoissonFACPreconditioner is a FACPreconditioner that has been specialized for Poisson problems.">PoissonFACPreconditioner</a> is a <a class="el" href="classIBTK_1_1FACPreconditioner.html" title="Class FACPreconditioner is a concrete LinearSolver for implementing FAC (multilevel multigrid) precon...">FACPreconditioner</a> that has been specialized for Poisson problems.  <a href="classIBTK_1_1PoissonFACPreconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PoissonFACPreconditionerStrategy.html">PoissonFACPreconditionerStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PoissonFACPreconditionerStrategy.html" title="Class PoissonFACPreconditionerStrategy is an abstract FACPreconditionerStrategy implementing many of ...">PoissonFACPreconditionerStrategy</a> is an abstract <a class="el" href="classIBTK_1_1FACPreconditionerStrategy.html" title="Class FACPreconditionerStrategy provides an interface for specifying the problem-specific operations ...">FACPreconditionerStrategy</a> implementing many of the operations required by smoothers for the Poisson equation and related problems.  <a href="classIBTK_1_1PoissonFACPreconditionerStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PoissonSolver.html">PoissonSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PoissonSolver.html" title="Class PoissonSolver is an abstract base class for Poisson solvers.">PoissonSolver</a> is an abstract base class for Poisson solvers.  <a href="classIBTK_1_1PoissonSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1PoissonUtilities.html">PoissonUtilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1PoissonUtilities.html" title="Class PoissonUtilities provides utility functions for constructing Poisson solvers.">PoissonUtilities</a> provides utility functions for constructing Poisson solvers.  <a href="classIBTK_1_1PoissonUtilities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1Quad4Mapping.html">Quad4Mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1Quad9Mapping.html">Quad9Mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1QuadratureCache.html">QuadratureCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class storing multiple <a class="el" href="namespacelibMesh.html">libMesh</a> quadrature objects. We assume that quadrature rules are uniquely determined by the element type, quadrature type, and approximation order. There are several places in <a class="el" href="namespaceIBTK.html">IBTK</a> where we make this assumption, e.g., we will use data from two quadrature rules assumed to be equal (by this metric) to initialize FEMap objects.  <a href="classIBTK_1_1QuadratureCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIBTK_1_1QuadratureData.html">QuadratureData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1RefinePatchStrategySet.html">RefinePatchStrategySet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1RefinePatchStrategySet.html" title="Class RefinePatchStrategySet is a utility class that allows multiple SAMRAI::xfer::RefinePatchStrateg...">RefinePatchStrategySet</a> is a utility class that allows multiple <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo...">SAMRAI::xfer::RefinePatchStrategy</a> objects to be employed by a single <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html" title="Class RefineSchedule&lt;DIM&gt; performs the communication operations that refine data to,...">SAMRAI::xfer::RefineSchedule</a>.  <a href="classIBTK_1_1RefinePatchStrategySet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html" title="Class RobinPhysBdryPatchStrategy is an abstract strategy class that extends the SAMRAI::xfer::RefineP...">RobinPhysBdryPatchStrategy</a> is an abstract strategy class that extends the <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo...">SAMRAI::xfer::RefinePatchStrategy</a> interface to provide routines specific for setting Robin boundary conditions at physical boundaries. This class also provides default implementations of some methods defined in <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo...">SAMRAI::xfer::RefinePatchStrategy</a> that are generally not needed for filling ghost cell values at physical boundaries.  <a href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1SAMRAIDataCache.html">SAMRAIDataCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1SAMRAIDataCache.html" title="Class SAMRAIDataCache is a utility class for caching cloned SAMRAI patch data. Patch data are allocat...">SAMRAIDataCache</a> is a utility class for caching cloned <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data. Patch data are allocated as needed and should not be deallocated by the caller.  <a href="classIBTK_1_1SAMRAIDataCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1SAMRAIGhostDataAccumulator.html">SAMRAIGhostDataAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that can accumulate data summed into ghost regions on a patch hierarchy into their correct locations.  <a href="classIBTK_1_1SAMRAIGhostDataAccumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1SAMRAIScopedVectorCopy.html">SAMRAIScopedVectorCopy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1SAMRAIScopedVectorDuplicate.html">SAMRAIScopedVectorDuplicate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1SCLaplaceOperator.html">SCLaplaceOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1SCLaplaceOperator.html" title="Class SCLaplaceOperator is a concrete LaplaceOperator which implements a globally second-order accura...">SCLaplaceOperator</a> is a concrete <a class="el" href="classIBTK_1_1LaplaceOperator.html" title="Class LaplaceOperator is an abstract base class for a Laplace-type operators.">LaplaceOperator</a> which implements a globally second-order accurate side-centered finite difference discretization of a scalar elliptic operator of the form \( L = C I + \nabla \cdot D \nabla\).  <a href="classIBTK_1_1SCLaplaceOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1SCPoissonHypreLevelSolver.html">SCPoissonHypreLevelSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1SCPoissonHypreLevelSolver.html" title="Class SCPoissonHypreLevelSolver is a concrete LinearSolver for solving elliptic equations of the form...">SCPoissonHypreLevelSolver</a> is a concrete <a class="el" href="classIBTK_1_1LinearSolver.html" title="Class LinearSolver provides an abstract interface for the implementation of solvers for linear proble...">LinearSolver</a> for solving elliptic equations of the form \( \mbox{$L u$} = \mbox{$(C I + \nabla \cdot D \nabla) u$} = f \) on a <em>single</em> <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a> using <a href="https://computation.llnl.gov/casc/linear_solvers/sls_hypre.html">hypre</a>.  <a href="classIBTK_1_1SCPoissonHypreLevelSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1SCPoissonPETScLevelSolver.html">SCPoissonPETScLevelSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1SCPoissonPETScLevelSolver.html" title="Class SCPoissonPETScLevelSolver is a concrete PETScLevelSolver for solving elliptic equations of the ...">SCPoissonPETScLevelSolver</a> is a concrete <a class="el" href="classIBTK_1_1PETScLevelSolver.html" title="Class PETScLevelSolver is an abstract LinearSolver for solving systems of linear equations on a singl...">PETScLevelSolver</a> for solving elliptic equations of the form \( \mbox{$L u$} = \mbox{$(C I + \nabla \cdot D \nabla) u$} = f \) on a <em>single</em> <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a> using <a href="http://www.mcs.anl.gov/petsc/petsc-as">PETSc</a>.  <a href="classIBTK_1_1SCPoissonPETScLevelSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1SCPoissonPointRelaxationFACOperator.html">SCPoissonPointRelaxationFACOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1SCPoissonPointRelaxationFACOperator.html" title="Class SCPoissonPointRelaxationFACOperator is a concrete PoissonFACPreconditionerStrategy for solving ...">SCPoissonPointRelaxationFACOperator</a> is a concrete <a class="el" href="classIBTK_1_1PoissonFACPreconditionerStrategy.html" title="Class PoissonFACPreconditionerStrategy is an abstract FACPreconditionerStrategy implementing many of ...">PoissonFACPreconditionerStrategy</a> for solving elliptic equations of the form \( \mbox{$L u$} = \mbox{$(C I + \nabla \cdot D \nabla) u$} = f \) using a globally second-order accurate side-centered finite-difference discretization, with support for Robin and periodic boundary conditions.  <a href="classIBTK_1_1SCPoissonPointRelaxationFACOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1SCPoissonSolverManager.html">SCPoissonSolverManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1SCPoissonSolverManager.html" title="Class SCPoissonSolverManager is a singleton manager class to provide access to generic side-centered ...">SCPoissonSolverManager</a> is a singleton manager class to provide access to generic side-centered <a class="el" href="classIBTK_1_1PoissonSolver.html" title="Class PoissonSolver is an abstract base class for Poisson solvers.">PoissonSolver</a> implementations.  <a href="classIBTK_1_1SCPoissonSolverManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1SecondaryHierarchy.html">SecondaryHierarchy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1SideDataSynchronization.html">SideDataSynchronization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1SideDataSynchronization.html" title="Class SideDataSynchronization encapsulates the operations required to &quot;synchronize&quot; side-centered val...">SideDataSynchronization</a> encapsulates the operations required to "synchronize" side-centered values defined at patch boundaries.  <a href="classIBTK_1_1SideDataSynchronization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1SideNoCornersFillPattern.html">SideNoCornersFillPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class SideCellNoCornersFillPattern is a concrete implementation of the abstract base class <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">SAMRAI::xfer::VariableFillPattern</a>. It is used to calculate overlaps according to a pattern that limits overlaps to the cell-centered ghost region surrounding a patch on the target level, excluding all corners (and, in 3D, patch edges).  <a href="classIBTK_1_1SideNoCornersFillPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1SideSynchCopyFillPattern.html">SideSynchCopyFillPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class SideCellSynchCopyFillPattern is a concrete implementation of the abstract base class <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">SAMRAI::xfer::VariableFillPattern</a>. It is used to calculate overlaps according to a pattern which limits overlaps to the side-centered ghost region surrounding a patch appropriate for "synchronizing" side-centered values at patch boundaries.  <a href="classIBTK_1_1SideSynchCopyFillPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1SnapshotCache.html">SnapshotCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1SnapshotCache.html" title="Class SnapshotCache provides a method of storing snapshots of patch data on a snapshot of the patch h...">SnapshotCache</a> provides a method of storing snapshots of patch data on a snapshot of the patch hierarchy.  <a href="classIBTK_1_1SnapshotCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StableCentroidPartitioner.html">StableCentroidPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespacelibMesh.html">libMesh</a> partitioner that partitions a mesh based on the x coordinate of each centroid in a numerically stable way.  <a href="classIBTK_1_1StableCentroidPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StaggeredPhysicalBoundaryHelper.html">StaggeredPhysicalBoundaryHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1StaggeredPhysicalBoundaryHelper.html" title="Class StaggeredPhysicalBoundaryHelper provides helper functions to handle physical boundary condition...">StaggeredPhysicalBoundaryHelper</a> provides helper functions to handle physical boundary conditions for a staggered grid discretizations.  <a href="classIBTK_1_1StaggeredPhysicalBoundaryHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html">StandardTagAndInitStrategySet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1StandardTagAndInitStrategySet.html" title="Class StandardTagAndInitStrategySet is a utility class that allows multiple SAMRAI::mesh::StandardTag...">StandardTagAndInitStrategySet</a> is a utility class that allows multiple <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a> objects to be employed by a single <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html">SAMRAI::mesh::StandardTagAndInitialize</a> object.  <a href="classIBTK_1_1StandardTagAndInitStrategySet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1Streamable.html">Streamable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1Streamable.html" title="Class Streamable is an abstract interface for objects that can be packed into SAMRAI::tbox::AbstractS...">Streamable</a> is an abstract interface for objects that can be packed into <a class="el" href="classSAMRAI_1_1tbox_1_1AbstractStream.html">SAMRAI::tbox::AbstractStream</a> data streams.  <a href="classIBTK_1_1Streamable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StreamableFactory.html">StreamableFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1StreamableFactory.html" title="Class StreamableFactory is an abstract interface for classes that can unpack particular concrete Stre...">StreamableFactory</a> is an abstract interface for classes that can unpack particular concrete <a class="el" href="classIBTK_1_1Streamable.html" title="Class Streamable is an abstract interface for objects that can be packed into SAMRAI::tbox::AbstractS...">Streamable</a> objects from <a class="el" href="classSAMRAI_1_1tbox_1_1AbstractStream.html">SAMRAI::tbox::AbstractStream</a> data streams.  <a href="classIBTK_1_1StreamableFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1StreamableManager.html">StreamableManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1StreamableManager.html" title="Class StreamableManager is a singleton manager class that organizes the actual packing and unpacking ...">StreamableManager</a> is a singleton manager class that organizes the actual packing and unpacking of concrete <a class="el" href="classIBTK_1_1Streamable.html" title="Class Streamable is an abstract interface for objects that can be packed into SAMRAI::tbox::AbstractS...">Streamable</a> objects for <a class="el" href="classSAMRAI_1_1tbox_1_1AbstractStream.html">SAMRAI::tbox::AbstractStream</a> based communication.  <a href="classIBTK_1_1StreamableManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1SubdomainToPatchLevelTranslation.html">SubdomainToPatchLevelTranslation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIBTK_1_1SystemData.html">SystemData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1Tet10Mapping.html">Tet10Mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1Tet4Mapping.html">Tet4Mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1Tri3Mapping.html">Tri3Mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1Tri6Mapping.html">Tri6Mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1VCSCViscousOperator.html">VCSCViscousOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1VCSCViscousOperator.html" title="Class VCSCViscousOperator is a subclass of SCLaplaceOperator which implements a globally second-order...">VCSCViscousOperator</a> is a subclass of <a class="el" href="classIBTK_1_1SCLaplaceOperator.html" title="Class SCLaplaceOperator is a concrete LaplaceOperator which implements a globally second-order accura...">SCLaplaceOperator</a> which implements a globally second-order accurate side-centered finite difference discretization of a vector elliptic operator of the form \( L = \beta C I + \alpha \nabla \cdot \mu ( (\nabla u) + (\nabla u)^T ) \).  <a href="classIBTK_1_1VCSCViscousOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1VCSCViscousOpPointRelaxationFACOperator.html">VCSCViscousOpPointRelaxationFACOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1VCSCViscousOpPointRelaxationFACOperator.html" title="Class VCSCViscousOpPointRelaxationFACOperator is a specialization of SCPoissonPointRelaxationFACOpera...">VCSCViscousOpPointRelaxationFACOperator</a> is a specialization of <a class="el" href="classIBTK_1_1SCPoissonPointRelaxationFACOperator.html" title="Class SCPoissonPointRelaxationFACOperator is a concrete PoissonFACPreconditionerStrategy for solving ...">SCPoissonPointRelaxationFACOperator</a> for solving vector elliptic equation of the form \( \mbox{$L u$} = C u + \nabla \cdot \mu (\nabla u + (\nabla u)^T) = f \) using a globally second-order accurate side-centered finite-difference discretization, with support for Robin and periodic boundary conditions.  <a href="classIBTK_1_1VCSCViscousOpPointRelaxationFACOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1VCSCViscousPETScLevelSolver.html">VCSCViscousPETScLevelSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classIBTK_1_1VCSCViscousPETScLevelSolver.html" title="Class VCSCViscousPETScLevelSolver is a subclass of SCPoissonPETScLevelSolver class which solves vecto...">VCSCViscousPETScLevelSolver</a> is a subclass of <a class="el" href="classIBTK_1_1SCPoissonPETScLevelSolver.html" title="Class SCPoissonPETScLevelSolver is a concrete PETScLevelSolver for solving elliptic equations of the ...">SCPoissonPETScLevelSolver</a> class which solves vector-valued elliptic equation of the form \( \mbox{$L u$} = C u + \nabla \cdot \mu (\nabla u + (\nabla u)^T) = f \) on a <em>single</em> <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a> using <a href="http://www.mcs.anl.gov/petsc/petsc-as">PETSc</a>.  <a href="classIBTK_1_1VCSCViscousPETScLevelSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4e421bc18e78027f97855673b767bdc5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e421bc18e78027f97855673b767bdc5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a4e421bc18e78027f97855673b767bdc5">EigenAlignedVector</a> = std::vector&lt; T &gt;</td></tr>
<tr class="separator:a4e421bc18e78027f97855673b767bdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9a16623626884f27ea03f128cadfcb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#adf9a16623626884f27ea03f128cadfcb">Matrix2d</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, 2, 2 &gt;</td></tr>
<tr class="separator:adf9a16623626884f27ea03f128cadfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c2c9e6af54a75b53b2899e1dd737c9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a57c2c9e6af54a75b53b2899e1dd737c9">Vector2d</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, 2, 1 &gt;</td></tr>
<tr class="separator:a57c2c9e6af54a75b53b2899e1dd737c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b3ea7366a0fe96f56b0200bc1b8e77"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a93b3ea7366a0fe96f56b0200bc1b8e77">ColumnVector2d</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, 2, 1 &gt;</td></tr>
<tr class="separator:a93b3ea7366a0fe96f56b0200bc1b8e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7055bb6960f6fc39aa553494fb69d4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a8d7055bb6960f6fc39aa553494fb69d4">RowVector2d</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, 1, 2 &gt;</td></tr>
<tr class="separator:a8d7055bb6960f6fc39aa553494fb69d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ad687550740b96db47464cde5721f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a82ad687550740b96db47464cde5721f4">Matrix3d</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, 3, 3 &gt;</td></tr>
<tr class="separator:a82ad687550740b96db47464cde5721f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ae9d461191bfbc3f356a669835f365"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ab4ae9d461191bfbc3f356a669835f365">Vector3d</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, 3, 1 &gt;</td></tr>
<tr class="separator:ab4ae9d461191bfbc3f356a669835f365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed427cf9ba7c7dc4fccefdaba4be823b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#aed427cf9ba7c7dc4fccefdaba4be823b">ColumnVector3d</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, 3, 1 &gt;</td></tr>
<tr class="separator:aed427cf9ba7c7dc4fccefdaba4be823b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada34760f7623fade0ba21f04b76dcf63"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ada34760f7623fade0ba21f04b76dcf63">RowVector3d</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, 1, 3 &gt;</td></tr>
<tr class="separator:ada34760f7623fade0ba21f04b76dcf63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f18d4de9fe15f20d78f4f943f818bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a67f18d4de9fe15f20d78f4f943f818bc">MatrixNd</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, NDIM, NDIM &gt;</td></tr>
<tr class="separator:a67f18d4de9fe15f20d78f4f943f818bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b73983d16b31c6192694e6101f57273"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a2b73983d16b31c6192694e6101f57273">VectorNd</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, NDIM, 1 &gt;</td></tr>
<tr class="separator:a2b73983d16b31c6192694e6101f57273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1137eefc68da668954ab11a43255186"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#af1137eefc68da668954ab11a43255186">ColumnVectorNd</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, NDIM, 1 &gt;</td></tr>
<tr class="separator:af1137eefc68da668954ab11a43255186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca334f5726a653bdade6bb25e533b533"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#aca334f5726a653bdade6bb25e533b533">RowVectorNd</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, 1, NDIM &gt;</td></tr>
<tr class="separator:aca334f5726a653bdade6bb25e533b533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3d55a318b465924a7a4a9163c650ad"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a1b3d55a318b465924a7a4a9163c650ad">MatrixXd</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a1b3d55a318b465924a7a4a9163c650ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c64fdd39a3b5adab73e8d5173aa9d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a12c64fdd39a3b5adab73e8d5173aa9d2">VectorXd</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:a12c64fdd39a3b5adab73e8d5173aa9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451e0b737a3282a03632af2b90f8c026"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a451e0b737a3282a03632af2b90f8c026">ColumnVectorXd</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:a451e0b737a3282a03632af2b90f8c026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839aacfd5da68aab82ccc0838f86d27a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a839aacfd5da68aab82ccc0838f86d27a">RowVectorXd</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a839aacfd5da68aab82ccc0838f86d27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571dee285c7f5b44c20ffb11a1b96ed3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a571dee285c7f5b44c20ffb11a1b96ed3">Matrix</a> = <a class="el" href="namespaceIBTK.html#a67f18d4de9fe15f20d78f4f943f818bc">MatrixNd</a></td></tr>
<tr class="separator:a571dee285c7f5b44c20ffb11a1b96ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c97469e791a47756eb44b9ec93c59e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">Point</a> = <a class="el" href="namespaceIBTK.html#a2b73983d16b31c6192694e6101f57273">VectorNd</a></td></tr>
<tr class="separator:ac8c97469e791a47756eb44b9ec93c59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a4d4ded781c3a9630a42d88680e89f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a09a4d4ded781c3a9630a42d88680e89f">Vector</a> = <a class="el" href="namespaceIBTK.html#a2b73983d16b31c6192694e6101f57273">VectorNd</a></td></tr>
<tr class="separator:a09a4d4ded781c3a9630a42d88680e89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5c7844e08cab1447e1ce7423a5fa3c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">RigidDOFVector</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="namespaceIBTK.html#a6fd93a9c16e327725aa68e0b9c43e800">s_max_free_dofs</a>, 1 &gt;</td></tr>
<tr class="separator:a0d5c7844e08cab1447e1ce7423a5fa3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17100e3633baaf42d5aae6933b8e5db"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ad17100e3633baaf42d5aae6933b8e5db">FreeRigidDOFVector</a> = Eigen::Matrix&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="namespaceIBTK.html#a6fd93a9c16e327725aa68e0b9c43e800">s_max_free_dofs</a>, 1 &gt;</td></tr>
<tr class="separator:ad17100e3633baaf42d5aae6933b8e5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3765caccae641a3ff08f3bed8798af5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ad3765caccae641a3ff08f3bed8798af5">RDV</a> = <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">RigidDOFVector</a></td></tr>
<tr class="separator:ad3765caccae641a3ff08f3bed8798af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac19301c6fd0897bd5254ffad040e24c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#aac19301c6fd0897bd5254ffad040e24c">FRDV</a> = <a class="el" href="namespaceIBTK.html#ad17100e3633baaf42d5aae6933b8e5db">FreeRigidDOFVector</a></td></tr>
<tr class="separator:aac19301c6fd0897bd5254ffad040e24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6516d72a11e660ef8321ed1ed6b119d0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a6516d72a11e660ef8321ed1ed6b119d0">IndexFortranOrder</a> = struct <a class="el" href="structIBTK_1_1IndexOrder.html">IndexOrder</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">SAMRAI::hier::Index</a>&lt; NDIM &gt; &gt;</td></tr>
<tr class="separator:a6516d72a11e660ef8321ed1ed6b119d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bbac2eaf9010f28398d4c6a27cef96"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a98bbac2eaf9010f28398d4c6a27cef96">CellIndexFortranOrder</a> = struct <a class="el" href="structIBTK_1_1IndexOrder.html">IndexOrder</a>&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1CellIndex.html">SAMRAI::pdat::CellIndex</a>&lt; NDIM &gt; &gt;</td></tr>
<tr class="separator:a98bbac2eaf9010f28398d4c6a27cef96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcbdcaac090060b5a4ee6d10120911b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a8dcbdcaac090060b5a4ee6d10120911b">quadrature_key_type</a> = std::tuple&lt; libMesh::ElemType, libMesh::QuadratureType, libMesh::Order, <a class="el" href="classbool.html">bool</a> &gt;</td></tr>
<tr class="separator:a8dcbdcaac090060b5a4ee6d10120911b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f04732f2606c4a49ff92ca5b3c514b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a3f04732f2606c4a49ff92ca5b3c514b9">ScalarMeshFcnPtr</a> = void(*)(<a class="el" href="classdouble.html">double</a> &amp;F, const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;FF, const libMesh::Point &amp;x, const libMesh::Point &amp;X, libMesh::Elem *elem, const std::vector&lt; const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &amp;system_var_data, const std::vector&lt; const std::vector&lt; <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; * &gt; &amp;system_grad_var_data, <a class="el" href="classdouble.html">double</a> data_time, void *ctx)</td></tr>
<tr class="separator:a3f04732f2606c4a49ff92ca5b3c514b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503cb21b0cf0bd3e1ed168623b674d8e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a503cb21b0cf0bd3e1ed168623b674d8e">VectorMeshFcnPtr</a> = void(*)(<a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F, const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;FF, const libMesh::Point &amp;x, const libMesh::Point &amp;X, libMesh::Elem *elem, const std::vector&lt; const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &amp;system_var_data, const std::vector&lt; const std::vector&lt; <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; * &gt; &amp;system_grad_var_data, <a class="el" href="classdouble.html">double</a> data_time, void *ctx)</td></tr>
<tr class="separator:a503cb21b0cf0bd3e1ed168623b674d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2047e8d6003cdf2c5017d741cad69907"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a2047e8d6003cdf2c5017d741cad69907">TensorMeshFcnPtr</a> = void(*)(<a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F, const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;FF, const libMesh::Point &amp;x, const libMesh::Point &amp;X, libMesh::Elem *elem, const std::vector&lt; const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &amp;system_var_data, const std::vector&lt; const std::vector&lt; <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; * &gt; &amp;system_grad_var_data, <a class="el" href="classdouble.html">double</a> data_time, void *ctx)</td></tr>
<tr class="separator:a2047e8d6003cdf2c5017d741cad69907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0828e2d557e67a201c8526a7c9b761b0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a0828e2d557e67a201c8526a7c9b761b0">ScalarSurfaceFcnPtr</a> = void(*)(<a class="el" href="classdouble.html">double</a> &amp;F, const <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;n, const <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;N, const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;FF, const libMesh::Point &amp;x, const libMesh::Point &amp;X, libMesh::Elem *elem, unsigned short <a class="el" href="classint.html">int</a> side, const std::vector&lt; const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &amp;system_var_data, const std::vector&lt; const std::vector&lt; <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; * &gt; &amp;system_grad_var_data, <a class="el" href="classdouble.html">double</a> data_time, void *ctx)</td></tr>
<tr class="separator:a0828e2d557e67a201c8526a7c9b761b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45007c53f48bbf752259fcec0884767c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a45007c53f48bbf752259fcec0884767c">VectorSurfaceFcnPtr</a> = void(*)(<a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F, const <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;n, const <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;N, const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;FF, const libMesh::Point &amp;x, const libMesh::Point &amp;X, libMesh::Elem *elem, unsigned short <a class="el" href="classint.html">int</a> side, const std::vector&lt; const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &amp;system_var_data, const std::vector&lt; const std::vector&lt; <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; * &gt; &amp;system_grad_var_data, <a class="el" href="classdouble.html">double</a> data_time, void *ctx)</td></tr>
<tr class="separator:a45007c53f48bbf752259fcec0884767c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae611604880133ce595ea19e89a73b182"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ae611604880133ce595ea19e89a73b182">TensorSurfaceFcnPtr</a> = void(*)(<a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F, const <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;n, const <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;N, const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;FF, const libMesh::Point &amp;x, const libMesh::Point &amp;X, libMesh::Elem *elem, unsigned short <a class="el" href="classint.html">int</a> side, const std::vector&lt; const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &amp;system_var_data, const std::vector&lt; const std::vector&lt; <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; * &gt; &amp;system_grad_var_data, <a class="el" href="classdouble.html">double</a> data_time, void *ctx)</td></tr>
<tr class="separator:ae611604880133ce595ea19e89a73b182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d1dccdfce78faf8f3f8a0a2bd7f77f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a49d1dccdfce78faf8f3f8a0a2bd7f77f">LNodeIndexSet</a> = <a class="el" href="classIBTK_1_1LSet.html">LSet</a>&lt; <a class="el" href="classIBTK_1_1LNodeIndex.html">LNodeIndex</a> &gt;</td></tr>
<tr class="separator:a49d1dccdfce78faf8f3f8a0a2bd7f77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c6e91d089ec5775d73b824dd4ac456"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a26c6e91d089ec5775d73b824dd4ac456">LNodeIndexSetData</a> = <a class="el" href="classIBTK_1_1LIndexSetData.html">LIndexSetData</a>&lt; <a class="el" href="classIBTK_1_1LNodeIndex.html">LNodeIndex</a> &gt;</td></tr>
<tr class="separator:a26c6e91d089ec5775d73b824dd4ac456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c714ac40dfb45d45a0f1a3a9ac79e96"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a9c714ac40dfb45d45a0f1a3a9ac79e96">LNodeIndexSetDataFactory</a> = <a class="el" href="classIBTK_1_1LIndexSetDataFactory.html">LIndexSetDataFactory</a>&lt; <a class="el" href="classIBTK_1_1LNodeIndex.html">LNodeIndex</a> &gt;</td></tr>
<tr class="separator:a9c714ac40dfb45d45a0f1a3a9ac79e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fb2c83a523385b5d1c6fb70ff41b1f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a18fb2c83a523385b5d1c6fb70ff41b1f">LNodeIndexSetDataIterator</a> = <a class="el" href="classIBTK_1_1LSetDataIterator.html">LSetDataIterator</a>&lt; <a class="el" href="classIBTK_1_1LNodeIndex.html">LNodeIndex</a> &gt;</td></tr>
<tr class="separator:a18fb2c83a523385b5d1c6fb70ff41b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fe4ea71ef285edd7994e07e781cdf5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a93fe4ea71ef285edd7994e07e781cdf5">LNodeIndexSetVariable</a> = <a class="el" href="classIBTK_1_1LIndexSetVariable.html">LIndexSetVariable</a>&lt; <a class="el" href="classIBTK_1_1LNodeIndex.html">LNodeIndex</a> &gt;</td></tr>
<tr class="separator:a93fe4ea71ef285edd7994e07e781cdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b022d253611a53adfa402422e613d04"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a6b022d253611a53adfa402422e613d04">LNodeIndexTransaction</a> = <a class="el" href="classIBTK_1_1LTransaction.html">LTransaction</a>&lt; <a class="el" href="classIBTK_1_1LNodeIndex.html">LNodeIndex</a> &gt;</td></tr>
<tr class="separator:a6b022d253611a53adfa402422e613d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5e5af7d75b4b4246dd44d65c5439b0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a6e5e5af7d75b4b4246dd44d65c5439b0">LNodeSet</a> = <a class="el" href="classIBTK_1_1LSet.html">LSet</a>&lt; <a class="el" href="classIBTK_1_1LNode.html">LNode</a> &gt;</td></tr>
<tr class="separator:a6e5e5af7d75b4b4246dd44d65c5439b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd5c02a25ef1925fd161c7297ff5224"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a9dd5c02a25ef1925fd161c7297ff5224">LNodeSetData</a> = <a class="el" href="classIBTK_1_1LIndexSetData.html">LIndexSetData</a>&lt; <a class="el" href="classIBTK_1_1LNode.html">LNode</a> &gt;</td></tr>
<tr class="separator:a9dd5c02a25ef1925fd161c7297ff5224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab528c6bbf975269300b58d8178263599"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ab528c6bbf975269300b58d8178263599">LNodeSetDataFactory</a> = <a class="el" href="classIBTK_1_1LIndexSetDataFactory.html">LIndexSetDataFactory</a>&lt; <a class="el" href="classIBTK_1_1LNode.html">LNode</a> &gt;</td></tr>
<tr class="separator:ab528c6bbf975269300b58d8178263599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1a0390039ab214bee68db589e9014b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#aac1a0390039ab214bee68db589e9014b">LNodeSetDataIterator</a> = <a class="el" href="classIBTK_1_1LSetDataIterator.html">LSetDataIterator</a>&lt; <a class="el" href="classIBTK_1_1LNode.html">LNode</a> &gt;</td></tr>
<tr class="separator:aac1a0390039ab214bee68db589e9014b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb9f4aa1a24bc680e2744c833f6d439"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a9eb9f4aa1a24bc680e2744c833f6d439">LNodeSetVariable</a> = <a class="el" href="classIBTK_1_1LIndexSetVariable.html">LIndexSetVariable</a>&lt; <a class="el" href="classIBTK_1_1LNode.html">LNode</a> &gt;</td></tr>
<tr class="separator:a9eb9f4aa1a24bc680e2744c833f6d439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed20f3055d55d60889801d99ef671c1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#aeed20f3055d55d60889801d99ef671c1">LNodeTransaction</a> = <a class="el" href="classIBTK_1_1LTransaction.html">LTransaction</a>&lt; <a class="el" href="classIBTK_1_1LNode.html">LNode</a> &gt;</td></tr>
<tr class="separator:aeed20f3055d55d60889801d99ef671c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae8048f832efc6a3000180a8b59de9091"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> { <br />
&#160;&#160;<a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091a643d9c888b06a36de3593a171a6d456d">update_default</a> = 0, 
<a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091a9f04987cef3783ee1f9329eca30c5558">update_phi</a> = 1, 
<a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091acd49d3ad2cb8bd317153305be3d4245e">update_dphi</a> = 2, 
<a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091a58e0e6170d8bbc6c71e3178134956a98">update_contravariants</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091aa95b826ef42215b565c40633467c357e">update_covariants</a> = 8, 
<a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091a29569a61a25961316d205f2c5fb2a9f0">update_jacobians</a> = 16, 
<a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091adbc46effec6a8d7a3e96045f6c824059">update_JxW</a> = 32, 
<a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091a1203d6d0b8a28ce88108337cc289a477">update_quadrature_points</a> = 64
<br />
 }</td></tr>
<tr class="separator:ae8048f832efc6a3000180a8b59de9091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19008659d5b79c98ba2edfefb73b17a0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a19008659d5b79c98ba2edfefb73b17a0">MGCycleType</a> { <br />
&#160;&#160;<a class="el" href="namespaceIBTK.html#a19008659d5b79c98ba2edfefb73b17a0a156cbdd231d67047a3b27eae8ac3f88f">F_CYCLE</a>, 
<a class="el" href="namespaceIBTK.html#a19008659d5b79c98ba2edfefb73b17a0a81a2ba87e1aa986e59289c8eb4ed1c13">FMG_CYCLE</a>, 
<a class="el" href="namespaceIBTK.html#a19008659d5b79c98ba2edfefb73b17a0a4276274af2aebba7074c81f0b48a8cd6">V_CYCLE</a>, 
<a class="el" href="namespaceIBTK.html#a19008659d5b79c98ba2edfefb73b17a0a60c9e8c9557dcb352803949f98afccf5">W_CYCLE</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceIBTK.html#a19008659d5b79c98ba2edfefb73b17a0af294963103e6075fd34881d6c9762e29">UNKNOWN_MG_CYCLE_TYPE</a> = -1
<br />
 }</td></tr>
<tr class="memdesc:a19008659d5b79c98ba2edfefb73b17a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type for different multigrid cycle types.  <a href="namespaceIBTK.html#a19008659d5b79c98ba2edfefb73b17a0">More...</a><br /></td></tr>
<tr class="separator:a19008659d5b79c98ba2edfefb73b17a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe95f73a473353d18098f9fbf7ba8567"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#afe95f73a473353d18098f9fbf7ba8567">RegridMode</a> { <a class="el" href="namespaceIBTK.html#afe95f73a473353d18098f9fbf7ba8567af15af331bad16eed6efe38d5169f389a">STANDARD</a>, 
<a class="el" href="namespaceIBTK.html#afe95f73a473353d18098f9fbf7ba8567ad83ecc46228a4c8bce60a4df8a49056b">AGGRESSIVE</a>, 
<a class="el" href="namespaceIBTK.html#afe95f73a473353d18098f9fbf7ba8567a6ddad444aaee260c5a0f11d6f2d027ed">UNKNOWN_REGRID_MODE</a> = -1
 }</td></tr>
<tr class="memdesc:afe95f73a473353d18098f9fbf7ba8567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type for different regridding modes.  <a href="namespaceIBTK.html#afe95f73a473353d18098f9fbf7ba8567">More...</a><br /></td></tr>
<tr class="separator:afe95f73a473353d18098f9fbf7ba8567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081318a0a7bce6de82de3b81dd67794a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a081318a0a7bce6de82de3b81dd67794a">VariableContextType</a> { <a class="el" href="namespaceIBTK.html#a081318a0a7bce6de82de3b81dd67794aa0df46afff987d6d92771ec52b3959977">CURRENT_DATA</a>, 
<a class="el" href="namespaceIBTK.html#a081318a0a7bce6de82de3b81dd67794aada90f57d09ce8251d4fa58fb1dba62de">NEW_DATA</a>, 
<a class="el" href="namespaceIBTK.html#a081318a0a7bce6de82de3b81dd67794aadd219ea2dc8002f9770549207756660b">SCRATCH_DATA</a>, 
<a class="el" href="namespaceIBTK.html#a081318a0a7bce6de82de3b81dd67794aa835fb1cef6648c4647717485e1e41c26">UNKNOWN_VARIABLE_CONTEXT_TYPE</a> = -1
 }</td></tr>
<tr class="memdesc:a081318a0a7bce6de82de3b81dd67794a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type for different standard data contexts.  <a href="namespaceIBTK.html#a081318a0a7bce6de82de3b81dd67794a">More...</a><br /></td></tr>
<tr class="separator:a081318a0a7bce6de82de3b81dd67794a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0e485ab1820bbc97d938e4131d3972"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#aca0e485ab1820bbc97d938e4131d3972">VCInterpType</a> { <a class="el" href="namespaceIBTK.html#aca0e485ab1820bbc97d938e4131d3972af82189324a86df10848193c85bcf6bd8">VC_AVERAGE_INTERP</a> = 1, 
<a class="el" href="namespaceIBTK.html#aca0e485ab1820bbc97d938e4131d3972ad16a4e03cf055272a86cca038c6b65d6">VC_HARMONIC_INTERP</a> = 2, 
<a class="el" href="namespaceIBTK.html#aca0e485ab1820bbc97d938e4131d3972adaad48ad56a9e40158d2e57cb8edaa49">UNKNOWN_VC_INTERP_TYPE</a> = -1
 }</td></tr>
<tr class="memdesc:aca0e485ab1820bbc97d938e4131d3972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type for different interpolation types for the material properties of the viscous solver.  <a href="namespaceIBTK.html#aca0e485ab1820bbc97d938e4131d3972">More...</a><br /></td></tr>
<tr class="separator:aca0e485ab1820bbc97d938e4131d3972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f11b6d5086d88dfb13c1518bf8b6afd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a4f11b6d5086d88dfb13c1518bf8b6afd">NodeOutsidePatchCheckType</a> { <a class="el" href="namespaceIBTK.html#a4f11b6d5086d88dfb13c1518bf8b6afda178e0cd3931e20acc7e3b793518b1b6d">NODE_OUTSIDE_PERMIT</a> = 1, 
<a class="el" href="namespaceIBTK.html#a4f11b6d5086d88dfb13c1518bf8b6afdaeb02e5ca8910018e8986c55c86d03673">NODE_OUTSIDE_WARN</a> = 2, 
<a class="el" href="namespaceIBTK.html#a4f11b6d5086d88dfb13c1518bf8b6afda3ac623c23d3170654eb95589df58b3d3">NODE_OUTSIDE_ERROR</a> = 3, 
<a class="el" href="namespaceIBTK.html#a4f11b6d5086d88dfb13c1518bf8b6afda35b564b3c008a8bcb27eb3ce4ab3e4f1">UNKNOWN_NODE_OUTSIDE_PATCH_CHECK_TYPE</a> = -1
 }</td></tr>
<tr class="separator:a4f11b6d5086d88dfb13c1518bf8b6afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c7f8cb3eb8f785386fb3be5d246782"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782">TimePoint</a> { <a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782abc9cd2d8ebda07c7f1ce0a1d9a94c7cc">TimePoint::CURRENT_TIME</a>, 
<a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782ab763f44331074a91fe69ede12eac324b">TimePoint::HALF_TIME</a>, 
<a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782a9651fb594d683bfce76bb192716db1e1">TimePoint::NEW_TIME</a>, 
<a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782ac7f94f555b90ba339323af50894ea46b">TimePoint::UNKNOWN_TIME</a>
 }</td></tr>
<tr class="separator:a37c7f8cb3eb8f785386fb3be5d246782"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a26083fd9213059180492800c432649a2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a26083fd9213059180492800c432649a2">merge_boxes_by_longest_edge</a> (const std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &gt; &amp;boxes)</td></tr>
<tr class="separator:a26083fd9213059180492800c432649a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2f64610b7d15183ce7e534a2f8a800"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a9a2f64610b7d15183ce7e534a2f8a800">operator&amp;</a> (const <a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> f1, const <a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> f2)</td></tr>
<tr class="separator:a9a2f64610b7d15183ce7e534a2f8a800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec91280c11f51e37e3b3f17c2c814a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#aeec91280c11f51e37e3b3f17c2c814a6">operator|</a> (const <a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> f1, const <a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> f2)</td></tr>
<tr class="separator:aeec91280c11f51e37e3b3f17c2c814a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e94038433d94b44c668708c398e402"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a57e94038433d94b44c668708c398e402">operator|=</a> (<a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> &amp;f1, const <a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> f2)</td></tr>
<tr class="separator:a57e94038433d94b44c668708c398e402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1582f6fd26602fbcf4515d3087f70b96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a1582f6fd26602fbcf4515d3087f70b96">operator&amp;=</a> (<a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> &amp;f1, const <a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> f2)</td></tr>
<tr class="separator:a1582f6fd26602fbcf4515d3087f70b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378982fbd968cc2b71685926f391cf97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a378982fbd968cc2b71685926f391cf97"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a378982fbd968cc2b71685926f391cf97">string_to_enum</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a378982fbd968cc2b71685926f391cf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine for converting strings to enums.  <a href="namespaceIBTK.html#a378982fbd968cc2b71685926f391cf97">More...</a><br /></td></tr>
<tr class="separator:a378982fbd968cc2b71685926f391cf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c9374e709f84b9a7bf5b61f8064ecc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa7c9374e709f84b9a7bf5b61f8064ecc"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#aa7c9374e709f84b9a7bf5b61f8064ecc">enum_to_string</a> (T)</td></tr>
<tr class="memdesc:aa7c9374e709f84b9a7bf5b61f8064ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine for converting enums to strings.  <a href="namespaceIBTK.html#aa7c9374e709f84b9a7bf5b61f8064ecc">More...</a><br /></td></tr>
<tr class="separator:aa7c9374e709f84b9a7bf5b61f8064ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7ca4acf7739400e4b1bba7413312c3"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7a7ca4acf7739400e4b1bba7413312c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceIBTK.html#a19008659d5b79c98ba2edfefb73b17a0">MGCycleType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a7a7ca4acf7739400e4b1bba7413312c3">string_to_enum&lt; MGCycleType &gt;</a> (const std::string &amp;val)</td></tr>
<tr class="separator:a7a7ca4acf7739400e4b1bba7413312c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f7c26c6b5f0c7960f38f41f9c5a3c4"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af6f7c26c6b5f0c7960f38f41f9c5a3c4"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#af6f7c26c6b5f0c7960f38f41f9c5a3c4">enum_to_string&lt; MGCycleType &gt;</a> (<a class="el" href="namespaceIBTK.html#a19008659d5b79c98ba2edfefb73b17a0">MGCycleType</a> val)</td></tr>
<tr class="separator:af6f7c26c6b5f0c7960f38f41f9c5a3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fd86235dfd906319dea3bebb9e5c57"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab4fd86235dfd906319dea3bebb9e5c57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceIBTK.html#afe95f73a473353d18098f9fbf7ba8567">RegridMode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ab4fd86235dfd906319dea3bebb9e5c57">string_to_enum&lt; RegridMode &gt;</a> (const std::string &amp;val)</td></tr>
<tr class="separator:ab4fd86235dfd906319dea3bebb9e5c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03001e01e2b7846bf23e2b0a5f039768"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a03001e01e2b7846bf23e2b0a5f039768"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a03001e01e2b7846bf23e2b0a5f039768">enum_to_string&lt; RegridMode &gt;</a> (<a class="el" href="namespaceIBTK.html#afe95f73a473353d18098f9fbf7ba8567">RegridMode</a> val)</td></tr>
<tr class="separator:a03001e01e2b7846bf23e2b0a5f039768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52eba6c97612fff98f870ce29db3555"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa52eba6c97612fff98f870ce29db3555"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceIBTK.html#a081318a0a7bce6de82de3b81dd67794a">VariableContextType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#aa52eba6c97612fff98f870ce29db3555">string_to_enum&lt; VariableContextType &gt;</a> (const std::string &amp;val)</td></tr>
<tr class="separator:aa52eba6c97612fff98f870ce29db3555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97bf54893b2b6fbe523a7a296367247"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac97bf54893b2b6fbe523a7a296367247"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ac97bf54893b2b6fbe523a7a296367247">enum_to_string&lt; VariableContextType &gt;</a> (<a class="el" href="namespaceIBTK.html#a081318a0a7bce6de82de3b81dd67794a">VariableContextType</a> val)</td></tr>
<tr class="separator:ac97bf54893b2b6fbe523a7a296367247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6e3ba6c157be86c5696008d59b5f4d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9f6e3ba6c157be86c5696008d59b5f4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceIBTK.html#aca0e485ab1820bbc97d938e4131d3972">VCInterpType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a9f6e3ba6c157be86c5696008d59b5f4d">string_to_enum&lt; VCInterpType &gt;</a> (const std::string &amp;val)</td></tr>
<tr class="separator:a9f6e3ba6c157be86c5696008d59b5f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031c25dc335135dda3025f2705d3f04a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a031c25dc335135dda3025f2705d3f04a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a031c25dc335135dda3025f2705d3f04a">enum_to_string&lt; VCInterpType &gt;</a> (<a class="el" href="namespaceIBTK.html#aca0e485ab1820bbc97d938e4131d3972">VCInterpType</a> val)</td></tr>
<tr class="separator:a031c25dc335135dda3025f2705d3f04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1008d47ad40da2288b3ba08307784a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6f1008d47ad40da2288b3ba08307784a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceIBTK.html#a4f11b6d5086d88dfb13c1518bf8b6afd">NodeOutsidePatchCheckType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a6f1008d47ad40da2288b3ba08307784a">string_to_enum&lt; NodeOutsidePatchCheckType &gt;</a> (const std::string &amp;val)</td></tr>
<tr class="separator:a6f1008d47ad40da2288b3ba08307784a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfaff651ceafd14e9c2d55955a09e53"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:abbfaff651ceafd14e9c2d55955a09e53"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#abbfaff651ceafd14e9c2d55955a09e53">enum_to_string&lt; NodeOutsidePatchCheckType &gt;</a> (<a class="el" href="namespaceIBTK.html#a4f11b6d5086d88dfb13c1518bf8b6afd">NodeOutsidePatchCheckType</a> val)</td></tr>
<tr class="separator:abbfaff651ceafd14e9c2d55955a09e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0c3eb2d7962831f32374c8b174f266"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aae0c3eb2d7962831f32374c8b174f266"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782">TimePoint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#aae0c3eb2d7962831f32374c8b174f266">string_to_enum&lt; TimePoint &gt;</a> (const std::string &amp;val)</td></tr>
<tr class="separator:aae0c3eb2d7962831f32374c8b174f266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891e0de16b7751a71a1b9147ea123c24"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a891e0de16b7751a71a1b9147ea123c24"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a891e0de16b7751a71a1b9147ea123c24">enum_to_string&lt; TimePoint &gt;</a> (<a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782">TimePoint</a> val)</td></tr>
<tr class="separator:a891e0de16b7751a71a1b9147ea123c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddabfcd34ababf0834ec38c2a7c4c39"><td class="memItemLeft" align="right" valign="top">MPI_Datatype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a6ddabfcd34ababf0834ec38c2a7c4c39">mpi_type_id</a> (const <a class="el" href="classdouble.html">double</a>)</td></tr>
<tr class="separator:a6ddabfcd34ababf0834ec38c2a7c4c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c691a2b1f28c51707460a095cf2b15"><td class="memItemLeft" align="right" valign="top">MPI_Datatype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ad8c691a2b1f28c51707460a095cf2b15">mpi_type_id</a> (const std::pair&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="classint.html">int</a> &gt;)</td></tr>
<tr class="separator:ad8c691a2b1f28c51707460a095cf2b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b0c51d3da18f6ce9bd90804cebbb51"><td class="memItemLeft" align="right" valign="top">MPI_Datatype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a57b0c51d3da18f6ce9bd90804cebbb51">mpi_type_id</a> (const <a class="el" href="classint.html">int</a>)</td></tr>
<tr class="separator:a57b0c51d3da18f6ce9bd90804cebbb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73599fa4fc37abf78a70e601b2f8695"><td class="memItemLeft" align="right" valign="top">MPI_Datatype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ae73599fa4fc37abf78a70e601b2f8695">mpi_type_id</a> (const std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt;)</td></tr>
<tr class="separator:ae73599fa4fc37abf78a70e601b2f8695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd3c0b75d6cecc44097ab5fc55c10d3"><td class="memItemLeft" align="right" valign="top">MPI_Datatype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a8fd3c0b75d6cecc44097ab5fc55c10d3">mpi_type_id</a> (const float)</td></tr>
<tr class="separator:a8fd3c0b75d6cecc44097ab5fc55c10d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795e57846fae15ab87c8cede49ea627e"><td class="memItemLeft" align="right" valign="top">MPI_Datatype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a795e57846fae15ab87c8cede49ea627e">mpi_type_id</a> (const std::pair&lt; float, <a class="el" href="classint.html">int</a> &gt;)</td></tr>
<tr class="separator:a795e57846fae15ab87c8cede49ea627e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbcd21d326bb27292544e3f61ec7ff7"><td class="memItemLeft" align="right" valign="top">MPI_Datatype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#acfbcd21d326bb27292544e3f61ec7ff7">mpi_type_id</a> (const char)</td></tr>
<tr class="separator:acfbcd21d326bb27292544e3f61ec7ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd5dfe1e8fa179577fc4113402bd286"><td class="memItemLeft" align="right" valign="top">MPI_Datatype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#accd5dfe1e8fa179577fc4113402bd286">mpi_type_id</a> (const unsigned <a class="el" href="classint.html">int</a>)</td></tr>
<tr class="separator:accd5dfe1e8fa179577fc4113402bd286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47de442a01da3c636968316c57049329"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a47de442a01da3c636968316c57049329"><td class="memTemplItemLeft" align="right" valign="top">MPI_Datatype&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a47de442a01da3c636968316c57049329">mpi_type_id</a> (const T &amp;)</td></tr>
<tr class="separator:a47de442a01da3c636968316c57049329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af5457aa7b50c3efa4126055ae1c5a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a9af5457aa7b50c3efa4126055ae1c5a6">rel_equal_eps</a> (<a class="el" href="classdouble.html">double</a> a, <a class="el" href="classdouble.html">double</a> b, <a class="el" href="classdouble.html">double</a> eps=std::sqrt(std::numeric_limits&lt; <a class="el" href="classdouble.html">double</a> &gt;::epsilon()))</td></tr>
<tr class="separator:a9af5457aa7b50c3efa4126055ae1c5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb9571d83ab737535a849cbb0803c43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#aebb9571d83ab737535a849cbb0803c43">abs_equal_eps</a> (<a class="el" href="classdouble.html">double</a> a, <a class="el" href="classdouble.html">double</a> b, <a class="el" href="classdouble.html">double</a> eps=std::sqrt(std::numeric_limits&lt; <a class="el" href="classdouble.html">double</a> &gt;::epsilon()))</td></tr>
<tr class="memdesc:aebb9571d83ab737535a849cbb0803c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the absolute difference between a and b are within the threshold eps.  <a href="namespaceIBTK.html#aebb9571d83ab737535a849cbb0803c43">More...</a><br /></td></tr>
<tr class="separator:aebb9571d83ab737535a849cbb0803c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f0d16e02dcc4734ef6fb35bb70b0ba"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a41f0d16e02dcc4734ef6fb35bb70b0ba">get_data_time_str</a> (const <a class="el" href="classdouble.html">double</a> data_time, const <a class="el" href="classdouble.html">double</a> current_time, const <a class="el" href="classdouble.html">double</a> new_time)</td></tr>
<tr class="separator:a41f0d16e02dcc4734ef6fb35bb70b0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6cf75ea2f6fb03d09bc32341d9c0a09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#aa6cf75ea2f6fb03d09bc32341d9c0a09">get_min_patch_dx</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a>&lt; NDIM &gt; &amp;patch_level)</td></tr>
<tr class="separator:aa6cf75ea2f6fb03d09bc32341d9c0a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745d00f9bbbb00d11e989436f8ce7911"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned N&gt; </td></tr>
<tr class="memitem:a745d00f9bbbb00d11e989436f8ce7911"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a745d00f9bbbb00d11e989436f8ce7911">array_constant</a> (const T &amp;v)</td></tr>
<tr class="separator:a745d00f9bbbb00d11e989436f8ce7911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526c5e2ad3c545703a6e180a3e3231bc"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned N&gt; </td></tr>
<tr class="memitem:a526c5e2ad3c545703a6e180a3e3231bc"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a526c5e2ad3c545703a6e180a3e3231bc">array_one</a> ()</td></tr>
<tr class="separator:a526c5e2ad3c545703a6e180a3e3231bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac284988f6336dc2b082c6fd1ff38fbee"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned N&gt; </td></tr>
<tr class="memitem:ac284988f6336dc2b082c6fd1ff38fbee"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ac284988f6336dc2b082c6fd1ff38fbee">array_zero</a> ()</td></tr>
<tr class="separator:ac284988f6336dc2b082c6fd1ff38fbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a14e41cdb653b629ee7aed2958d387"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ab7a14e41cdb653b629ee7aed2958d387">level_can_be_refined</a> (<a class="el" href="classint.html">int</a> level_number, <a class="el" href="classint.html">int</a> max_levels)</td></tr>
<tr class="separator:ab7a14e41cdb653b629ee7aed2958d387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d81edd603b8e9ea39ec04e986480c6d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a7d81edd603b8e9ea39ec04e986480c6d">voigt_to_tensor_idx</a> (const <a class="el" href="classint.html">int</a> k)</td></tr>
<tr class="separator:a7d81edd603b8e9ea39ec04e986480c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eed5a2c7a3e14447a70fe4a46b42aad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a5eed5a2c7a3e14447a70fe4a46b42aad">tensor_idx_to_voigt</a> (const std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt; &amp;idx)</td></tr>
<tr class="separator:a5eed5a2c7a3e14447a70fe4a46b42aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd643aba5793178126d00ce49bc89117"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#abd643aba5793178126d00ce49bc89117">smooth_heaviside</a> (const <a class="el" href="classdouble.html">double</a> &amp;phi, const <a class="el" href="classdouble.html">double</a> &amp;alpha)</td></tr>
<tr class="separator:abd643aba5793178126d00ce49bc89117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656dd83948f190947d77648f9968936d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a656dd83948f190947d77648f9968936d">smooth_delta</a> (const <a class="el" href="classdouble.html">double</a> &amp;phi, const <a class="el" href="classdouble.html">double</a> &amp;alpha)</td></tr>
<tr class="separator:a656dd83948f190947d77648f9968936d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac191f1d9b061d30c1b4ad47f66dc582e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ac191f1d9b061d30c1b4ad47f66dc582e">discontinuous_heaviside</a> (const <a class="el" href="classdouble.html">double</a> &amp;phi)</td></tr>
<tr class="separator:ac191f1d9b061d30c1b4ad47f66dc582e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714c8977f8e113df297ff17b71683b62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a714c8977f8e113df297ff17b71683b62">deallocate_vector_data</a> (<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;x, <a class="el" href="classint.html">int</a> coarsest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>, <a class="el" href="classint.html">int</a> finest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>)</td></tr>
<tr class="separator:a714c8977f8e113df297ff17b71683b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5eb8c1b082d5690d6b59fc45dc1dafe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ae5eb8c1b082d5690d6b59fc45dc1dafe">free_vector_components</a> (<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;x, <a class="el" href="classint.html">int</a> coarsest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>, <a class="el" href="classint.html">int</a> finest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>)</td></tr>
<tr class="separator:ae5eb8c1b082d5690d6b59fc45dc1dafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c9f83fddcfd441b41c75aaa9325ca6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a20c9f83fddcfd441b41c75aaa9325ca6"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a20c9f83fddcfd441b41c75aaa9325ca6">checked_dereference</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="separator:a20c9f83fddcfd441b41c75aaa9325ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd05bbfd156142ef625ad1683e44e75"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:accd05bbfd156142ef625ad1683e44e75"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#accd05bbfd156142ef625ad1683e44e75">checked_dereference</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="separator:accd05bbfd156142ef625ad1683e44e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8d519e0d0fa8226dd2dd3b5cc4852f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#aac8d519e0d0fa8226dd2dd3b5cc4852f">interpolate</a> (const <a class="el" href="namespaceIBTK.html#a2b73983d16b31c6192694e6101f57273">VectorNd</a> &amp;X, <a class="el" href="classint.html">int</a> data_idx, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a>&lt; NDIM &gt; &gt; Q_var, <a class="el" href="classint.html">int</a> Q_depth, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; patch_hierarchy, std::string kernel_fcn=&quot;IB_4&quot;)</td></tr>
<tr class="separator:aac8d519e0d0fa8226dd2dd3b5cc4852f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fae93b8ba9a8a747ff3bbfda25a7a7b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a5fae93b8ba9a8a747ff3bbfda25a7a7b">interpolate</a> (const std::vector&lt; <a class="el" href="namespaceIBTK.html#a2b73983d16b31c6192694e6101f57273">VectorNd</a> &gt; &amp;X, <a class="el" href="classint.html">int</a> data_idx, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a>&lt; NDIM &gt; &gt; Q_var, <a class="el" href="classint.html">int</a> Q_depth, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; patch_hierarchy, std::string kernel_fcn=&quot;IB_4&quot;)</td></tr>
<tr class="separator:a5fae93b8ba9a8a747ff3bbfda25a7a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6862737600f8050ffc8a9193d2855fac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a6862737600f8050ffc8a9193d2855fac">get_dim</a> (const libMesh::ElemType elem_type)</td></tr>
<tr class="separator:a6862737600f8050ffc8a9193d2855fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a597273d59eba2e3a2a2c5f4f3978f6"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a5a597273d59eba2e3a2a2c5f4f3978f6">get_n_nodes</a> (const libMesh::ElemType elem_type)</td></tr>
<tr class="separator:a5a597273d59eba2e3a2a2c5f4f3978f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7726626d63e9010519ec81caa7ad6aec"><td class="memItemLeft" align="right" valign="top">libMesh::Order&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a7726626d63e9010519ec81caa7ad6aec">get_default_order</a> (const libMesh::ElemType elem_type)</td></tr>
<tr class="separator:a7726626d63e9010519ec81caa7ad6aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d9e757aec602f3e004b0f358aa4ac6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a89d9e757aec602f3e004b0f358aa4ac6">copy_and_synch</a> (<a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;v_in, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;v_out, const <a class="el" href="classbool.html">bool</a> close_v_in=true, const <a class="el" href="classbool.html">bool</a> close_v_out=true)</td></tr>
<tr class="separator:a89d9e757aec602f3e004b0f358aa4ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bd271fbec4ef139e18db887375d1ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ad4bd271fbec4ef139e18db887375d1ae">batch_vec_copy</a> (const std::vector&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &amp;x_vecs, const std::vector&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &amp;y_vecs)</td></tr>
<tr class="separator:ad4bd271fbec4ef139e18db887375d1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0aedb65486ee6f549037773c72e511"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a5b0aedb65486ee6f549037773c72e511">batch_vec_copy</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &gt; &amp;x_vecs, const std::vector&lt; std::vector&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &gt; &amp;y_vecs)</td></tr>
<tr class="separator:a5b0aedb65486ee6f549037773c72e511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fec04e6523e6c8f83de2f7d918810b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#aa6fec04e6523e6c8f83de2f7d918810b">batch_vec_assembly</a> (const std::vector&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &amp;vecs)</td></tr>
<tr class="separator:aa6fec04e6523e6c8f83de2f7d918810b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40353749599abca6ca36c221001787a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a40353749599abca6ca36c221001787a3">batch_vec_assembly</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &gt; &amp;vecs)</td></tr>
<tr class="separator:a40353749599abca6ca36c221001787a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8557a2bff01645c5c9140b10323492b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ac8557a2bff01645c5c9140b10323492b">batch_vec_ghost_update</a> (const std::vector&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &amp;vecs, const InsertMode insert_mode, const ScatterMode scatter_mode)</td></tr>
<tr class="separator:ac8557a2bff01645c5c9140b10323492b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd21f0ce38740f36c527bd51d00cea2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#abbd21f0ce38740f36c527bd51d00cea2">batch_vec_ghost_update</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &gt; &amp;vecs, const InsertMode insert_mode, const ScatterMode scatter_mode)</td></tr>
<tr class="separator:abbd21f0ce38740f36c527bd51d00cea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b41be6d36de9d935548318a7c6dfacf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a4b41be6d36de9d935548318a7c6dfacf">setup_system_vectors</a> (libMesh::EquationSystems *equation_systems, const std::vector&lt; std::string &gt; &amp;system_names, const std::vector&lt; std::string &gt; &amp;vector_names, const <a class="el" href="classbool.html">bool</a> from_restart)</td></tr>
<tr class="separator:a4b41be6d36de9d935548318a7c6dfacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c7364c1bce910e24678a0db1cbe084"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a18c7364c1bce910e24678a0db1cbe084">setup_system_vector</a> (libMesh::System &amp;system, const std::string &amp;vector_name, const <a class="el" href="classbool.html">bool</a> from_restart)</td></tr>
<tr class="separator:a18c7364c1bce910e24678a0db1cbe084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf0ebd2eaf6f0e5da22eb24321914c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a4cf0ebd2eaf6f0e5da22eb24321914c3">copy_dof_ids_to_vector</a> (const unsigned <a class="el" href="classint.html">int</a> var_n, const boost::multi_array&lt; libMesh::dof_id_type, 2 &gt; &amp;elem_dofs, std::vector&lt; libMesh::dof_id_type &gt; &amp;dofs)</td></tr>
<tr class="separator:a4cf0ebd2eaf6f0e5da22eb24321914c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1b936ae530a4aacdc032c8edbb3475"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a6e1b936ae530a4aacdc032c8edbb3475">apply_transposed_constraint_matrix</a> (const libMesh::DofMap &amp;dof_map, <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:a6e1b936ae530a4aacdc032c8edbb3475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492518a5170b5fa7e076f6634a7a935b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIBTK.html#a8dcbdcaac090060b5a4ee6d10120911b">quadrature_key_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a492518a5170b5fa7e076f6634a7a935b">getQuadratureKey</a> (libMesh::QuadratureType quad_type, libMesh::Order order, <a class="el" href="classbool.html">bool</a> use_adaptive_quadrature, <a class="el" href="classdouble.html">double</a> point_density, <a class="el" href="classbool.html">bool</a> allow_rules_with_negative_weights, const libMesh::Elem *elem, const boost::multi_array&lt; <a class="el" href="classdouble.html">double</a>, 2 &gt; &amp;X_node, <a class="el" href="classdouble.html">double</a> dx_min)</td></tr>
<tr class="separator:a492518a5170b5fa7e076f6634a7a935b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed5aca02cba73e5d78468ef40470e7d"><td class="memTemplParams" colspan="2">template&lt;class MultiArray , class Array &gt; </td></tr>
<tr class="memitem:abed5aca02cba73e5d78468ef40470e7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#abed5aca02cba73e5d78468ef40470e7d">get_values_for_interpolation</a> (MultiArray &amp;U_node, const <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;U_petsc_vec, const Array &amp;U_local_soln, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;dof_indices)</td></tr>
<tr class="separator:abed5aca02cba73e5d78468ef40470e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5566c2958f93c08e9f6f9581fbf8a96"><td class="memTemplParams" colspan="2">template&lt;class MultiArray_1 , class MultiArray_2 , class Array &gt; </td></tr>
<tr class="memitem:ac5566c2958f93c08e9f6f9581fbf8a96"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ac5566c2958f93c08e9f6f9581fbf8a96">get_values_for_interpolation</a> (MultiArray_1 &amp;U_node, const <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;U_petsc_vec, const Array &amp;U_local_soln, const MultiArray_2 &amp;dof_indices)</td></tr>
<tr class="separator:ac5566c2958f93c08e9f6f9581fbf8a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85814a33961cc7772ab4ce8d5ba38f06"><td class="memTemplParams" colspan="2">template&lt;class MultiArray &gt; </td></tr>
<tr class="memitem:a85814a33961cc7772ab4ce8d5ba38f06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a85814a33961cc7772ab4ce8d5ba38f06">get_values_for_interpolation</a> (MultiArray &amp;U_node, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;U_vec, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;dof_indices)</td></tr>
<tr class="separator:a85814a33961cc7772ab4ce8d5ba38f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7af807f024e42d14c9afa7ba41cda42"><td class="memTemplParams" colspan="2">template&lt;class MultiArray_1 , class MultiArray_2 &gt; </td></tr>
<tr class="memitem:ac7af807f024e42d14c9afa7ba41cda42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ac7af807f024e42d14c9afa7ba41cda42">get_values_for_interpolation</a> (MultiArray_1 &amp;U_node, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;U_vec, const MultiArray_2 &amp;dof_indices)</td></tr>
<tr class="separator:ac7af807f024e42d14c9afa7ba41cda42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e621904d431a494ee6d70939ea3517b"><td class="memTemplParams" colspan="2">template&lt;class MultiArray &gt; </td></tr>
<tr class="memitem:a6e621904d431a494ee6d70939ea3517b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a6e621904d431a494ee6d70939ea3517b">interpolate</a> (<a class="el" href="classdouble.html">double</a> &amp;U, const <a class="el" href="classint.html">int</a> qp, const MultiArray &amp;U_node, const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;phi)</td></tr>
<tr class="separator:a6e621904d431a494ee6d70939ea3517b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc24178d5490dc9c567ced0c6fd396dd"><td class="memTemplParams" colspan="2">template&lt;class MultiArray &gt; </td></tr>
<tr class="memitem:afc24178d5490dc9c567ced0c6fd396dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#afc24178d5490dc9c567ced0c6fd396dd">interpolate</a> (const <a class="el" href="classint.html">int</a> qp, const MultiArray &amp;U_node, const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;phi)</td></tr>
<tr class="separator:afc24178d5490dc9c567ced0c6fd396dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4cce3704003cf03a1d50ca1b5856cb"><td class="memTemplParams" colspan="2">template&lt;class MultiArray &gt; </td></tr>
<tr class="memitem:a8a4cce3704003cf03a1d50ca1b5856cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a8a4cce3704003cf03a1d50ca1b5856cb">interpolate</a> (<a class="el" href="classdouble.html">double</a> *const U, const <a class="el" href="classint.html">int</a> qp, const MultiArray &amp;U_node, const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;phi)</td></tr>
<tr class="separator:a8a4cce3704003cf03a1d50ca1b5856cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7533ce02f3c58746ebc2ea90405fcc2"><td class="memTemplParams" colspan="2">template&lt;class MultiArray &gt; </td></tr>
<tr class="memitem:ae7533ce02f3c58746ebc2ea90405fcc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ae7533ce02f3c58746ebc2ea90405fcc2">interpolate</a> (libMesh::TypeVector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;U, const <a class="el" href="classint.html">int</a> qp, const MultiArray &amp;U_node, const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;phi)</td></tr>
<tr class="separator:ae7533ce02f3c58746ebc2ea90405fcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9028293137d8bfcafec9ac4a39d5381e"><td class="memTemplParams" colspan="2">template&lt;class MultiArray &gt; </td></tr>
<tr class="memitem:a9028293137d8bfcafec9ac4a39d5381e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a9028293137d8bfcafec9ac4a39d5381e">jacobian</a> (libMesh::TypeTensor&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;dX_ds, const <a class="el" href="classint.html">int</a> qp, const MultiArray &amp;X_node, const std::vector&lt; std::vector&lt; <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &gt; &amp;dphi)</td></tr>
<tr class="separator:a9028293137d8bfcafec9ac4a39d5381e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30f742f750669176152497db0ef0726"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ae30f742f750669176152497db0ef0726">tensor_inverse</a> (<a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;A_inv, const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;A, const <a class="el" href="classint.html">int</a> dim=NDIM)</td></tr>
<tr class="separator:ae30f742f750669176152497db0ef0726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f2422ce2973d7fd6a5e6cd59760c52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ad1f2422ce2973d7fd6a5e6cd59760c52">tensor_inverse</a> (const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;A, const <a class="el" href="classint.html">int</a> dim=NDIM)</td></tr>
<tr class="separator:ad1f2422ce2973d7fd6a5e6cd59760c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a57a16c4c54f61aaa275e2dfe42c9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a20a57a16c4c54f61aaa275e2dfe42c9b">tensor_inverse_transpose</a> (<a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;A_inv_trans, const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;A, const <a class="el" href="classint.html">int</a> dim=NDIM)</td></tr>
<tr class="separator:a20a57a16c4c54f61aaa275e2dfe42c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faa18f96d9a0bc0ebb915eb2d9c3744"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a4faa18f96d9a0bc0ebb915eb2d9c3744">tensor_inverse_transpose</a> (const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;A, const <a class="el" href="classint.html">int</a> dim=NDIM)</td></tr>
<tr class="separator:a4faa18f96d9a0bc0ebb915eb2d9c3744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef27a5af903369f0c26e66e4e2155b81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#aef27a5af903369f0c26e66e4e2155b81">outer_product</a> (<a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;u_prod_v, const libMesh::TypeVector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;u, const libMesh::TypeVector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;v, const <a class="el" href="classint.html">int</a> dim=NDIM)</td></tr>
<tr class="separator:aef27a5af903369f0c26e66e4e2155b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa273687ead649c1d10fb8382ea1f21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a2fa273687ead649c1d10fb8382ea1f21">outer_product</a> (const libMesh::TypeVector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;u, const libMesh::TypeVector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;v, const <a class="el" href="classint.html">int</a> dim=NDIM)</td></tr>
<tr class="separator:a2fa273687ead649c1d10fb8382ea1f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45293290dab489896e0d1bb04efb6d75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a45293290dab489896e0d1bb04efb6d75">intersect_line_with_edge</a> (std::vector&lt; std::pair&lt; <a class="el" href="classdouble.html">double</a>, libMesh::Point &gt; &gt; &amp;t_vals, libMesh::Edge *elem, libMesh::Point r, <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; q, const <a class="el" href="classdouble.html">double</a> tol=0.0)</td></tr>
<tr class="separator:a45293290dab489896e0d1bb04efb6d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4956967de7ecb8746eddcc1d54e24283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a4956967de7ecb8746eddcc1d54e24283">intersect_line_with_face</a> (std::vector&lt; std::pair&lt; <a class="el" href="classdouble.html">double</a>, libMesh::Point &gt; &gt; &amp;t_vals, libMesh::Face *elem, libMesh::Point r, <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; q, const <a class="el" href="classdouble.html">double</a> tol=0.0)</td></tr>
<tr class="separator:a4956967de7ecb8746eddcc1d54e24283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d173c9bc7d2bcd1c37c549a2075adca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a6d173c9bc7d2bcd1c37c549a2075adca">get_nodal_dof_indices</a> (const libMesh::DofMap &amp;dof_map, const libMesh::Node *const node, const unsigned <a class="el" href="classint.html">int</a> variable_n, std::vector&lt; libMesh::dof_id_type &gt; &amp;nodal_indices)</td></tr>
<tr class="separator:a6d173c9bc7d2bcd1c37c549a2075adca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9fab55956157fb2e0bc09f77c0f425"><td class="memTemplParams" colspan="2">template&lt;class MultiArray &gt; </td></tr>
<tr class="memitem:aca9fab55956157fb2e0bc09f77c0f425"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#aca9fab55956157fb2e0bc09f77c0f425">get_max_edge_length</a> (const libMesh::Elem *const elem, const MultiArray &amp;X_node)</td></tr>
<tr class="separator:aca9fab55956157fb2e0bc09f77c0f425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceed8ef2e29cf7a38d720d5418751e73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#aceed8ef2e29cf7a38d720d5418751e73">write_elem_partitioning</a> (const std::string &amp;file_name, const libMesh::System &amp;position_system)</td></tr>
<tr class="separator:aceed8ef2e29cf7a38d720d5418751e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ede2ffd0f710fcf1b00c933cdc4da8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a07ede2ffd0f710fcf1b00c933cdc4da8">write_node_partitioning</a> (const std::string &amp;file_name, const libMesh::System &amp;position_system)</td></tr>
<tr class="separator:a07ede2ffd0f710fcf1b00c933cdc4da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdfa95b0f503f8d536421975ab1967e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::BoundingBox &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a5cdfa95b0f503f8d536421975ab1967e">get_local_element_bounding_boxes</a> (const libMesh::MeshBase &amp;mesh, const libMesh::System &amp;X_system, libMesh::QuadratureType quad_type, libMesh::Order quad_order, <a class="el" href="classbool.html">bool</a> use_adaptive_quadrature, <a class="el" href="classdouble.html">double</a> point_density, <a class="el" href="classbool.html">bool</a> allow_rules_with_negative_weights, <a class="el" href="classdouble.html">double</a> patch_dx_min)</td></tr>
<tr class="separator:a5cdfa95b0f503f8d536421975ab1967e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f37f0ab5719de37e2222276d354f9d9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::BoundingBox &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a5f37f0ab5719de37e2222276d354f9d9">get_local_element_bounding_boxes</a> (const libMesh::MeshBase &amp;mesh, const libMesh::System &amp;X_system)</td></tr>
<tr class="separator:a5f37f0ab5719de37e2222276d354f9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7930152214e1b9eaf0aac541be3560ae"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::BoundingBox &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a7930152214e1b9eaf0aac541be3560ae">get_global_element_bounding_boxes</a> (const libMesh::MeshBase &amp;mesh, const std::vector&lt; libMesh::BoundingBox &gt; &amp;local_bboxes)</td></tr>
<tr class="separator:a7930152214e1b9eaf0aac541be3560ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0a5591017f3ba7225050b2aaf4ea5e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::BoundingBox &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a7b0a5591017f3ba7225050b2aaf4ea5e">get_global_element_bounding_boxes</a> (const libMesh::MeshBase &amp;mesh, const libMesh::System &amp;X_system)</td></tr>
<tr class="separator:a7b0a5591017f3ba7225050b2aaf4ea5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fdfe0a5d6114b04e025c647f22883f"><td class="memItemLeft" align="right" valign="top">Vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a67fdfe0a5d6114b04e025c647f22883f">setup_petsc_vector</a> (const unsigned <a class="el" href="classint.html">int</a> num_local_nodes, const unsigned <a class="el" href="classint.html">int</a> depth, const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;nonlocal_petsc_indices)</td></tr>
<tr class="separator:a67fdfe0a5d6114b04e025c647f22883f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085d3e516adba59c0389be491da63052"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a085d3e516adba59c0389be491da63052">update_snapshot</a> (<a class="el" href="classIBTK_1_1SnapshotCache.html">SnapshotCache</a> &amp;cache, <a class="el" href="classint.html">int</a> u_idx, <a class="el" href="classdouble.html">double</a> time, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; current_hierarchy, <a class="el" href="classdouble.html">double</a> tol=1.0e-8)</td></tr>
<tr class="separator:a085d3e516adba59c0389be491da63052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d5fe26a02150fd4d2413fe9f4dd2ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a23d5fe26a02150fd4d2413fe9f4dd2ab">fill_snapshot_on_hierarchy</a> (<a class="el" href="classIBTK_1_1SnapshotCache.html">SnapshotCache</a> &amp;cache, <a class="el" href="classint.html">int</a> u_idx, <a class="el" href="classdouble.html">double</a> time, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; current_hierarchy, const std::string &amp;snapshot_refine_type, <a class="el" href="classdouble.html">double</a> tol=1.0e-8)</td></tr>
<tr class="separator:a23d5fe26a02150fd4d2413fe9f4dd2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5a774f26d36fed17d038b8217511ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a2d5a774f26d36fed17d038b8217511ee">fill_snapshot_at_time</a> (<a class="el" href="classIBTK_1_1SnapshotCache.html">SnapshotCache</a> &amp;snapshot_cache, <a class="el" href="classint.html">int</a> u_idx, <a class="el" href="classdouble.html">double</a> t, <a class="el" href="classint.html">int</a> scr_idx, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, const std::string &amp;refine_type, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsReal.html">SAMRAI::math::HierarchyDataOpsReal</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &gt; hier_data_ops=nullptr, <a class="el" href="classdouble.html">double</a> period=std::numeric_limits&lt; <a class="el" href="classdouble.html">double</a> &gt;::quiet_NaN())</td></tr>
<tr class="separator:a2d5a774f26d36fed17d038b8217511ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925f529d0165b30ed0bdc51a481674ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a925f529d0165b30ed0bdc51a481674ee">reportPETScKSPConvergedReason</a> (const std::string &amp;object_name, const KSPConvergedReason &amp;reason, std::ostream &amp;os)</td></tr>
<tr class="memdesc:a925f529d0165b30ed0bdc51a481674ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the KSPConvergedReason.  <a href="namespaceIBTK.html#a925f529d0165b30ed0bdc51a481674ee">More...</a><br /></td></tr>
<tr class="separator:a925f529d0165b30ed0bdc51a481674ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b2fcc10382e4b16b66a8619f66b3a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ad4b2fcc10382e4b16b66a8619f66b3a6">reportPETScSNESConvergedReason</a> (const std::string &amp;object_name, const SNESConvergedReason &amp;reason, std::ostream &amp;os)</td></tr>
<tr class="memdesc:ad4b2fcc10382e4b16b66a8619f66b3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the SNESConvergedReason.  <a href="namespaceIBTK.html#ad4b2fcc10382e4b16b66a8619f66b3a6">More...</a><br /></td></tr>
<tr class="separator:ad4b2fcc10382e4b16b66a8619f66b3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab468c521d57e4d982172b8937eacbe05"><td class="memItemLeft" align="right" valign="top">std::array&lt; HYPRE_Int, NDIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#ab468c521d57e4d982172b8937eacbe05">hypre_array</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">SAMRAI::hier::Index</a>&lt; NDIM &gt; &amp;index)</td></tr>
<tr class="memdesc:ab468c521d57e4d982172b8937eacbe05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to convert <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> indices to Hypre integers.  <a href="namespaceIBTK.html#ab468c521d57e4d982172b8937eacbe05">More...</a><br /></td></tr>
<tr class="separator:ab468c521d57e4d982172b8937eacbe05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e408613b9a8dd6a086d9b13808bc127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a6e408613b9a8dd6a086d9b13808bc127">copyFromHypre</a> (<a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">SAMRAI::pdat::CellData</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;dst_data, const std::vector&lt; HYPRE_StructVector &gt; &amp;vectors, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &amp;box)</td></tr>
<tr class="memdesc:a6e408613b9a8dd6a086d9b13808bc127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from a vector of Hypre vectors to <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell centered data with depth equal to number of Hypre vectors.  <a href="namespaceIBTK.html#a6e408613b9a8dd6a086d9b13808bc127">More...</a><br /></td></tr>
<tr class="separator:a6e408613b9a8dd6a086d9b13808bc127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d130b6670b3fe4cf839f5c76d7e3d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a26d130b6670b3fe4cf839f5c76d7e3d1">copyFromHypre</a> (<a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">SAMRAI::pdat::SideData</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;dst_data, HYPRE_SStructVector vector, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &amp;box)</td></tr>
<tr class="memdesc:a26d130b6670b3fe4cf839f5c76d7e3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from a Hypre vector to <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> side centered data.  <a href="namespaceIBTK.html#a26d130b6670b3fe4cf839f5c76d7e3d1">More...</a><br /></td></tr>
<tr class="separator:a26d130b6670b3fe4cf839f5c76d7e3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e9bd568bbdd3245c15404ca2cf4701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a07e9bd568bbdd3245c15404ca2cf4701">copyToHypre</a> (const std::vector&lt; HYPRE_StructVector &gt; &amp;vectors, <a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">SAMRAI::pdat::CellData</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;src_data, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &amp;box)</td></tr>
<tr class="memdesc:a07e9bd568bbdd3245c15404ca2cf4701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell centered data to Hypre vectors.  <a href="namespaceIBTK.html#a07e9bd568bbdd3245c15404ca2cf4701">More...</a><br /></td></tr>
<tr class="separator:a07e9bd568bbdd3245c15404ca2cf4701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19653d3a298370f4975c115cff103ecd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a19653d3a298370f4975c115cff103ecd">copyToHypre</a> (HYPRE_SStructVector &amp;vector, <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">SAMRAI::pdat::SideData</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;src_data, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &amp;box)</td></tr>
<tr class="memdesc:a19653d3a298370f4975c115cff103ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> side centered data to a Hypre vector.  <a href="namespaceIBTK.html#a19653d3a298370f4975c115cff103ecd">More...</a><br /></td></tr>
<tr class="separator:a19653d3a298370f4975c115cff103ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7159301f2c1c020f5bbf43c6060b5e0d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a7159301f2c1c020f5bbf43c6060b5e0d">ENABLE_TIMERS</a> = true</td></tr>
<tr class="separator:a7159301f2c1c020f5bbf43c6060b5e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd93a9c16e327725aa68e0b9c43e800"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a6fd93a9c16e327725aa68e0b9c43e800">s_max_free_dofs</a> = NDIM * (NDIM + 1) / 2</td></tr>
<tr class="separator:a6fd93a9c16e327725aa68e0b9c43e800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426852ad282d4bb75fa436e05150870d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a> = -1</td></tr>
<tr class="separator:a426852ad282d4bb75fa436e05150870d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4beed89342258cb4b5e9bc9e8bc90aaf"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">invalid_index</a> = -1</td></tr>
<tr class="separator:a4beed89342258cb4b5e9bc9e8bc90aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a4e421bc18e78027f97855673b767bdc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e421bc18e78027f97855673b767bdc5">&#9670;&nbsp;</a></span>EigenAlignedVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a4e421bc18e78027f97855673b767bdc5">IBTK::EigenAlignedVector</a> = typedef std::vector&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Eigen types have special alignment requirements and require a specific memory allocator. This is a convenience type alias for a <code>std::vector</code> with the correct allocator.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>This alias is no longer necessary. </dd></dl>

</div>
</div>
<a id="adf9a16623626884f27ea03f128cadfcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9a16623626884f27ea03f128cadfcb">&#9670;&nbsp;</a></span>Matrix2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#adf9a16623626884f27ea03f128cadfcb">IBTK::Matrix2d</a> = typedef Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, 2, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57c2c9e6af54a75b53b2899e1dd737c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c2c9e6af54a75b53b2899e1dd737c9">&#9670;&nbsp;</a></span>Vector2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a57c2c9e6af54a75b53b2899e1dd737c9">IBTK::Vector2d</a> = typedef Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, 2, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93b3ea7366a0fe96f56b0200bc1b8e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b3ea7366a0fe96f56b0200bc1b8e77">&#9670;&nbsp;</a></span>ColumnVector2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a93b3ea7366a0fe96f56b0200bc1b8e77">IBTK::ColumnVector2d</a> = typedef Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, 2, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d7055bb6960f6fc39aa553494fb69d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7055bb6960f6fc39aa553494fb69d4">&#9670;&nbsp;</a></span>RowVector2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a8d7055bb6960f6fc39aa553494fb69d4">IBTK::RowVector2d</a> = typedef Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, 1, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82ad687550740b96db47464cde5721f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ad687550740b96db47464cde5721f4">&#9670;&nbsp;</a></span>Matrix3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a82ad687550740b96db47464cde5721f4">IBTK::Matrix3d</a> = typedef Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, 3, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4ae9d461191bfbc3f356a669835f365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ae9d461191bfbc3f356a669835f365">&#9670;&nbsp;</a></span>Vector3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#ab4ae9d461191bfbc3f356a669835f365">IBTK::Vector3d</a> = typedef Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, 3, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed427cf9ba7c7dc4fccefdaba4be823b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed427cf9ba7c7dc4fccefdaba4be823b">&#9670;&nbsp;</a></span>ColumnVector3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#aed427cf9ba7c7dc4fccefdaba4be823b">IBTK::ColumnVector3d</a> = typedef Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, 3, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada34760f7623fade0ba21f04b76dcf63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada34760f7623fade0ba21f04b76dcf63">&#9670;&nbsp;</a></span>RowVector3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#ada34760f7623fade0ba21f04b76dcf63">IBTK::RowVector3d</a> = typedef Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, 1, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67f18d4de9fe15f20d78f4f943f818bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f18d4de9fe15f20d78f4f943f818bc">&#9670;&nbsp;</a></span>MatrixNd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a67f18d4de9fe15f20d78f4f943f818bc">IBTK::MatrixNd</a> = typedef Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, NDIM, NDIM&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b73983d16b31c6192694e6101f57273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b73983d16b31c6192694e6101f57273">&#9670;&nbsp;</a></span>VectorNd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a2b73983d16b31c6192694e6101f57273">IBTK::VectorNd</a> = typedef Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, NDIM, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af1137eefc68da668954ab11a43255186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1137eefc68da668954ab11a43255186">&#9670;&nbsp;</a></span>ColumnVectorNd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#af1137eefc68da668954ab11a43255186">IBTK::ColumnVectorNd</a> = typedef Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, NDIM, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca334f5726a653bdade6bb25e533b533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca334f5726a653bdade6bb25e533b533">&#9670;&nbsp;</a></span>RowVectorNd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#aca334f5726a653bdade6bb25e533b533">IBTK::RowVectorNd</a> = typedef Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, 1, NDIM&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b3d55a318b465924a7a4a9163c650ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3d55a318b465924a7a4a9163c650ad">&#9670;&nbsp;</a></span>MatrixXd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a1b3d55a318b465924a7a4a9163c650ad">IBTK::MatrixXd</a> = typedef Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, Eigen::Dynamic, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12c64fdd39a3b5adab73e8d5173aa9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c64fdd39a3b5adab73e8d5173aa9d2">&#9670;&nbsp;</a></span>VectorXd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a12c64fdd39a3b5adab73e8d5173aa9d2">IBTK::VectorXd</a> = typedef Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, Eigen::Dynamic, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a451e0b737a3282a03632af2b90f8c026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451e0b737a3282a03632af2b90f8c026">&#9670;&nbsp;</a></span>ColumnVectorXd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a451e0b737a3282a03632af2b90f8c026">IBTK::ColumnVectorXd</a> = typedef Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, Eigen::Dynamic, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a839aacfd5da68aab82ccc0838f86d27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839aacfd5da68aab82ccc0838f86d27a">&#9670;&nbsp;</a></span>RowVectorXd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a839aacfd5da68aab82ccc0838f86d27a">IBTK::RowVectorXd</a> = typedef Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, 1, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a571dee285c7f5b44c20ffb11a1b96ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571dee285c7f5b44c20ffb11a1b96ed3">&#9670;&nbsp;</a></span>Matrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a571dee285c7f5b44c20ffb11a1b96ed3">IBTK::Matrix</a> = typedef <a class="el" href="namespaceIBTK.html#a67f18d4de9fe15f20d78f4f943f818bc">MatrixNd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8c97469e791a47756eb44b9ec93c59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c97469e791a47756eb44b9ec93c59e">&#9670;&nbsp;</a></span>Point</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">IBTK::Point</a> = typedef <a class="el" href="namespaceIBTK.html#a2b73983d16b31c6192694e6101f57273">VectorNd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09a4d4ded781c3a9630a42d88680e89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a4d4ded781c3a9630a42d88680e89f">&#9670;&nbsp;</a></span>Vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a09a4d4ded781c3a9630a42d88680e89f">IBTK::Vector</a> = typedef <a class="el" href="namespaceIBTK.html#a2b73983d16b31c6192694e6101f57273">VectorNd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d5c7844e08cab1447e1ce7423a5fa3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5c7844e08cab1447e1ce7423a5fa3c">&#9670;&nbsp;</a></span>RigidDOFVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> = typedef Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, <a class="el" href="namespaceIBTK.html#a6fd93a9c16e327725aa68e0b9c43e800">s_max_free_dofs</a>, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad17100e3633baaf42d5aae6933b8e5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17100e3633baaf42d5aae6933b8e5db">&#9670;&nbsp;</a></span>FreeRigidDOFVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#ad17100e3633baaf42d5aae6933b8e5db">IBTK::FreeRigidDOFVector</a> = typedef Eigen::Matrix&lt;<a class="el" href="classint.html">int</a>, <a class="el" href="namespaceIBTK.html#a6fd93a9c16e327725aa68e0b9c43e800">s_max_free_dofs</a>, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3765caccae641a3ff08f3bed8798af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3765caccae641a3ff08f3bed8798af5">&#9670;&nbsp;</a></span>RDV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#ad3765caccae641a3ff08f3bed8798af5">IBTK::RDV</a> = typedef <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">RigidDOFVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac19301c6fd0897bd5254ffad040e24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac19301c6fd0897bd5254ffad040e24c">&#9670;&nbsp;</a></span>FRDV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#aac19301c6fd0897bd5254ffad040e24c">IBTK::FRDV</a> = typedef <a class="el" href="namespaceIBTK.html#ad17100e3633baaf42d5aae6933b8e5db">FreeRigidDOFVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6516d72a11e660ef8321ed1ed6b119d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6516d72a11e660ef8321ed1ed6b119d0">&#9670;&nbsp;</a></span>IndexFortranOrder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a6516d72a11e660ef8321ed1ed6b119d0">IBTK::IndexFortranOrder</a> = typedef struct <a class="el" href="structIBTK_1_1IndexOrder.html">IndexOrder</a>&lt;<a class="el" href="classSAMRAI_1_1hier_1_1Index.html">SAMRAI::hier::Index</a>&lt;NDIM&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98bbac2eaf9010f28398d4c6a27cef96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98bbac2eaf9010f28398d4c6a27cef96">&#9670;&nbsp;</a></span>CellIndexFortranOrder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a98bbac2eaf9010f28398d4c6a27cef96">IBTK::CellIndexFortranOrder</a> = typedef struct <a class="el" href="structIBTK_1_1IndexOrder.html">IndexOrder</a>&lt;<a class="el" href="classSAMRAI_1_1pdat_1_1CellIndex.html">SAMRAI::pdat::CellIndex</a>&lt;NDIM&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dcbdcaac090060b5a4ee6d10120911b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcbdcaac090060b5a4ee6d10120911b">&#9670;&nbsp;</a></span>quadrature_key_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a8dcbdcaac090060b5a4ee6d10120911b">IBTK::quadrature_key_type</a> = typedef std::tuple&lt;libMesh::ElemType, libMesh::QuadratureType, libMesh::Order, <a class="el" href="classbool.html">bool</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f04732f2606c4a49ff92ca5b3c514b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f04732f2606c4a49ff92ca5b3c514b9">&#9670;&nbsp;</a></span>ScalarMeshFcnPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a3f04732f2606c4a49ff92ca5b3c514b9">IBTK::ScalarMeshFcnPtr</a> = typedef void (*)(<a class="el" href="classdouble.html">double</a>&amp; F, const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; FF, const libMesh::Point&amp; x, const libMesh::Point&amp; X, libMesh::Elem* elem, const std::vector&lt;const std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt;*&gt;&amp; system_var_data, const std::vector&lt;const std::vector&lt;<a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt;*&gt;&amp; system_grad_var_data, <a class="el" href="classdouble.html">double</a> data_time, void* ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a503cb21b0cf0bd3e1ed168623b674d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503cb21b0cf0bd3e1ed168623b674d8e">&#9670;&nbsp;</a></span>VectorMeshFcnPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a503cb21b0cf0bd3e1ed168623b674d8e">IBTK::VectorMeshFcnPtr</a> = typedef void (*)(<a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; F, const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; FF, const libMesh::Point&amp; x, const libMesh::Point&amp; X, libMesh::Elem* elem, const std::vector&lt;const std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt;*&gt;&amp; system_var_data, const std::vector&lt;const std::vector&lt;<a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt;*&gt;&amp; system_grad_var_data, <a class="el" href="classdouble.html">double</a> data_time, void* ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2047e8d6003cdf2c5017d741cad69907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2047e8d6003cdf2c5017d741cad69907">&#9670;&nbsp;</a></span>TensorMeshFcnPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a2047e8d6003cdf2c5017d741cad69907">IBTK::TensorMeshFcnPtr</a> = typedef void (*)(<a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; F, const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; FF, const libMesh::Point&amp; x, const libMesh::Point&amp; X, libMesh::Elem* elem, const std::vector&lt;const std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt;*&gt;&amp; system_var_data, const std::vector&lt;const std::vector&lt;<a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt;*&gt;&amp; system_grad_var_data, <a class="el" href="classdouble.html">double</a> data_time, void* ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0828e2d557e67a201c8526a7c9b761b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0828e2d557e67a201c8526a7c9b761b0">&#9670;&nbsp;</a></span>ScalarSurfaceFcnPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a0828e2d557e67a201c8526a7c9b761b0">IBTK::ScalarSurfaceFcnPtr</a> = typedef void (*)(<a class="el" href="classdouble.html">double</a>&amp; F, const <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; n, const <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; N, const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; FF, const libMesh::Point&amp; x, const libMesh::Point&amp; X, libMesh::Elem* elem, unsigned short <a class="el" href="classint.html">int</a> side, const std::vector&lt;const std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt;*&gt;&amp; system_var_data, const std::vector&lt;const std::vector&lt;<a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt;*&gt;&amp; system_grad_var_data, <a class="el" href="classdouble.html">double</a> data_time, void* ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45007c53f48bbf752259fcec0884767c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45007c53f48bbf752259fcec0884767c">&#9670;&nbsp;</a></span>VectorSurfaceFcnPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a45007c53f48bbf752259fcec0884767c">IBTK::VectorSurfaceFcnPtr</a> = typedef void (*)(<a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; F, const <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; n, const <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; N, const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; FF, const libMesh::Point&amp; x, const libMesh::Point&amp; X, libMesh::Elem* elem, unsigned short <a class="el" href="classint.html">int</a> side, const std::vector&lt;const std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt;*&gt;&amp; system_var_data, const std::vector&lt;const std::vector&lt;<a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt;*&gt;&amp; system_grad_var_data, <a class="el" href="classdouble.html">double</a> data_time, void* ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae611604880133ce595ea19e89a73b182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae611604880133ce595ea19e89a73b182">&#9670;&nbsp;</a></span>TensorSurfaceFcnPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#ae611604880133ce595ea19e89a73b182">IBTK::TensorSurfaceFcnPtr</a> = typedef void (*)(<a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; F, const <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; n, const <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; N, const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; FF, const libMesh::Point&amp; x, const libMesh::Point&amp; X, libMesh::Elem* elem, unsigned short <a class="el" href="classint.html">int</a> side, const std::vector&lt;const std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt;*&gt;&amp; system_var_data, const std::vector&lt;const std::vector&lt;<a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt;*&gt;&amp; system_grad_var_data, <a class="el" href="classdouble.html">double</a> data_time, void* ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49d1dccdfce78faf8f3f8a0a2bd7f77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d1dccdfce78faf8f3f8a0a2bd7f77f">&#9670;&nbsp;</a></span>LNodeIndexSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a49d1dccdfce78faf8f3f8a0a2bd7f77f">IBTK::LNodeIndexSet</a> = typedef <a class="el" href="classIBTK_1_1LSet.html">LSet</a>&lt;<a class="el" href="classIBTK_1_1LNodeIndex.html">LNodeIndex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26c6e91d089ec5775d73b824dd4ac456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c6e91d089ec5775d73b824dd4ac456">&#9670;&nbsp;</a></span>LNodeIndexSetData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a26c6e91d089ec5775d73b824dd4ac456">IBTK::LNodeIndexSetData</a> = typedef <a class="el" href="classIBTK_1_1LIndexSetData.html">LIndexSetData</a>&lt;<a class="el" href="classIBTK_1_1LNodeIndex.html">LNodeIndex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c714ac40dfb45d45a0f1a3a9ac79e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c714ac40dfb45d45a0f1a3a9ac79e96">&#9670;&nbsp;</a></span>LNodeIndexSetDataFactory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a9c714ac40dfb45d45a0f1a3a9ac79e96">IBTK::LNodeIndexSetDataFactory</a> = typedef <a class="el" href="classIBTK_1_1LIndexSetDataFactory.html">LIndexSetDataFactory</a>&lt;<a class="el" href="classIBTK_1_1LNodeIndex.html">LNodeIndex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18fb2c83a523385b5d1c6fb70ff41b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18fb2c83a523385b5d1c6fb70ff41b1f">&#9670;&nbsp;</a></span>LNodeIndexSetDataIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a18fb2c83a523385b5d1c6fb70ff41b1f">IBTK::LNodeIndexSetDataIterator</a> = typedef <a class="el" href="classIBTK_1_1LSetDataIterator.html">LSetDataIterator</a>&lt;<a class="el" href="classIBTK_1_1LNodeIndex.html">LNodeIndex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93fe4ea71ef285edd7994e07e781cdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fe4ea71ef285edd7994e07e781cdf5">&#9670;&nbsp;</a></span>LNodeIndexSetVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a93fe4ea71ef285edd7994e07e781cdf5">IBTK::LNodeIndexSetVariable</a> = typedef <a class="el" href="classIBTK_1_1LIndexSetVariable.html">LIndexSetVariable</a>&lt;<a class="el" href="classIBTK_1_1LNodeIndex.html">LNodeIndex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b022d253611a53adfa402422e613d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b022d253611a53adfa402422e613d04">&#9670;&nbsp;</a></span>LNodeIndexTransaction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a6b022d253611a53adfa402422e613d04">IBTK::LNodeIndexTransaction</a> = typedef <a class="el" href="classIBTK_1_1LTransaction.html">LTransaction</a>&lt;<a class="el" href="classIBTK_1_1LNodeIndex.html">LNodeIndex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e5e5af7d75b4b4246dd44d65c5439b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5e5af7d75b4b4246dd44d65c5439b0">&#9670;&nbsp;</a></span>LNodeSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a6e5e5af7d75b4b4246dd44d65c5439b0">IBTK::LNodeSet</a> = typedef <a class="el" href="classIBTK_1_1LSet.html">LSet</a>&lt;<a class="el" href="classIBTK_1_1LNode.html">LNode</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dd5c02a25ef1925fd161c7297ff5224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd5c02a25ef1925fd161c7297ff5224">&#9670;&nbsp;</a></span>LNodeSetData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a9dd5c02a25ef1925fd161c7297ff5224">IBTK::LNodeSetData</a> = typedef <a class="el" href="classIBTK_1_1LIndexSetData.html">LIndexSetData</a>&lt;<a class="el" href="classIBTK_1_1LNode.html">LNode</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab528c6bbf975269300b58d8178263599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab528c6bbf975269300b58d8178263599">&#9670;&nbsp;</a></span>LNodeSetDataFactory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#ab528c6bbf975269300b58d8178263599">IBTK::LNodeSetDataFactory</a> = typedef <a class="el" href="classIBTK_1_1LIndexSetDataFactory.html">LIndexSetDataFactory</a>&lt;<a class="el" href="classIBTK_1_1LNode.html">LNode</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac1a0390039ab214bee68db589e9014b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1a0390039ab214bee68db589e9014b">&#9670;&nbsp;</a></span>LNodeSetDataIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#aac1a0390039ab214bee68db589e9014b">IBTK::LNodeSetDataIterator</a> = typedef <a class="el" href="classIBTK_1_1LSetDataIterator.html">LSetDataIterator</a>&lt;<a class="el" href="classIBTK_1_1LNode.html">LNode</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9eb9f4aa1a24bc680e2744c833f6d439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb9f4aa1a24bc680e2744c833f6d439">&#9670;&nbsp;</a></span>LNodeSetVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#a9eb9f4aa1a24bc680e2744c833f6d439">IBTK::LNodeSetVariable</a> = typedef <a class="el" href="classIBTK_1_1LIndexSetVariable.html">LIndexSetVariable</a>&lt;<a class="el" href="classIBTK_1_1LNode.html">LNode</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeed20f3055d55d60889801d99ef671c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed20f3055d55d60889801d99ef671c1">&#9670;&nbsp;</a></span>LNodeTransaction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceIBTK.html#aeed20f3055d55d60889801d99ef671c1">IBTK::LNodeTransaction</a> = typedef <a class="el" href="classIBTK_1_1LTransaction.html">LTransaction</a>&lt;<a class="el" href="classIBTK_1_1LNode.html">LNode</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae8048f832efc6a3000180a8b59de9091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8048f832efc6a3000180a8b59de9091">&#9670;&nbsp;</a></span>FEUpdateFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">IBTK::FEUpdateFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration describing the various update options available for libMesh::FEBase objects stored by <a class="el" href="classIBTK_1_1FECache.html" title="Class storing multiple libMesh::FE objects, each corresponding to a different quadrature rule....">FECache</a>. Multiple flags can be enabled with bitwise or operations, e.g.,</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">IBTK::FEUpdateFlags</a> update_flags = <a class="code" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091a9f04987cef3783ee1f9329eca30c5558">IBTK::update_phi</a> | <a class="code" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091acd49d3ad2cb8bd317153305be3d4245e">IBTK::update_dphi</a>;</div>
</div><!-- fragment --><p>See <a class="el" href="classIBTK_1_1FECache.html" title="Class storing multiple libMesh::FE objects, each corresponding to a different quadrature rule....">IBTK::FECache</a> for more information. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae8048f832efc6a3000180a8b59de9091a643d9c888b06a36de3593a171a6d456d"></a>update_default&#160;</td><td class="fielddoc"><p>Do not update anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae8048f832efc6a3000180a8b59de9091a9f04987cef3783ee1f9329eca30c5558"></a>update_phi&#160;</td><td class="fielddoc"><p>Update phi (shape function values). </p>
</td></tr>
<tr><td class="fieldname"><a id="ae8048f832efc6a3000180a8b59de9091acd49d3ad2cb8bd317153305be3d4245e"></a>update_dphi&#160;</td><td class="fielddoc"><p>Update dphi (shape function gradients). </p>
</td></tr>
<tr><td class="fieldname"><a id="ae8048f832efc6a3000180a8b59de9091a58e0e6170d8bbc6c71e3178134956a98"></a>update_contravariants&#160;</td><td class="fielddoc"><p>Update mapping contravariants. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae8048f832efc6a3000180a8b59de9091aa95b826ef42215b565c40633467c357e"></a>update_covariants&#160;</td><td class="fielddoc"><p>Update mapping covariants. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae8048f832efc6a3000180a8b59de9091a29569a61a25961316d205f2c5fb2a9f0"></a>update_jacobians&#160;</td><td class="fielddoc"><p>Update mapping Jacobians. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae8048f832efc6a3000180a8b59de9091adbc46effec6a8d7a3e96045f6c824059"></a>update_JxW&#160;</td><td class="fielddoc"><p>Update JxW values. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae8048f832efc6a3000180a8b59de9091a1203d6d0b8a28ce88108337cc289a477"></a>update_quadrature_points&#160;</td><td class="fielddoc"><p>Update mapped quadrature points. </p>
</td></tr>
</table>

</div>
</div>
<a id="a19008659d5b79c98ba2edfefb73b17a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19008659d5b79c98ba2edfefb73b17a0">&#9670;&nbsp;</a></span>MGCycleType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceIBTK.html#a19008659d5b79c98ba2edfefb73b17a0">IBTK::MGCycleType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a19008659d5b79c98ba2edfefb73b17a0a156cbdd231d67047a3b27eae8ac3f88f"></a>F_CYCLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a19008659d5b79c98ba2edfefb73b17a0a81a2ba87e1aa986e59289c8eb4ed1c13"></a>FMG_CYCLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a19008659d5b79c98ba2edfefb73b17a0a4276274af2aebba7074c81f0b48a8cd6"></a>V_CYCLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a19008659d5b79c98ba2edfefb73b17a0a60c9e8c9557dcb352803949f98afccf5"></a>W_CYCLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a19008659d5b79c98ba2edfefb73b17a0af294963103e6075fd34881d6c9762e29"></a>UNKNOWN_MG_CYCLE_TYPE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="afe95f73a473353d18098f9fbf7ba8567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe95f73a473353d18098f9fbf7ba8567">&#9670;&nbsp;</a></span>RegridMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceIBTK.html#afe95f73a473353d18098f9fbf7ba8567">IBTK::RegridMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afe95f73a473353d18098f9fbf7ba8567af15af331bad16eed6efe38d5169f389a"></a>STANDARD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe95f73a473353d18098f9fbf7ba8567ad83ecc46228a4c8bce60a4df8a49056b"></a>AGGRESSIVE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe95f73a473353d18098f9fbf7ba8567a6ddad444aaee260c5a0f11d6f2d027ed"></a>UNKNOWN_REGRID_MODE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a081318a0a7bce6de82de3b81dd67794a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081318a0a7bce6de82de3b81dd67794a">&#9670;&nbsp;</a></span>VariableContextType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceIBTK.html#a081318a0a7bce6de82de3b81dd67794a">IBTK::VariableContextType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a081318a0a7bce6de82de3b81dd67794aa0df46afff987d6d92771ec52b3959977"></a>CURRENT_DATA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a081318a0a7bce6de82de3b81dd67794aada90f57d09ce8251d4fa58fb1dba62de"></a>NEW_DATA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a081318a0a7bce6de82de3b81dd67794aadd219ea2dc8002f9770549207756660b"></a>SCRATCH_DATA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a081318a0a7bce6de82de3b81dd67794aa835fb1cef6648c4647717485e1e41c26"></a>UNKNOWN_VARIABLE_CONTEXT_TYPE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aca0e485ab1820bbc97d938e4131d3972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0e485ab1820bbc97d938e4131d3972">&#9670;&nbsp;</a></span>VCInterpType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceIBTK.html#aca0e485ab1820bbc97d938e4131d3972">IBTK::VCInterpType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aca0e485ab1820bbc97d938e4131d3972af82189324a86df10848193c85bcf6bd8"></a>VC_AVERAGE_INTERP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aca0e485ab1820bbc97d938e4131d3972ad16a4e03cf055272a86cca038c6b65d6"></a>VC_HARMONIC_INTERP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aca0e485ab1820bbc97d938e4131d3972adaad48ad56a9e40158d2e57cb8edaa49"></a>UNKNOWN_VC_INTERP_TYPE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a4f11b6d5086d88dfb13c1518bf8b6afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f11b6d5086d88dfb13c1518bf8b6afd">&#9670;&nbsp;</a></span>NodeOutsidePatchCheckType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceIBTK.html#a4f11b6d5086d88dfb13c1518bf8b6afd">IBTK::NodeOutsidePatchCheckType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4f11b6d5086d88dfb13c1518bf8b6afda178e0cd3931e20acc7e3b793518b1b6d"></a>NODE_OUTSIDE_PERMIT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4f11b6d5086d88dfb13c1518bf8b6afdaeb02e5ca8910018e8986c55c86d03673"></a>NODE_OUTSIDE_WARN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4f11b6d5086d88dfb13c1518bf8b6afda3ac623c23d3170654eb95589df58b3d3"></a>NODE_OUTSIDE_ERROR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4f11b6d5086d88dfb13c1518bf8b6afda35b564b3c008a8bcb27eb3ce4ab3e4f1"></a>UNKNOWN_NODE_OUTSIDE_PATCH_CHECK_TYPE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a37c7f8cb3eb8f785386fb3be5d246782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c7f8cb3eb8f785386fb3be5d246782">&#9670;&nbsp;</a></span>TimePoint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782">IBTK::TimePoint</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a37c7f8cb3eb8f785386fb3be5d246782abc9cd2d8ebda07c7f1ce0a1d9a94c7cc"></a>CURRENT_TIME&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a37c7f8cb3eb8f785386fb3be5d246782ab763f44331074a91fe69ede12eac324b"></a>HALF_TIME&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a37c7f8cb3eb8f785386fb3be5d246782a9651fb594d683bfce76bb192716db1e1"></a>NEW_TIME&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a37c7f8cb3eb8f785386fb3be5d246782ac7f94f555b90ba339323af50894ea46b"></a>UNKNOWN_TIME&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a26083fd9213059180492800c432649a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26083fd9213059180492800c432649a2">&#9670;&nbsp;</a></span>merge_boxes_by_longest_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt;NDIM&gt; &gt; IBTK::merge_boxes_by_longest_edge </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a set of boxes (which describe a region in index space), return another set of boxes whose union covers the same index space. The returned set of boxes is formed by merging boxes in <code>boxes</code> along their longest edges. </p>

</div>
</div>
<a id="a9a2f64610b7d15183ce7e534a2f8a800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2f64610b7d15183ce7e534a2f8a800">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> IBTK::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Permit modifying FEUpdateFlags as though it were an integer type. </p>

</div>
</div>
<a id="aeec91280c11f51e37e3b3f17c2c814a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec91280c11f51e37e3b3f17c2c814a6">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> IBTK::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Permit modifying FEUpdateFlags as though it were an integer type. </p>

</div>
</div>
<a id="a57e94038433d94b44c668708c398e402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e94038433d94b44c668708c398e402">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&amp; IBTK::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Permit modifying FEUpdateFlags as though it were an integer type. </p>

</div>
</div>
<a id="a1582f6fd26602fbcf4515d3087f70b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1582f6fd26602fbcf4515d3087f70b96">&#9670;&nbsp;</a></span>operator&amp;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&amp; IBTK::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">FEUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Permit modifying FEUpdateFlags as though it were an integer type. </p>

</div>
</div>
<a id="a378982fbd968cc2b71685926f391cf97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378982fbd968cc2b71685926f391cf97">&#9670;&nbsp;</a></span>string_to_enum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T IBTK::string_to_enum </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7c9374e709f84b9a7bf5b61f8064ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c9374e709f84b9a7bf5b61f8064ecc">&#9670;&nbsp;</a></span>enum_to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string IBTK::enum_to_string </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a7ca4acf7739400e4b1bba7413312c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7ca4acf7739400e4b1bba7413312c3">&#9670;&nbsp;</a></span>string_to_enum&lt; MGCycleType &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIBTK.html#a19008659d5b79c98ba2edfefb73b17a0">MGCycleType</a> <a class="el" href="namespaceIBTK.html#a378982fbd968cc2b71685926f391cf97">IBTK::string_to_enum</a>&lt; <a class="el" href="namespaceIBTK.html#a19008659d5b79c98ba2edfefb73b17a0">MGCycleType</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af6f7c26c6b5f0c7960f38f41f9c5a3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f7c26c6b5f0c7960f38f41f9c5a3c4">&#9670;&nbsp;</a></span>enum_to_string&lt; MGCycleType &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceIBTK.html#aa7c9374e709f84b9a7bf5b61f8064ecc">IBTK::enum_to_string</a>&lt; <a class="el" href="namespaceIBTK.html#a19008659d5b79c98ba2edfefb73b17a0">MGCycleType</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a19008659d5b79c98ba2edfefb73b17a0">MGCycleType</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4fd86235dfd906319dea3bebb9e5c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fd86235dfd906319dea3bebb9e5c57">&#9670;&nbsp;</a></span>string_to_enum&lt; RegridMode &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIBTK.html#afe95f73a473353d18098f9fbf7ba8567">RegridMode</a> <a class="el" href="namespaceIBTK.html#a378982fbd968cc2b71685926f391cf97">IBTK::string_to_enum</a>&lt; <a class="el" href="namespaceIBTK.html#afe95f73a473353d18098f9fbf7ba8567">RegridMode</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03001e01e2b7846bf23e2b0a5f039768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03001e01e2b7846bf23e2b0a5f039768">&#9670;&nbsp;</a></span>enum_to_string&lt; RegridMode &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceIBTK.html#aa7c9374e709f84b9a7bf5b61f8064ecc">IBTK::enum_to_string</a>&lt; <a class="el" href="namespaceIBTK.html#afe95f73a473353d18098f9fbf7ba8567">RegridMode</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#afe95f73a473353d18098f9fbf7ba8567">RegridMode</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa52eba6c97612fff98f870ce29db3555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52eba6c97612fff98f870ce29db3555">&#9670;&nbsp;</a></span>string_to_enum&lt; VariableContextType &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIBTK.html#a081318a0a7bce6de82de3b81dd67794a">VariableContextType</a> <a class="el" href="namespaceIBTK.html#a378982fbd968cc2b71685926f391cf97">IBTK::string_to_enum</a>&lt; <a class="el" href="namespaceIBTK.html#a081318a0a7bce6de82de3b81dd67794a">VariableContextType</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac97bf54893b2b6fbe523a7a296367247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97bf54893b2b6fbe523a7a296367247">&#9670;&nbsp;</a></span>enum_to_string&lt; VariableContextType &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceIBTK.html#aa7c9374e709f84b9a7bf5b61f8064ecc">IBTK::enum_to_string</a>&lt; <a class="el" href="namespaceIBTK.html#a081318a0a7bce6de82de3b81dd67794a">VariableContextType</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a081318a0a7bce6de82de3b81dd67794a">VariableContextType</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f6e3ba6c157be86c5696008d59b5f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6e3ba6c157be86c5696008d59b5f4d">&#9670;&nbsp;</a></span>string_to_enum&lt; VCInterpType &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIBTK.html#aca0e485ab1820bbc97d938e4131d3972">VCInterpType</a> <a class="el" href="namespaceIBTK.html#a378982fbd968cc2b71685926f391cf97">IBTK::string_to_enum</a>&lt; <a class="el" href="namespaceIBTK.html#aca0e485ab1820bbc97d938e4131d3972">VCInterpType</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a031c25dc335135dda3025f2705d3f04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031c25dc335135dda3025f2705d3f04a">&#9670;&nbsp;</a></span>enum_to_string&lt; VCInterpType &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceIBTK.html#aa7c9374e709f84b9a7bf5b61f8064ecc">IBTK::enum_to_string</a>&lt; <a class="el" href="namespaceIBTK.html#aca0e485ab1820bbc97d938e4131d3972">VCInterpType</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#aca0e485ab1820bbc97d938e4131d3972">VCInterpType</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f1008d47ad40da2288b3ba08307784a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1008d47ad40da2288b3ba08307784a">&#9670;&nbsp;</a></span>string_to_enum&lt; NodeOutsidePatchCheckType &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIBTK.html#a4f11b6d5086d88dfb13c1518bf8b6afd">NodeOutsidePatchCheckType</a> <a class="el" href="namespaceIBTK.html#a378982fbd968cc2b71685926f391cf97">IBTK::string_to_enum</a>&lt; <a class="el" href="namespaceIBTK.html#a4f11b6d5086d88dfb13c1518bf8b6afd">NodeOutsidePatchCheckType</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abbfaff651ceafd14e9c2d55955a09e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfaff651ceafd14e9c2d55955a09e53">&#9670;&nbsp;</a></span>enum_to_string&lt; NodeOutsidePatchCheckType &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceIBTK.html#aa7c9374e709f84b9a7bf5b61f8064ecc">IBTK::enum_to_string</a>&lt; <a class="el" href="namespaceIBTK.html#a4f11b6d5086d88dfb13c1518bf8b6afd">NodeOutsidePatchCheckType</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a4f11b6d5086d88dfb13c1518bf8b6afd">NodeOutsidePatchCheckType</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aae0c3eb2d7962831f32374c8b174f266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0c3eb2d7962831f32374c8b174f266">&#9670;&nbsp;</a></span>string_to_enum&lt; TimePoint &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782">TimePoint</a> <a class="el" href="namespaceIBTK.html#a378982fbd968cc2b71685926f391cf97">IBTK::string_to_enum</a>&lt; <a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782">TimePoint</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a891e0de16b7751a71a1b9147ea123c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891e0de16b7751a71a1b9147ea123c24">&#9670;&nbsp;</a></span>enum_to_string&lt; TimePoint &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceIBTK.html#aa7c9374e709f84b9a7bf5b61f8064ecc">IBTK::enum_to_string</a>&lt; <a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782">TimePoint</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a37c7f8cb3eb8f785386fb3be5d246782">TimePoint</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ddabfcd34ababf0834ec38c2a7c4c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddabfcd34ababf0834ec38c2a7c4c39">&#9670;&nbsp;</a></span>mpi_type_id() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Datatype IBTK::mpi_type_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8c691a2b1f28c51707460a095cf2b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c691a2b1f28c51707460a095cf2b15">&#9670;&nbsp;</a></span>mpi_type_id() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Datatype IBTK::mpi_type_id </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57b0c51d3da18f6ce9bd90804cebbb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b0c51d3da18f6ce9bd90804cebbb51">&#9670;&nbsp;</a></span>mpi_type_id() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Datatype IBTK::mpi_type_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae73599fa4fc37abf78a70e601b2f8695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73599fa4fc37abf78a70e601b2f8695">&#9670;&nbsp;</a></span>mpi_type_id() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Datatype IBTK::mpi_type_id </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fd3c0b75d6cecc44097ab5fc55c10d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd3c0b75d6cecc44097ab5fc55c10d3">&#9670;&nbsp;</a></span>mpi_type_id() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Datatype IBTK::mpi_type_id </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a795e57846fae15ab87c8cede49ea627e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795e57846fae15ab87c8cede49ea627e">&#9670;&nbsp;</a></span>mpi_type_id() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Datatype IBTK::mpi_type_id </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; float, <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acfbcd21d326bb27292544e3f61ec7ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbcd21d326bb27292544e3f61ec7ff7">&#9670;&nbsp;</a></span>mpi_type_id() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Datatype IBTK::mpi_type_id </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="accd5dfe1e8fa179577fc4113402bd286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd5dfe1e8fa179577fc4113402bd286">&#9670;&nbsp;</a></span>mpi_type_id() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Datatype IBTK::mpi_type_id </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47de442a01da3c636968316c57049329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47de442a01da3c636968316c57049329">&#9670;&nbsp;</a></span>mpi_type_id() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Datatype IBTK::mpi_type_id </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9af5457aa7b50c3efa4126055ae1c5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af5457aa7b50c3efa4126055ae1c5a6">&#9670;&nbsp;</a></span>rel_equal_eps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::rel_equal_eps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>eps</em> = <code>std::sqrt(std::numeric_limits&lt;<a class="el" href="classdouble.html">double</a>&gt;::epsilon())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check whether the relative difference between a and b are within the threshold eps.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be used with caution to check numbers close to zero. In this case, consider using the abs_equal_eps function. </dd></dl>

</div>
</div>
<a id="aebb9571d83ab737535a849cbb0803c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb9571d83ab737535a849cbb0803c43">&#9670;&nbsp;</a></span>abs_equal_eps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::abs_equal_eps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>eps</em> = <code>std::sqrt(std::numeric_limits&lt;<a class="el" href="classdouble.html">double</a>&gt;::epsilon())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function should be used with caution to check numbers that have large magnitudes. In these cases, consider using the rel_equal_eps function. </dd></dl>

</div>
</div>
<a id="a41f0d16e02dcc4734ef6fb35bb70b0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f0d16e02dcc4734ef6fb35bb70b0ba">&#9670;&nbsp;</a></span>get_data_time_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string IBTK::get_data_time_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6cf75ea2f6fb03d09bc32341d9c0a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6cf75ea2f6fb03d09bc32341d9c0a09">&#9670;&nbsp;</a></span>get_min_patch_dx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBTK::get_min_patch_dx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch_level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the smallest cell width on the specified level. This operation is collective. </p>

</div>
</div>
<a id="a745d00f9bbbb00d11e989436f8ce7911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745d00f9bbbb00d11e989436f8ce7911">&#9670;&nbsp;</a></span>array_constant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, N&gt; IBTK::array_constant </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a526c5e2ad3c545703a6e180a3e3231bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526c5e2ad3c545703a6e180a3e3231bc">&#9670;&nbsp;</a></span>array_one()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, N&gt; IBTK::array_one </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac284988f6336dc2b082c6fd1ff38fbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac284988f6336dc2b082c6fd1ff38fbee">&#9670;&nbsp;</a></span>array_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, N&gt; IBTK::array_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7a14e41cdb653b629ee7aed2958d387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a14e41cdb653b629ee7aed2958d387">&#9670;&nbsp;</a></span>level_can_be_refined()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::level_can_be_refined </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_levels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d81edd603b8e9ea39ec04e986480c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d81edd603b8e9ea39ec04e986480c6d">&#9670;&nbsp;</a></span>voigt_to_tensor_idx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>&gt; IBTK::voigt_to_tensor_idx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a Voigt notation index to the corresponding symmetric tensor index. This function only returns the upper triangular index. </p>

</div>
</div>
<a id="a5eed5a2c7a3e14447a70fe4a46b42aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eed5a2c7a3e14447a70fe4a46b42aad">&#9670;&nbsp;</a></span>tensor_idx_to_voigt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::tensor_idx_to_voigt </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a symmetric tensor index to the corresponding Voigt notation index. </p>

</div>
</div>
<a id="abd643aba5793178126d00ce49bc89117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd643aba5793178126d00ce49bc89117">&#9670;&nbsp;</a></span>smooth_heaviside()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBTK::smooth_heaviside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Smooth heaviside function. </p>

</div>
</div>
<a id="a656dd83948f190947d77648f9968936d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656dd83948f190947d77648f9968936d">&#9670;&nbsp;</a></span>smooth_delta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBTK::smooth_delta </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Smooth delta function. </p>

</div>
</div>
<a id="ac191f1d9b061d30c1b4ad47f66dc582e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac191f1d9b061d30c1b4ad47f66dc582e">&#9670;&nbsp;</a></span>discontinuous_heaviside()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBTK::discontinuous_heaviside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Discontinuous heaviside function. </p>

</div>
</div>
<a id="a714c8977f8e113df297ff17b71683b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714c8977f8e113df297ff17b71683b62">&#9670;&nbsp;</a></span>deallocate_vector_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::deallocate_vector_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deallocate a SAMRAIVectorReal. </p>

</div>
</div>
<a id="ae5eb8c1b082d5690d6b59fc45dc1dafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5eb8c1b082d5690d6b59fc45dc1dafe">&#9670;&nbsp;</a></span>free_vector_components()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::free_vector_components </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free the components of a SAMRAIVectorReal. </p>

</div>
</div>
<a id="a20c9f83fddcfd441b41c75aaa9325ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c9f83fddcfd441b41c75aaa9325ca6">&#9670;&nbsp;</a></span>checked_dereference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; IBTK::checked_dereference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function which asserts that the <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> pointer is not null.</p>
<p>This is useful for writing generic code in which we might want to assert that a pointer is not null in the initialization list where we cannot use the normal assertion macro. </p>

</div>
</div>
<a id="accd05bbfd156142ef625ad1683e44e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd05bbfd156142ef625ad1683e44e75">&#9670;&nbsp;</a></span>checked_dereference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; IBTK::checked_dereference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same idea, but for a non-const pointer. </p>

</div>
</div>
<a id="aac8d519e0d0fa8226dd2dd3b5cc4852f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8d519e0d0fa8226dd2dd3b5cc4852f">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt; IBTK::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#a2b73983d16b31c6192694e6101f57273">VectorNd</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>Q_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>Q_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>patch_hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>kernel_fcn</em> = <code>&quot;IB_4&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fae93b8ba9a8a747ff3bbfda25a7a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fae93b8ba9a8a747ff3bbfda25a7a7b">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt; IBTK::interpolate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceIBTK.html#a2b73983d16b31c6192694e6101f57273">VectorNd</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>Q_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>Q_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>patch_hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>kernel_fcn</em> = <code>&quot;IB_4&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6862737600f8050ffc8a9193d2855fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6862737600f8050ffc8a9193d2855fac">&#9670;&nbsp;</a></span>get_dim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::get_dim </td>
          <td>(</td>
          <td class="paramtype">const libMesh::ElemType&#160;</td>
          <td class="paramname"><em>elem_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Utility function for getting the dimensionality of a <a class="el" href="namespacelibMesh.html">libMesh</a> element type. </p>

</div>
</div>
<a id="a5a597273d59eba2e3a2a2c5f4f3978f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a597273d59eba2e3a2a2c5f4f3978f6">&#9670;&nbsp;</a></span>get_n_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t IBTK::get_n_nodes </td>
          <td>(</td>
          <td class="paramtype">const libMesh::ElemType&#160;</td>
          <td class="paramname"><em>elem_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Utility function for getting the number of nodes of a <a class="el" href="namespacelibMesh.html">libMesh</a> element type. </p>

</div>
</div>
<a id="a7726626d63e9010519ec81caa7ad6aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7726626d63e9010519ec81caa7ad6aec">&#9670;&nbsp;</a></span>get_default_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Order IBTK::get_default_order </td>
          <td>(</td>
          <td class="paramtype">const libMesh::ElemType&#160;</td>
          <td class="paramname"><em>elem_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Utility function for getting the default order of a <a class="el" href="namespacelibMesh.html">libMesh</a> element type. </p>

</div>
</div>
<a id="a89d9e757aec602f3e004b0f358aa4ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d9e757aec602f3e004b0f358aa4ac6">&#9670;&nbsp;</a></span>copy_and_synch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::copy_and_synch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close_v_in</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close_v_out</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4bd271fbec4ef139e18db887375d1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bd271fbec4ef139e18db887375d1ae">&#9670;&nbsp;</a></span>batch_vec_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::batch_vec_copy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_vecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b0aedb65486ee6f549037773c72e511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0aedb65486ee6f549037773c72e511">&#9670;&nbsp;</a></span>batch_vec_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::batch_vec_copy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_vecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6fec04e6523e6c8f83de2f7d918810b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6fec04e6523e6c8f83de2f7d918810b">&#9670;&nbsp;</a></span>batch_vec_assembly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::batch_vec_assembly </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a40353749599abca6ca36c221001787a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40353749599abca6ca36c221001787a3">&#9670;&nbsp;</a></span>batch_vec_assembly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::batch_vec_assembly </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8557a2bff01645c5c9140b10323492b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8557a2bff01645c5c9140b10323492b">&#9670;&nbsp;</a></span>batch_vec_ghost_update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::batch_vec_ghost_update </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode&#160;</td>
          <td class="paramname"><em>insert_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScatterMode&#160;</td>
          <td class="paramname"><em>scatter_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abbd21f0ce38740f36c527bd51d00cea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd21f0ce38740f36c527bd51d00cea2">&#9670;&nbsp;</a></span>batch_vec_ghost_update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::batch_vec_ghost_update </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode&#160;</td>
          <td class="paramname"><em>insert_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScatterMode&#160;</td>
          <td class="paramname"><em>scatter_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b41be6d36de9d935548318a7c6dfacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b41be6d36de9d935548318a7c6dfacf">&#9670;&nbsp;</a></span>setup_system_vectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::setup_system_vectors </td>
          <td>(</td>
          <td class="paramtype">libMesh::EquationSystems *&#160;</td>
          <td class="paramname"><em>equation_systems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>system_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>from_restart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function that calls setup_system_vector for all specified systems and vector names. This function is aware of System::rhs and will reset it correctly. </p>

</div>
</div>
<a id="a18c7364c1bce910e24678a0db1cbe084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c7364c1bce910e24678a0db1cbe084">&#9670;&nbsp;</a></span>setup_system_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::setup_system_vector </td>
          <td>(</td>
          <td class="paramtype">libMesh::System &amp;&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vector_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>from_restart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setup the vector with name <code>vector_name</code> in the libMesh::System object named <code>system_name</code>.</p>
<p>The behavior of this function depends on whether or not we are working with restart data: </p><ol>
<li>
If <code>from_restart</code> is false then the vector is added to the system in the normal way. </li>
<li>
If <code>from_restart</code> is true then the vector stored in the System corresponding to the given name is overwritten and has its type changed from PARALLEL to GHOSTED. This works around a bug in <a class="el" href="namespacelibMesh.html">libMesh</a> versions prior to 1.7.0 where vectors are always serialized as PARALLEL. </li>
</ol>

</div>
</div>
<a id="a4cf0ebd2eaf6f0e5da22eb24321914c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf0ebd2eaf6f0e5da22eb24321914c3">&#9670;&nbsp;</a></span>copy_dof_ids_to_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::copy_dof_ids_to_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>var_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; libMesh::dof_id_type, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>elem_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; libMesh::dof_id_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Utility function for copying dofs from the format used by <a class="el" href="namespaceIBAMR.html">IBAMR</a> for caching to the format <a class="el" href="namespacelibMesh.html">libMesh</a> expects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">var_n</td><td>The variable number.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_dofs</td><td>Dofs on the current element, indexed first by variable.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dofs</td><td>vector containing the dofs for the given vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e1b936ae530a4aacdc032c8edbb3475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1b936ae530a4aacdc032c8edbb3475">&#9670;&nbsp;</a></span>apply_transposed_constraint_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::apply_transposed_constraint_matrix </td>
          <td>(</td>
          <td class="paramtype">const libMesh::DofMap &amp;&#160;</td>
          <td class="paramname"><em>dof_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply in-place the action of the transpose of the constraint matrix stored by <code>dof_map</code> to <code>rhs</code>.</p>
<p>This function is necessary (instead of the usual procedure, where we apply constraints to element vectors during assembly) when assembly is done with the IB partitioning since, in that case, the constraints corresponding to the elements used for assembly are not available. To resolve this problem we recommend doing the following:</p>
<ol>
<li>
Assemble a RHS vector without considering the constraints (this is done, for example, in <a class="el" href="classIBTK_1_1FEDataManager.html#abc7cb3a78eb4576d22a9b00f7601faca" title="Set up the right-hand side F of an L2 projection problem where Eulerian data given by f_data_idx is p...">FEDataManager::interpWeighted()</a>). </li>
<li>
Assemble the vector in parallel in the normal way (i.e., via VecGhostUpdateBegin() and VecGhostUpdateEnd()). <em>This function assumes that the input vector contains up-to-date ghost data for all entries relevant to resolving constraints.</em> </li>
<li>
Call this function. This function replaces the ghost values in the input vector with entries that need to be summed into off-processor entries (i.e., the values generated during constraint resolution when a locally owned dof is constrained by values of off-processor dofs.) </li>
<li>
Do assembly a second time (i.e., again with VecGhostUpdateBegin() and VecGhostUpdateEnd()). </li>
</ol>

</div>
</div>
<a id="a492518a5170b5fa7e076f6634a7a935b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492518a5170b5fa7e076f6634a7a935b">&#9670;&nbsp;</a></span>getQuadratureKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIBTK.html#a8dcbdcaac090060b5a4ee6d10120911b">quadrature_key_type</a> IBTK::getQuadratureKey </td>
          <td>(</td>
          <td class="paramtype">libMesh::QuadratureType&#160;</td>
          <td class="paramname"><em>quad_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libMesh::Order&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_adaptive_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>point_density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_rules_with_negative_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::Elem *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; <a class="el" href="classdouble.html">double</a>, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dx_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the quadrature key description (see <a class="el" href="classIBTK_1_1QuadratureCache.html" title="Class storing multiple libMesh quadrature objects. We assume that quadrature rules are uniquely deter...">QuadratureCache</a> and <a class="el" href="classIBTK_1_1FECache.html" title="Class storing multiple libMesh::FE objects, each corresponding to a different quadrature rule....">FECache</a>) of a quadrature rule.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quad_type</td><td>The type of quadrature rule to use. At the present time only QGAUSS and QGRID are supported.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The order of the quadrature rule.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_adaptive_quadrature</td><td>Whether or not the element data should be read (and <code>order</code> possibly modified) to get the correct quadrature point spacing.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_density</td><td>Parameter for computing the number of points in the quadrature rule. The number of points is computed as <code>ceil(point_density * hmax / dx_min)</code>, where <code>hmax</code> is the maximum edge length of the deformed element (i.e., with nodal coordinates given by <code>X_node</code>).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allow_rules_with_negative_weights</td><td>Whether the quadrature rule is allowed to have any negative weights.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The <a class="el" href="namespacelibMesh.html">libMesh</a> element. The quadrature rule generated by this function will always have enough points to integrate the basis functions defined on the element exactly.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_node</td><td>Values of <code>elem's</code> shape functions of the structure location field (i.e., X): for interpolatory finite elements (e.g., libMesh::LAGRANGE) these the actual coordinates of the node (since shape functions will either be one or zero at nodes). <code>X_node</code> is assumed to be a two-dimensional array whose rows correspond to node number and whose columns correspond to x, y, and (in 3D) z coordinates.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dx_min</td><td>See <code>point_density</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>@seealso <a class="el" href="classIBTK_1_1FEDataManager.html#ae4ed30182580bdcb694def0583fff81c">FEDataManager::updateQuadratureRule</a>. </p>

</div>
</div>
<a id="abed5aca02cba73e5d78468ef40470e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed5aca02cba73e5d78468ef40470e7d">&#9670;&nbsp;</a></span>get_values_for_interpolation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray , class Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::get_values_for_interpolation </td>
          <td>(</td>
          <td class="paramtype">MultiArray &amp;&#160;</td>
          <td class="paramname"><em>U_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>U_petsc_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>U_local_soln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Populate <code>U_node</code> with the finite element solution coefficients on the current element. This particular overload is for scalar finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">U_node</td><td>Multidimensional array (usually a boost::multi_array) which will be filled with finite element solution coefficients.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_petsc_vec</td><td>The relevant finite element solution vector.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_local_soln</td><td>A localized version of the current solution (i.e., the same information as <code>U_petsc_vec</code>, but accessed with local instead of global indices).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_indices</td><td>DoF indices of the current element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5566c2958f93c08e9f6f9581fbf8a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5566c2958f93c08e9f6f9581fbf8a96">&#9670;&nbsp;</a></span>get_values_for_interpolation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray_1 , class MultiArray_2 , class Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::get_values_for_interpolation </td>
          <td>(</td>
          <td class="paramtype">MultiArray_1 &amp;&#160;</td>
          <td class="paramname"><em>U_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>U_petsc_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>U_local_soln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArray_2 &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Populate <code>U_node</code> with the finite element solution coefficients on the current element. This particular overload is for vector-valued finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">U_node</td><td>Multidimensional array (usually a boost::multi_array) which will be filled with finite element solution coefficients.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_petsc_vec</td><td>The relevant finite element solution vector.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_local_soln</td><td>A localized version of the current solution (i.e., the same information as <code>U_petsc_vec</code>, but accessed with local instead of global indices).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_indices</td><td>DoF indices of the current element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85814a33961cc7772ab4ce8d5ba38f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85814a33961cc7772ab4ce8d5ba38f06">&#9670;&nbsp;</a></span>get_values_for_interpolation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::get_values_for_interpolation </td>
          <td>(</td>
          <td class="paramtype">MultiArray &amp;&#160;</td>
          <td class="paramname"><em>U_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>U_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Populate <code>U_node</code> with the finite element solution coefficients on the current element. This particular overload is for scalar finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">U_node</td><td>Multidimensional array (usually a boost::multi_array) which will be filled with finite element solution coefficients.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_vec</td><td>The relevant finite element solution vector. This must be a <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_indices</td><td>DoF indices of the current element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7af807f024e42d14c9afa7ba41cda42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7af807f024e42d14c9afa7ba41cda42">&#9670;&nbsp;</a></span>get_values_for_interpolation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray_1 , class MultiArray_2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::get_values_for_interpolation </td>
          <td>(</td>
          <td class="paramtype">MultiArray_1 &amp;&#160;</td>
          <td class="paramname"><em>U_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>U_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArray_2 &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Populate <code>U_node</code> with the finite element solution coefficients on the current element. This particular overload is for vector-valued finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">U_node</td><td>Multidimensional array (usually a boost::multi_array) which will be filled with finite element solution coefficients.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_vec</td><td>The relevant finite element solution vector. This must be a <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_indices</td><td>DoF indices of the current element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e621904d431a494ee6d70939ea3517b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e621904d431a494ee6d70939ea3517b">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArray &amp;&#160;</td>
          <td class="paramname"><em>U_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the current solution at quadrature point number @qp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>Value of the finite element solution at the given point.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qp</td><td>Number of the quadrature point at which we will compute the solution value.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_node</td><td>Multidimensional array containing finite element solution coefficients on the current element.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi</td><td>Reference values of the shape functions indexed in the usual way (first by basis function number and then by quadrature point number). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc24178d5490dc9c567ced0c6fd396dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc24178d5490dc9c567ced0c6fd396dd">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBTK::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArray &amp;&#160;</td>
          <td class="paramname"><em>U_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the current solution at quadrature point number @qp. Returns the value instead of taking a reference to it as the first argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qp</td><td>Number of the quadrature point at which we will compute the solution value.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_node</td><td>Multidimensional array containing finite element solution coefficients on the current element.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi</td><td>Reference values of the shape functions indexed in the usual way (first by basis function number and then by quadrature point number). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a4cce3704003cf03a1d50ca1b5856cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4cce3704003cf03a1d50ca1b5856cb">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *const&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArray &amp;&#160;</td>
          <td class="paramname"><em>U_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the current solution at quadrature point number @qp. This version of <a class="el" href="namespaceIBTK.html#aac8d519e0d0fa8226dd2dd3b5cc4852f">interpolate()</a> is vector-valued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>Array containing the output of this function. This function assumes that this array has at least <code>U_node.shape()[1]</code> entries.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qp</td><td>Number of the quadrature point at which we will compute the solution value.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_node</td><td>Multidimensional array containing finite element solution coefficients on the current element.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi</td><td>Reference values of the shape functions indexed in the usual way (first by basis function number and then by quadrature point number). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7533ce02f3c58746ebc2ea90405fcc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7533ce02f3c58746ebc2ea90405fcc2">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::interpolate </td>
          <td>(</td>
          <td class="paramtype">libMesh::TypeVector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArray &amp;&#160;</td>
          <td class="paramname"><em>U_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the current solution at quadrature point number @qp. This version of <a class="el" href="namespaceIBTK.html#aac8d519e0d0fa8226dd2dd3b5cc4852f">interpolate()</a> is vector-valued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>Array containing the output of this function. This function assumes that this TypeVector has at least <code>U_node.shape()[1]</code> entries.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qp</td><td>Number of the quadrature point at which we will compute the solution value.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_node</td><td>Multidimensional array containing finite element solution coefficients on the current element.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi</td><td>Reference values of the shape functions indexed in the usual way (first by basis function number and then by quadrature point number). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9028293137d8bfcafec9ac4a39d5381e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9028293137d8bfcafec9ac4a39d5381e">&#9670;&nbsp;</a></span>jacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::jacobian </td>
          <td>(</td>
          <td class="paramtype">libMesh::TypeTensor&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dX_ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArray &amp;&#160;</td>
          <td class="paramname"><em>X_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dphi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the jacobian with respect to the initial configuration in the deformed configuration <code>X_node</code> at quadrature point number @qp.</p>
<p class="formulaDsp">
\[ J(qp) = \sum_{i = 1}^n \xi_i \otimes \nabla_X \phi_i(qp) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dX_ds</td><td>Tensor containing the output of this function of size 3x3.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qp</td><td>Number of the quadrature point at which we will compute the solution value.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_node</td><td>Values of the shape functions of the structure location field (i.e., X): for interpolatory finite elements (e.g., libMesh::LAGRANGE) these the actual coordinates of the node (since shape functions will either be one or zero at nodes). <code>X_node</code> is assumed to be a two-dimensional array whose rows correspond to node number and whose columns correspond to x, y, and (in 3D) z coordinates.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dphi</td><td>Reference values of the gradient of the shape functions indexed in the usual way (first by basis function number and then by quadrature point number). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae30f742f750669176152497db0ef0726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30f742f750669176152497db0ef0726">&#9670;&nbsp;</a></span>tensor_inverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::tensor_inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dim</em> = <code>NDIM</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1f2422ce2973d7fd6a5e6cd59760c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f2422ce2973d7fd6a5e6cd59760c52">&#9670;&nbsp;</a></span>tensor_inverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; IBTK::tensor_inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dim</em> = <code>NDIM</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a20a57a16c4c54f61aaa275e2dfe42c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a57a16c4c54f61aaa275e2dfe42c9b">&#9670;&nbsp;</a></span>tensor_inverse_transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::tensor_inverse_transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_inv_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dim</em> = <code>NDIM</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4faa18f96d9a0bc0ebb915eb2d9c3744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4faa18f96d9a0bc0ebb915eb2d9c3744">&#9670;&nbsp;</a></span>tensor_inverse_transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; IBTK::tensor_inverse_transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dim</em> = <code>NDIM</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aef27a5af903369f0c26e66e4e2155b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef27a5af903369f0c26e66e4e2155b81">&#9670;&nbsp;</a></span>outer_product() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::outer_product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_prod_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::TypeVector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::TypeVector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dim</em> = <code>NDIM</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fa273687ead649c1d10fb8382ea1f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa273687ead649c1d10fb8382ea1f21">&#9670;&nbsp;</a></span>outer_product() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1TensorValue.html">libMesh::TensorValue</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; IBTK::outer_product </td>
          <td>(</td>
          <td class="paramtype">const libMesh::TypeVector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::TypeVector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dim</em> = <code>NDIM</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a45293290dab489896e0d1bb04efb6d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45293290dab489896e0d1bb04efb6d75">&#9670;&nbsp;</a></span>intersect_line_with_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::intersect_line_with_edge </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="classdouble.html">double</a>, libMesh::Point &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libMesh::Edge *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libMesh::Point&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4956967de7ecb8746eddcc1d54e24283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4956967de7ecb8746eddcc1d54e24283">&#9670;&nbsp;</a></span>intersect_line_with_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::intersect_line_with_face </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="classdouble.html">double</a>, libMesh::Point &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libMesh::Face *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libMesh::Point&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d173c9bc7d2bcd1c37c549a2075adca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d173c9bc7d2bcd1c37c549a2075adca">&#9670;&nbsp;</a></span>get_nodal_dof_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::get_nodal_dof_indices </td>
          <td>(</td>
          <td class="paramtype">const libMesh::DofMap &amp;&#160;</td>
          <td class="paramname"><em>dof_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::Node *const&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>variable_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; libMesh::dof_id_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodal_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recent versions of <a class="el" href="namespacelibMesh.html">libMesh</a> acquired a useful function that lets us extract the DoFs corresponding to basis functions with node value functionals. This compatibility function either calls that function directly or uses our own implementation if the present <a class="el" href="namespacelibMesh.html">libMesh</a> is too old.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>Use DofMap::dof_indices() instead. </dd></dl>

</div>
</div>
<a id="aca9fab55956157fb2e0bc09f77c0f425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9fab55956157fb2e0bc09f77c0f425">&#9670;&nbsp;</a></span>get_max_edge_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBTK::get_max_edge_length </td>
          <td>(</td>
          <td class="paramtype">const libMesh::Elem *const&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArray &amp;&#160;</td>
          <td class="paramname"><em>X_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the maximum edge length of a given element with mapped nodes. If the edges of the mapped element are not straight lines (i.e., a Tet10 element subject to some nonlinear deformation) then the edge length is approximated as the sum of the lengths of the line segments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The given <a class="el" href="namespacelibMesh.html">libMesh</a> element.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_node</td><td>Values of <code>elem's</code> shape functions of the structure location field (i.e., X): for interpolatory finite elements (e.g., libMesh::LAGRANGE) these the actual coordinates of the node (since shape functions will either be one or zero at nodes). <code>X_node</code> is assumed to be a two-dimensional array whose rows correspond to node number and whose columns correspond to x, y, and (in 3D) z coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aceed8ef2e29cf7a38d720d5418751e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceed8ef2e29cf7a38d720d5418751e73">&#9670;&nbsp;</a></span>write_elem_partitioning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::write_elem_partitioning </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::System &amp;&#160;</td>
          <td class="paramname"><em>position_system</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save, in a plain text file, the <a class="el" href="namespacelibMesh.html">libMesh</a> partitioning, with the format </p><pre class="fragment">x,y,z,rank
</pre><p>where x, y, and z are the center of an Elem and rank is the current MPI rank.</p>
<dl class="section note"><dt>Note</dt><dd>this function collates the output from all MPI processors in the communicator assigned to <code>position_system</code>, so it is an inherently serial function. </dd></dl>

</div>
</div>
<a id="a07ede2ffd0f710fcf1b00c933cdc4da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ede2ffd0f710fcf1b00c933cdc4da8">&#9670;&nbsp;</a></span>write_node_partitioning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::write_node_partitioning </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::System &amp;&#160;</td>
          <td class="paramname"><em>position_system</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save, in a plain text file, the <a class="el" href="namespacelibMesh.html">libMesh</a> Node partitioning, with the format </p><pre class="fragment">x,y,z,rank
</pre><p>where x, y, and z are the coordinates of a Node and rank is the current MPI rank.</p>
<dl class="section note"><dt>Note</dt><dd>this function collates the output from all MPI processors in the communicator assigned to <code>position_system</code>, so it is an inherently serial function. </dd></dl>

</div>
</div>
<a id="a5cdfa95b0f503f8d536421975ab1967e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdfa95b0f503f8d536421975ab1967e">&#9670;&nbsp;</a></span>get_local_element_bounding_boxes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::BoundingBox&gt; IBTK::get_local_element_bounding_boxes </td>
          <td>(</td>
          <td class="paramtype">const libMesh::MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::System &amp;&#160;</td>
          <td class="paramname"><em>X_system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libMesh::QuadratureType&#160;</td>
          <td class="paramname"><em>quad_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libMesh::Order&#160;</td>
          <td class="paramname"><em>quad_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_adaptive_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>point_density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_rules_with_negative_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>patch_dx_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute bounding boxes based on where an elements quadrature points are. See getQuadratureKey for descriptions of the last five arguments.</p>
<dl class="section warning"><dt>Warning</dt><dd>Since non-active elements do not have degrees of freedom assigned to them, this function assigns them bounding boxes that cover the complete range of finite double precision values. They are still included in the output vector so that that vector can be indexed by element ids. </dd></dl>

</div>
</div>
<a id="a5f37f0ab5719de37e2222276d354f9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f37f0ab5719de37e2222276d354f9d9">&#9670;&nbsp;</a></span>get_local_element_bounding_boxes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::BoundingBox&gt; IBTK::get_local_element_bounding_boxes </td>
          <td>(</td>
          <td class="paramtype">const libMesh::MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::System &amp;&#160;</td>
          <td class="paramname"><em>X_system</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute bounding boxes for each local (i.e., owned by the current processor) element in <code>mesh</code> with coordinates given by <code>X_system</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Since non-active elements do not have degrees of freedom assigned to them, this function assigns them bounding boxes that cover the complete range of finite double precision values. They are still included in the output vector so that that vector can be indexed by element ids. </dd></dl>

</div>
</div>
<a id="a7930152214e1b9eaf0aac541be3560ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7930152214e1b9eaf0aac541be3560ae">&#9670;&nbsp;</a></span>get_global_element_bounding_boxes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::BoundingBox&gt; IBTK::get_global_element_bounding_boxes </td>
          <td>(</td>
          <td class="paramtype">const libMesh::MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; libMesh::BoundingBox &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_bboxes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the global list of bounding boxes from the local list.</p>
<dl class="section warning"><dt>Warning</dt><dd>Since non-active elements do not have degrees of freedom assigned to them, this function assigns them bounding boxes that cover the complete range of finite double precision values. They are still included in the output vector so that that vector can be indexed by element ids. </dd></dl>

</div>
</div>
<a id="a7b0a5591017f3ba7225050b2aaf4ea5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0a5591017f3ba7225050b2aaf4ea5e">&#9670;&nbsp;</a></span>get_global_element_bounding_boxes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::BoundingBox&gt; IBTK::get_global_element_bounding_boxes </td>
          <td>(</td>
          <td class="paramtype">const libMesh::MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::System &amp;&#160;</td>
          <td class="paramname"><em>X_system</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute bounding boxes for all elements in <code>mesh</code> with coordinates given by <code>X_system</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Since non-active elements do not have degrees of freedom assigned to them, this function assigns them bounding boxes that cover the complete range of finite double precision values. They are still included in the output vector so that that vector can be indexed by element ids. </dd></dl>

</div>
</div>
<a id="a67fdfe0a5d6114b04e025c647f22883f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fdfe0a5d6114b04e025c647f22883f">&#9670;&nbsp;</a></span>setup_petsc_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vec IBTK::setup_petsc_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_local_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nonlocal_petsc_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal function for setting up a PETSc function of given size and depth. See the documentation of <a class="el" href="classIBTK_1_1LData.html" title="Class LData provides storage for a single scalar- or vector-valued Lagrangian quantity.">LData</a> for more information. </p>

</div>
</div>
<a id="a085d3e516adba59c0389be491da63052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085d3e516adba59c0389be491da63052">&#9670;&nbsp;</a></span>update_snapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::update_snapshot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1SnapshotCache.html">SnapshotCache</a> &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>u_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>current_hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1.0e-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update a snapshot at the given time. This function copies the data stored in u_idx into the snapshot index in the cache object. The snapshotted hierarchy is also updated to the current hierarchy.</p>
<p>This outputs an error if a snapshot with that time point within the specified tolerance can not be found.</p>
<p>Calls to this function may use a different patch index than the one used in setSnapshot(), but the underlying data layout must be consistent. This data layout is specified by the variable used to construct the cache. </p>

</div>
</div>
<a id="a23d5fe26a02150fd4d2413fe9f4dd2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d5fe26a02150fd4d2413fe9f4dd2ab">&#9670;&nbsp;</a></span>fill_snapshot_on_hierarchy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::fill_snapshot_on_hierarchy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1SnapshotCache.html">SnapshotCache</a> &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>u_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>current_hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>snapshot_refine_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1.0e-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transfer the snapshot at the specified time value within a given tolerance to the patch index u_idx on the supplied patch hierarchy. The patch index u_idx must contain sufficient ghost cell width to perform the operations used by the refinement operator.</p>
<p>Note this can require a significant amount of communication if the supplied patch hierarchy has a different configuration of patches than the snapshot patch hierarchy.</p>
<p>This function does not synchronize the data on the current hierarchy (i.e. no coarsening is performed). It transfers the snapshot using the refinement operator. </p>

</div>
</div>
<a id="a2d5a774f26d36fed17d038b8217511ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5a774f26d36fed17d038b8217511ee">&#9670;&nbsp;</a></span>fill_snapshot_at_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::fill_snapshot_at_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1SnapshotCache.html">SnapshotCache</a> &amp;&#160;</td>
          <td class="paramname"><em>snapshot_cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>u_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>scr_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>refine_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsReal.html">SAMRAI::math::HierarchyDataOpsReal</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>hier_data_ops</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>period</em> = <code>std::numeric_limits&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;::quiet_NaN()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function interpolates in time between two snapshots. We find the two closest time points stored in the snapshot cache and linear interpolate in time between them. Each snapshot will be transferred onto the provided hierarchy. A scratch patch index with the same patch layout as u_idx must be provided, and data for both must be already allocated. The refine_type must be a valid refinement operation for the data layout.</p>
<p>This assumes that the time is between two snapshots stored in the cache. An error will occur if two time points can not be found. If there is a single snapshot, this function returns that snapshot.</p>
<p>The hier_data_ops object, if provided, must match the same variable type used in for the snapshots.</p>
<p>If the optional period parameter is provided, this function will treat the first snapshot time point t_1 as also the last snapshot time point t_1 + period. </p>

</div>
</div>
<a id="a925f529d0165b30ed0bdc51a481674ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925f529d0165b30ed0bdc51a481674ee">&#9670;&nbsp;</a></span>reportPETScKSPConvergedReason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::reportPETScKSPConvergedReason </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KSPConvergedReason &amp;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4b2fcc10382e4b16b66a8619f66b3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b2fcc10382e4b16b66a8619f66b3a6">&#9670;&nbsp;</a></span>reportPETScSNESConvergedReason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::reportPETScSNESConvergedReason </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SNESConvergedReason &amp;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab468c521d57e4d982172b8937eacbe05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab468c521d57e4d982172b8937eacbe05">&#9670;&nbsp;</a></span>hypre_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;HYPRE_Int, NDIM&gt; IBTK::hypre_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">SAMRAI::hier::Index</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Hypre can use 64 bit indices, but <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> IntVectors are always 32. </dd></dl>

</div>
</div>
<a id="a6e408613b9a8dd6a086d9b13808bc127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e408613b9a8dd6a086d9b13808bc127">&#9670;&nbsp;</a></span>copyFromHypre() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::copyFromHypre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">SAMRAI::pdat::CellData</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; HYPRE_StructVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dst_data</td><td>Reference to destination for data to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vectors</td><td>Vector of Hypre data to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>Box over which to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26d130b6670b3fe4cf839f5c76d7e3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d130b6670b3fe4cf839f5c76d7e3d1">&#9670;&nbsp;</a></span>copyFromHypre() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::copyFromHypre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">SAMRAI::pdat::SideData</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HYPRE_SStructVector&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function is specialized for cases when the Hypre vector has one part with number of variables equal to the spatial dimension.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dst_data</td><td>Reference to destination for data to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vector</td><td>Vector of Hypre data to copy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>Box over which to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07e9bd568bbdd3245c15404ca2cf4701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e9bd568bbdd3245c15404ca2cf4701">&#9670;&nbsp;</a></span>copyToHypre() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::copyToHypre </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; HYPRE_StructVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">SAMRAI::pdat::CellData</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">vectors</td><td>Reference to vector of Hypre vectors to be copied to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_data</td><td>Reference to cell centered data to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>Box over which to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19653d3a298370f4975c115cff103ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19653d3a298370f4975c115cff103ecd">&#9670;&nbsp;</a></span>copyToHypre() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::copyToHypre </td>
          <td>(</td>
          <td class="paramtype">HYPRE_SStructVector &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">SAMRAI::pdat::SideData</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function is specialized for cases when the Hypre vector has one part with number of variables equal to the spatial dimension.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">vectors</td><td>Reference to Hypre vector to be copied to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_data</td><td>Reference to side centered data to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>Box over which to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7159301f2c1c020f5bbf43c6060b5e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7159301f2c1c020f5bbf43c6060b5e0d">&#9670;&nbsp;</a></span>ENABLE_TIMERS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbool.html">bool</a> IBTK::ENABLE_TIMERS = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fd93a9c16e327725aa68e0b9c43e800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd93a9c16e327725aa68e0b9c43e800">&#9670;&nbsp;</a></span>s_max_free_dofs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classint.html">int</a> IBTK::s_max_free_dofs = NDIM * (NDIM + 1) / 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a426852ad282d4bb75fa436e05150870d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426852ad282d4bb75fa436e05150870d">&#9670;&nbsp;</a></span>invalid_level_number</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classint.html">int</a> IBTK::invalid_level_number = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4beed89342258cb4b5e9bc9e8bc90aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4beed89342258cb4b5e9bc9e8bc90aaf">&#9670;&nbsp;</a></span>invalid_index</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classint.html">int</a> IBTK::invalid_index = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespaceIBTK_html_ae8048f832efc6a3000180a8b59de9091"><div class="ttname"><a href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091">IBTK::FEUpdateFlags</a></div><div class="ttdeci">FEUpdateFlags</div><div class="ttdef"><b>Definition:</b> FECache.h:54</div></div>
<div class="ttc" id="anamespaceIBTK_html_ae8048f832efc6a3000180a8b59de9091a9f04987cef3783ee1f9329eca30c5558"><div class="ttname"><a href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091a9f04987cef3783ee1f9329eca30c5558">IBTK::update_phi</a></div><div class="ttdeci">@ update_phi</div><div class="ttdef"><b>Definition:</b> FECache.h:64</div></div>
<div class="ttc" id="anamespaceIBTK_html_ae8048f832efc6a3000180a8b59de9091acd49d3ad2cb8bd317153305be3d4245e"><div class="ttname"><a href="namespaceIBTK.html#ae8048f832efc6a3000180a8b59de9091acd49d3ad2cb8bd317153305be3d4245e">IBTK::update_dphi</a></div><div class="ttdeci">@ update_dphi</div><div class="ttdef"><b>Definition:</b> FECache.h:69</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
