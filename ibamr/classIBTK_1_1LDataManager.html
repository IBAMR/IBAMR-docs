<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: IBTK::LDataManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IBAMR
   &#160;<span id="projectnumber">IBAMR version 0.19.</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceIBTK.html">IBTK</a></li><li class="navelem"><a class="el" href="classIBTK_1_1LDataManager.html">LDataManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classIBTK_1_1LDataManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IBTK::LDataManager Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class <a class="el" href="classIBTK_1_1LDataManager.html" title="Class LDataManager coordinates the irregular distribution of LNode and LData on the patch hierarchy.">LDataManager</a> coordinates the irregular distribution of <a class="el" href="classIBTK_1_1LNode.html" title="Class LNode is the basic element of an LMesh.">LNode</a> and <a class="el" href="classIBTK_1_1LData.html" title="Class LData provides storage for a single scalar- or vector-valued Lagrangian quantity.">LData</a> on the patch hierarchy.  
 <a href="classIBTK_1_1LDataManager.html#details">More...</a></p>

<p><code>#include &lt;ibtk/LDataManager.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IBTK::LDataManager:</div>
<div class="dyncontent">
<div class="center"><img src="classIBTK_1_1LDataManager__inherit__graph.png" border="0" usemap="#IBTK_1_1LDataManager_inherit__map" alt="Inheritance graph"/></div>
<map name="IBTK_1_1LDataManager_inherit__map" id="IBTK_1_1LDataManager_inherit__map">
<area shape="rect" title="Class LDataManager coordinates the irregular distribution of LNode and LData on the patch hierarchy." alt="" coords="110,288,265,315"/>
<area shape="rect" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html" title=" " alt="" coords="5,197,212,239"/>
<area shape="rect" href="classSAMRAI_1_1tbox_1_1DescribedClass.html" title="Base class for all objects that use run&#45;time type identification (RTTI)." alt="" coords="33,5,251,32"/>
<area shape="rect" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html" title=" " alt="" coords="39,81,245,123"/>
<area shape="rect" href="classSAMRAI_1_1tbox_1_1Serializable.html" title=" " alt="" coords="186,147,381,173"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5263bfe8622e41d1a2df35f9803a5ca1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a5263bfe8622e41d1a2df35f9803a5ca1">getLevelDt</a> (const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level, const <a class="el" href="classdouble.html">double</a> dt_time, const <a class="el" href="classbool.html">bool</a> initial_time)</td></tr>
<tr class="separator:a5263bfe8622e41d1a2df35f9803a5ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e8a35a6b5ab6ec7e14f040e718adf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a9e4e8a35a6b5ab6ec7e14f040e718adf">advanceLevel</a> (const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level, const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classdouble.html">double</a> current_time, const <a class="el" href="classdouble.html">double</a> new_time, const <a class="el" href="classbool.html">bool</a> first_step, const <a class="el" href="classbool.html">bool</a> last_step, const <a class="el" href="classbool.html">bool</a> regrid_advance=false)</td></tr>
<tr class="separator:a9e4e8a35a6b5ab6ec7e14f040e718adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97641642baa1b5c67749fada52b12341"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a97641642baa1b5c67749fada52b12341">resetTimeDependentData</a> (const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level, const <a class="el" href="classdouble.html">double</a> new_time, const <a class="el" href="classbool.html">bool</a> can_be_refined)</td></tr>
<tr class="separator:a97641642baa1b5c67749fada52b12341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f563618437d3a5231d35eb6937fcd1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#af6f563618437d3a5231d35eb6937fcd1">resetDataToPreadvanceState</a> (const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; level)</td></tr>
<tr class="separator:af6f563618437d3a5231d35eb6937fcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f31cfe38a0690a629fcbeb7ad89888"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#af8f31cfe38a0690a629fcbeb7ad89888">initializeLevelData</a> (const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> level_number, const <a class="el" href="classdouble.html">double</a> init_data_time, const <a class="el" href="classbool.html">bool</a> can_be_refined, const <a class="el" href="classbool.html">bool</a> initial_time, const tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt; old_level=tbox::Pointer&lt; hier::BasePatchLevel&lt; DIM &gt; &gt;(NULL), const <a class="el" href="classbool.html">bool</a> allocate_data=true)=0</td></tr>
<tr class="separator:af8f31cfe38a0690a629fcbeb7ad89888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8d89482d4bdafc824307cc21c728c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a6f8d89482d4bdafc824307cc21c728c9">resetHierarchyConfiguration</a> (const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> coarsest_level, const <a class="el" href="classint.html">int</a> finest_level)=0</td></tr>
<tr class="separator:a6f8d89482d4bdafc824307cc21c728c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac201b9cd28087aa92f9c1370f147667a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#ac201b9cd28087aa92f9c1370f147667a">applyGradientDetector</a> (const tbox::Pointer&lt; hier::BasePatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> level_number, const <a class="el" href="classdouble.html">double</a> error_data_time, const <a class="el" href="classint.html">int</a> tag_index, const <a class="el" href="classbool.html">bool</a> initial_time, const <a class="el" href="classbool.html">bool</a> uses_richardson_extrapolation_too)</td></tr>
<tr class="separator:ac201b9cd28087aa92f9c1370f147667a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e5b7b5d98eaf7221b5088b0d12a2a8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a81e5b7b5d98eaf7221b5088b0d12a2a8">applyRichardsonExtrapolation</a> (const tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; level, const <a class="el" href="classdouble.html">double</a> error_data_time, const <a class="el" href="classint.html">int</a> tag_index, const <a class="el" href="classdouble.html">double</a> deltat, const <a class="el" href="classint.html">int</a> error_coarsen_ratio, const <a class="el" href="classbool.html">bool</a> initial_time, const <a class="el" href="classbool.html">bool</a> uses_gradient_detector_too)</td></tr>
<tr class="separator:a81e5b7b5d98eaf7221b5088b0d12a2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3ec75cca71a27c6599a48ac6cd37ea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a9e3ec75cca71a27c6599a48ac6cd37ea">coarsenDataForRichardsonExtrapolation</a> (const tbox::Pointer&lt; hier::PatchHierarchy&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> level_number, const tbox::Pointer&lt; hier::PatchLevel&lt; DIM &gt; &gt; coarser_level, const <a class="el" href="classdouble.html">double</a> coarsen_data_time, const <a class="el" href="classbool.html">bool</a> before_advance)</td></tr>
<tr class="separator:a9e3ec75cca71a27c6599a48ac6cd37ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a97a22257f2f2c3ceb09a9aff7d52ae1e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classIBTK_1_1LDataManager.html">LDataManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a97a22257f2f2c3ceb09a9aff7d52ae1e">getManager</a> (const std::string &amp;name, const std::string &amp;default_interp_kernel_fcn, const std::string &amp;default_spread_kernel_fcn, <a class="el" href="classbool.html">bool</a> error_if_points_leave_domain=false, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;min_ghost_width=<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt;(0), <a class="el" href="classbool.html">bool</a> register_for_restart=true)</td></tr>
<tr class="separator:a97a22257f2f2c3ceb09a9aff7d52ae1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670d40bee489e0b6aec3389d88427496"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a670d40bee489e0b6aec3389d88427496">freeAllManagers</a> ()</td></tr>
<tr class="separator:a670d40bee489e0b6aec3389d88427496"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a359fffa7d2f68d6ec3ad02d7b8599b0d"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a359fffa7d2f68d6ec3ad02d7b8599b0d">POSN_DATA_NAME</a></td></tr>
<tr class="separator:a359fffa7d2f68d6ec3ad02d7b8599b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd892b71bce2c9096c49efd80db288de"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#afd892b71bce2c9096c49efd80db288de">INIT_POSN_DATA_NAME</a></td></tr>
<tr class="separator:afd892b71bce2c9096c49efd80db288de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e7f66b3437a4b69237fef346348ad6"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a04e7f66b3437a4b69237fef346348ad6">VEL_DATA_NAME</a></td></tr>
<tr class="separator:a04e7f66b3437a4b69237fef346348ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Methods to set and get the patch hierarchy and range of patch</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp857dc8ff43dbf6f11c88be587bf5a7d2"></a>levels associated with this manager class. </p>
</td></tr>
<tr class="memitem:a9124254c2a86ec2502ac119f458ab86e"><td class="memItemLeft" align="right" valign="top">static std::map&lt; std::string, <a class="el" href="classIBTK_1_1LDataManager.html">LDataManager</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a9124254c2a86ec2502ac119f458ab86e">s_data_manager_instances</a></td></tr>
<tr class="separator:a9124254c2a86ec2502ac119f458ab86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3192dffb5755d186065840d172e536d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aa3192dffb5755d186065840d172e536d">s_registered_callback</a></td></tr>
<tr class="separator:aa3192dffb5755d186065840d172e536d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b3d296d579b0818bc84e826943b0e3"><td class="memItemLeft" align="right" valign="top">static unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a18b3d296d579b0818bc84e826943b0e3">s_shutdown_priority</a></td></tr>
<tr class="separator:a18b3d296d579b0818bc84e826943b0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab653140910b0cebb049038ffd7b8db35"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ab653140910b0cebb049038ffd7b8db35">d_object_name</a></td></tr>
<tr class="separator:ab653140910b0cebb049038ffd7b8db35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b843ecae2ddd375cbc448e506813df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ae6b843ecae2ddd375cbc448e506813df">d_registered_for_restart</a></td></tr>
<tr class="separator:ae6b843ecae2ddd375cbc448e506813df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cda6867bfbfef1b224d94c3621c3e36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a6cda6867bfbfef1b224d94c3621c3e36">d_hierarchy</a></td></tr>
<tr class="separator:a6cda6867bfbfef1b224d94c3621c3e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05f28fdcba215b1f967994cd8f2efd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html">SAMRAI::geom::CartesianGridGeometry</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ad05f28fdcba215b1f967994cd8f2efd6">d_grid_geom</a></td></tr>
<tr class="separator:ad05f28fdcba215b1f967994cd8f2efd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4dbd10ad48a64e9342f9310653b545"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aba4dbd10ad48a64e9342f9310653b545">d_coarsest_ln</a> = <a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">IBTK::invalid_level_number</a></td></tr>
<tr class="separator:aba4dbd10ad48a64e9342f9310653b545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1782228fde51b7cdf693b221545dd075"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a1782228fde51b7cdf693b221545dd075">d_finest_ln</a> = <a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">IBTK::invalid_level_number</a></td></tr>
<tr class="separator:a1782228fde51b7cdf693b221545dd075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9506b6a32eac6a6aa52f4c9546e4db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBTK_1_1SAMRAIDataCache.html">SAMRAIDataCache</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a7c9506b6a32eac6a6aa52f4c9546e4db">d_cached_eulerian_data</a></td></tr>
<tr class="separator:a7c9506b6a32eac6a6aa52f4c9546e4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7786a5ce3ec6c5985c74010c290de8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">SAMRAI::appu::VisItDataWriter</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a5c7786a5ce3ec6c5985c74010c290de8">d_visit_writer</a></td></tr>
<tr class="separator:a5c7786a5ce3ec6c5985c74010c290de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae244a2dfab9ec1dde9e21195b0d0fcfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LSiloDataWriter.html">LSiloDataWriter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ae244a2dfab9ec1dde9e21195b0d0fcfb">d_silo_writer</a></td></tr>
<tr class="separator:ae244a2dfab9ec1dde9e21195b0d0fcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c9854b10dff17017e6c4f905d5d8c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalancer.html">SAMRAI::mesh::LoadBalancer</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a00c9854b10dff17017e6c4f905d5d8c1">d_load_balancer</a></td></tr>
<tr class="separator:a00c9854b10dff17017e6c4f905d5d8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59777a6a1886d9fc2dc6cf85ffadbbd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LInitStrategy.html">LInitStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a59777a6a1886d9fc2dc6cf85ffadbbd0">d_lag_init</a></td></tr>
<tr class="separator:a59777a6a1886d9fc2dc6cf85ffadbbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade37bd5e57213a7d02c82744ef737d18"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ade37bd5e57213a7d02c82744ef737d18">d_level_contains_lag_data</a></td></tr>
<tr class="separator:ade37bd5e57213a7d02c82744ef737d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadce5c441cbc1665f5a6d04ef93c7664"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="namespaceIBTK.html#a9eb9f4aa1a24bc680e2744c833f6d439">LNodeSetVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aadce5c441cbc1665f5a6d04ef93c7664">d_lag_node_index_var</a></td></tr>
<tr class="separator:aadce5c441cbc1665f5a6d04ef93c7664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068c5f22578d3e16027741057cfd2662"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a068c5f22578d3e16027741057cfd2662">d_lag_node_index_current_idx</a> = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td></tr>
<tr class="separator:a068c5f22578d3e16027741057cfd2662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ae0878c883cdfb8fa566d211c1dd95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a29ae0878c883cdfb8fa566d211c1dd95">d_lag_node_index_scratch_idx</a> = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td></tr>
<tr class="separator:a29ae0878c883cdfb8fa566d211c1dd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8200e7385a751e538dcc36959e8ae4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; std::vector&lt; <a class="el" href="classIBTK_1_1LNode.html">LNode</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a9e8200e7385a751e538dcc36959e8ae4">d_local_and_ghost_nodes</a></td></tr>
<tr class="separator:a9e8200e7385a751e538dcc36959e8ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88df2e0f8c4ef9ebc7f26cd19c62330c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a88df2e0f8c4ef9ebc7f26cd19c62330c">d_beta_work</a> = 1.0</td></tr>
<tr class="separator:a88df2e0f8c4ef9ebc7f26cd19c62330c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ac407cf59ac270d26974d4d829c50e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ac2ac407cf59ac270d26974d4d829c50e">d_workload_var</a></td></tr>
<tr class="separator:ac2ac407cf59ac270d26974d4d829c50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7453fec65010f7e124b3042563d59f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a3e7453fec65010f7e124b3042563d59f">d_workload_idx</a> = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td></tr>
<tr class="separator:a3e7453fec65010f7e124b3042563d59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f194a3edbb5d331e705f2725c78bc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ad6f194a3edbb5d331e705f2725c78bc3">d_output_workload</a> = false</td></tr>
<tr class="separator:ad6f194a3edbb5d331e705f2725c78bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301ee0df9d1d3505e0d5cfa7362cd988"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a301ee0df9d1d3505e0d5cfa7362cd988">d_node_count_var</a></td></tr>
<tr class="separator:a301ee0df9d1d3505e0d5cfa7362cd988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3577b3c08eb0e68d85d646102d09fb2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a3577b3c08eb0e68d85d646102d09fb2d">d_node_count_idx</a> = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td></tr>
<tr class="separator:a3577b3c08eb0e68d85d646102d09fb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee80a81caca53c2dd5ba2104e5c239b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aee80a81caca53c2dd5ba2104e5c239b8">d_output_node_count</a> = false</td></tr>
<tr class="separator:aee80a81caca53c2dd5ba2104e5c239b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad91e6c5d9ab6832db4eef21c5252764"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aad91e6c5d9ab6832db4eef21c5252764">d_default_interp_kernel_fcn</a></td></tr>
<tr class="separator:aad91e6c5d9ab6832db4eef21c5252764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04366e28010d04cc517c1d35dd23f529"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a04366e28010d04cc517c1d35dd23f529">d_default_spread_kernel_fcn</a></td></tr>
<tr class="separator:a04366e28010d04cc517c1d35dd23f529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9241574a7d7f9fcb07765592b6baf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a1c9241574a7d7f9fcb07765592b6baf5">d_error_if_points_leave_domain</a></td></tr>
<tr class="separator:a1c9241574a7d7f9fcb07765592b6baf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac610b13354619f0609930acce8db2aab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ac610b13354619f0609930acce8db2aab">d_ghost_width</a></td></tr>
<tr class="separator:ac610b13354619f0609930acce8db2aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf852873987504a8d521f3d07153d64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#afcf852873987504a8d521f3d07153d64">d_lag_node_index_bdry_fill_alg</a></td></tr>
<tr class="separator:afcf852873987504a8d521f3d07153d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669a8e5f56f4f9eb939877a6caab0591"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a669a8e5f56f4f9eb939877a6caab0591">d_lag_node_index_bdry_fill_scheds</a></td></tr>
<tr class="separator:a669a8e5f56f4f9eb939877a6caab0591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb932832634bc497dcbadf2238cfbd20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html">SAMRAI::xfer::CoarsenAlgorithm</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aeb932832634bc497dcbadf2238cfbd20">d_node_count_coarsen_alg</a></td></tr>
<tr class="separator:aeb932832634bc497dcbadf2238cfbd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79dd3841550b13e798b3dba6d4719de"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ad79dd3841550b13e798b3dba6d4719de">d_node_count_coarsen_scheds</a></td></tr>
<tr class="separator:ad79dd3841550b13e798b3dba6d4719de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2254232cd8e4c67acebb635909b0fa44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">SAMRAI::hier::VariableContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a2254232cd8e4c67acebb635909b0fa44">d_current_context</a></td></tr>
<tr class="separator:a2254232cd8e4c67acebb635909b0fa44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa047375ab5e3ae189d87f7a29a598f93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">SAMRAI::hier::VariableContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aa047375ab5e3ae189d87f7a29a598f93">d_scratch_context</a></td></tr>
<tr class="separator:aa047375ab5e3ae189d87f7a29a598f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb1c9f0d19f445c7a9e48b9a6c971d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">SAMRAI::hier::ComponentSelector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a4cb1c9f0d19f445c7a9e48b9a6c971d6">d_current_data</a></td></tr>
<tr class="separator:a4cb1c9f0d19f445c7a9e48b9a6c971d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c3eeeb950064fce3dc5b385e77fe2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">SAMRAI::hier::ComponentSelector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a82c3eeeb950064fce3dc5b385e77fe2d">d_scratch_data</a></td></tr>
<tr class="separator:a82c3eeeb950064fce3dc5b385e77fe2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36cecd3accdf64b12e8f1093fb3ac7d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a36cecd3accdf64b12e8f1093fb3ac7d8">setPatchHierarchy</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy)</td></tr>
<tr class="memdesc:a36cecd3accdf64b12e8f1093fb3ac7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset patch hierarchy over which operations occur.  <a href="classIBTK_1_1LDataManager.html#a36cecd3accdf64b12e8f1093fb3ac7d8">More...</a><br /></td></tr>
<tr class="separator:a36cecd3accdf64b12e8f1093fb3ac7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a23bd73f82ea1e392fb2d31da8dd40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a75a23bd73f82ea1e392fb2d31da8dd40">getPatchHierarchy</a> () const</td></tr>
<tr class="memdesc:a75a23bd73f82ea1e392fb2d31da8dd40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the patch hierarchy used by this object.  <a href="classIBTK_1_1LDataManager.html#a75a23bd73f82ea1e392fb2d31da8dd40">More...</a><br /></td></tr>
<tr class="separator:a75a23bd73f82ea1e392fb2d31da8dd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66d2c666c08047508864acd1d12f27c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ab66d2c666c08047508864acd1d12f27c">setPatchLevels</a> (<a class="el" href="classint.html">int</a> coarsest_ln, <a class="el" href="classint.html">int</a> finest_ln)</td></tr>
<tr class="memdesc:ab66d2c666c08047508864acd1d12f27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset range of patch levels over which operations occur.  <a href="classIBTK_1_1LDataManager.html#ab66d2c666c08047508864acd1d12f27c">More...</a><br /></td></tr>
<tr class="separator:ab66d2c666c08047508864acd1d12f27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a34a179b38ae05b5765083bc8e2adc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ad4a34a179b38ae05b5765083bc8e2adc">getPatchLevels</a> () const</td></tr>
<tr class="memdesc:ad4a34a179b38ae05b5765083bc8e2adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the range of patch levels used by this object.  <a href="classIBTK_1_1LDataManager.html#ad4a34a179b38ae05b5765083bc8e2adc">More...</a><br /></td></tr>
<tr class="separator:ad4a34a179b38ae05b5765083bc8e2adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37180542cf9127e3082a927de1feb624"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a37180542cf9127e3082a927de1feb624">getGhostCellWidth</a> () const</td></tr>
<tr class="memdesc:a37180542cf9127e3082a927de1feb624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ghost cell width associated with the interaction scheme.  <a href="classIBTK_1_1LDataManager.html#a37180542cf9127e3082a927de1feb624">More...</a><br /></td></tr>
<tr class="separator:a37180542cf9127e3082a927de1feb624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee4a20865323c6ffb5165ecb4328c95"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a4ee4a20865323c6ffb5165ecb4328c95">getDefaultInterpKernelFunction</a> () const</td></tr>
<tr class="memdesc:a4ee4a20865323c6ffb5165ecb4328c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the default kernel function associated with the Eulerian-to-Lagrangian interpolation scheme.  <a href="classIBTK_1_1LDataManager.html#a4ee4a20865323c6ffb5165ecb4328c95">More...</a><br /></td></tr>
<tr class="separator:a4ee4a20865323c6ffb5165ecb4328c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a6888c6fdcf811c9342e21f86cb8ad"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a88a6888c6fdcf811c9342e21f86cb8ad">getDefaultSpreadKernelFunction</a> () const</td></tr>
<tr class="memdesc:a88a6888c6fdcf811c9342e21f86cb8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the default kernel function associated with the Lagrangian-to-Eulerian spreading scheme.  <a href="classIBTK_1_1LDataManager.html#a88a6888c6fdcf811c9342e21f86cb8ad">More...</a><br /></td></tr>
<tr class="separator:a88a6888c6fdcf811c9342e21f86cb8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a7a199cfd186f610f87c5117e699df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a84a7a199cfd186f610f87c5117e699df">spread</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; F_data, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; X_data, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; ds_data, <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *f_phys_bdry_op, <a class="el" href="classint.html">int</a> level_num, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_prolongation_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;(), <a class="el" href="classdouble.html">double</a> fill_data_time=0.0, <a class="el" href="classbool.html">bool</a> F_data_ghost_node_update=true, <a class="el" href="classbool.html">bool</a> X_data_ghost_node_update=true, <a class="el" href="classbool.html">bool</a> ds_data_ghost_node_update=true)</td></tr>
<tr class="memdesc:a84a7a199cfd186f610f87c5117e699df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spread a quantity from the Lagrangian mesh to the Eulerian grid using the default spreading kernel function.  <a href="classIBTK_1_1LDataManager.html#a84a7a199cfd186f610f87c5117e699df">More...</a><br /></td></tr>
<tr class="separator:a84a7a199cfd186f610f87c5117e699df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bec837fe1c813bd4b51829f574de630"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a8bec837fe1c813bd4b51829f574de630">spread</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; F_data, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; X_data, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; ds_data, const std::string &amp;spread_kernel_fcn, <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *f_phys_bdry_op, <a class="el" href="classint.html">int</a> level_num, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_prolongation_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;(), <a class="el" href="classdouble.html">double</a> fill_data_time=0.0, <a class="el" href="classbool.html">bool</a> F_data_ghost_node_update=true, <a class="el" href="classbool.html">bool</a> X_data_ghost_node_update=true, <a class="el" href="classbool.html">bool</a> ds_data_ghost_node_update=true)</td></tr>
<tr class="memdesc:a8bec837fe1c813bd4b51829f574de630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spread a quantity from the Lagrangian mesh to the Eulerian grid using a specified spreading kernel function.  <a href="classIBTK_1_1LDataManager.html#a8bec837fe1c813bd4b51829f574de630">More...</a><br /></td></tr>
<tr class="separator:a8bec837fe1c813bd4b51829f574de630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78977702d7d34a5367af101c7bf422f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ac78977702d7d34a5367af101c7bf422f">spread</a> (<a class="el" href="classint.html">int</a> f_data_idx, std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;F_data, std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;X_data, std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;ds_data, <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *f_phys_bdry_op, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_prolongation_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;(), <a class="el" href="classdouble.html">double</a> fill_data_time=0.0, <a class="el" href="classbool.html">bool</a> F_data_ghost_node_update=true, <a class="el" href="classbool.html">bool</a> X_data_ghost_node_update=true, <a class="el" href="classbool.html">bool</a> ds_data_ghost_node_update=true, <a class="el" href="classint.html">int</a> coarsest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>, <a class="el" href="classint.html">int</a> finest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>)</td></tr>
<tr class="memdesc:ac78977702d7d34a5367af101c7bf422f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spread a quantity from the Lagrangian mesh to the Eulerian grid using the default spreading kernel function.  <a href="classIBTK_1_1LDataManager.html#ac78977702d7d34a5367af101c7bf422f">More...</a><br /></td></tr>
<tr class="separator:ac78977702d7d34a5367af101c7bf422f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4843f7ab68ecdd8dcb55934a4132aedf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a4843f7ab68ecdd8dcb55934a4132aedf">spread</a> (<a class="el" href="classint.html">int</a> f_data_idx, std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;F_data, std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;X_data, std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;ds_data, const std::string &amp;spread_kernel_fcn, <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *f_phys_bdry_op, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_prolongation_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;(), <a class="el" href="classdouble.html">double</a> fill_data_time=0.0, <a class="el" href="classbool.html">bool</a> F_data_ghost_node_update=true, <a class="el" href="classbool.html">bool</a> X_data_ghost_node_update=true, <a class="el" href="classbool.html">bool</a> ds_data_ghost_node_update=true, <a class="el" href="classint.html">int</a> coarsest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>, <a class="el" href="classint.html">int</a> finest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>)</td></tr>
<tr class="memdesc:a4843f7ab68ecdd8dcb55934a4132aedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spread a quantity from the Lagrangian mesh to the Eulerian grid using a specified spreading kernel function.  <a href="classIBTK_1_1LDataManager.html#a4843f7ab68ecdd8dcb55934a4132aedf">More...</a><br /></td></tr>
<tr class="separator:a4843f7ab68ecdd8dcb55934a4132aedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe90013688c6dbaf9d827cc652234f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#abfe90013688c6dbaf9d827cc652234f0">spread</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; F_data, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; X_data, <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *f_phys_bdry_op, <a class="el" href="classint.html">int</a> level_num, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_prolongation_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;(), <a class="el" href="classdouble.html">double</a> fill_data_time=0.0, <a class="el" href="classbool.html">bool</a> F_data_ghost_node_update=true, <a class="el" href="classbool.html">bool</a> X_data_ghost_node_update=true)</td></tr>
<tr class="memdesc:abfe90013688c6dbaf9d827cc652234f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spread a quantity from the Lagrangian mesh to the Eulerian grid using the default spreading kernel function.  <a href="classIBTK_1_1LDataManager.html#abfe90013688c6dbaf9d827cc652234f0">More...</a><br /></td></tr>
<tr class="separator:abfe90013688c6dbaf9d827cc652234f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b321e1f75f119445da3a107d43cd76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#af3b321e1f75f119445da3a107d43cd76">spread</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; F_data, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; X_data, const std::string &amp;spread_kernel_fcn, <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *f_phys_bdry_op, <a class="el" href="classint.html">int</a> level_num, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_prolongation_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;(), <a class="el" href="classdouble.html">double</a> fill_data_time=0.0, <a class="el" href="classbool.html">bool</a> F_data_ghost_node_update=true, <a class="el" href="classbool.html">bool</a> X_data_ghost_node_update=true)</td></tr>
<tr class="memdesc:af3b321e1f75f119445da3a107d43cd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spread a quantity from the Lagrangian mesh to the Eulerian grid using the specified spreading kernel function.  <a href="classIBTK_1_1LDataManager.html#af3b321e1f75f119445da3a107d43cd76">More...</a><br /></td></tr>
<tr class="separator:af3b321e1f75f119445da3a107d43cd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a34de4cad12ca5cd91126b2254ca512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a5a34de4cad12ca5cd91126b2254ca512">spread</a> (<a class="el" href="classint.html">int</a> f_data_idx, std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;F_data, std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;X_data, <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *f_phys_bdry_op, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_prolongation_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;(), <a class="el" href="classdouble.html">double</a> fill_data_time=0.0, <a class="el" href="classbool.html">bool</a> F_data_ghost_node_update=true, <a class="el" href="classbool.html">bool</a> X_data_ghost_node_update=true, <a class="el" href="classint.html">int</a> coarsest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>, <a class="el" href="classint.html">int</a> finest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>)</td></tr>
<tr class="memdesc:a5a34de4cad12ca5cd91126b2254ca512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spread a quantity from the Lagrangian mesh to the Eulerian grid using the default spreading kernel function.  <a href="classIBTK_1_1LDataManager.html#a5a34de4cad12ca5cd91126b2254ca512">More...</a><br /></td></tr>
<tr class="separator:a5a34de4cad12ca5cd91126b2254ca512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d81438d0f2f6f2ffb4d251e16cbf098"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a0d81438d0f2f6f2ffb4d251e16cbf098">spread</a> (<a class="el" href="classint.html">int</a> f_data_idx, std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;F_data, std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;X_data, const std::string &amp;spread_kernel_fcn, <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *f_phys_bdry_op, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_prolongation_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;(), <a class="el" href="classdouble.html">double</a> fill_data_time=0.0, <a class="el" href="classbool.html">bool</a> F_data_ghost_node_update=true, <a class="el" href="classbool.html">bool</a> X_data_ghost_node_update=true, <a class="el" href="classint.html">int</a> coarsest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>, <a class="el" href="classint.html">int</a> finest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>)</td></tr>
<tr class="memdesc:a0d81438d0f2f6f2ffb4d251e16cbf098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spread a quantity from the Lagrangian mesh to the Eulerian grid using the specified spreading kernel function.  <a href="classIBTK_1_1LDataManager.html#a0d81438d0f2f6f2ffb4d251e16cbf098">More...</a><br /></td></tr>
<tr class="separator:a0d81438d0f2f6f2ffb4d251e16cbf098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4648251121262ca5bae15054fb760a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ab4648251121262ca5bae15054fb760a6">interp</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; F_data, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; X_data, <a class="el" href="classint.html">int</a> level_num, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_synch_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt;(), const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_ghost_fill_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;(), <a class="el" href="classdouble.html">double</a> fill_data_time=0.0)</td></tr>
<tr class="memdesc:ab4648251121262ca5bae15054fb760a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a quantity from the Eulerian grid to the Lagrangian mesh using the default interpolation kernel function.  <a href="classIBTK_1_1LDataManager.html#ab4648251121262ca5bae15054fb760a6">More...</a><br /></td></tr>
<tr class="separator:ab4648251121262ca5bae15054fb760a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93643716df661265a436ba6660e9601"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ae93643716df661265a436ba6660e9601">interp</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; F_data, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; X_data, const std::string &amp;interp_kernel_fcn, <a class="el" href="classint.html">int</a> level_num, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_synch_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt;(), const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_ghost_fill_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;(), <a class="el" href="classdouble.html">double</a> fill_data_time=0.0)</td></tr>
<tr class="memdesc:ae93643716df661265a436ba6660e9601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a quantity from the Eulerian grid to the Lagrangian mesh using the specified interpolation kernel function.  <a href="classIBTK_1_1LDataManager.html#ae93643716df661265a436ba6660e9601">More...</a><br /></td></tr>
<tr class="separator:ae93643716df661265a436ba6660e9601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f74a879c8830c9d293eaf2126fde08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ae7f74a879c8830c9d293eaf2126fde08">interp</a> (<a class="el" href="classint.html">int</a> f_data_idx, std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;F_data, std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;X_data, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_synch_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt;(), const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_ghost_fill_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;(), <a class="el" href="classdouble.html">double</a> fill_data_time=0.0, <a class="el" href="classint.html">int</a> coarsest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>, <a class="el" href="classint.html">int</a> finest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>)</td></tr>
<tr class="memdesc:ae7f74a879c8830c9d293eaf2126fde08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a quantity from the Eulerian grid to the Lagrangian mesh using the default interpolation kernel function.  <a href="classIBTK_1_1LDataManager.html#ae7f74a879c8830c9d293eaf2126fde08">More...</a><br /></td></tr>
<tr class="separator:ae7f74a879c8830c9d293eaf2126fde08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d131025eaa1b6effc004a874d13d43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ad9d131025eaa1b6effc004a874d13d43">interp</a> (<a class="el" href="classint.html">int</a> f_data_idx, std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;F_data, std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;X_data, const std::string &amp;interp_kernel_fcn, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_synch_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt;(), const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_ghost_fill_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;(), <a class="el" href="classdouble.html">double</a> fill_data_time=0.0, <a class="el" href="classint.html">int</a> coarsest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>, <a class="el" href="classint.html">int</a> finest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>)</td></tr>
<tr class="memdesc:ad9d131025eaa1b6effc004a874d13d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a quantity from the Eulerian grid to the Lagrangian mesh using the specified interpolation kernel function.  <a href="classIBTK_1_1LDataManager.html#ad9d131025eaa1b6effc004a874d13d43">More...</a><br /></td></tr>
<tr class="separator:ad9d131025eaa1b6effc004a874d13d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b81e163585cde632beaea203a574a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a56b81e163585cde632beaea203a574a1">registerLInitStrategy</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LInitStrategy.html">LInitStrategy</a> &gt; lag_init)</td></tr>
<tr class="separator:a56b81e163585cde632beaea203a574a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c54478bd27a46546e19292ed3f2ef08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a0c54478bd27a46546e19292ed3f2ef08">freeLInitStrategy</a> ()</td></tr>
<tr class="separator:a0c54478bd27a46546e19292ed3f2ef08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68d470c1bb587fb77525d7a303bedcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aa68d470c1bb587fb77525d7a303bedcd">registerVisItDataWriter</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">SAMRAI::appu::VisItDataWriter</a>&lt; NDIM &gt; &gt; visit_writer)</td></tr>
<tr class="memdesc:aa68d470c1bb587fb77525d7a303bedcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a VisIt data writer with the manager.  <a href="classIBTK_1_1LDataManager.html#aa68d470c1bb587fb77525d7a303bedcd">More...</a><br /></td></tr>
<tr class="separator:aa68d470c1bb587fb77525d7a303bedcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9946bcc90dc2bd5841fca70b8fa82a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aa9946bcc90dc2bd5841fca70b8fa82a2">registerLSiloDataWriter</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LSiloDataWriter.html">LSiloDataWriter</a> &gt; silo_writer)</td></tr>
<tr class="memdesc:aa9946bcc90dc2bd5841fca70b8fa82a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a Silo data writer with the manager.  <a href="classIBTK_1_1LDataManager.html#aa9946bcc90dc2bd5841fca70b8fa82a2">More...</a><br /></td></tr>
<tr class="separator:aa9946bcc90dc2bd5841fca70b8fa82a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4091bdb848f92c5ee87d5c6eb92145d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a4091bdb848f92c5ee87d5c6eb92145d0">registerLoadBalancer</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalancer.html">SAMRAI::mesh::LoadBalancer</a>&lt; NDIM &gt; &gt; load_balancer, <a class="el" href="classint.html">int</a> workload_data_idx)</td></tr>
<tr class="memdesc:a4091bdb848f92c5ee87d5c6eb92145d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a load balancer for non-uniform load balancing.  <a href="classIBTK_1_1LDataManager.html#a4091bdb848f92c5ee87d5c6eb92145d0">More...</a><br /></td></tr>
<tr class="separator:a4091bdb848f92c5ee87d5c6eb92145d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd16f75b4748368af21aae6ea2f6ef9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#adfd16f75b4748368af21aae6ea2f6ef9">levelContainsLagrangianData</a> (<a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="memdesc:adfd16f75b4748368af21aae6ea2f6ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether there is Lagrangian data on the given patch hierarchy level.  <a href="classIBTK_1_1LDataManager.html#adfd16f75b4748368af21aae6ea2f6ef9">More...</a><br /></td></tr>
<tr class="separator:adfd16f75b4748368af21aae6ea2f6ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e8a86979d02d8009ca0626c2758da7"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a74e8a86979d02d8009ca0626c2758da7">getNumberOfNodes</a> (<a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="separator:a74e8a86979d02d8009ca0626c2758da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7786a413368a16487070edde75769db2"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a7786a413368a16487070edde75769db2">getNumberOfLocalNodes</a> (<a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="separator:a7786a413368a16487070edde75769db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75dfe561f56b122d936317c6ee71965b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a75dfe561f56b122d936317c6ee71965b">getNumberOfGhostNodes</a> (<a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="separator:a75dfe561f56b122d936317c6ee71965b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14458ddb1312e72f133fa6d88d3e395c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a14458ddb1312e72f133fa6d88d3e395c">getGlobalNodeOffset</a> (<a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="separator:a14458ddb1312e72f133fa6d88d3e395c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25ad98658d45fbf72e9a1fbe695b4ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LMesh.html">LMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aa25ad98658d45fbf72e9a1fbe695b4ee">getLMesh</a> (<a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="memdesc:aa25ad98658d45fbf72e9a1fbe695b4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Lagrangian mesh associated with the given patch hierarchy level.  <a href="classIBTK_1_1LDataManager.html#aa25ad98658d45fbf72e9a1fbe695b4ee">More...</a><br /></td></tr>
<tr class="separator:aa25ad98658d45fbf72e9a1fbe695b4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329154c9e3b78a7582ea193e4d0bcad1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a329154c9e3b78a7582ea193e4d0bcad1">getLData</a> (const std::string &amp;quantity_name, <a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="memdesc:a329154c9e3b78a7582ea193e4d0bcad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified Lagrangian quantity data on the given patch hierarchy level.  <a href="classIBTK_1_1LDataManager.html#a329154c9e3b78a7582ea193e4d0bcad1">More...</a><br /></td></tr>
<tr class="separator:a329154c9e3b78a7582ea193e4d0bcad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6caed9ba4ee98feb55f01c9194df9ac7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a6caed9ba4ee98feb55f01c9194df9ac7">createLData</a> (const std::string &amp;quantity_name, <a class="el" href="classint.html">int</a> level_number, unsigned <a class="el" href="classint.html">int</a> depth=1, <a class="el" href="classbool.html">bool</a> maintain_data=false)</td></tr>
<tr class="memdesc:a6caed9ba4ee98feb55f01c9194df9ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate new Lagrangian level data with the specified name and depth. If specified, the quantity is maintained as the patch hierarchy evolves.  <a href="classIBTK_1_1LDataManager.html#a6caed9ba4ee98feb55f01c9194df9ac7">More...</a><br /></td></tr>
<tr class="separator:a6caed9ba4ee98feb55f01c9194df9ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f008aacfafaa0a84536764c46fbe06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a95f008aacfafaa0a84536764c46fbe06">getLNodePatchDescriptorIndex</a> () const</td></tr>
<tr class="memdesc:a95f008aacfafaa0a84536764c46fbe06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the patch data descriptor index for the Lagrangian index data.  <a href="classIBTK_1_1LDataManager.html#a95f008aacfafaa0a84536764c46fbe06">More...</a><br /></td></tr>
<tr class="separator:a95f008aacfafaa0a84536764c46fbe06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1c394e98949baf2d46bc9a0d2d5733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aad1c394e98949baf2d46bc9a0d2d5733">getWorkloadPatchDescriptorIndex</a> () const</td></tr>
<tr class="memdesc:aad1c394e98949baf2d46bc9a0d2d5733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the patch data descriptor index for the workload cell data.  <a href="classIBTK_1_1LDataManager.html#aad1c394e98949baf2d46bc9a0d2d5733">More...</a><br /></td></tr>
<tr class="separator:aad1c394e98949baf2d46bc9a0d2d5733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c68b1859783756cb1d07306268faf31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a2c68b1859783756cb1d07306268faf31">getNodeCountPatchDescriptorIndex</a> () const</td></tr>
<tr class="memdesc:a2c68b1859783756cb1d07306268faf31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the patch data descriptor index for the Lagrangian node count cell data.  <a href="classIBTK_1_1LDataManager.html#a2c68b1859783756cb1d07306268faf31">More...</a><br /></td></tr>
<tr class="separator:a2c68b1859783756cb1d07306268faf31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d54d77cee8721071813fb79335cd22c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a0d54d77cee8721071813fb79335cd22c">getLagrangianStructureNames</a> (<a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="memdesc:a0d54d77cee8721071813fb79335cd22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of Lagrangian structure names for the specified level of the patch hierarchy.  <a href="classIBTK_1_1LDataManager.html#a0d54d77cee8721071813fb79335cd22c">More...</a><br /></td></tr>
<tr class="separator:a0d54d77cee8721071813fb79335cd22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24da50545eef138442a83a4655aa922"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ad24da50545eef138442a83a4655aa922">getLagrangianStructureIDs</a> (<a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="memdesc:ad24da50545eef138442a83a4655aa922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of Lagrangian structure IDs for the specified level of the patch hierarchy.  <a href="classIBTK_1_1LDataManager.html#ad24da50545eef138442a83a4655aa922">More...</a><br /></td></tr>
<tr class="separator:ad24da50545eef138442a83a4655aa922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddfd62821a60a7f1431ef29ffb09804"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a0ddfd62821a60a7f1431ef29ffb09804">getLagrangianStructureID</a> (<a class="el" href="classint.html">int</a> lagrangian_index, <a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="memdesc:a0ddfd62821a60a7f1431ef29ffb09804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID of the Lagrangian structure associated with the specified Lagrangian index.  <a href="classIBTK_1_1LDataManager.html#a0ddfd62821a60a7f1431ef29ffb09804">More...</a><br /></td></tr>
<tr class="separator:a0ddfd62821a60a7f1431ef29ffb09804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905eac8a4c80aee2fdb70726f89e76e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a905eac8a4c80aee2fdb70726f89e76e3">getLagrangianStructureID</a> (const std::string &amp;structure_name, <a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="memdesc:a905eac8a4c80aee2fdb70726f89e76e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID of the Lagrangian structure with the specified name.  <a href="classIBTK_1_1LDataManager.html#a905eac8a4c80aee2fdb70726f89e76e3">More...</a><br /></td></tr>
<tr class="separator:a905eac8a4c80aee2fdb70726f89e76e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d946e90a1a3954a5fcafbac3438fc81"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a6d946e90a1a3954a5fcafbac3438fc81">getLagrangianStructureName</a> (<a class="el" href="classint.html">int</a> structure_id, <a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="memdesc:a6d946e90a1a3954a5fcafbac3438fc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the Lagrangian structure with the specified ID.  <a href="classIBTK_1_1LDataManager.html#a6d946e90a1a3954a5fcafbac3438fc81">More...</a><br /></td></tr>
<tr class="separator:a6d946e90a1a3954a5fcafbac3438fc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b2cd7d9ef2b9009bf294671e8f107d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aa0b2cd7d9ef2b9009bf294671e8f107d">getLagrangianStructureIndexRange</a> (<a class="el" href="classint.html">int</a> structure_id, <a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="memdesc:aa0b2cd7d9ef2b9009bf294671e8f107d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the range of Lagrangian indices for the Lagrangian structure with the specified ID.  <a href="classIBTK_1_1LDataManager.html#aa0b2cd7d9ef2b9009bf294671e8f107d">More...</a><br /></td></tr>
<tr class="separator:aa0b2cd7d9ef2b9009bf294671e8f107d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2d121ec746f96f49662e4e6478b86a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a6d2d121ec746f96f49662e4e6478b86a">computeLagrangianStructureCenterOfMass</a> (<a class="el" href="classint.html">int</a> structure_id, <a class="el" href="classint.html">int</a> level_number)</td></tr>
<tr class="memdesc:a6d2d121ec746f96f49662e4e6478b86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the center of mass of the Lagrangian structure with the specified ID.  <a href="classIBTK_1_1LDataManager.html#a6d2d121ec746f96f49662e4e6478b86a">More...</a><br /></td></tr>
<tr class="separator:a6d2d121ec746f96f49662e4e6478b86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa64127c630b3133459e38ac2344a368"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">Point</a>, <a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#afa64127c630b3133459e38ac2344a368">computeLagrangianStructureBoundingBox</a> (<a class="el" href="classint.html">int</a> structure_id, <a class="el" href="classint.html">int</a> level_number)</td></tr>
<tr class="memdesc:afa64127c630b3133459e38ac2344a368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bounding box of the Lagrangian structure with the specified ID.  <a href="classIBTK_1_1LDataManager.html#afa64127c630b3133459e38ac2344a368">More...</a><br /></td></tr>
<tr class="separator:afa64127c630b3133459e38ac2344a368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaafde7e8e58a5f2ab5ee5deaeb5ca0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#afdaafde7e8e58a5f2ab5ee5deaeb5ca0">reinitLagrangianStructure</a> (const <a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">Point</a> &amp;X_center, <a class="el" href="classint.html">int</a> structure_id, <a class="el" href="classint.html">int</a> level_number)</td></tr>
<tr class="memdesc:afdaafde7e8e58a5f2ab5ee5deaeb5ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the positions of the nodes of the Lagrangian structure with the specified ID to be equal to the initial positions but shifted so that the bounding box of the structure is centered about X_center.  <a href="classIBTK_1_1LDataManager.html#afdaafde7e8e58a5f2ab5ee5deaeb5ca0">More...</a><br /></td></tr>
<tr class="separator:afdaafde7e8e58a5f2ab5ee5deaeb5ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e91185ad0ce241dafd8fa176dea8fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a11e91185ad0ce241dafd8fa176dea8fc">displaceLagrangianStructure</a> (const <a class="el" href="namespaceIBTK.html#a09a4d4ded781c3a9630a42d88680e89f">Vector</a> &amp;dX, <a class="el" href="classint.html">int</a> structure_id, <a class="el" href="classint.html">int</a> level_number)</td></tr>
<tr class="memdesc:a11e91185ad0ce241dafd8fa176dea8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the positions of the nodes of the Lagrangian structure with the specified ID by a displacement dX.  <a href="classIBTK_1_1LDataManager.html#a11e91185ad0ce241dafd8fa176dea8fc">More...</a><br /></td></tr>
<tr class="separator:a11e91185ad0ce241dafd8fa176dea8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4eaedcdd89b31a5dfb6a668fbb3807"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aef4eaedcdd89b31a5dfb6a668fbb3807">activateLagrangianStructures</a> (const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;structure_ids, <a class="el" href="classint.html">int</a> level_number)</td></tr>
<tr class="memdesc:aef4eaedcdd89b31a5dfb6a668fbb3807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate the Lagrangian structures with the specified ID numbers.  <a href="classIBTK_1_1LDataManager.html#aef4eaedcdd89b31a5dfb6a668fbb3807">More...</a><br /></td></tr>
<tr class="separator:aef4eaedcdd89b31a5dfb6a668fbb3807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aeb7b0d36f493ac4e242da1f73b5598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a3aeb7b0d36f493ac4e242da1f73b5598">inactivateLagrangianStructures</a> (const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;structure_ids, <a class="el" href="classint.html">int</a> level_number)</td></tr>
<tr class="memdesc:a3aeb7b0d36f493ac4e242da1f73b5598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inactivate the Lagrangian structures with the specified ID numbers.  <a href="classIBTK_1_1LDataManager.html#a3aeb7b0d36f493ac4e242da1f73b5598">More...</a><br /></td></tr>
<tr class="separator:a3aeb7b0d36f493ac4e242da1f73b5598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9687be9b34a0add1b34b855cbd6f0959"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a9687be9b34a0add1b34b855cbd6f0959">getLagrangianStructureIsActivated</a> (<a class="el" href="classint.html">int</a> structure_id, <a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="memdesc:a9687be9b34a0add1b34b855cbd6f0959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the Lagrangian structure with the specified ID number is activated.  <a href="classIBTK_1_1LDataManager.html#a9687be9b34a0add1b34b855cbd6f0959">More...</a><br /></td></tr>
<tr class="separator:a9687be9b34a0add1b34b855cbd6f0959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0ba6c6041ed2af54fefae9df7d9a68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a7f0ba6c6041ed2af54fefae9df7d9a68">zeroInactivatedComponents</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; lag_data, <a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="memdesc:a7f0ba6c6041ed2af54fefae9df7d9a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the components of the supplied <a class="el" href="classIBTK_1_1LData.html" title="Class LData provides storage for a single scalar- or vector-valued Lagrangian quantity.">LData</a> object to zero for those entries that correspond to inactivated structures.  <a href="classIBTK_1_1LDataManager.html#a7f0ba6c6041ed2af54fefae9df7d9a68">More...</a><br /></td></tr>
<tr class="separator:a7f0ba6c6041ed2af54fefae9df7d9a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788f12a28a00c0615c73ade4c8137029"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a788f12a28a00c0615c73ade4c8137029">mapLagrangianToPETSc</a> (std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;inds, <a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="memdesc:a788f12a28a00c0615c73ade4c8137029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the collection of Lagrangian indices to the corresponding global PETSc indices.  <a href="classIBTK_1_1LDataManager.html#a788f12a28a00c0615c73ade4c8137029">More...</a><br /></td></tr>
<tr class="separator:a788f12a28a00c0615c73ade4c8137029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c248230e7c8e3ad596c947f7ebf40d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a73c248230e7c8e3ad596c947f7ebf40d">mapPETScToLagrangian</a> (std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;inds, <a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="memdesc:a73c248230e7c8e3ad596c947f7ebf40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the collection of global PETSc indices to the corresponding Lagrangian indices.  <a href="classIBTK_1_1LDataManager.html#a73c248230e7c8e3ad596c947f7ebf40d">More...</a><br /></td></tr>
<tr class="separator:a73c248230e7c8e3ad596c947f7ebf40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f9734f12d8544a0a839d4d54ac9d3f"><td class="memItemLeft" align="right" valign="top">AO &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ae4f9734f12d8544a0a839d4d54ac9d3f">getAO</a> (<a class="el" href="classint.html">int</a> level_number)</td></tr>
<tr class="memdesc:ae4f9734f12d8544a0a839d4d54ac9d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the AO object that maps Lagrangian indices to PETSc indices.  <a href="classIBTK_1_1LDataManager.html#ae4f9734f12d8544a0a839d4d54ac9d3f">More...</a><br /></td></tr>
<tr class="separator:ae4f9734f12d8544a0a839d4d54ac9d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad835b0ad918dc4e8dc418c41fd477378"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ad835b0ad918dc4e8dc418c41fd477378">scatterLagrangianToPETSc</a> (Vec &amp;lagrangian_vec, Vec &amp;petsc_vec, <a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="memdesc:ad835b0ad918dc4e8dc418c41fd477378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter data from the Lagrangian ordering to the global PETSc ordering.  <a href="classIBTK_1_1LDataManager.html#ad835b0ad918dc4e8dc418c41fd477378">More...</a><br /></td></tr>
<tr class="separator:ad835b0ad918dc4e8dc418c41fd477378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed942039455f7d451e74a2a2ef98f0e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aed942039455f7d451e74a2a2ef98f0e7">scatterPETScToLagrangian</a> (Vec &amp;petsc_vec, Vec &amp;lagrangian_vec, <a class="el" href="classint.html">int</a> level_number) const</td></tr>
<tr class="memdesc:aed942039455f7d451e74a2a2ef98f0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter data from the global PETSc ordering to the Lagrangian ordering.  <a href="classIBTK_1_1LDataManager.html#aed942039455f7d451e74a2a2ef98f0e7">More...</a><br /></td></tr>
<tr class="separator:aed942039455f7d451e74a2a2ef98f0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afe950ed1465f6a9dfab92d6e090972"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a9afe950ed1465f6a9dfab92d6e090972">scatterToAll</a> (Vec &amp;parallel_vec, Vec &amp;sequential_vec) const</td></tr>
<tr class="memdesc:a9afe950ed1465f6a9dfab92d6e090972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter data from a distributed PETSc vector to all processors.  <a href="classIBTK_1_1LDataManager.html#a9afe950ed1465f6a9dfab92d6e090972">More...</a><br /></td></tr>
<tr class="separator:a9afe950ed1465f6a9dfab92d6e090972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321687e02e581f7741239c31b5c0f7af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a321687e02e581f7741239c31b5c0f7af">scatterToZero</a> (Vec &amp;parallel_vec, Vec &amp;sequential_vec) const</td></tr>
<tr class="memdesc:a321687e02e581f7741239c31b5c0f7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter data from a distributed PETSc vector to processor zero.  <a href="classIBTK_1_1LDataManager.html#a321687e02e581f7741239c31b5c0f7af">More...</a><br /></td></tr>
<tr class="separator:a321687e02e581f7741239c31b5c0f7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53775a84194e1c0998f8f00193c99315"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a53775a84194e1c0998f8f00193c99315">beginDataRedistribution</a> (<a class="el" href="classint.html">int</a> coarsest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>, <a class="el" href="classint.html">int</a> finest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>)</td></tr>
<tr class="memdesc:a53775a84194e1c0998f8f00193c99315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the process of redistributing the Lagrangian data.  <a href="classIBTK_1_1LDataManager.html#a53775a84194e1c0998f8f00193c99315">More...</a><br /></td></tr>
<tr class="separator:a53775a84194e1c0998f8f00193c99315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d2e53f28436a6f8c08853440846455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a44d2e53f28436a6f8c08853440846455">endDataRedistribution</a> (<a class="el" href="classint.html">int</a> coarsest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>, <a class="el" href="classint.html">int</a> finest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>)</td></tr>
<tr class="memdesc:a44d2e53f28436a6f8c08853440846455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish the process of redistributing the Lagrangian data.  <a href="classIBTK_1_1LDataManager.html#a44d2e53f28436a6f8c08853440846455">More...</a><br /></td></tr>
<tr class="separator:a44d2e53f28436a6f8c08853440846455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4411433e4cc96b6348c9f4627c8167e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a4411433e4cc96b6348c9f4627c8167e1">addWorkloadEstimate</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> workload_data_idx, const <a class="el" href="classint.html">int</a> coarsest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>, const <a class="el" href="classint.html">int</a> finest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>)</td></tr>
<tr class="memdesc:a4411433e4cc96b6348c9f4627c8167e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the workload and count of nodes per cell.  <a href="classIBTK_1_1LDataManager.html#a4411433e4cc96b6348c9f4627c8167e1">More...</a><br /></td></tr>
<tr class="separator:a4411433e4cc96b6348c9f4627c8167e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d5ce3bfcfca62ff2628c39c3228242"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ac3d5ce3bfcfca62ff2628c39c3228242">updateNodeCountData</a> (<a class="el" href="classint.html">int</a> coarsest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>, <a class="el" href="classint.html">int</a> finest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>)</td></tr>
<tr class="memdesc:ac3d5ce3bfcfca62ff2628c39c3228242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the count of nodes per cell.  <a href="classIBTK_1_1LDataManager.html#ac3d5ce3bfcfca62ff2628c39c3228242">More...</a><br /></td></tr>
<tr class="separator:ac3d5ce3bfcfca62ff2628c39c3228242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6060e1a8a6cd8ffe935b5c9be5cde3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ae6060e1a8a6cd8ffe935b5c9be5cde3a">initializeLevelData</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classint.html">int</a> level_number, <a class="el" href="classdouble.html">double</a> init_data_time, <a class="el" href="classbool.html">bool</a> can_be_refined, <a class="el" href="classbool.html">bool</a> initial_time, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt; old_level=<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt;(nullptr), <a class="el" href="classbool.html">bool</a> allocate_data=true) override</td></tr>
<tr class="separator:ae6060e1a8a6cd8ffe935b5c9be5cde3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cc205680804bb8acfa23ff391ca427"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#af3cc205680804bb8acfa23ff391ca427">resetHierarchyConfiguration</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classint.html">int</a> coarsest_ln, <a class="el" href="classint.html">int</a> finest_ln) override</td></tr>
<tr class="separator:af3cc205680804bb8acfa23ff391ca427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364d84921020373679547b5f2f03158d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a364d84921020373679547b5f2f03158d">applyGradientDetector</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classint.html">int</a> level_number, <a class="el" href="classdouble.html">double</a> error_data_time, <a class="el" href="classint.html">int</a> tag_index, <a class="el" href="classbool.html">bool</a> initial_time, <a class="el" href="classbool.html">bool</a> uses_richardson_extrapolation_too) override</td></tr>
<tr class="separator:a364d84921020373679547b5f2f03158d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb93939023933dd4231b8cd705b457"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aa6bb93939023933dd4231b8cd705b457">putToDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; db) override</td></tr>
<tr class="separator:aa6bb93939023933dd4231b8cd705b457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a272cdb539279e2ee9dea9677a7860"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ad5a272cdb539279e2ee9dea9677a7860">registerUserDefinedLData</a> (const std::string &amp;data_name, <a class="el" href="classint.html">int</a> depth)</td></tr>
<tr class="separator:ad5a272cdb539279e2ee9dea9677a7860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950881aaa96eb24f54e6a24619972eba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a950881aaa96eb24f54e6a24619972eba">LDataManager</a> (std::string object_name, std::string default_interp_kernel_fcn, std::string default_spread_kernel_fcn, <a class="el" href="classbool.html">bool</a> error_if_points_leave_domain, <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; ghost_width, <a class="el" href="classbool.html">bool</a> register_for_restart=true)</td></tr>
<tr class="memdesc:a950881aaa96eb24f54e6a24619972eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classIBTK_1_1LDataManager.html#a950881aaa96eb24f54e6a24619972eba">More...</a><br /></td></tr>
<tr class="separator:a950881aaa96eb24f54e6a24619972eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b47ef5a2be4290da1f1ecd31d956e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a43b47ef5a2be4290da1f1ecd31d956e2">~LDataManager</a> ()</td></tr>
<tr class="memdesc:a43b47ef5a2be4290da1f1ecd31d956e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classIBTK_1_1LDataManager.html" title="Class LDataManager coordinates the irregular distribution of LNode and LData on the patch hierarchy.">LDataManager</a> destructor cleans up any remaining PETSc AO objects.  <a href="classIBTK_1_1LDataManager.html#a43b47ef5a2be4290da1f1ecd31d956e2">More...</a><br /></td></tr>
<tr class="separator:a43b47ef5a2be4290da1f1ecd31d956e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc080d94b9dfcd1b29831b62b6015db3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#adc080d94b9dfcd1b29831b62b6015db3">LDataManager</a> ()</td></tr>
<tr class="memdesc:adc080d94b9dfcd1b29831b62b6015db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classIBTK_1_1LDataManager.html#adc080d94b9dfcd1b29831b62b6015db3">More...</a><br /></td></tr>
<tr class="separator:adc080d94b9dfcd1b29831b62b6015db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab636a857c80a84a00384248aea0b8b29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ab636a857c80a84a00384248aea0b8b29">LDataManager</a> (const <a class="el" href="classIBTK_1_1LDataManager.html">LDataManager</a> &amp;from)=delete</td></tr>
<tr class="memdesc:ab636a857c80a84a00384248aea0b8b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classIBTK_1_1LDataManager.html#ab636a857c80a84a00384248aea0b8b29">More...</a><br /></td></tr>
<tr class="separator:ab636a857c80a84a00384248aea0b8b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6861d201198ba905fcfbec6e1b59218"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBTK_1_1LDataManager.html">LDataManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ad6861d201198ba905fcfbec6e1b59218">operator=</a> (const <a class="el" href="classIBTK_1_1LDataManager.html">LDataManager</a> &amp;that)=delete</td></tr>
<tr class="memdesc:ad6861d201198ba905fcfbec6e1b59218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classIBTK_1_1LDataManager.html#ad6861d201198ba905fcfbec6e1b59218">More...</a><br /></td></tr>
<tr class="separator:ad6861d201198ba905fcfbec6e1b59218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8b151096ea78c6e2479e1f1265b9b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a5c8b151096ea78c6e2479e1f1265b9b2">scatterData</a> (Vec &amp;lagrangian_vec, Vec &amp;petsc_vec, <a class="el" href="classint.html">int</a> level_number, ScatterMode mode) const</td></tr>
<tr class="memdesc:a5c8b151096ea78c6e2479e1f1265b9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common implementation of <a class="el" href="classIBTK_1_1LDataManager.html#aed942039455f7d451e74a2a2ef98f0e7" title="Scatter data from the global PETSc ordering to the Lagrangian ordering.">scatterPETScToLagrangian()</a> and <a class="el" href="classIBTK_1_1LDataManager.html#ad835b0ad918dc4e8dc418c41fd477378" title="Scatter data from the Lagrangian ordering to the global PETSc ordering.">scatterLagrangianToPETSc()</a>.  <a href="classIBTK_1_1LDataManager.html#a5c8b151096ea78c6e2479e1f1265b9b2">More...</a><br /></td></tr>
<tr class="separator:a5c8b151096ea78c6e2479e1f1265b9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b982c4e1113481e090081ff1fc5b4e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a4b982c4e1113481e090081ff1fc5b4e7">beginNonlocalDataFill</a> (<a class="el" href="classint.html">int</a> coarsest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>, <a class="el" href="classint.html">int</a> finest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>)</td></tr>
<tr class="memdesc:a4b982c4e1113481e090081ff1fc5b4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin the process of refilling nonlocal Lagrangian quantities over the specified range of levels in the patch hierarchy.  <a href="classIBTK_1_1LDataManager.html#a4b982c4e1113481e090081ff1fc5b4e7">More...</a><br /></td></tr>
<tr class="separator:a4b982c4e1113481e090081ff1fc5b4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb49791ca463f0f5ba7b20285ee7335f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#afb49791ca463f0f5ba7b20285ee7335f">endNonlocalDataFill</a> (<a class="el" href="classint.html">int</a> coarsest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>, <a class="el" href="classint.html">int</a> finest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>)</td></tr>
<tr class="memdesc:afb49791ca463f0f5ba7b20285ee7335f"><td class="mdescLeft">&#160;</td><td class="mdescRight">End the process of refilling nonlocal Lagrangian quantities over the specified range of levels in the patch hierarchy.  <a href="classIBTK_1_1LDataManager.html#afb49791ca463f0f5ba7b20285ee7335f">More...</a><br /></td></tr>
<tr class="separator:afb49791ca463f0f5ba7b20285ee7335f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04901bfef13cc5cd721f38fcf2933ff8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a04901bfef13cc5cd721f38fcf2933ff8">computeNodeDistribution</a> (AO &amp;ao, std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;local_lag_indices, std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;nonlocal_lag_indices, std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;local_petsc_indices, std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;nonlocal_petsc_indices, unsigned <a class="el" href="classint.html">int</a> &amp;num_nodes, unsigned <a class="el" href="classint.html">int</a> &amp;node_offset, <a class="el" href="classint.html">int</a> level_number)</td></tr>
<tr class="separator:a04901bfef13cc5cd721f38fcf2933ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d62bee7a5276db371a3fadf0dcc65b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a28d62bee7a5276db371a3fadf0dcc65b">getFromRestart</a> ()</td></tr>
<tr class="separator:a28d62bee7a5276db371a3fadf0dcc65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530a07cc82c75297f830725009a0429c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a530a07cc82c75297f830725009a0429c">computeNodeOffsets</a> (unsigned <a class="el" href="classint.html">int</a> &amp;num_nodes, unsigned <a class="el" href="classint.html">int</a> &amp;node_offset, unsigned <a class="el" href="classint.html">int</a> num_local_nodes)</td></tr>
<tr class="separator:a530a07cc82c75297f830725009a0429c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Data that is separately maintained for each level of the patch</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp0b13ef5935031c83e23c72e1511bc658"></a>hierarchy. </p>
</td></tr>
<tr class="memitem:ad3e17e86d8bee508a857a3d417b1d871"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#ad3e17e86d8bee508a857a3d417b1d871">s_ao_dummy</a></td></tr>
<tr class="separator:ad3e17e86d8bee508a857a3d417b1d871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf6c11650f23f3222df3e49d9417871"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::map&lt; std::string, <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aebf6c11650f23f3222df3e49d9417871">d_strct_name_to_strct_id_map</a></td></tr>
<tr class="separator:aebf6c11650f23f3222df3e49d9417871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7748792790ef04505a581014637156"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::map&lt; <a class="el" href="classint.html">int</a>, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aaa7748792790ef04505a581014637156">d_strct_id_to_strct_name_map</a></td></tr>
<tr class="separator:aaa7748792790ef04505a581014637156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d21021e1a72ddeaab180e45840cc4da"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::map&lt; <a class="el" href="classint.html">int</a>, std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a6d21021e1a72ddeaab180e45840cc4da">d_strct_id_to_lag_idx_range_map</a></td></tr>
<tr class="separator:a6d21021e1a72ddeaab180e45840cc4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48cd5ae71d90e254ddded3ae01a0824"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::map&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aa48cd5ae71d90e254ddded3ae01a0824">d_last_lag_idx_to_strct_id_map</a></td></tr>
<tr class="separator:aa48cd5ae71d90e254ddded3ae01a0824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830a0004c928f20ea502aeedfb848cd8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIBTK_1_1ParallelSet.html">ParallelSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a830a0004c928f20ea502aeedfb848cd8">d_inactive_strcts</a></td></tr>
<tr class="separator:a830a0004c928f20ea502aeedfb848cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f4b870f5e7f0ef42c7ab74e5961230"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aa5f4b870f5e7f0ef42c7ab74e5961230">d_displaced_strct_ids</a></td></tr>
<tr class="separator:aa5f4b870f5e7f0ef42c7ab74e5961230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f23d4a6f12a3dba5992d3ba6ce3636"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::pair&lt; <a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">Point</a>, <a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">Point</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#aa9f23d4a6f12a3dba5992d3ba6ce3636">d_displaced_strct_bounding_boxes</a></td></tr>
<tr class="separator:aa9f23d4a6f12a3dba5992d3ba6ce3636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cddcc074181f550eeeddccbe27dc84"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classIBTK_1_1LSet.html#abb10e33b689046edbf17966b00543509">LNodeSet::value_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a53cddcc074181f550eeeddccbe27dc84">d_displaced_strct_lnode_idxs</a></td></tr>
<tr class="separator:a53cddcc074181f550eeeddccbe27dc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625a61489b722f140400942568245bb3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">Point</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a625a61489b722f140400942568245bb3">d_displaced_strct_lnode_posns</a></td></tr>
<tr class="separator:a625a61489b722f140400942568245bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225719cf10ad4562988c0c1f3388e359"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LMesh.html">LMesh</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a225719cf10ad4562988c0c1f3388e359">d_lag_mesh</a></td></tr>
<tr class="separator:a225719cf10ad4562988c0c1f3388e359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd60d6d0aca62bce7f973cb7fdc0362"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::map&lt; std::string, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a8bd60d6d0aca62bce7f973cb7fdc0362">d_lag_mesh_data</a></td></tr>
<tr class="separator:a8bd60d6d0aca62bce7f973cb7fdc0362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c330e80c74f6c5401191da593514c6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a02c330e80c74f6c5401191da593514c6">d_needs_synch</a></td></tr>
<tr class="separator:a02c330e80c74f6c5401191da593514c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4bc9edafae8c09fd48d39f76c7e3f2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; AO &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a0b4bc9edafae8c09fd48d39f76c7e3f2">d_ao</a></td></tr>
<tr class="separator:a0b4bc9edafae8c09fd48d39f76c7e3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771e5d7fe530941fe7a4b30d95a1f38e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a771e5d7fe530941fe7a4b30d95a1f38e">d_num_nodes</a></td></tr>
<tr class="separator:a771e5d7fe530941fe7a4b30d95a1f38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9f954fe78641c1f749a53d3ccbff63"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a8e9f954fe78641c1f749a53d3ccbff63">d_node_offset</a></td></tr>
<tr class="separator:a8e9f954fe78641c1f749a53d3ccbff63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e70f5eb586edf8d066e3b3c49177757"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a6e70f5eb586edf8d066e3b3c49177757">d_local_lag_indices</a></td></tr>
<tr class="separator:a6e70f5eb586edf8d066e3b3c49177757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3549f3871bdd0c8b976b258182651f4a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a3549f3871bdd0c8b976b258182651f4a">d_nonlocal_lag_indices</a></td></tr>
<tr class="separator:a3549f3871bdd0c8b976b258182651f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8240ffbba000255374a8fbd525f00186"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a8240ffbba000255374a8fbd525f00186">d_local_petsc_indices</a></td></tr>
<tr class="separator:a8240ffbba000255374a8fbd525f00186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc7743e2a0edf6effd960e9ecc4ae25"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a8fc7743e2a0edf6effd960e9ecc4ae25">d_nonlocal_petsc_indices</a></td></tr>
<tr class="separator:a8fc7743e2a0edf6effd960e9ecc4ae25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0360c3f8c54ea77f07cfab09030999f5"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1LDataManager.html#a0360c3f8c54ea77f07cfab09030999f5">d_user_defined_ldata</a></td></tr>
<tr class="separator:a0360c3f8c54ea77f07cfab09030999f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The manager class is responsible for maintaining this data distribution and for all inter-processor communications. All access to instantiated <a class="el" href="classIBTK_1_1LDataManager.html" title="Class LDataManager coordinates the irregular distribution of LNode and LData on the patch hierarchy.">LDataManager</a> objects is via the static method <a class="el" href="classIBTK_1_1LDataManager.html#a97a22257f2f2c3ceb09a9aff7d52ae1e">getManager()</a>.</p>
<p>Each Lagrangian point is associated with an <a class="el" href="classIBTK_1_1LNode.html" title="Class LNode is the basic element of an LMesh.">LNode</a> object which provides an interface between the Lagrangian and PETSc ordering as well as the data storage for force specification objects and other objects associated with the point. From each <a class="el" href="classIBTK_1_1LNode.html" title="Class LNode is the basic element of an LMesh.">LNode</a> object, we can retrieve the Lagrangian index as well as any associated node data. The <a class="el" href="classIBTK_1_1LNode.html" title="Class LNode is the basic element of an LMesh.">LNode</a> objects for each processor are contained in an <a class="el" href="classIBTK_1_1LMesh.html" title="Class LMesh is a collection of LNode objects.">LMesh</a> object. The <a class="el" href="classIBTK_1_1LMesh.html" title="Class LMesh is a collection of LNode objects.">LMesh</a> object contains two vectors of LNodes: one containing just the local <a class="el" href="classIBTK_1_1LNode.html" title="Class LNode is the basic element of an LMesh.">LNode</a> objects, and another containing 'ghost' LNodes. The 'ghost' LNodes are Lagrangian points assigned to other processors but have data needed for calculations. Interacting with Lagrangian data is mediated through the static <a class="el" href="classIBTK_1_1LDataManager.html" title="Class LDataManager coordinates the irregular distribution of LNode and LData on the patch hierarchy.">LDataManager</a> object. From this class, we can get the local <a class="el" href="classIBTK_1_1LMesh.html" title="Class LMesh is a collection of LNode objects.">LMesh</a> object for each level of the Cartesian grid, and then loop through all associated Lagrangian nodes.</p>
<p>As an example, suppose we have a circle of Lagrangian points that are tethered to target points, and we wish to specify the motion of the target points, and hence the circle, to move in a straight line. We can do this by looping through all the nodes, pull out the <a class="el" href="classIBAMR_1_1IBTargetPointForceSpec.html" title="Class IBTargetPointForceSpec encapsulates the data necessary to compute the penalty force generated b...">IBAMR::IBTargetPointForceSpec</a>, and then update the target point location. In parallel, we also need to update the target point locations of the ghost data.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">update_target_points(Pointer&lt;PatchHierarchy&lt;NDIM&gt;&gt; hierarchy,</div>
<div class="line">                     <a class="code" href="classIBTK_1_1LDataManager.html#adc080d94b9dfcd1b29831b62b6015db3">LDataManager</a>* <span class="keyword">const</span> l_data_manager,</div>
<div class="line">                     <span class="keyword">const</span> <span class="keywordtype">double</span> current_time,</div>
<div class="line">                     <span class="keyword">const</span> <span class="keywordtype">double</span> dt)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> finest_ln = hierarchy-&gt;getFinestLevelNumber();</div>
<div class="line">    <span class="comment">// Note we assume the circle is the 0th structure and on the finest level.</span></div>
<div class="line">    <span class="keyword">const</span> std::pair&lt;int, int&gt;&amp; circle_lag_idxs = l_data_manager-&gt;getLagrangianStructureIndexRange(0, finest_ln);</div>
<div class="line">    Pointer&lt;LMesh&gt; mesh = l_data_manager-&gt;getLMesh(finest_ln);</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;LNode*&gt;&amp; local_nodes = mesh-&gt;getLocalNodes();</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;LNode*&gt;&amp; ghost_nodes = mesh-&gt;getGhostNodes();</div>
<div class="line">    std::vector&lt;LNode*&gt; nodes = local_nodes;</div>
<div class="line">    nodes.insert(nodes.end(), ghost_nodes.begin(), ghost_nodes.end());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; node : nodes)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> force_spec = node-&gt;getNodeDataItem&lt;IBTargetPointForceSpec&gt;();</div>
<div class="line">        <span class="keywordflow">if</span> (force_spec == <span class="keyword">nullptr</span>) <span class="keywordflow">continue</span>;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> lag_idx = node-&gt;getLagrangianIndex();</div>
<div class="line">        <a class="code" href="classlibMesh_1_1Point.html">Point</a>&amp; X_target = force_spec-&gt;getTargetPointPosition();</div>
<div class="line">        <span class="keywordflow">if</span> (circle_lag_idxs.first &lt;= lag_idx &amp;&amp; lag_idx &lt; circle_lag_idxs.second)</div>
<div class="line">        {</div>
<div class="line">            X_target[0] += 0.1 * dt; <span class="comment">// Move point to the right with speed 0.1</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>For some applications, it might be useful to get the Eulerian data of the Lagrangian points. To do this, it is important to understand the Lagrangian and PETSc index ordering. The Lagrangian ordering is fixed at the beginning of the simulation and is set by the reading of the vertices, whether through an input file or programmatically. The PETSc ordering, however, will change over the course of the simulation. Whenever a regridding operation is triggered, the PETSc indexing is changed to ensure efficient memory usage. The Eulerian data is stored in PETSc ordering, so in order to access that data, we need to map Lagrangian indices to their corresponding PETSc indices. We can then access the corresponding components of the PETSc data vector which is wrapped in an <a class="el" href="classIBTK_1_1LData.html" title="Class LData provides storage for a single scalar- or vector-valued Lagrangian quantity.">LData</a> object. As an example, here we loop over and print out the physical coordinates of all the Lagrangian points on the finest level.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">print_eul_data(Pointer&lt;PatchHierarchy&lt;NDIM&gt;&gt; hierarchy,</div>
<div class="line">               <a class="code" href="classIBTK_1_1LDataManager.html#adc080d94b9dfcd1b29831b62b6015db3">LDataManager</a>* <span class="keyword">const</span> l_data_manager)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> finest_ln = hierarchy-&gt;getFinestLevelNumber();</div>
<div class="line">    Pointer&lt;LData&gt; X_data = l_data_manager-&gt;getLData(<span class="stringliteral">&quot;X&quot;</span>, finest_ln);</div>
<div class="line">    Vec X_vec = X_data-&gt;getVec();</div>
<div class="line">    <span class="keywordtype">double</span>* x_vals;</div>
<div class="line">    <span class="keywordtype">int</span> ierr = VecGetArray(X_vec, &amp;x_vals);</div>
<div class="line">    <a class="code" href="IBTK__CHKERRQ_8h.html#a82134efd79614179ddc74839a56497ef">IBTK_CHKERRQ</a>(ierr);</div>
<div class="line"> </div>
<div class="line">    Pointer&lt;LMesh&gt; mesh = l_data_manager-&gt;getLMesh(finest_ln);</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;LNode*&gt;&amp; nodes = mesh-&gt;getLocalNodes();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; node : nodes)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> lag_idx = node-&gt;getLagrangianIndex();</div>
<div class="line">        <span class="comment">// Note we use the local index instead of the global index.</span></div>
<div class="line">        <span class="comment">// The global index is the local index plust the total indices on all processors of lower rank.</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> petsc_idx = node-&gt;getLocalPETScIndex();</div>
<div class="line">        Eigen::Map&lt;VectorNd&gt; X(&amp;x_vals[petsc_idx * NDIM]);</div>
<div class="line">        <a class="code" href="namespaceSAMRAI_1_1tbox.html#a1e98e73dc869d986f7ffe5b295075979">pout</a> &lt;&lt; <span class="stringliteral">&quot;Euerian location of node &quot;</span> &lt;&lt; lag_idx &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span></div>
<div class="line">             &lt;&lt; X &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Multiple <a class="el" href="classIBTK_1_1LDataManager.html" title="Class LDataManager coordinates the irregular distribution of LNode and LData on the patch hierarchy.">LDataManager</a> objects may be instantiated simultaneously.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classIBTK_1_1LMesh.html" title="Class LMesh is a collection of LNode objects.">LMesh</a>, <a class="el" href="classIBTK_1_1LNode.html" title="Class LNode is the basic element of an LMesh.">LNode</a>, <a class="el" href="classIBTK_1_1LData.html" title="Class LData provides storage for a single scalar- or vector-valued Lagrangian quantity.">LData</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a950881aaa96eb24f54e6a24619972eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950881aaa96eb24f54e6a24619972eba">&#9670;&nbsp;</a></span>LDataManager() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::LDataManager::LDataManager </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>default_interp_kernel_fcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>default_spread_kernel_fcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>error_if_points_leave_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt;&#160;</td>
          <td class="paramname"><em>ghost_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>register_for_restart</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a43b47ef5a2be4290da1f1ecd31d956e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b47ef5a2be4290da1f1ecd31d956e2">&#9670;&nbsp;</a></span>~LDataManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::LDataManager::~LDataManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adc080d94b9dfcd1b29831b62b6015db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc080d94b9dfcd1b29831b62b6015db3">&#9670;&nbsp;</a></span>LDataManager() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::LDataManager::LDataManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This constructor is not implemented and should not be used. </dd></dl>

</div>
</div>
<a id="ab636a857c80a84a00384248aea0b8b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab636a857c80a84a00384248aea0b8b29">&#9670;&nbsp;</a></span>LDataManager() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::LDataManager::LDataManager </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIBTK_1_1LDataManager.html">LDataManager</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This constructor is not implemented and should not be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The value to copy to this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a97a22257f2f2c3ceb09a9aff7d52ae1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a22257f2f2c3ceb09a9aff7d52ae1e">&#9670;&nbsp;</a></span>getManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classIBTK_1_1LDataManager.html">LDataManager</a>* IBTK::LDataManager::getManager </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_interp_kernel_fcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_spread_kernel_fcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>error_if_points_leave_domain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>min_ghost_width</em> = <code><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt;&#160;NDIM&#160;&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>register_for_restart</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the instance of the Lagrangian data manager corresponding to the specified name. Access to <a class="el" href="classIBTK_1_1LDataManager.html" title="Class LDataManager coordinates the irregular distribution of LNode and LData on the patch hierarchy.">LDataManager</a> objects is mediated by the <a class="el" href="classIBTK_1_1LDataManager.html#a97a22257f2f2c3ceb09a9aff7d52ae1e">getManager()</a> function.</p>
<p>Note that when a manager is accessed for the first time, the freeAllManagers static method is registered with the ShutdownRegistry class. Consequently, all allocated managers are freed at program completion. Thus, users of this class do not explicitly allocate or deallocate the <a class="el" href="classIBTK_1_1LDataManager.html" title="Class LDataManager coordinates the irregular distribution of LNode and LData on the patch hierarchy.">LDataManager</a> instances.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the data manager instance.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>By default, the ghost cell width is set according to the interpolation and spreading kernel functions. </dd></dl>

</div>
</div>
<a id="a670d40bee489e0b6aec3389d88427496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670d40bee489e0b6aec3389d88427496">&#9670;&nbsp;</a></span>freeAllManagers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IBTK::LDataManager::freeAllManagers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deallocate all of the <a class="el" href="classIBTK_1_1LDataManager.html" title="Class LDataManager coordinates the irregular distribution of LNode and LData on the patch hierarchy.">LDataManager</a> instances.</p>
<p>It is not necessary to call this function at program termination since it is automatically called by the ShutdownRegistry class. </p>

</div>
</div>
<a id="a36cecd3accdf64b12e8f1093fb3ac7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36cecd3accdf64b12e8f1093fb3ac7d8">&#9670;&nbsp;</a></span>setPatchHierarchy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::setPatchHierarchy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75a23bd73f82ea1e392fb2d31da8dd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a23bd73f82ea1e392fb2d31da8dd40">&#9670;&nbsp;</a></span>getPatchHierarchy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt;NDIM&gt; &gt; IBTK::LDataManager::getPatchHierarchy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab66d2c666c08047508864acd1d12f27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66d2c666c08047508864acd1d12f27c">&#9670;&nbsp;</a></span>setPatchLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::setPatchLevels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The levels must exist in the hierarchy or an assertion failure will result. </p>

</div>
</div>
<a id="ad4a34a179b38ae05b5765083bc8e2adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a34a179b38ae05b5765083bc8e2adc">&#9670;&nbsp;</a></span>getPatchLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>&gt; IBTK::LDataManager::getPatchLevels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Returns [coarsest_ln,finest_ln+1). </dd></dl>

</div>
</div>
<a id="a37180542cf9127e3082a927de1feb624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37180542cf9127e3082a927de1feb624">&#9670;&nbsp;</a></span>getGhostCellWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp; IBTK::LDataManager::getGhostCellWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ee4a20865323c6ffb5165ecb4328c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee4a20865323c6ffb5165ecb4328c95">&#9670;&nbsp;</a></span>getDefaultInterpKernelFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; IBTK::LDataManager::getDefaultInterpKernelFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a88a6888c6fdcf811c9342e21f86cb8ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a6888c6fdcf811c9342e21f86cb8ad">&#9670;&nbsp;</a></span>getDefaultSpreadKernelFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; IBTK::LDataManager::getDefaultSpreadKernelFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a84a7a199cfd186f610f87c5117e699df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a7a199cfd186f610f87c5117e699df">&#9670;&nbsp;</a></span>spread() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::spread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt;&#160;</td>
          <td class="paramname"><em>F_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt;&#160;</td>
          <td class="paramname"><em>X_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt;&#160;</td>
          <td class="paramname"><em>ds_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *&#160;</td>
          <td class="paramname"><em>f_phys_bdry_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_prolongation_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>F_data_ghost_node_update</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>X_data_ghost_node_update</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>ds_data_ghost_node_update</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This spreading operation does include the scale factor corresponding to the curvilinear volume element (dq dr ds). The spreading formula is <pre class="fragment">f(i,j,k) = f(i,j,k) + Sum_{q,r,s} F(q,r,s) delta_h(x(i,j,k) - X(q,r,s)) ds(q,r,s)
</pre></dd></dl>
<p>This is the standard regularized delta function spreading operation, which spreads densities, <em>NOT</em> values. </p>

</div>
</div>
<a id="a8bec837fe1c813bd4b51829f574de630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bec837fe1c813bd4b51829f574de630">&#9670;&nbsp;</a></span>spread() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::spread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt;&#160;</td>
          <td class="paramname"><em>F_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt;&#160;</td>
          <td class="paramname"><em>X_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt;&#160;</td>
          <td class="paramname"><em>ds_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>spread_kernel_fcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *&#160;</td>
          <td class="paramname"><em>f_phys_bdry_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_prolongation_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>F_data_ghost_node_update</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>X_data_ghost_node_update</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>ds_data_ghost_node_update</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This spreading operation does include the scale factor corresponding to the curvilinear volume element (dq dr ds). The spreading formula is <pre class="fragment">f(i,j,k) = f(i,j,k) + Sum_{q,r,s} F(q,r,s) delta_h(x(i,j,k) - X(q,r,s)) ds(q,r,s)
</pre></dd></dl>
<p>This is the standard regularized delta function spreading operation, which spreads densities, <em>NOT</em> values. </p>

</div>
</div>
<a id="ac78977702d7d34a5367af101c7bf422f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78977702d7d34a5367af101c7bf422f">&#9670;&nbsp;</a></span>spread() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::spread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ds_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *&#160;</td>
          <td class="paramname"><em>f_phys_bdry_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_prolongation_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>F_data_ghost_node_update</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>X_data_ghost_node_update</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>ds_data_ghost_node_update</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This spreading operation does include the scale factor corresponding to the curvilinear volume element (dq dr ds). The spreading formula is <pre class="fragment">f(i,j,k) = f(i,j,k) + Sum_{q,r,s} F(q,r,s) delta_h(x(i,j,k) - X(q,r,s)) ds(q,r,s)
</pre></dd></dl>
<p>This is the standard regularized delta function spreading operation, which spreads densities, <em>NOT</em> values. </p>

</div>
</div>
<a id="a4843f7ab68ecdd8dcb55934a4132aedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4843f7ab68ecdd8dcb55934a4132aedf">&#9670;&nbsp;</a></span>spread() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::spread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ds_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>spread_kernel_fcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *&#160;</td>
          <td class="paramname"><em>f_phys_bdry_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_prolongation_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>F_data_ghost_node_update</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>X_data_ghost_node_update</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>ds_data_ghost_node_update</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This spreading operation does include the scale factor corresponding to the curvilinear volume element (dq dr ds). The spreading formula is <pre class="fragment">f(i,j,k) = f(i,j,k) + Sum_{q,r,s} F(q,r,s) delta_h(x(i,j,k) - X(q,r,s)) ds(q,r,s)
</pre></dd></dl>
<p>This is the standard regularized delta function spreading operation, which spreads densities, <em>NOT</em> values. </p>

</div>
</div>
<a id="abfe90013688c6dbaf9d827cc652234f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe90013688c6dbaf9d827cc652234f0">&#9670;&nbsp;</a></span>spread() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::spread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt;&#160;</td>
          <td class="paramname"><em>F_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt;&#160;</td>
          <td class="paramname"><em>X_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *&#160;</td>
          <td class="paramname"><em>f_phys_bdry_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_prolongation_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>F_data_ghost_node_update</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>X_data_ghost_node_update</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This spreading operation does NOT include the scale factor corresponding to the curvilinear volume element (dq dr ds). The spreading formula is <pre class="fragment">f(i,j,k) = f(i,j,k) + Sum_{q,r,s} F(q,r,s) delta_h(x(i,j,k) - X(q,r,s))
</pre></dd></dl>
<p>Unlike the standard regularized delta function spreading operation, the implemented operation spreads values, <em>NOT</em> densities. </p>

</div>
</div>
<a id="af3b321e1f75f119445da3a107d43cd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b321e1f75f119445da3a107d43cd76">&#9670;&nbsp;</a></span>spread() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::spread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt;&#160;</td>
          <td class="paramname"><em>F_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt;&#160;</td>
          <td class="paramname"><em>X_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>spread_kernel_fcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *&#160;</td>
          <td class="paramname"><em>f_phys_bdry_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_prolongation_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>F_data_ghost_node_update</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>X_data_ghost_node_update</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This spreading operation does NOT include the scale factor corresponding to the curvilinear volume element (dq dr ds). The spreading formula is <pre class="fragment">f(i,j,k) = f(i,j,k) + Sum_{q,r,s} F(q,r,s) delta_h(x(i,j,k) - X(q,r,s))
</pre></dd></dl>
<p>Unlike the standard regularized delta function spreading operation, the implemented operation spreads values, <em>NOT</em> densities. </p>

</div>
</div>
<a id="a5a34de4cad12ca5cd91126b2254ca512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a34de4cad12ca5cd91126b2254ca512">&#9670;&nbsp;</a></span>spread() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::spread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *&#160;</td>
          <td class="paramname"><em>f_phys_bdry_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_prolongation_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>F_data_ghost_node_update</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>X_data_ghost_node_update</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This spreading operation does NOT include the scale factor corresponding to the curvilinear volume element (dq dr ds). The spreading formula is <pre class="fragment">f(i,j,k) = f(i,j,k) + Sum_{q,r,s} F(q,r,s) delta_h(x(i,j,k) - X(q,r,s))
</pre></dd></dl>
<p>Unlike the standard regularized delta function spreading operation, the implemented operation spreads values, <em>NOT</em> densities. </p>

</div>
</div>
<a id="a0d81438d0f2f6f2ffb4d251e16cbf098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d81438d0f2f6f2ffb4d251e16cbf098">&#9670;&nbsp;</a></span>spread() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::spread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>spread_kernel_fcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *&#160;</td>
          <td class="paramname"><em>f_phys_bdry_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_prolongation_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>F_data_ghost_node_update</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>X_data_ghost_node_update</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This spreading operation does NOT include the scale factor corresponding to the curvilinear volume element (dq dr ds). The spreading formula is <pre class="fragment">f(i,j,k) = f(i,j,k) + Sum_{q,r,s} F(q,r,s) delta_h(x(i,j,k) - X(q,r,s))
</pre></dd></dl>
<p>Unlike the standard regularized delta function spreading operation, the implemented operation spreads values, <em>NOT</em> densities. </p>

</div>
</div>
<a id="ab4648251121262ca5bae15054fb760a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4648251121262ca5bae15054fb760a6">&#9670;&nbsp;</a></span>interp() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::interp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt;&#160;</td>
          <td class="paramname"><em>F_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt;&#160;</td>
          <td class="paramname"><em>X_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_synch_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ghost_fill_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae93643716df661265a436ba6660e9601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93643716df661265a436ba6660e9601">&#9670;&nbsp;</a></span>interp() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::interp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt;&#160;</td>
          <td class="paramname"><em>F_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt;&#160;</td>
          <td class="paramname"><em>X_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>interp_kernel_fcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_synch_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ghost_fill_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7f74a879c8830c9d293eaf2126fde08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f74a879c8830c9d293eaf2126fde08">&#9670;&nbsp;</a></span>interp() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::interp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_synch_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ghost_fill_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9d131025eaa1b6effc004a874d13d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d131025eaa1b6effc004a874d13d43">&#9670;&nbsp;</a></span>interp() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::interp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>interp_kernel_fcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_synch_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ghost_fill_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56b81e163585cde632beaea203a574a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b81e163585cde632beaea203a574a1">&#9670;&nbsp;</a></span>registerLInitStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::registerLInitStrategy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LInitStrategy.html">LInitStrategy</a> &gt;&#160;</td>
          <td class="paramname"><em>lag_init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a concrete strategy object with the integrator that specifies the initial configuration of the curvilinear mesh nodes.</p>
<dl class="section note"><dt>Note</dt><dd>This function calls <a class="el" href="classIBTK_1_1LInitStrategy.html#ad7c66e95e4e4fc801408a82f9cbf07d1" title="Initialize structure specific configurations.">LInitStrategy::init()</a>. All preprocessing should be completed before registering a <a class="el" href="classIBTK_1_1LInitStrategy.html" title="Class LInitStrategy provides a mechanism for specifying the initial configuration of the curvilinear ...">LInitStrategy</a> object. </dd></dl>

</div>
</div>
<a id="a0c54478bd27a46546e19292ed3f2ef08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c54478bd27a46546e19292ed3f2ef08">&#9670;&nbsp;</a></span>freeLInitStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::freeLInitStrategy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the concrete initialization strategy object.</p>
<dl class="section note"><dt>Note</dt><dd>Be sure to call this method only once the initialization object is no longer needed. </dd></dl>

</div>
</div>
<a id="aa68d470c1bb587fb77525d7a303bedcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68d470c1bb587fb77525d7a303bedcd">&#9670;&nbsp;</a></span>registerVisItDataWriter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::registerVisItDataWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">SAMRAI::appu::VisItDataWriter</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>visit_writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9946bcc90dc2bd5841fca70b8fa82a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9946bcc90dc2bd5841fca70b8fa82a2">&#9670;&nbsp;</a></span>registerLSiloDataWriter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::registerLSiloDataWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LSiloDataWriter.html">LSiloDataWriter</a> &gt;&#160;</td>
          <td class="paramname"><em>silo_writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4091bdb848f92c5ee87d5c6eb92145d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4091bdb848f92c5ee87d5c6eb92145d0">&#9670;&nbsp;</a></span>registerLoadBalancer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::registerLoadBalancer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalancer.html">SAMRAI::mesh::LoadBalancer</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>load_balancer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>workload_data_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>This method is deprecated since the current strategy for handling non-uniform load balancing does not require that this object store a pointer to the load balancer. </dd></dl>

</div>
</div>
<a id="adfd16f75b4748368af21aae6ea2f6ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd16f75b4748368af21aae6ea2f6ef9">&#9670;&nbsp;</a></span>levelContainsLagrangianData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::LDataManager::levelContainsLagrangianData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a74e8a86979d02d8009ca0626c2758da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e8a86979d02d8009ca0626c2758da7">&#9670;&nbsp;</a></span>getNumberOfNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> IBTK::LDataManager::getNumberOfNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of total nodes of the Lagrangian data for the specified level of the patch hierarchy. </dd></dl>

</div>
</div>
<a id="a7786a413368a16487070edde75769db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7786a413368a16487070edde75769db2">&#9670;&nbsp;</a></span>getNumberOfLocalNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> IBTK::LDataManager::getNumberOfLocalNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of local (i.e., on-processor) nodes of the Lagrangian data for the specified level of the patch hierarchy.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This count does not include nodes that only lie in ghost cells for the current process.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classIBTK_1_1LDataManager.html#a74e8a86979d02d8009ca0626c2758da7">getNumberOfNodes</a> </dd>
<dd>
<a class="el" href="classIBTK_1_1LDataManager.html#a75dfe561f56b122d936317c6ee71965b">getNumberOfGhostNodes</a> </dd></dl>

</div>
</div>
<a id="a75dfe561f56b122d936317c6ee71965b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75dfe561f56b122d936317c6ee71965b">&#9670;&nbsp;</a></span>getNumberOfGhostNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> IBTK::LDataManager::getNumberOfGhostNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of ghost (i.e., off-processor) nodes of the Lagrangian data for the specified level of the patch hierarchy.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classIBTK_1_1LDataManager.html#a74e8a86979d02d8009ca0626c2758da7">getNumberOfNodes</a> </dd>
<dd>
<a class="el" href="classIBTK_1_1LDataManager.html#a7786a413368a16487070edde75769db2">getNumberOfLocalNodes</a> </dd></dl>

</div>
</div>
<a id="a14458ddb1312e72f133fa6d88d3e395c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14458ddb1312e72f133fa6d88d3e395c">&#9670;&nbsp;</a></span>getGlobalNodeOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> IBTK::LDataManager::getGlobalNodeOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of nodes on all processors with MPI rank less than the current process on the specified level of the patch hierarchy.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This count does not include nodes that only lie in ghost cells for the current process. </dd></dl>

</div>
</div>
<a id="aa25ad98658d45fbf72e9a1fbe695b4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25ad98658d45fbf72e9a1fbe695b4ee">&#9670;&nbsp;</a></span>getLMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LMesh.html">LMesh</a> &gt; IBTK::LDataManager::getLMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a329154c9e3b78a7582ea193e4d0bcad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329154c9e3b78a7582ea193e4d0bcad1">&#9670;&nbsp;</a></span>getLData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt; IBTK::LDataManager::getLData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>quantity_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6caed9ba4ee98feb55f01c9194df9ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6caed9ba4ee98feb55f01c9194df9ac7">&#9670;&nbsp;</a></span>createLData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LData.html">LData</a>&gt; IBTK::LDataManager::createLData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>quantity_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>maintain_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Quantities maintained by the <a class="el" href="classIBTK_1_1LDataManager.html" title="Class LDataManager coordinates the irregular distribution of LNode and LData on the patch hierarchy.">LDataManager</a> must have unique names. The name "X" is reserved for the nodal coordinates. </dd></dl>

</div>
</div>
<a id="a95f008aacfafaa0a84536764c46fbe06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f008aacfafaa0a84536764c46fbe06">&#9670;&nbsp;</a></span>getLNodePatchDescriptorIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::LDataManager::getLNodePatchDescriptorIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad1c394e98949baf2d46bc9a0d2d5733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1c394e98949baf2d46bc9a0d2d5733">&#9670;&nbsp;</a></span>getWorkloadPatchDescriptorIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::LDataManager::getWorkloadPatchDescriptorIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>This method is deprecated since, in future versions of <a class="el" href="namespaceIBAMR.html">IBAMR</a>, this value will no longer be stored and will only be available via the parent hierarchy integrator. </dd></dl>

</div>
</div>
<a id="a2c68b1859783756cb1d07306268faf31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c68b1859783756cb1d07306268faf31">&#9670;&nbsp;</a></span>getNodeCountPatchDescriptorIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::LDataManager::getNodeCountPatchDescriptorIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d54d77cee8721071813fb79335cd22c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d54d77cee8721071813fb79335cd22c">&#9670;&nbsp;</a></span>getLagrangianStructureNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; IBTK::LDataManager::getLagrangianStructureNames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad24da50545eef138442a83a4655aa922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24da50545eef138442a83a4655aa922">&#9670;&nbsp;</a></span>getLagrangianStructureIDs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classint.html">int</a> &gt; IBTK::LDataManager::getLagrangianStructureIDs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ddfd62821a60a7f1431ef29ffb09804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddfd62821a60a7f1431ef29ffb09804">&#9670;&nbsp;</a></span>getLagrangianStructureID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::LDataManager::getLagrangianStructureID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>lagrangian_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Returns -1 in the case that the Lagrangian index is not associated with any Lagrangian structure. </dd></dl>

</div>
</div>
<a id="a905eac8a4c80aee2fdb70726f89e76e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905eac8a4c80aee2fdb70726f89e76e3">&#9670;&nbsp;</a></span>getLagrangianStructureID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::LDataManager::getLagrangianStructureID </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>structure_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Returns -1 in the case that the Lagrangian structure name is not associated with any Lagrangian structure. </dd></dl>

</div>
</div>
<a id="a6d946e90a1a3954a5fcafbac3438fc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d946e90a1a3954a5fcafbac3438fc81">&#9670;&nbsp;</a></span>getLagrangianStructureName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string IBTK::LDataManager::getLagrangianStructureName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>structure_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Returns "UNKNOWN" in the case that the Lagrangian structure ID is not associated with any Lagrangian structure. </dd></dl>

</div>
</div>
<a id="aa0b2cd7d9ef2b9009bf294671e8f107d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b2cd7d9ef2b9009bf294671e8f107d">&#9670;&nbsp;</a></span>getLagrangianStructureIndexRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt; IBTK::LDataManager::getLagrangianStructureIndexRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>structure_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A pair of indices such that if pair.first &lt;= lag_idx &lt; pair.second, then lag_idx is associated with the specified structure; otherwise, lag_idx is not associated with the specified structure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns std::make_pair(-1,-1) in the case that the Lagrangian structure ID is not associated with any Lagrangian structure. </dd></dl>

</div>
</div>
<a id="a6d2d121ec746f96f49662e4e6478b86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2d121ec746f96f49662e4e6478b86a">&#9670;&nbsp;</a></span>computeLagrangianStructureCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">Point</a> IBTK::LDataManager::computeLagrangianStructureCenterOfMass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>structure_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The center of mass X of a particular structure is computed as</dd></dl>
<p>X = (1/N) Sum_{k in structure} X_k</p>
<p>in which N is the number of nodes associated with that structure.</p>
<dl class="section note"><dt>Note</dt><dd>Returns Point::Zero() in the case that the Lagrangian structure ID is not associated with any Lagrangian structure. </dd></dl>

</div>
</div>
<a id="afa64127c630b3133459e38ac2344a368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa64127c630b3133459e38ac2344a368">&#9670;&nbsp;</a></span>computeLagrangianStructureBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">Point</a>, <a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">Point</a>&gt; IBTK::LDataManager::computeLagrangianStructureBoundingBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>structure_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Returns the entire range of double precision values in the case that the Lagrangian structure ID is not associated with any Lagrangian structure. </dd></dl>

</div>
</div>
<a id="afdaafde7e8e58a5f2ab5ee5deaeb5ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdaafde7e8e58a5f2ab5ee5deaeb5ca0">&#9670;&nbsp;</a></span>reinitLagrangianStructure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::reinitLagrangianStructure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>X_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>structure_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This operation must be performed immediately before a regridding operation, otherwise the results are undefined. </dd></dl>

</div>
</div>
<a id="a11e91185ad0ce241dafd8fa176dea8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e91185ad0ce241dafd8fa176dea8fc">&#9670;&nbsp;</a></span>displaceLagrangianStructure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::displaceLagrangianStructure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#a09a4d4ded781c3a9630a42d88680e89f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>dX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>structure_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This operation must be performed immediately before a regridding operation, otherwise the results are undefined.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All displacements must involve shifts that do <em>not</em> cross periodic boundaries. </dd></dl>

</div>
</div>
<a id="aef4eaedcdd89b31a5dfb6a668fbb3807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4eaedcdd89b31a5dfb6a668fbb3807">&#9670;&nbsp;</a></span>activateLagrangianStructures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::activateLagrangianStructures </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>structure_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This method is collective (i.e., must be called by all MPI processes); however, each MPI process may provide a different collection of structures to activate. </dd></dl>

</div>
</div>
<a id="a3aeb7b0d36f493ac4e242da1f73b5598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aeb7b0d36f493ac4e242da1f73b5598">&#9670;&nbsp;</a></span>inactivateLagrangianStructures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::inactivateLagrangianStructures </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>structure_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This method is collective (i.e., must be called by all MPI processes); however, each MPI process may provide a different collection of structures to inactivate. </dd></dl>

</div>
</div>
<a id="a9687be9b34a0add1b34b855cbd6f0959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9687be9b34a0add1b34b855cbd6f0959">&#9670;&nbsp;</a></span>getLagrangianStructureIsActivated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::LDataManager::getLagrangianStructureIsActivated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>structure_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f0ba6c6041ed2af54fefae9df7d9a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0ba6c6041ed2af54fefae9df7d9a68">&#9670;&nbsp;</a></span>zeroInactivatedComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::zeroInactivatedComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classIBTK_1_1LData.html">LData</a> &gt;&#160;</td>
          <td class="paramname"><em>lag_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a788f12a28a00c0615c73ade4c8137029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788f12a28a00c0615c73ade4c8137029">&#9670;&nbsp;</a></span>mapLagrangianToPETSc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::mapLagrangianToPETSc </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a73c248230e7c8e3ad596c947f7ebf40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c248230e7c8e3ad596c947f7ebf40d">&#9670;&nbsp;</a></span>mapPETScToLagrangian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::mapPETScToLagrangian </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4f9734f12d8544a0a839d4d54ac9d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f9734f12d8544a0a839d4d54ac9d3f">&#9670;&nbsp;</a></span>getAO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AO&amp; IBTK::LDataManager::getAO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad835b0ad918dc4e8dc418c41fd477378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad835b0ad918dc4e8dc418c41fd477378">&#9670;&nbsp;</a></span>scatterLagrangianToPETSc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::scatterLagrangianToPETSc </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>lagrangian_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>petsc_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Optimize the implementation of this method. </dd></dl>

</div>
</div>
<a id="aed942039455f7d451e74a2a2ef98f0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed942039455f7d451e74a2a2ef98f0e7">&#9670;&nbsp;</a></span>scatterPETScToLagrangian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::scatterPETScToLagrangian </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>petsc_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>lagrangian_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Optimize the implementation of this method. </dd></dl>

</div>
</div>
<a id="a9afe950ed1465f6a9dfab92d6e090972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afe950ed1465f6a9dfab92d6e090972">&#9670;&nbsp;</a></span>scatterToAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::scatterToAll </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>parallel_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>sequential_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Optimize the implementation of this method. </dd></dl>

</div>
</div>
<a id="a321687e02e581f7741239c31b5c0f7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321687e02e581f7741239c31b5c0f7af">&#9670;&nbsp;</a></span>scatterToZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::scatterToZero </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>parallel_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>sequential_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Optimize the implementation of this method. </dd></dl>

</div>
</div>
<a id="a53775a84194e1c0998f8f00193c99315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53775a84194e1c0998f8f00193c99315">&#9670;&nbsp;</a></span>beginDataRedistribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::beginDataRedistribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method uses the present location of each Lagrangian mesh node to redistribute the LNodeData managed by this object.</p>
<dl class="section note"><dt>Note</dt><dd>This routine assumes that the time interval between node redistribution satisfies a timestep restriction of the form dt &lt;= C*dx*|U| with C &lt;= 1. This restriction prevents nodes from moving more than one cell width per timestep.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classIBTK_1_1LDataManager.html#a44d2e53f28436a6f8c08853440846455" title="Finish the process of redistributing the Lagrangian data.">endDataRedistribution</a> </dd></dl>

</div>
</div>
<a id="a44d2e53f28436a6f8c08853440846455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d2e53f28436a6f8c08853440846455">&#9670;&nbsp;</a></span>endDataRedistribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::endDataRedistribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method redistributes the quantities associated with each node in the Lagrangian mesh according to the data distribution defined by the LNodeData managed by this object. This routine potentially involves SUBSTANTIAL inter-processor communication.</p>
<dl class="section note"><dt>Note</dt><dd>Since this routine potentially results in a large amount of inter-processor communication, it may be worth putting it off for as long as possible. If the timestep dt satisfies a condition of the form dt &lt;= C*dx*|U| with C &lt;&lt; 1, it may be possible to redistribute the Lagrangian data less frequently than every timestep.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classIBTK_1_1LDataManager.html#a53775a84194e1c0998f8f00193c99315" title="Start the process of redistributing the Lagrangian data.">beginDataRedistribution</a> </dd></dl>

</div>
</div>
<a id="a4411433e4cc96b6348c9f4627c8167e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4411433e4cc96b6348c9f4627c8167e1">&#9670;&nbsp;</a></span>addWorkloadEstimate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::addWorkloadEstimate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>workload_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine updates cell data that is maintained on the patch hierarchy to track the number of nodes in each cell of the AMR index space. The node count data is used to tag cells for refinement, and to specify non-uniform load balancing. The workload per cell is defined by</p>
<p>workload(i) = 1 + beta_work*node_count(i)</p>
<p>in which alpha and beta are parameters that each default to the value 1. </p>

</div>
</div>
<a id="ac3d5ce3bfcfca62ff2628c39c3228242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d5ce3bfcfca62ff2628c39c3228242">&#9670;&nbsp;</a></span>updateNodeCountData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::updateNodeCountData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine updates cell data that is maintained on the patch hierarchy to track the number of nodes in each cell of the AMR index space. The node count data is used to tag cells for refinement, and to specify non-uniform load balancing. </p>

</div>
</div>
<a id="ae6060e1a8a6cd8ffe935b5c9be5cde3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6060e1a8a6cd8ffe935b5c9be5cde3a">&#9670;&nbsp;</a></span>initializeLevelData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::initializeLevelData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>init_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>can_be_refined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>old_level</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">SAMRAI::hier::BasePatchLevel</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;(nullptr)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allocate_data</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize data on a new level after it is inserted into an AMR patch hierarchy by the gridding algorithm. The level number indicates that of the new level. The old_level pointer corresponds to the level that resided in the hierarchy before the level with the specified number was introduced. If the pointer is null, there was no level in the hierarchy prior to the call and the level data is set based on the user routines and the simulation time. Otherwise, the specified level replaces the old level and the new level receives data from the old level appropriately before it is destroyed.</p>
<p>The boolean argument initial_time indicates whether the level is being introduced for the first time (i.e., at initialization time) or after some regrid process during the calculation beyond the initial hierarchy construction. This information is provided since the initialization of the data on a patch may be different in each of those circumstances. The can_be_refined boolean argument indicates whether the level is the finest level allowed in the hierarchy. This may or may not affect the data initialization process depending on the problem.</p>
<p>When assertion checking is active, an unrecoverable exception will result if the hierarchy pointer is null, the level number does not match any level in the hierarchy, or the old level number does not match the level number (if the old level pointer is non-null). </p>

</div>
</div>
<a id="af3cc205680804bb8acfa23ff391ca427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cc205680804bb8acfa23ff391ca427">&#9670;&nbsp;</a></span>resetHierarchyConfiguration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::resetHierarchyConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset cached communication schedules after the hierarchy has changed (for example, due to regridding) and the data has been initialized on the new levels. The intent is that the cost of data movement on the hierarchy will be amortized across multiple communication cycles, if possible. The level numbers indicate the range of levels in the hierarchy that have changed. However, this routine updates communication schedules every level finer than and including that indexed by the coarsest level number given.</p>
<p>When assertion checking is active, an unrecoverable exception will result if the hierarchy pointer is null, any pointer to a level in the hierarchy that is coarser than the finest level is null, or the given level numbers not specified properly; e.g., coarsest_ln &gt; finest_ln. </p>

</div>
</div>
<a id="a364d84921020373679547b5f2f03158d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364d84921020373679547b5f2f03158d">&#9670;&nbsp;</a></span>applyGradientDetector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::applyGradientDetector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>uses_richardson_extrapolation_too</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set integer tags to "one" in cells where refinement of the given level should occur due to the presence of Lagrangian data. The double time argument is the regrid time. The integer "tag_index" argument is the patch descriptor index of the cell centered integer tag array on each patch in the hierarchy. The boolean argument initial_time indicates whether the level is being subject to refinement at the initial simulation time. If it is false, then the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. The boolean argument uses_richardson_extrapolation_too is true when Richardson extrapolation error estimation is used in addition to the gradient detector, and false otherwise. This argument helps the user to manage multiple regridding criteria.</p>
<p>When assertion checking is active, an unrecoverable exception will result if the hierarchy pointer is null or the level number does not match any existing level in the hierarchy. </p>

</div>
</div>
<a id="aa6bb93939023933dd4231b8cd705b457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6bb93939023933dd4231b8cd705b457">&#9670;&nbsp;</a></span>putToDatabase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::putToDatabase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt;&#160;</td>
          <td class="paramname"><em>db</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write out object state to the given database.</p>
<p>When assertion checking is active, database pointer must be non-null. </p>

<p>Implements <a class="el" href="classSAMRAI_1_1tbox_1_1Serializable.html#ad90b74ae3fd7af9a7bb9cbf7f3ebc08a">SAMRAI::tbox::Serializable</a>.</p>

</div>
</div>
<a id="ad5a272cdb539279e2ee9dea9677a7860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a272cdb539279e2ee9dea9677a7860">&#9670;&nbsp;</a></span>registerUserDefinedLData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::registerUserDefinedLData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>data_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register user defined Lagrangian data to be maintained </p>

</div>
</div>
<a id="ad6861d201198ba905fcfbec6e1b59218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6861d201198ba905fcfbec6e1b59218">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBTK_1_1LDataManager.html">LDataManager</a>&amp; IBTK::LDataManager::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIBTK_1_1LDataManager.html">LDataManager</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This operator is not implemented and should not be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>The value to assign to this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<a id="a5c8b151096ea78c6e2479e1f1265b9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8b151096ea78c6e2479e1f1265b9b2">&#9670;&nbsp;</a></span>scatterData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::scatterData </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>lagrangian_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>petsc_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScatterMode&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b982c4e1113481e090081ff1fc5b4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b982c4e1113481e090081ff1fc5b4e7">&#9670;&nbsp;</a></span>beginNonlocalDataFill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::beginNonlocalDataFill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The operation is essentially equivalent to refilling ghost cells for structured (<a class="el" href="namespaceSAMRAI.html">SAMRAI</a> native) data. </p>

</div>
</div>
<a id="afb49791ca463f0f5ba7b20285ee7335f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb49791ca463f0f5ba7b20285ee7335f">&#9670;&nbsp;</a></span>endNonlocalDataFill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::endNonlocalDataFill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The operation is essentially equivalent to refilling ghost cells for structured (<a class="el" href="namespaceSAMRAI.html">SAMRAI</a> native) data. </p>

</div>
</div>
<a id="a04901bfef13cc5cd721f38fcf2933ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04901bfef13cc5cd721f38fcf2933ff8">&#9670;&nbsp;</a></span>computeNodeDistribution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::computeNodeDistribution </td>
          <td>(</td>
          <td class="paramtype">AO &amp;&#160;</td>
          <td class="paramname"><em>ao</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_lag_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nonlocal_lag_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_petsc_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nonlocal_petsc_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>num_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>node_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines the global Lagrangian and PETSc indices of the local and nonlocal nodes associated with the processor as well as the local PETSc indices of the interior and ghost nodes in each patch of the specified level.</p>
<dl class="section note"><dt>Note</dt><dd>The set of local Lagrangian indices lists all the nodes that are owned by this processor. The set of nonlocal Lagrangian indices lists all of the nodes that are not owned by this processor but that appear in the ghost cell region of some patch on this processor. Both of these sets of node indices use the fixed, global Lagrangian indexing scheme.</dd>
<dd>
The set of interior local indices lists the nodes that live on the interior on each patch. The set of ghost local indices lists the nodes that live in the ghost cell region of each patch. Both of these sets of node indices use the local PETSc indexing scheme, determined by the present distribution of data across the processors.</dd></dl>
<p>Since each processor may own multiple patches in a given level, nodes appearing in the ghost cell region of a patch may or may not be owned by this processor. </p>

</div>
</div>
<a id="a530a07cc82c75297f830725009a0429c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530a07cc82c75297f830725009a0429c">&#9670;&nbsp;</a></span>computeNodeOffsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IBTK::LDataManager::computeNodeOffsets </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>num_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>node_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_local_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine the number of local Lagrangian nodes on all MPI processes with rank less than the rank of the current MPI process. </p>

</div>
</div>
<a id="a28d62bee7a5276db371a3fadf0dcc65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d62bee7a5276db371a3fadf0dcc65b">&#9670;&nbsp;</a></span>getFromRestart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::LDataManager::getFromRestart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read object state from the restart file and initialize class data members. The database from which the restart data is read is determined by the object_name specified in the constructor.</p>
<p>Unrecoverable Errors:</p>
<ul>
<li>The database corresponding to object_name is not found in the restart file.</li>
<li>The class version number and restart version number do not match. </li>
</ul>

</div>
</div>
<a id="a5263bfe8622e41d1a2df35f9803a5ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5263bfe8622e41d1a2df35f9803a5ca1">&#9670;&nbsp;</a></span>getLevelDt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::getLevelDt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dt_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine time increment to advance data on level. The recompute_dt option specifies whether to compute the timestep using the current level data or to return the value stored by the time integrator. The default true setting means the timestep will be computed if no value is supplied. <br  />
</p>
<p>This routine is only when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="a9e4e8a35a6b5ab6ec7e14f040e718adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4e8a35a6b5ab6ec7e14f040e718adf">&#9670;&nbsp;</a></span>advanceLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::advanceLevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>first_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>last_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>regrid_advance</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance data on all patches on specified patch level from current time (current_time) to new time (new_time). This routine is called only during time-dependent regridding procedures, such as Richardson extrapolation. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. The boolean arguments are used to determine the state of the algorithm and the data when the advance routine is called. Note that this advance function is also used during normal time integration steps.</p>
<p>When this function is called, the level data required to begin the advance must be allocated and be defined appropriately. Typically, this is equivalent to what is needed to initialize a new level after regridding. Upon exiting this routine, both current and new data may exist on the level. This data is needed until level synchronization occurs, in general. Current and new data may be reset by calling the member function <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a97641642baa1b5c67749fada52b12341">resetTimeDependentData()</a>.</p>
<p>This routine is called from two different points within the Richardson exptrapolation process: to advance a temporary level that is coarser than the hierarchy level on which error estimation is performed, and to advance the hierarchy level itself. In the first case, the values of the boolean flags are:</p>
<ul>
<li><b>first_step</b> = true.</li>
<li><b>last_step</b> = true.</li>
<li><b>regrid_advance</b> = true.</li>
</ul>
<p>In the second case, the values of the boolean flags are:</p>
<ul>
<li><b>first_step</b> (when regridding during time integration sequence) = true when the level is not coarsest level to synchronize immediately before the regridding process; else, false. (when generating initial hierarchy construction) = true, even though there may be multiple advance steps.</li>
<li><b>last_step</b> = true when the advance is the last in the Richardson extrapolation step sequence; else false.</li>
<li><b>regrid_advance</b> = true. </li>
</ul>

</div>
</div>
<a id="a97641642baa1b5c67749fada52b12341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97641642baa1b5c67749fada52b12341">&#9670;&nbsp;</a></span>resetTimeDependentData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::resetTimeDependentData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>can_be_refined</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset time-dependent data storage for the specified patch level.</p>
<p>This routine only applies when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="af6f563618437d3a5231d35eb6937fcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f563618437d3a5231d35eb6937fcd1">&#9670;&nbsp;</a></span>resetDataToPreadvanceState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::resetDataToPreadvanceState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset data on the patch level by destroying all patch data other than that which is needed to initialize the solution on that level. In other words, this is the data needed to begin a time integration step on the level.</p>
<p>This routine is only when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="af8f31cfe38a0690a629fcbeb7ad89888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f31cfe38a0690a629fcbeb7ad89888">&#9670;&nbsp;</a></span>initializeLevelData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::initializeLevelData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>init_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>can_be_refined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>old_level</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1hier_1_1BasePatchLevel.html">hier::BasePatchLevel</a>&lt;DIM&gt;&#160;&gt;(NULL)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allocate_data</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize data on a new level after it is inserted into an AMR patch hierarchy by the gridding algorithm. The level number indicates that of the new level.</p>
<p>Generally, when data is set, it is interpolated from coarser levels in the hierarchy. If the old level pointer in the argument list is non-null, then data is copied from the old level to the new level on regions of intersection between those levels before interpolation occurs. In this case, the level number must match that of the old level. The specific operations that occur when initializing level data are determined by the particular solution methods in use; i.e., in the subclass of this abstract base class.</p>
<p>The boolean argument initial_time indicates whether the level is being introduced for the first time (i.e., at initialization time), or after some regrid process during the calculation beyond the initial hierarchy construction. This information is provided since the initialization of the data may be different in each of those circumstances. The can_be_refined boolean argument indicates whether the level is the finest allowable level in the hierarchy. </p>

</div>
</div>
<a id="a6f8d89482d4bdafc824307cc21c728c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8d89482d4bdafc824307cc21c728c9">&#9670;&nbsp;</a></span>resetHierarchyConfiguration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::resetHierarchyConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After hierarchy levels have changed and data has been initialized on the new levels, this routine can be used to reset any information needed by the solution method that is particular to the hierarchy configuration. For example, the solution procedure may cache communication schedules to amortize the cost of data movement on the AMR patch hierarchy. This function will be called by the gridding algorithm after the initialization occurs so that the algorithm-specific subclass can reset such things. Also, if the solution method must make the solution consistent across multiple levels after the hierarchy is changed, this process may be invoked by this routine. Of course the details of these processes are determined by the particular solution methods in use.</p>
<p>The level number arguments indicate the coarsest and finest levels in the current hierarchy configuration that have changed. It should be assumed that all intermediate levels have changed as well. </p>

</div>
</div>
<a id="ac201b9cd28087aa92f9c1370f147667a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac201b9cd28087aa92f9c1370f147667a">&#9670;&nbsp;</a></span>applyGradientDetector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::applyGradientDetector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>uses_richardson_extrapolation_too</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set integer tags to "one" in cells where refinement of the given level should occur according to some user-supplied gradient criteria. The double time argument is the regrid time. The integer "tag_index" argument is the patch descriptor index of the cell-centered integer tag array on each patch in the hierarchy. The boolean argument initial_time indicates whether the level is being subject to refinement at the initial simulation time. If it is false, then the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. Typically, this information is passed to the user's patch tagging routines since the error estimator or gradient detector may be different in each case.</p>
<p>The boolean uses_richardson_extrapolation_too is true when Richardson extrapolation error estimation is used in addition to the gradient detector, and false otherwise. This argument helps the user to manage multiple regridding criteria.</p>
<p>This routine is only when gradient detector is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="a81e5b7b5d98eaf7221b5088b0d12a2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e5b7b5d98eaf7221b5088b0d12a2a8">&#9670;&nbsp;</a></span>applyRichardsonExtrapolation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::applyRichardsonExtrapolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>deltat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>error_coarsen_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>uses_gradient_detector_too</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set integer tags to "one" in cells where refinement of the given level should occur according to some user-supplied Richardson extrapolation criteria. The "error_data_time" argument is the regrid time. The "deltat" argument is the time increment to advance the solution on the level to be refined. Note that that level is finer than the level in the argument list, in general. The ratio between the argument level and the actual hierarchy level is given by the integer "coarsen ratio".</p>
<p>The integer "tag_index" argument is the patch descriptor index of the cell-centered integer tag array on each patch in the hierarchy.</p>
<p>The boolean argument initial_time indicates whether the level is being subject to refinement at the initial simulation time. If it is false, then the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. Typically, this information is passed to the user's patch tagging routines since the application of the Richardson extrapolation process may be different in each case.</p>
<p>The boolean uses_gradient_detector_too is true when a gradient detector procedure is used in addition to Richardson extrapolation, and false otherwise. This argument helps the user to manage multiple regridding criteria.</p>
<p>This routine is only when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<a id="a9e3ec75cca71a27c6599a48ac6cd37ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3ec75cca71a27c6599a48ac6cd37ea">&#9670;&nbsp;</a></span>coarsenDataForRichardsonExtrapolation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a>&lt; DIM &gt;::coarsenDataForRichardsonExtrapolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>coarsen_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>before_advance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen solution data from level to coarse_level for Richardson extrapolation. Note that this routine will be called twice during the Richardson extrapolation error estimation process, once to set data on the coarser level and once to coarsen data from after advancing the fine level. The init_coarse_level boolean argument indicates whether data is set on the coarse level by coarsening the "old" time level solution or by coarsening the "new" solution on the fine level (i.e., after it has been advanced).</p>
<p>This routine is only when Richardson extrapolation is being used. It is virtual with an empty implementation here (rather than pure virtual) so that users are not required to provide an implementation when the function is not needed. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a359fffa7d2f68d6ec3ad02d7b8599b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359fffa7d2f68d6ec3ad02d7b8599b0d">&#9670;&nbsp;</a></span>POSN_DATA_NAME</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBTK::LDataManager::POSN_DATA_NAME</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The name of the <a class="el" href="classIBTK_1_1LData.html" title="Class LData provides storage for a single scalar- or vector-valued Lagrangian quantity.">LData</a> that specifies the current positions of the curvilinear mesh nodes. </p>

</div>
</div>
<a id="afd892b71bce2c9096c49efd80db288de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd892b71bce2c9096c49efd80db288de">&#9670;&nbsp;</a></span>INIT_POSN_DATA_NAME</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBTK::LDataManager::INIT_POSN_DATA_NAME</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The name of the <a class="el" href="classIBTK_1_1LData.html" title="Class LData provides storage for a single scalar- or vector-valued Lagrangian quantity.">LData</a> that specifies the initial positions of the curvilinear mesh nodes. </p>

</div>
</div>
<a id="a04e7f66b3437a4b69237fef346348ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e7f66b3437a4b69237fef346348ad6">&#9670;&nbsp;</a></span>VEL_DATA_NAME</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBTK::LDataManager::VEL_DATA_NAME</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The name of the <a class="el" href="classIBTK_1_1LData.html" title="Class LData provides storage for a single scalar- or vector-valued Lagrangian quantity.">LData</a> that specifies the velocities of the curvilinear mesh nodes. </p>

</div>
</div>
<a id="a9124254c2a86ec2502ac119f458ab86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9124254c2a86ec2502ac119f458ab86e">&#9670;&nbsp;</a></span>s_data_manager_instances</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="classIBTK_1_1LDataManager.html">LDataManager</a>*&gt; IBTK::LDataManager::s_data_manager_instances</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Static data members used to control access to and destruction of singleton data manager instance. </p>

</div>
</div>
<a id="aa3192dffb5755d186065840d172e536d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3192dffb5755d186065840d172e536d">&#9670;&nbsp;</a></span>s_registered_callback</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::LDataManager::s_registered_callback</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a18b3d296d579b0818bc84e826943b0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b3d296d579b0818bc84e826943b0e3">&#9670;&nbsp;</a></span>s_shutdown_priority</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char IBTK::LDataManager::s_shutdown_priority</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab653140910b0cebb049038ffd7b8db35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab653140910b0cebb049038ffd7b8db35">&#9670;&nbsp;</a></span>d_object_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string IBTK::LDataManager::d_object_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6b843ecae2ddd375cbc448e506813df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b843ecae2ddd375cbc448e506813df">&#9670;&nbsp;</a></span>d_registered_for_restart</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::LDataManager::d_registered_for_restart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6cda6867bfbfef1b224d94c3621c3e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cda6867bfbfef1b224d94c3621c3e36">&#9670;&nbsp;</a></span>d_hierarchy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt;NDIM&gt; &gt; IBTK::LDataManager::d_hierarchy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad05f28fdcba215b1f967994cd8f2efd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05f28fdcba215b1f967994cd8f2efd6">&#9670;&nbsp;</a></span>d_grid_geom</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html">SAMRAI::geom::CartesianGridGeometry</a>&lt;NDIM&gt; &gt; IBTK::LDataManager::d_grid_geom</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba4dbd10ad48a64e9342f9310653b545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4dbd10ad48a64e9342f9310653b545">&#9670;&nbsp;</a></span>d_coarsest_ln</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::LDataManager::d_coarsest_ln = <a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">IBTK::invalid_level_number</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1782228fde51b7cdf693b221545dd075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1782228fde51b7cdf693b221545dd075">&#9670;&nbsp;</a></span>d_finest_ln</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::LDataManager::d_finest_ln = <a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">IBTK::invalid_level_number</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c9506b6a32eac6a6aa52f4c9546e4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9506b6a32eac6a6aa52f4c9546e4db">&#9670;&nbsp;</a></span>d_cached_eulerian_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBTK_1_1SAMRAIDataCache.html">SAMRAIDataCache</a> IBTK::LDataManager::d_cached_eulerian_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c7786a5ce3ec6c5985c74010c290de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7786a5ce3ec6c5985c74010c290de8">&#9670;&nbsp;</a></span>d_visit_writer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">SAMRAI::appu::VisItDataWriter</a>&lt;NDIM&gt; &gt; IBTK::LDataManager::d_visit_writer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae244a2dfab9ec1dde9e21195b0d0fcfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae244a2dfab9ec1dde9e21195b0d0fcfb">&#9670;&nbsp;</a></span>d_silo_writer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LSiloDataWriter.html">LSiloDataWriter</a>&gt; IBTK::LDataManager::d_silo_writer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00c9854b10dff17017e6c4f905d5d8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c9854b10dff17017e6c4f905d5d8c1">&#9670;&nbsp;</a></span>d_load_balancer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalancer.html">SAMRAI::mesh::LoadBalancer</a>&lt;NDIM&gt; &gt; IBTK::LDataManager::d_load_balancer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a59777a6a1886d9fc2dc6cf85ffadbbd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59777a6a1886d9fc2dc6cf85ffadbbd0">&#9670;&nbsp;</a></span>d_lag_init</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LInitStrategy.html">LInitStrategy</a>&gt; IBTK::LDataManager::d_lag_init</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade37bd5e57213a7d02c82744ef737d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade37bd5e57213a7d02c82744ef737d18">&#9670;&nbsp;</a></span>d_level_contains_lag_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; IBTK::LDataManager::d_level_contains_lag_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aadce5c441cbc1665f5a6d04ef93c7664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadce5c441cbc1665f5a6d04ef93c7664">&#9670;&nbsp;</a></span>d_lag_node_index_var</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="namespaceIBTK.html#a9eb9f4aa1a24bc680e2744c833f6d439">LNodeSetVariable</a>&gt; IBTK::LDataManager::d_lag_node_index_var</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a068c5f22578d3e16027741057cfd2662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068c5f22578d3e16027741057cfd2662">&#9670;&nbsp;</a></span>d_lag_node_index_current_idx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::LDataManager::d_lag_node_index_current_idx = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a29ae0878c883cdfb8fa566d211c1dd95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ae0878c883cdfb8fa566d211c1dd95">&#9670;&nbsp;</a></span>d_lag_node_index_scratch_idx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::LDataManager::d_lag_node_index_scratch_idx = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e8200e7385a751e538dcc36959e8ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8200e7385a751e538dcc36959e8ae4">&#9670;&nbsp;</a></span>d_local_and_ghost_nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;std::vector&lt;<a class="el" href="classIBTK_1_1LNode.html">LNode</a>&gt; &gt; &gt; IBTK::LDataManager::d_local_and_ghost_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a88df2e0f8c4ef9ebc7f26cd19c62330c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88df2e0f8c4ef9ebc7f26cd19c62330c">&#9670;&nbsp;</a></span>d_beta_work</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> IBTK::LDataManager::d_beta_work = 1.0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2ac407cf59ac270d26974d4d829c50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ac407cf59ac270d26974d4d829c50e">&#9670;&nbsp;</a></span>d_workload_var</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt;NDIM, <a class="el" href="classdouble.html">double</a>&gt; &gt; IBTK::LDataManager::d_workload_var</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e7453fec65010f7e124b3042563d59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7453fec65010f7e124b3042563d59f">&#9670;&nbsp;</a></span>d_workload_idx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::LDataManager::d_workload_idx = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6f194a3edbb5d331e705f2725c78bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f194a3edbb5d331e705f2725c78bc3">&#9670;&nbsp;</a></span>d_output_workload</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::LDataManager::d_output_workload = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a301ee0df9d1d3505e0d5cfa7362cd988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301ee0df9d1d3505e0d5cfa7362cd988">&#9670;&nbsp;</a></span>d_node_count_var</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt;NDIM, <a class="el" href="classdouble.html">double</a>&gt; &gt; IBTK::LDataManager::d_node_count_var</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3577b3c08eb0e68d85d646102d09fb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3577b3c08eb0e68d85d646102d09fb2d">&#9670;&nbsp;</a></span>d_node_count_idx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::LDataManager::d_node_count_idx = <a class="el" href="namespaceIBTK.html#a4beed89342258cb4b5e9bc9e8bc90aaf">IBTK::invalid_index</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aee80a81caca53c2dd5ba2104e5c239b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee80a81caca53c2dd5ba2104e5c239b8">&#9670;&nbsp;</a></span>d_output_node_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::LDataManager::d_output_node_count = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad91e6c5d9ab6832db4eef21c5252764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad91e6c5d9ab6832db4eef21c5252764">&#9670;&nbsp;</a></span>d_default_interp_kernel_fcn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBTK::LDataManager::d_default_interp_kernel_fcn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04366e28010d04cc517c1d35dd23f529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04366e28010d04cc517c1d35dd23f529">&#9670;&nbsp;</a></span>d_default_spread_kernel_fcn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string IBTK::LDataManager::d_default_spread_kernel_fcn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c9241574a7d7f9fcb07765592b6baf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9241574a7d7f9fcb07765592b6baf5">&#9670;&nbsp;</a></span>d_error_if_points_leave_domain</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::LDataManager::d_error_if_points_leave_domain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac610b13354619f0609930acce8db2aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac610b13354619f0609930acce8db2aab">&#9670;&nbsp;</a></span>d_ghost_width</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt;NDIM&gt; IBTK::LDataManager::d_ghost_width</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afcf852873987504a8d521f3d07153d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf852873987504a8d521f3d07153d64">&#9670;&nbsp;</a></span>d_lag_node_index_bdry_fill_alg</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a>&lt;NDIM&gt; &gt; IBTK::LDataManager::d_lag_node_index_bdry_fill_alg</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a669a8e5f56f4f9eb939877a6caab0591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669a8e5f56f4f9eb939877a6caab0591">&#9670;&nbsp;</a></span>d_lag_node_index_bdry_fill_scheds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;NDIM&gt; &gt; &gt; IBTK::LDataManager::d_lag_node_index_bdry_fill_scheds</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb932832634bc497dcbadf2238cfbd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb932832634bc497dcbadf2238cfbd20">&#9670;&nbsp;</a></span>d_node_count_coarsen_alg</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html">SAMRAI::xfer::CoarsenAlgorithm</a>&lt;NDIM&gt; &gt; IBTK::LDataManager::d_node_count_coarsen_alg</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad79dd3841550b13e798b3dba6d4719de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79dd3841550b13e798b3dba6d4719de">&#9670;&nbsp;</a></span>d_node_count_coarsen_scheds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a>&lt;NDIM&gt; &gt; &gt; IBTK::LDataManager::d_node_count_coarsen_scheds</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2254232cd8e4c67acebb635909b0fa44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2254232cd8e4c67acebb635909b0fa44">&#9670;&nbsp;</a></span>d_current_context</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">SAMRAI::hier::VariableContext</a>&gt; IBTK::LDataManager::d_current_context</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa047375ab5e3ae189d87f7a29a598f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa047375ab5e3ae189d87f7a29a598f93">&#9670;&nbsp;</a></span>d_scratch_context</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">SAMRAI::hier::VariableContext</a>&gt; IBTK::LDataManager::d_scratch_context</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cb1c9f0d19f445c7a9e48b9a6c971d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb1c9f0d19f445c7a9e48b9a6c971d6">&#9670;&nbsp;</a></span>d_current_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">SAMRAI::hier::ComponentSelector</a> IBTK::LDataManager::d_current_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82c3eeeb950064fce3dc5b385e77fe2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c3eeeb950064fce3dc5b385e77fe2d">&#9670;&nbsp;</a></span>d_scratch_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">SAMRAI::hier::ComponentSelector</a> IBTK::LDataManager::d_scratch_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebf6c11650f23f3222df3e49d9417871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf6c11650f23f3222df3e49d9417871">&#9670;&nbsp;</a></span>d_strct_name_to_strct_id_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::map&lt;std::string, <a class="el" href="classint.html">int</a>&gt; &gt; IBTK::LDataManager::d_strct_name_to_strct_id_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Information about the names and IDs of the various Lagrangian structures. </p>

</div>
</div>
<a id="aaa7748792790ef04505a581014637156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7748792790ef04505a581014637156">&#9670;&nbsp;</a></span>d_strct_id_to_strct_name_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::map&lt;<a class="el" href="classint.html">int</a>, std::string&gt; &gt; IBTK::LDataManager::d_strct_id_to_strct_name_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d21021e1a72ddeaab180e45840cc4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d21021e1a72ddeaab180e45840cc4da">&#9670;&nbsp;</a></span>d_strct_id_to_lag_idx_range_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::map&lt;<a class="el" href="classint.html">int</a>, std::pair&lt;<a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>&gt; &gt; &gt; IBTK::LDataManager::d_strct_id_to_lag_idx_range_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa48cd5ae71d90e254ddded3ae01a0824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48cd5ae71d90e254ddded3ae01a0824">&#9670;&nbsp;</a></span>d_last_lag_idx_to_strct_id_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::map&lt;<a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>&gt; &gt; IBTK::LDataManager::d_last_lag_idx_to_strct_id_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a830a0004c928f20ea502aeedfb848cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830a0004c928f20ea502aeedfb848cd8">&#9670;&nbsp;</a></span>d_inactive_strcts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classIBTK_1_1ParallelSet.html">ParallelSet</a>&gt; IBTK::LDataManager::d_inactive_strcts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5f4b870f5e7f0ef42c7ab74e5961230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f4b870f5e7f0ef42c7ab74e5961230">&#9670;&nbsp;</a></span>d_displaced_strct_ids</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classint.html">int</a>&gt; &gt; IBTK::LDataManager::d_displaced_strct_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9f23d4a6f12a3dba5992d3ba6ce3636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f23d4a6f12a3dba5992d3ba6ce3636">&#9670;&nbsp;</a></span>d_displaced_strct_bounding_boxes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::pair&lt;<a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">Point</a>, <a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">Point</a>&gt; &gt; &gt; IBTK::LDataManager::d_displaced_strct_bounding_boxes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a53cddcc074181f550eeeddccbe27dc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cddcc074181f550eeeddccbe27dc84">&#9670;&nbsp;</a></span>d_displaced_strct_lnode_idxs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classIBTK_1_1LSet.html#abb10e33b689046edbf17966b00543509">LNodeSet::value_type</a>&gt; &gt; IBTK::LDataManager::d_displaced_strct_lnode_idxs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a625a61489b722f140400942568245bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625a61489b722f140400942568245bb3">&#9670;&nbsp;</a></span>d_displaced_strct_lnode_posns</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="namespaceIBTK.html#ac8c97469e791a47756eb44b9ec93c59e">Point</a>&gt; &gt; IBTK::LDataManager::d_displaced_strct_lnode_posns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a225719cf10ad4562988c0c1f3388e359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225719cf10ad4562988c0c1f3388e359">&#9670;&nbsp;</a></span>d_lag_mesh</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LMesh.html">LMesh</a>&gt; &gt; IBTK::LDataManager::d_lag_mesh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lagrangian mesh data. </p>

</div>
</div>
<a id="a8bd60d6d0aca62bce7f973cb7fdc0362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd60d6d0aca62bce7f973cb7fdc0362">&#9670;&nbsp;</a></span>d_lag_mesh_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::map&lt;std::string, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classIBTK_1_1LData.html">LData</a>&gt; &gt; &gt; IBTK::LDataManager::d_lag_mesh_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The Lagrangian mesh data owned by the manager object. </p>

</div>
</div>
<a id="a02c330e80c74f6c5401191da593514c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c330e80c74f6c5401191da593514c6">&#9670;&nbsp;</a></span>d_needs_synch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; IBTK::LDataManager::d_needs_synch</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates whether the <a class="el" href="classIBTK_1_1LData.html" title="Class LData provides storage for a single scalar- or vector-valued Lagrangian quantity.">LData</a> is in synch with the LNodeData. </p>

</div>
</div>
<a id="a0b4bc9edafae8c09fd48d39f76c7e3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4bc9edafae8c09fd48d39f76c7e3f2">&#9670;&nbsp;</a></span>d_ao</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;AO&gt; IBTK::LDataManager::d_ao</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>PETSc AO objects provide mappings between the fixed global Lagrangian node IDs and the ever-changing global PETSc ordering. </p>

</div>
</div>
<a id="ad3e17e86d8bee508a857a3d417b1d871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e17e86d8bee508a857a3d417b1d871">&#9670;&nbsp;</a></span>s_ao_dummy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classint.html">int</a>&gt; IBTK::LDataManager::s_ao_dummy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a771e5d7fe530941fe7a4b30d95a1f38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771e5d7fe530941fe7a4b30d95a1f38e">&#9670;&nbsp;</a></span>d_num_nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; IBTK::LDataManager::d_num_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The total number of nodes for all processors. </p>

</div>
</div>
<a id="a8e9f954fe78641c1f749a53d3ccbff63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9f954fe78641c1f749a53d3ccbff63">&#9670;&nbsp;</a></span>d_node_offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; IBTK::LDataManager::d_node_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The total number of local nodes for all processors with rank less than the rank of the current processor. </p>

</div>
</div>
<a id="a6e70f5eb586edf8d066e3b3c49177757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e70f5eb586edf8d066e3b3c49177757">&#9670;&nbsp;</a></span>d_local_lag_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classint.html">int</a>&gt; &gt; IBTK::LDataManager::d_local_lag_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The Lagrangian node indices of all local and nonlocal nodes on each level of the patch hierarchy.</p>
<p>A local node is one that is owned by a patch on this processor, while a nonlocal node is one that is owned by a patch on another processor, but found in the ghost region of some patch owned by this processor.</p>
<p>Note that these sets of indices provide the information necessary to determine the local PETSc index for all nodes. Local node d_local_lag_indices[ln][j] has local PETSc index j, while nonlocal node d_nonlocal_lag_indices[ln][k] has local PETSc index d_local_lag_indices.size()+j.</p>
<p>It is possible to determine the global PETSc index of a local node by making use of d_node_offset. Local node d_local_lag_indices[ln][j] has global PETSc index j+d_node_offset[ln]. A similar mapping for nonlocal nodes is not well defined. </p>

</div>
</div>
<a id="a3549f3871bdd0c8b976b258182651f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3549f3871bdd0c8b976b258182651f4a">&#9670;&nbsp;</a></span>d_nonlocal_lag_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classint.html">int</a>&gt; &gt; IBTK::LDataManager::d_nonlocal_lag_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8240ffbba000255374a8fbd525f00186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8240ffbba000255374a8fbd525f00186">&#9670;&nbsp;</a></span>d_local_petsc_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classint.html">int</a>&gt; &gt; IBTK::LDataManager::d_local_petsc_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The node indices of all local nodes (i.e. the nodes owned by this processor) on each level of the hierarchy. The indices are in the global PETSc ordering corresponding to a depth of 1. </p>

</div>
</div>
<a id="a8fc7743e2a0edf6effd960e9ecc4ae25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc7743e2a0edf6effd960e9ecc4ae25">&#9670;&nbsp;</a></span>d_nonlocal_petsc_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classint.html">int</a>&gt; &gt; IBTK::LDataManager::d_nonlocal_petsc_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The node indices of all nonlocal nodes (i.e. the nodes owned by another processor that appear in the ghost region of some patch owned by this processor) on each level of the hierarchy. The indices are in the global PETSc ordering corresponding to a depth of 1. </p>

</div>
</div>
<a id="a0360c3f8c54ea77f07cfab09030999f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0360c3f8c54ea77f07cfab09030999f5">&#9670;&nbsp;</a></span>d_user_defined_ldata</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="classint.html">int</a>&gt; IBTK::LDataManager::d_user_defined_ldata</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Container for additional user defined Lagrangian data </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ibtk/include/ibtk/<a class="el" href="LDataManager_8h.html">LDataManager.h</a></li>
<li>ibtk/include/ibtk/private/<a class="el" href="LDataManager-inl_8h.html">LDataManager-inl.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassIBTK_1_1LDataManager_html_adc080d94b9dfcd1b29831b62b6015db3"><div class="ttname"><a href="classIBTK_1_1LDataManager.html#adc080d94b9dfcd1b29831b62b6015db3">IBTK::LDataManager::LDataManager</a></div><div class="ttdeci">LDataManager()</div><div class="ttdoc">Default constructor.</div></div>
<div class="ttc" id="aIBTK__CHKERRQ_8h_html_a82134efd79614179ddc74839a56497ef"><div class="ttname"><a href="IBTK__CHKERRQ_8h.html#a82134efd79614179ddc74839a56497ef">IBTK_CHKERRQ</a></div><div class="ttdeci">#define IBTK_CHKERRQ(ierr)</div><div class="ttdoc">Throw an error exception from within any C++ source code.</div><div class="ttdef"><b>Definition:</b> IBTK_CHKERRQ.h:39</div></div>
<div class="ttc" id="aclasslibMesh_1_1Point_html"><div class="ttname"><a href="classlibMesh_1_1Point.html">Point</a></div></div>
<div class="ttc" id="anamespaceSAMRAI_1_1tbox_html_a1e98e73dc869d986f7ffe5b295075979"><div class="ttname"><a href="namespaceSAMRAI_1_1tbox.html#a1e98e73dc869d986f7ffe5b295075979">SAMRAI::tbox::pout</a></div><div class="ttdeci">std::ostream pout</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
