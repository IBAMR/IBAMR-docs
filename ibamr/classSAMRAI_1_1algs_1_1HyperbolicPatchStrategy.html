<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: SAMRAI::algs::HyperbolicPatchStrategy&lt; DIM &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IBAMR
   &#160;<span id="projectnumber">IBAMR version 0.19.</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a></li><li class="navelem"><a class="el" href="namespaceSAMRAI_1_1algs.html">algs</a></li><li class="navelem"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">HyperbolicPatchStrategy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SAMRAI::algs::HyperbolicPatchStrategy&lt; DIM &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;HyperbolicPatchStrategy.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SAMRAI::algs::HyperbolicPatchStrategy&lt; DIM &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy__inherit__graph.png" border="0" usemap="#SAMRAI_1_1algs_1_1HyperbolicPatchStrategy_3_01DIM_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="SAMRAI_1_1algs_1_1HyperbolicPatchStrategy_3_01DIM_01_4_inherit__map" id="SAMRAI_1_1algs_1_1HyperbolicPatchStrategy_3_01DIM_01_4_inherit__map">
<area shape="rect" title=" " alt="" coords="527,35,713,76"/>
<area shape="rect" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html" title=" " alt="" coords="832,35,1019,76"/>
<area shape="rect" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo..." alt="" coords="279,5,471,47"/>
<area shape="rect" href="classSAMRAI_1_1tbox_1_1DescribedClass.html" title="Base class for all objects that use run&#45;time type identification (RTTI)." alt="" coords="5,46,224,73"/>
<area shape="rect" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html" title="Class CoarsenPatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface f..." alt="" coords="273,71,477,112"/>
<area shape="rect" href="classIBAMR_1_1AdvectorPredictorCorrectorHyperbolicPatchOps.html" title="Class AdvectorPredictorCorrectorHyperbolicPatchOps is a concrete SAMRAI::algs::HyperbolicPatchStrateg..." alt="" coords="1068,35,1280,76"/>
<area shape="rect" href="classIBAMR_1_1AdvDiffPredictorCorrectorHyperbolicPatchOps.html" title="Class AdvDiffPredictorCorrectorHyperbolicPatchOps is a specialization of class AdvectorPredictorCorre..." alt="" coords="1329,35,1568,76"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a604e3058e146734865957562f7134e4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a604e3058e146734865957562f7134e4e">HyperbolicPatchStrategy</a> ()</td></tr>
<tr class="separator:a604e3058e146734865957562f7134e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13278752f44f714ce3dc206e3aa3de73"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a13278752f44f714ce3dc206e3aa3de73">~HyperbolicPatchStrategy</a> ()</td></tr>
<tr class="separator:a13278752f44f714ce3dc206e3aa3de73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bcb286ae7427f24b8bfa198715a59c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#af9bcb286ae7427f24b8bfa198715a59c">registerModelVariables</a> (<a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a>&lt; DIM &gt; *integrator)=0</td></tr>
<tr class="separator:af9bcb286ae7427f24b8bfa198715a59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cd9e86889424841e8cdeec2b597de8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#ad8cd9e86889424841e8cdeec2b597de8">setupLoadBalancer</a> (<a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a>&lt; DIM &gt; *integrator, <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a>&lt; DIM &gt; *gridding_algorithm)</td></tr>
<tr class="separator:ad8cd9e86889424841e8cdeec2b597de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b4a551e81ae8dba56d159ae976762d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a88b4a551e81ae8dba56d159ae976762d">initializeDataOnPatch</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;patch, const <a class="el" href="classdouble.html">double</a> data_time, const <a class="el" href="classbool.html">bool</a> initial_time)=0</td></tr>
<tr class="separator:a88b4a551e81ae8dba56d159ae976762d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda957878df1969dcc7119db26139c73"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#adda957878df1969dcc7119db26139c73">computeStableDtOnPatch</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;patch, const <a class="el" href="classbool.html">bool</a> initial_time, const <a class="el" href="classdouble.html">double</a> dt_time)=0</td></tr>
<tr class="separator:adda957878df1969dcc7119db26139c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c61114dfa91fcfc47c31ccde6944f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a96c61114dfa91fcfc47c31ccde6944f3">computeFluxesOnPatch</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;patch, const <a class="el" href="classdouble.html">double</a> time, const <a class="el" href="classdouble.html">double</a> dt)=0</td></tr>
<tr class="separator:a96c61114dfa91fcfc47c31ccde6944f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838a7f21aba2696cf2c9f6d8c703447d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a838a7f21aba2696cf2c9f6d8c703447d">conservativeDifferenceOnPatch</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;patch, const <a class="el" href="classdouble.html">double</a> time, const <a class="el" href="classdouble.html">double</a> dt, <a class="el" href="classbool.html">bool</a> at_syncronization)=0</td></tr>
<tr class="separator:a838a7f21aba2696cf2c9f6d8c703447d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdc6f473ab0c252950ad3efc23a7634"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#abfdc6f473ab0c252950ad3efc23a7634">preprocessAdvanceLevelState</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; &amp;level, <a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> dt, <a class="el" href="classbool.html">bool</a> first_step, <a class="el" href="classbool.html">bool</a> last_step, <a class="el" href="classbool.html">bool</a> regrid_advance)</td></tr>
<tr class="separator:abfdc6f473ab0c252950ad3efc23a7634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1883e669861b9570d0adb8e6fb0941"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a2d1883e669861b9570d0adb8e6fb0941">postprocessAdvanceLevelState</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; &amp;level, <a class="el" href="classdouble.html">double</a> current_time, <a class="el" href="classdouble.html">double</a> dt, <a class="el" href="classbool.html">bool</a> first_step, <a class="el" href="classbool.html">bool</a> last_step, <a class="el" href="classbool.html">bool</a> regrid_advance)</td></tr>
<tr class="separator:a2d1883e669861b9570d0adb8e6fb0941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e82758d953d417dcb394d93a4ff7fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a59e82758d953d417dcb394d93a4ff7fc">tagGradientDetectorCells</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;patch, const <a class="el" href="classdouble.html">double</a> regrid_time, const <a class="el" href="classbool.html">bool</a> initial_error, const <a class="el" href="classint.html">int</a> tag_index, const <a class="el" href="classbool.html">bool</a> uses_richardson_extrapolation_too)</td></tr>
<tr class="separator:a59e82758d953d417dcb394d93a4ff7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba5bd78b52617b89ef72791f1859e41"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#afba5bd78b52617b89ef72791f1859e41">tagRichardsonExtrapolationCells</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;patch, const <a class="el" href="classint.html">int</a> error_level_number, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt; coarsened_fine, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt; advanced_coarse, const <a class="el" href="classdouble.html">double</a> regrid_time, const <a class="el" href="classdouble.html">double</a> deltat, const <a class="el" href="classint.html">int</a> error_coarsen_ratio, const <a class="el" href="classbool.html">bool</a> initial_error, const <a class="el" href="classint.html">int</a> tag_index, const <a class="el" href="classbool.html">bool</a> uses_gradient_detector_too)</td></tr>
<tr class="separator:afba5bd78b52617b89ef72791f1859e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bd4bf254c841f4ac3f14d58ec51597"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a41bd4bf254c841f4ac3f14d58ec51597">setPhysicalBoundaryConditions</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;patch, const <a class="el" href="classdouble.html">double</a> fill_time, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ghost_width_to_fill)=0</td></tr>
<tr class="separator:a41bd4bf254c841f4ac3f14d58ec51597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31910907a77fbb19afe199cb947da024"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a31910907a77fbb19afe199cb947da024">getRefineOpStencilWidth</a> () const</td></tr>
<tr class="separator:a31910907a77fbb19afe199cb947da024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c097020c60c8976bc4d3a42f9dc15f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a40c097020c60c8976bc4d3a42f9dc15f">preprocessRefine</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;fine_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ratio)</td></tr>
<tr class="separator:a40c097020c60c8976bc4d3a42f9dc15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181018d92003feba894a4c851d424d3c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a181018d92003feba894a4c851d424d3c">postprocessRefine</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;fine_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ratio)</td></tr>
<tr class="separator:a181018d92003feba894a4c851d424d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302423cbfe5c3a0f2f5494e8ec823fee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a302423cbfe5c3a0f2f5494e8ec823fee">getCoarsenOpStencilWidth</a> () const</td></tr>
<tr class="separator:a302423cbfe5c3a0f2f5494e8ec823fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e571b2ad4d4e7f431f3f12a0a61381"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a37e571b2ad4d4e7f431f3f12a0a61381">preprocessCoarsen</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;coarse_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ratio)</td></tr>
<tr class="separator:a37e571b2ad4d4e7f431f3f12a0a61381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680d0e7114ac3ee308821fe5aa42af39"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a680d0e7114ac3ee308821fe5aa42af39">postprocessCoarsen</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;coarse_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ratio)</td></tr>
<tr class="separator:a680d0e7114ac3ee308821fe5aa42af39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9a4da0181ca5bacc4195ac6800b0e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a1e9a4da0181ca5bacc4195ac6800b0e0">getDataContext</a> () const</td></tr>
<tr class="separator:a1e9a4da0181ca5bacc4195ac6800b0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049ae90190f3d2be50aacbd4658467ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a049ae90190f3d2be50aacbd4658467ee">setDataContext</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt; context)</td></tr>
<tr class="separator:a049ae90190f3d2be50aacbd4658467ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0939649f2f49678cb846ccbc2482cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a1f0939649f2f49678cb846ccbc2482cd">clearDataContext</a> ()</td></tr>
<tr class="separator:a1f0939649f2f49678cb846ccbc2482cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133e4c3a0b27a9cf9e97ab4b5ec33111"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a133e4c3a0b27a9cf9e97ab4b5ec33111">preprocessRefineBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;fine_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ratio)</td></tr>
<tr class="separator:a133e4c3a0b27a9cf9e97ab4b5ec33111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f7581b8c4a5daf9997bbe6f579209d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#aa0f7581b8c4a5daf9997bbe6f579209d">postprocessRefineBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;fine_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ratio)</td></tr>
<tr class="separator:aa0f7581b8c4a5daf9997bbe6f579209d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af3968bf936b2f57b66585126c03b92ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#af3968bf936b2f57b66585126c03b92ae">d_data_context</a></td></tr>
<tr class="separator:af3968bf936b2f57b66585126c03b92ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int DIM&gt;<br />
class SAMRAI::algs::HyperbolicPatchStrategy&lt; DIM &gt;</h3>

<p>Class HyperbolicPatchStrategy&lt;DIM&gt; is an abstract base class defining the interface between an HyperbolicLevelIntegrator&lt;DIM&gt; object and operations applied to a single patch in a structured AMR hierarchy. The operations include patch initialization, dt calculation, flux computation, conservative differencing, and error estimation. This class is derived from the xfer::RefinePatchStrategy&lt;DIM&gt; and xfer::CoarsenPatchStrategy&lt;DIM&gt; abstract base classes. These base classes provide the interface for user-defined interlevel data refining and coarsening operations and the specification of physical boundary conditions. The functions <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a41bd4bf254c841f4ac3f14d58ec51597">setPhysicalBoundaryConditions()</a>, and pre/postprocessRefine() are overloaded from the class xfer::RefinePatchStrategy&lt;DIM&gt;. The operations pre/postprocessCoarsen() are overloaded from xfer::CoarsenPatchStrategy&lt;DIM&gt;. The pre/postprocessCoarsen/Refine() operations are given empty implementations here so that the user does not need to proovide them if the operations are not needed.</p>
<p>It is important to recognize that for the concrete patch strategy subclass and the HyperbolicLevelIntegrator&lt;DIM&gt; to work together, the concrete strategy must know which patch data to operate on. The patch data storage is manipulated by the level integrator. The set/clearDataContext() methods allow the integrator to inform the patch strategy of the correct data context. The concrete patch strategy subclass can access the appropriate context via the <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a1e9a4da0181ca5bacc4195ac6800b0e0">getDataContext()</a> method.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">algs::HyperbolicLevelIntegrator</a> </dd>
<dd>
<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo...">xfer::RefinePatchStrategy</a> </dd>
<dd>
<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html" title="Class CoarsenPatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface f...">xfer::CoarsenPatchStrategy</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a604e3058e146734865957562f7134e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604e3058e146734865957562f7134e4e">&#9670;&nbsp;</a></span>HyperbolicPatchStrategy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">HyperbolicPatchStrategy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blank constructor for HyperbolicPatchStrategy&lt;DIM&gt;. </p>

</div>
</div>
<a id="a13278752f44f714ce3dc206e3aa3de73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13278752f44f714ce3dc206e3aa3de73">&#9670;&nbsp;</a></span>~HyperbolicPatchStrategy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">HyperbolicPatchStrategy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual destructor for HyperbolicPatchStrategy&lt;DIM&gt;. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af9bcb286ae7427f24b8bfa198715a59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bcb286ae7427f24b8bfa198715a59c">&#9670;&nbsp;</a></span>registerModelVariables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::registerModelVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a>&lt; DIM &gt; *&#160;</td>
          <td class="paramname"><em>integrator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register specific variables needed in the numerical routines with the hyperbolic level integrator using the registerVariable() function in that class. The integrator manipulates storage for the data and this registration defines the way in which data for each quantity will be manipulated on the patches. Typically, the derived data quantities for plotting are registered with a visualization data writer in this routine as well, since the hyperbolic level integrator provides the variable context for plotting (i.e., which data is available when a plot file is generated). The integrator pointer cannot be null in most cases.</p>
<p>The gridding algorithm pointer is provided so that patch data objects may be registered with the load balancer object (owned by the gridding algorithm) for non-uniform load balancing, if needed. </p>

</div>
</div>
<a id="ad8cd9e86889424841e8cdeec2b597de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8cd9e86889424841e8cdeec2b597de8">&#9670;&nbsp;</a></span>setupLoadBalancer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::setupLoadBalancer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a>&lt; DIM &gt; *&#160;</td>
          <td class="paramname"><em>integrator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a>&lt; DIM &gt; *&#160;</td>
          <td class="paramname"><em>gridding_algorithm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set up parameters in the load balancer object (owned by the gridding algorithm) if needed. This function is called immediately after the <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#af9bcb286ae7427f24b8bfa198715a59c">registerModelVariables()</a> function is called. The hyperbolic level integrator pointer is provided so that the integrator can be used to manage data for the load balancer if needed (e.g., when using non-uniform load balancing).</p>
<p>Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. </p>

</div>
</div>
<a id="a88b4a551e81ae8dba56d159ae976762d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b4a551e81ae8dba56d159ae976762d">&#9670;&nbsp;</a></span>initializeDataOnPatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::initializeDataOnPatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the initial data on a patch interior only. Note that no ghost cells need to be set in this routine regardless of whether the patch data corresponding to the context requires ghost cells. The data_time is the simulation time when the routine is called. The boolean initial_time is true if the routine is called at the initial time when the hierarchy is initially constructed, otherwise it is false. </p>

</div>
</div>
<a id="adda957878df1969dcc7119db26139c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda957878df1969dcc7119db26139c73">&#9670;&nbsp;</a></span>computeStableDtOnPatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::computeStableDtOnPatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dt_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the stable time increment for a patch on the level with the given number. The boolean flag initial_time is true if the routine is called at the initial simulation time; otherwise it is false. The double argument dt_time is the simulation time. </p>

</div>
</div>
<a id="a96c61114dfa91fcfc47c31ccde6944f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c61114dfa91fcfc47c31ccde6944f3">&#9670;&nbsp;</a></span>computeFluxesOnPatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::computeFluxesOnPatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute TIME INTEGRALS of fluxes to be used in conservative difference for patch integration. That is, it is assumed that this numerical routine will compute the fluxes corresponding to the cell faces multiplied by the time increment. Typically, the numerical flux is the normal flux at the cell face. The flux integrals will be used in the conservative difference that updates the conserved quantities.</p>
<p>Note that the numerical routines in this method generally require ghost cells. Ghost cells data is filled before this routine is called. </p>

</div>
</div>
<a id="a838a7f21aba2696cf2c9f6d8c703447d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838a7f21aba2696cf2c9f6d8c703447d">&#9670;&nbsp;</a></span>conservativeDifferenceOnPatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::conservativeDifferenceOnPatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>at_syncronization</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update patch data with a conservative difference (approximating the divergence theorem) using the flux integrals computed in <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a96c61114dfa91fcfc47c31ccde6944f3">computeFluxesOnPatch()</a> routine. The boolean flag is true when this routine is called during a flux synchronization step. Otherwise, it is false. Note that the <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a96c61114dfa91fcfc47c31ccde6944f3">computeFluxesOnPatch()</a> routine computes TIME INTEGRALs of the numerical fluxes (e.g., they have been multiplied by dt). So the conservative difference routine should be consistent with this. </p>

</div>
</div>
<a id="abfdc6f473ab0c252950ad3efc23a7634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfdc6f473ab0c252950ad3efc23a7634">&#9670;&nbsp;</a></span>preprocessAdvanceLevelState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::preprocessAdvanceLevelState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>first_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>last_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>regrid_advance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an optional routine for user to process any application-specific patch strategy data BEFORE patches are advanced on the given level. This routine is called after patch boundary data is filled (i.e., ghosts) and before <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a96c61114dfa91fcfc47c31ccde6944f3">computeFluxesOnPatch()</a>. The arguments are: level &ndash; level that will be advanced, current_time &ndash; current integration time, dt &ndash; current time increment, first_step &ndash; boolean flag that is true if advance is first in time step sequence on level (i.e., previous advance step was on another level, false otherwise, last_step &ndash; boolean flag that is true if advance is last in time step sequence on level (i.e., synchronization with coarser level will occur immediately after this advance), regrid_advance &ndash; boolean flag that is true if the advance is during a regridding phase (i.e., the advance is not used to integrate data on the hierarchy) in which case the results of the advance will be discarded.</p>
<p>Note that when this routine is called, the scratch data is filled on all patches (i.e., ghost cells) and that data is the same as the current level data on all patch interiors. That is, both scratch and current data correspond to current_time.</p>
<p>Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. </p>

</div>
</div>
<a id="a2d1883e669861b9570d0adb8e6fb0941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1883e669861b9570d0adb8e6fb0941">&#9670;&nbsp;</a></span>postprocessAdvanceLevelState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::postprocessAdvanceLevelState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>first_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>last_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>regrid_advance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an optional routine for user to process any application-specific patch strategy data AFTER patches are advanced on the given level. This routine is called after <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a838a7f21aba2696cf2c9f6d8c703447d">conservativeDifferenceOnPatch()</a> is called and before <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#adda957878df1969dcc7119db26139c73">computeStableDtOnPatch()</a>. The arguments are: level &ndash; level that will be advanced, current_time &ndash; current integration time, dt &ndash; current time increment, first_step &ndash; boolean flag that is true if advance is first in time step sequence on level (i.e., previous advance step was on another level, false otherwise, last_step &ndash; boolean flag that is true if advance is last in time step sequence on level (i.e., synchronization with coarser level will occur immediately after this advance), regrid_advance &ndash; boolean flag that is true if the advance is during a regridding phase (i.e., the advance is not used to integrate data on the hierarchy) in which case the results of the advance will be discarded.</p>
<p>Note that when this routine is called, the scratch data is filled on all patches (i.e., ghost cells) and that data is the same as the new level data on all patch interiors. That is, both scratch and new data correspond to current_time + dt on patch interiors. <br  />
 The current data and ghost values correspond to the current_time.</p>
<p>Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. </p>

</div>
</div>
<a id="a59e82758d953d417dcb394d93a4ff7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e82758d953d417dcb394d93a4ff7fc">&#9670;&nbsp;</a></span>tagGradientDetectorCells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::tagGradientDetectorCells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>regrid_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>uses_richardson_extrapolation_too</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tag cells on the given patch that require refinement based on application-specific numerical quantities. The tag index argument indicates the index of the tag data on the patch data array. The boolean argument initial_error is true if tagging is being done at the initial simulation time; otherwise, it is false. The other boolean flag uses_richardson_extrapolation_too is true when Richardson extrapolation is used in addition to the gradient detector. This flag helps users manage multiple regridding criteria.</p>
<p>Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. </p>

</div>
</div>
<a id="afba5bd78b52617b89ef72791f1859e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba5bd78b52617b89ef72791f1859e41">&#9670;&nbsp;</a></span>tagRichardsonExtrapolationCells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::tagRichardsonExtrapolationCells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>error_level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt;&#160;</td>
          <td class="paramname"><em>coarsened_fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt;&#160;</td>
          <td class="paramname"><em>advanced_coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>regrid_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>deltat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>error_coarsen_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>uses_gradient_detector_too</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tag cells based from differences computed in the Richardson extrapolation. The Richardson extrapolation algorithm creates a coarsened version of some hierarchy patch level and advances data in time on both the coarsened patch level and the hierarchy level. This routine takes the data resulting from the advance on both the coarse and fine levels, compares them, and tags cells according to the difference. </p><pre class="fragment">*              (2)
*      n+1 ^-------&gt;x finish      (1) advanced_coarse
*          |        ^             (2) coarsened_fine
*  time  n -        |
*          ^        |(1)
*          |        |
*          &lt;--------o start
*        fine     coarse
* </pre><p>The patch supplied to this routine is on the coarsened level. However, the error_level_number corresponds to the actual hierarchy level from which it was coarsened. Data resides on this patch in two contexts - <code>advanced_coarse'' and</code>coarsened_fine''. Advanced coarse is data advanced on the coarsened version of the level, while coarsened fine is the data advanced on the fine level and then coarsened to the coarse level. The regrid time and the time increment are given for the actual hierarchy level. The error coarsen ratio argument is the ratio between the index spaces on the hierarchy level and the coarsened hierarchy level. The boolean flag `&lsquo;initial_error&rsquo;' is true when the error estimation is performed at the initial simulation time; i.e., when the hierarchy levels are being constructed for the first time. The tag index argument is the index of the tag data on the patch data array. The other boolean flag uses_gradient_detector_too is true when a gradient detector scheme is used in addition to Richardson extrapolation. This flag helps users manage multiple regridding criteria.</p>
<p>Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. </p>

</div>
</div>
<a id="a41bd4bf254c841f4ac3f14d58ec51597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bd4bf254c841f4ac3f14d58ec51597">&#9670;&nbsp;</a></span>setPhysicalBoundaryConditions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::setPhysicalBoundaryConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_width_to_fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set user-defined boundary conditions at the physical domain boundary. </p>

<p>Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#aece784dfaef6ec58bfbf678e68d2d2d3">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="a31910907a77fbb19afe199cb947da024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31910907a77fbb19afe199cb947da024">&#9670;&nbsp;</a></span>getRefineOpStencilWidth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;DIM&gt; <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::getRefineOpStencilWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return maximum stencil width needed for user-defined data interpolation operations. Default is to return zero, assuming no user-defined operations provided.</p>
<p>Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. </p>

<p>Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a92c93cfbcc150cd3ba647f510a102d17">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="a40c097020c60c8976bc4d3a42f9dc15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c097020c60c8976bc4d3a42f9dc15f">&#9670;&nbsp;</a></span>preprocessRefine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::preprocessRefine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pre- and post-processing routines for implementing user-defined spatial interpolation routines applied to variables. The interpolation routines are used in the hyperbolic AMR algorithm for filling patch ghost cells before advancing data on a level and after regridding a level to fill portions of the new level from some coarser level. These routines are called automatically from within patch boundary filling schedules; thus, some concrete function matching these signatures must be provided in the user's patch routines. However, the routines only need to perform some operations when "USER_DEFINED_REFINE" is given as the interpolation method for some variable when the patch routines register variables with the hyperbolic level integration algorithm, typically. If the user does not provide operations that refine such variables in either of these routines, then they will not be refined.</p>
<p>The order in which these operations are used in each patch boundary filling schedule is:</p>
<ul>
<li><b></b>(1) {Call user's <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a40c097020c60c8976bc4d3a42f9dc15f">preprocessRefine()</a> routine.}</li>
<li><b></b>(2) {Refine all variables with standard interpolation operators.}</li>
<li><b></b>(3) {Call user's <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a181018d92003feba894a4c851d424d3c">postprocessRefine()</a> routine.}</li>
</ul>
<p>Note that these functions are not pure virtual. They are given dummy implementations here so that users may ignore them when inheriting from this class. </p>

<p>Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a4e647ae59b0d7b45ac8e3e3072f69912">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="a181018d92003feba894a4c851d424d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181018d92003feba894a4c851d424d3c">&#9670;&nbsp;</a></span>postprocessRefine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::postprocessRefine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pure virtual function to perform user-defined postprocess data refine operations. This member function is called after standard refine operations (expressed using concrete subclasses of the RefineOperator&lt;DIM&gt; base class). The postprocess function must refine data from the scratch components of the coarse patch into the scratch components of the fine patch on the specified fine box region. Recall that the scratch components are specified in calls to the registerRefine() function in the RefineAlgorithm&lt;DIM&gt; class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fine</td><td>Fine patch containing destination data. </td></tr>
    <tr><td class="paramname">coarse</td><td>Coarse patch containing source data. </td></tr>
    <tr><td class="paramname">fine_box</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> region on fine patch into which data is refined. </td></tr>
    <tr><td class="paramname">ratio</td><td>Integer vector containing ratio relating index space between coarse and fine patches. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#aa8630858c8464794242a469bbcd48672">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="a302423cbfe5c3a0f2f5494e8ec823fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302423cbfe5c3a0f2f5494e8ec823fee">&#9670;&nbsp;</a></span>getCoarsenOpStencilWidth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;DIM&gt; <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::getCoarsenOpStencilWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return maximum stencil width needed for user-defined data coarsen operations. Default is to return zero, assuming no user-defined operations provided.</p>
<p>Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. </p>

<p>Implements <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html#ae384f7e8338fc150797d23bb5e1fdc68">SAMRAI::xfer::CoarsenPatchStrategy&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="a37e571b2ad4d4e7f431f3f12a0a61381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e571b2ad4d4e7f431f3f12a0a61381">&#9670;&nbsp;</a></span>preprocessCoarsen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::preprocessCoarsen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pre- and post-processing routines for implementing user-defined spatial coarsening routines applied to variables. The coarsening routines are used in the hyperbolic AMR algorithm synchronizing coarse and fine levels when they have been integrated to the same point. These routines are called automatically from within the data synchronization coarsen schedules; thus, some concrete function matching these signatures must be provided in the user's patch routines. However, the routines only need to perform some operations when "USER_DEFINED_COARSEN" is given as the coarsening method for some variable when the patch routines register variables with the hyperbolic level integration algorithm, typically. If the user does not provide operations that coarsen such variables in either of these routines, then they will not be coarsened.</p>
<p>The order in which these operations are used in each coarsening schedule is:</p>
<ul>
<li><b></b>(1) {Call user's <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a37e571b2ad4d4e7f431f3f12a0a61381">preprocessCoarsen()</a> routine.}</li>
<li><b></b>(2) {Coarsen all variables with standard coarsening operators.}</li>
<li><b></b>(3) {Call user's <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a680d0e7114ac3ee308821fe5aa42af39">postprocessCoarsen()</a> routine.}</li>
</ul>
<p>Note that these functions are not pure virtual. They are given dummy implementations here so that users may ignore them when inheriting from this class. </p>

<p>Implements <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html#a58f991252c5aff2f1b294cb367c78084">SAMRAI::xfer::CoarsenPatchStrategy&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="a680d0e7114ac3ee308821fe5aa42af39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680d0e7114ac3ee308821fe5aa42af39">&#9670;&nbsp;</a></span>postprocessCoarsen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::postprocessCoarsen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform user-defined coarsening operations. This member function is called after standard coarsening operations (expressed using concrete subclasses of the CoarsenOperator&lt;DIM&gt; base class). <br  />
 The postprocess function should move data from the source components on the fine patch into the source components on the coarse patch in the specified coarse box region. Recall that the source components are specified in calls to the registerCoarsen() function in the CoarsenAlgorithm&lt;DIM&gt; class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coarse</td><td>Coarse patch containing destination data. </td></tr>
    <tr><td class="paramname">fine</td><td>Fine patch containing source data. </td></tr>
    <tr><td class="paramname">coarse_box</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> region on coarse patch into which data is copied. </td></tr>
    <tr><td class="paramname">ratio</td><td>Integer vector containing ratio </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html#a09d0e805a42652dab3fe74933f9994df">SAMRAI::xfer::CoarsenPatchStrategy&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="a1e9a4da0181ca5bacc4195ac6800b0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9a4da0181ca5bacc4195ac6800b0e0">&#9670;&nbsp;</a></span>getDataContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a>&gt; <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::getDataContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return pointer to patch data context. </p>

</div>
</div>
<a id="a049ae90190f3d2be50aacbd4658467ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049ae90190f3d2be50aacbd4658467ee">&#9670;&nbsp;</a></span>setDataContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::setDataContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The hyperbolic integrator controls the context for the data to be used in the numerical routines implemented in the concrete patch strategy. The <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a049ae90190f3d2be50aacbd4658467ee">setDataContext()</a> allows the integrator to set the context for data on a patch on which to operate. </p>

</div>
</div>
<a id="a1f0939649f2f49678cb846ccbc2482cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0939649f2f49678cb846ccbc2482cd">&#9670;&nbsp;</a></span>clearDataContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::clearDataContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a1f0939649f2f49678cb846ccbc2482cd">clearDataContext()</a> routine resets the data context to be null. </p>

</div>
</div>
<a id="a133e4c3a0b27a9cf9e97ab4b5ec33111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133e4c3a0b27a9cf9e97ab4b5ec33111">&#9670;&nbsp;</a></span>preprocessRefineBoxes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a>&lt; DIM &gt;::preprocessRefineBoxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual function to perform user-defined refine operations. This member function is called before standard refining operations (expressed using concrete subclasses of the RefineOperator&lt;DIM&gt; base class). The preprocess function must refine data from the scratch components of the coarse patch into the scratch components of the fine patch on the specified fine box regions.</p>
<p>Typically, only the pure virtual members of this class are implemented in user-defined subclasses of this base class. This version of the preprocess function operates on an entire box list. By default, this version simply loops over the box list and calls the single-box version, which is a pure virtual function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fine</td><td>Fine patch containing destination data. </td></tr>
    <tr><td class="paramname">coarse</td><td>Coarse patch containing source data. </td></tr>
    <tr><td class="paramname">fine_boxes</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a> of box regions on fine patch into which data is refined. </td></tr>
    <tr><td class="paramname">ratio</td><td>Integer vector containing ratio relating index space between coarse and fine patches. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a49e017a4ae14333c19dd834a012adbaf">SAMRAI::solv::CartesianRobinBcHelper&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="aa0f7581b8c4a5daf9997bbe6f579209d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f7581b8c4a5daf9997bbe6f579209d">&#9670;&nbsp;</a></span>postprocessRefineBoxes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a>&lt; DIM &gt;::postprocessRefineBoxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual function to perform user-defined refine operations. This member function is called after standard refining operations (expressed using concrete subclasses of the RefineOperator&lt;DIM&gt; base class). The postprocess function must refine data from the scratch components of the coarse patch into the scratch components of the fine patch on the specified fine box regions.</p>
<p>Typically, only the pure virtual members of this class are implemented in user-defined subclasses of this base class. This version of the postprocess function operates on an entire box list. By default, this version simply loops over the box list and calls the single-box version, which is a pure virtual function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fine</td><td>Fine patch containing destination data. </td></tr>
    <tr><td class="paramname">coarse</td><td>Coarse patch containing source data. </td></tr>
    <tr><td class="paramname">fine_boxes</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a> of box regions on fine patch into which data is refined. </td></tr>
    <tr><td class="paramname">ratio</td><td>Integer vector containing ratio relating index space between coarse and fine patches. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#ac00d8c3c91de04862ba70c2bfd539075">SAMRAI::solv::CartesianRobinBcHelper&lt; DIM &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af3968bf936b2f57b66585126c03b92ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3968bf936b2f57b66585126c03b92ae">&#9670;&nbsp;</a></span>d_data_context</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a>&gt; <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a>&lt; DIM &gt;::d_data_context</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/samrai/include/<a class="el" href="HyperbolicPatchStrategy_8h.html">HyperbolicPatchStrategy.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
