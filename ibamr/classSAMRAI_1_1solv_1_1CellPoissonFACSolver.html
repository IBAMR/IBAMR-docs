<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: SAMRAI::solv::CellPoissonFACSolver&lt; DIM &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IBAMR
   &#160;<span id="projectnumber">IBAMR version 0.18.</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a></li><li class="navelem"><a class="el" href="namespaceSAMRAI_1_1solv.html">solv</a></li><li class="navelem"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">CellPoissonFACSolver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SAMRAI::solv::CellPoissonFACSolver&lt; DIM &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for solving scalar Poisson's equation on SAMR grid, wrapping up lower-level components (FAC cycling, Poisson equation operations and boundary conditions) in a single high-level interface.  
 <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#details">More...</a></p>

<p><code>#include &lt;CellPoissonFACSolver.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7daf699c06f69282279ea367c0690105"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a7daf699c06f69282279ea367c0690105">CellPoissonFACSolver</a> (const std::string &amp;object_name, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; database=<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;())</td></tr>
<tr class="memdesc:a7daf699c06f69282279ea367c0690105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a solver.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a7daf699c06f69282279ea367c0690105">More...</a><br /></td></tr>
<tr class="separator:a7daf699c06f69282279ea367c0690105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc01e13444a4d48a54d912841e15bc61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#abc01e13444a4d48a54d912841e15bc61">~CellPoissonFACSolver</a> ()</td></tr>
<tr class="memdesc:abc01e13444a4d48a54d912841e15bc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#abc01e13444a4d48a54d912841e15bc61">More...</a><br /></td></tr>
<tr class="separator:abc01e13444a4d48a54d912841e15bc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931c6f84231afadad697969f6f484449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a931c6f84231afadad697969f6f484449">enableLogging</a> (<a class="el" href="classbool.html">bool</a> logging)</td></tr>
<tr class="memdesc:a931c6f84231afadad697969f6f484449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable logging.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a931c6f84231afadad697969f6f484449">More...</a><br /></td></tr>
<tr class="separator:a931c6f84231afadad697969f6f484449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac843ba28e389a800fc42e80861c13bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#aac843ba28e389a800fc42e80861c13bb">solveSystem</a> (const <a class="el" href="classint.html">int</a> solution, const <a class="el" href="classint.html">int</a> rhs, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, <a class="el" href="classint.html">int</a> coarse_ln=-1, <a class="el" href="classint.html">int</a> fine_ln=-1)</td></tr>
<tr class="memdesc:aac843ba28e389a800fc42e80861c13bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve Poisson's equation, assuming an uninitialized solver state.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#aac843ba28e389a800fc42e80861c13bb">More...</a><br /></td></tr>
<tr class="separator:aac843ba28e389a800fc42e80861c13bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566d4d64d7eeec0d6e11029b85849867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a566d4d64d7eeec0d6e11029b85849867">solveSystem</a> (const <a class="el" href="classint.html">int</a> solution, const <a class="el" href="classint.html">int</a> rhs)</td></tr>
<tr class="memdesc:a566d4d64d7eeec0d6e11029b85849867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve Poisson's equation using the current solver state set by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a5ec5748569a7b696063d9988c0e485ee" title="Prepare the solver&#39;s internal state for solving.">initializeSolverState()</a>.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a566d4d64d7eeec0d6e11029b85849867">More...</a><br /></td></tr>
<tr class="separator:a566d4d64d7eeec0d6e11029b85849867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb00f7e223f0a76fc14da82bfd1e4c43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#adb00f7e223f0a76fc14da82bfd1e4c43">setBoundaries</a> (const std::string &amp;boundary_type, const <a class="el" href="classint.html">int</a> fluxes=-1, const <a class="el" href="classint.html">int</a> flags=-1, <a class="el" href="classint.html">int</a> *bdry_types=NULL)</td></tr>
<tr class="memdesc:adb00f7e223f0a76fc14da82bfd1e4c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the boundary conditions that are to be used at the physical domain boundary.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#adb00f7e223f0a76fc14da82bfd1e4c43">More...</a><br /></td></tr>
<tr class="separator:adb00f7e223f0a76fc14da82bfd1e4c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415f63a49f809fe3e1b7a30aae6a6dda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a415f63a49f809fe3e1b7a30aae6a6dda">setBcObject</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a>&lt; DIM &gt; *bc_object)</td></tr>
<tr class="memdesc:a415f63a49f809fe3e1b7a30aae6a6dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override internal implementation to set boundary condition coefficients with user-provided implementation.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a415f63a49f809fe3e1b7a30aae6a6dda">More...</a><br /></td></tr>
<tr class="separator:a415f63a49f809fe3e1b7a30aae6a6dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Specifying PDE parameters</div></td></tr>
<tr class="memitem:a59e06b634a6d6b79bd3b7f5c40ad0402"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a59e06b634a6d6b79bd3b7f5c40ad0402">setDPatchDataId</a> (<a class="el" href="classint.html">int</a> id)</td></tr>
<tr class="memdesc:a59e06b634a6d6b79bd3b7f5c40ad0402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the patch data index for variable D.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a59e06b634a6d6b79bd3b7f5c40ad0402">More...</a><br /></td></tr>
<tr class="separator:a59e06b634a6d6b79bd3b7f5c40ad0402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff8c6ef315c0aa0c1e45a77283d519d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a4ff8c6ef315c0aa0c1e45a77283d519d">setDConstant</a> (<a class="el" href="classdouble.html">double</a> scalar)</td></tr>
<tr class="memdesc:a4ff8c6ef315c0aa0c1e45a77283d519d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scalar value variable D.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a4ff8c6ef315c0aa0c1e45a77283d519d">More...</a><br /></td></tr>
<tr class="separator:a4ff8c6ef315c0aa0c1e45a77283d519d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad51a0ff5ea12d12c65a608c2352f0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a4ad51a0ff5ea12d12c65a608c2352f0f">setCPatchDataId</a> (<a class="el" href="classint.html">int</a> id)</td></tr>
<tr class="memdesc:a4ad51a0ff5ea12d12c65a608c2352f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scalar value variable C.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a4ad51a0ff5ea12d12c65a608c2352f0f">More...</a><br /></td></tr>
<tr class="separator:a4ad51a0ff5ea12d12c65a608c2352f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455143c9398eac7818c484215345d4af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a455143c9398eac7818c484215345d4af">setCConstant</a> (<a class="el" href="classdouble.html">double</a> scalar)</td></tr>
<tr class="memdesc:a455143c9398eac7818c484215345d4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the patch data index for variable C.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a455143c9398eac7818c484215345d4af">More...</a><br /></td></tr>
<tr class="separator:a455143c9398eac7818c484215345d4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4eae977ff41177ec8cf690dfa8e92b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a0d4eae977ff41177ec8cf690dfa8e92b">setCoarsestLevelSolverChoice</a> (const std::string &amp;choice)</td></tr>
<tr class="memdesc:a0d4eae977ff41177ec8cf690dfa8e92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set coarse level solver.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a0d4eae977ff41177ec8cf690dfa8e92b">More...</a><br /></td></tr>
<tr class="separator:a0d4eae977ff41177ec8cf690dfa8e92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315db4579c50fab9cbb81d1533714b40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a315db4579c50fab9cbb81d1533714b40">setCoarsestLevelSolverTolerance</a> (<a class="el" href="classdouble.html">double</a> tol)</td></tr>
<tr class="memdesc:a315db4579c50fab9cbb81d1533714b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set tolerance for coarse level solve.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a315db4579c50fab9cbb81d1533714b40">More...</a><br /></td></tr>
<tr class="separator:a315db4579c50fab9cbb81d1533714b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3d581947697df6643a41d7e5d5250a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a7e3d581947697df6643a41d7e5d5250a">setCoarsestLevelSolverMaxIterations</a> (<a class="el" href="classint.html">int</a> max_iterations)</td></tr>
<tr class="memdesc:a7e3d581947697df6643a41d7e5d5250a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set max iterations for coarse level solve.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a7e3d581947697df6643a41d7e5d5250a">More...</a><br /></td></tr>
<tr class="separator:a7e3d581947697df6643a41d7e5d5250a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb628677e3a79827deebe7f1b4d3a85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a8cb628677e3a79827deebe7f1b4d3a85">setCoarseFineDiscretization</a> (const std::string &amp;coarsefine_method)</td></tr>
<tr class="memdesc:a8cb628677e3a79827deebe7f1b4d3a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the coarse-fine boundary discretization method.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a8cb628677e3a79827deebe7f1b4d3a85">More...</a><br /></td></tr>
<tr class="separator:a8cb628677e3a79827deebe7f1b4d3a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5108e26c1d08517447ec9df60d04d11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#aa5108e26c1d08517447ec9df60d04d11">setProlongationMethod</a> (const std::string &amp;prolongation_method)</td></tr>
<tr class="memdesc:aa5108e26c1d08517447ec9df60d04d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the prolongation method.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#aa5108e26c1d08517447ec9df60d04d11">More...</a><br /></td></tr>
<tr class="separator:aa5108e26c1d08517447ec9df60d04d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc69a9279695499ee512fe8712d64c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#aadc69a9279695499ee512fe8712d64c3">setPresmoothingSweeps</a> (<a class="el" href="classint.html">int</a> num_pre_sweeps)</td></tr>
<tr class="memdesc:aadc69a9279695499ee512fe8712d64c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of pre-smoothing sweeps during FAC iteration process.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#aadc69a9279695499ee512fe8712d64c3">More...</a><br /></td></tr>
<tr class="separator:aadc69a9279695499ee512fe8712d64c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be4096775b7cef9dcb8fff94d1f373f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a9be4096775b7cef9dcb8fff94d1f373f">setPostsmoothingSweeps</a> (<a class="el" href="classint.html">int</a> num_post_sweeps)</td></tr>
<tr class="memdesc:a9be4096775b7cef9dcb8fff94d1f373f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of post-smoothing sweeps during FAC iteration process.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a9be4096775b7cef9dcb8fff94d1f373f">More...</a><br /></td></tr>
<tr class="separator:a9be4096775b7cef9dcb8fff94d1f373f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c06e1d0dd75e5af643b6101640591b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a76c06e1d0dd75e5af643b6101640591b">setMaxCycles</a> (<a class="el" href="classint.html">int</a> max_cycles)</td></tr>
<tr class="memdesc:a76c06e1d0dd75e5af643b6101640591b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the max number of iterations (cycles) to use per solve.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a76c06e1d0dd75e5af643b6101640591b">More...</a><br /></td></tr>
<tr class="separator:a76c06e1d0dd75e5af643b6101640591b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f51f7a64ea6fb0af0c99cadee5041aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a4f51f7a64ea6fb0af0c99cadee5041aa">setResidualTolerance</a> (<a class="el" href="classdouble.html">double</a> residual_tol)</td></tr>
<tr class="memdesc:a4f51f7a64ea6fb0af0c99cadee5041aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the residual tolerance for stopping.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a4f51f7a64ea6fb0af0c99cadee5041aa">More...</a><br /></td></tr>
<tr class="separator:a4f51f7a64ea6fb0af0c99cadee5041aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec5748569a7b696063d9988c0e485ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a5ec5748569a7b696063d9988c0e485ee">initializeSolverState</a> (const <a class="el" href="classint.html">int</a> solution, const <a class="el" href="classint.html">int</a> rhs, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> coarse_level=-1, const <a class="el" href="classint.html">int</a> fine_level=-1)</td></tr>
<tr class="memdesc:a5ec5748569a7b696063d9988c0e485ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the solver's internal state for solving.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a5ec5748569a7b696063d9988c0e485ee">More...</a><br /></td></tr>
<tr class="separator:a5ec5748569a7b696063d9988c0e485ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033abc256279a7a82a1072dc7237b729"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a033abc256279a7a82a1072dc7237b729">deallocateSolverState</a> ()</td></tr>
<tr class="memdesc:a033abc256279a7a82a1072dc7237b729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the solver's internal state data.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a033abc256279a7a82a1072dc7237b729">More...</a><br /></td></tr>
<tr class="separator:a033abc256279a7a82a1072dc7237b729"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions to get data on last solve.</h2></td></tr>
<tr class="memitem:a6f913114fe27e21cbb2905499990aebf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a6f913114fe27e21cbb2905499990aebf">d_object_name</a></td></tr>
<tr class="memdesc:a6f913114fe27e21cbb2905499990aebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object name.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a6f913114fe27e21cbb2905499990aebf">More...</a><br /></td></tr>
<tr class="separator:a6f913114fe27e21cbb2905499990aebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b3b35fdb670e0855dd9445d0eb3d92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1solv_1_1PoissonSpecifications.html">PoissonSpecifications</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#ae7b3b35fdb670e0855dd9445d0eb3d92">d_poisson_spec</a></td></tr>
<tr class="memdesc:ae7b3b35fdb670e0855dd9445d0eb3d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object holding the specifications of the Poisson equation.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#ae7b3b35fdb670e0855dd9445d0eb3d92">More...</a><br /></td></tr>
<tr class="separator:ae7b3b35fdb670e0855dd9445d0eb3d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70631fec6de7e8590b9a5f392e4a9adf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html">CellPoissonFACOps</a>&lt; DIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a70631fec6de7e8590b9a5f392e4a9adf">d_fac_ops</a></td></tr>
<tr class="memdesc:a70631fec6de7e8590b9a5f392e4a9adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">FAC operator implementation corresponding to cell-centered Poisson discretization.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a70631fec6de7e8590b9a5f392e4a9adf">More...</a><br /></td></tr>
<tr class="separator:a70631fec6de7e8590b9a5f392e4a9adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c3c3b2e47329b742d7ce55e6cfe6dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html">FACPreconditioner</a>&lt; DIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#ac1c3c3b2e47329b742d7ce55e6cfe6dc">d_fac_precond</a></td></tr>
<tr class="memdesc:ac1c3c3b2e47329b742d7ce55e6cfe6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">FAC preconditioner algorithm.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#ac1c3c3b2e47329b742d7ce55e6cfe6dc">More...</a><br /></td></tr>
<tr class="separator:ac1c3c3b2e47329b742d7ce55e6cfe6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472b0ce37cc7e453b6564ced16f9f1ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a>&lt; DIM &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a472b0ce37cc7e453b6564ced16f9f1ea">d_bc_object</a></td></tr>
<tr class="memdesc:a472b0ce37cc7e453b6564ced16f9f1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Robin bc object in use.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a472b0ce37cc7e453b6564ced16f9f1ea">More...</a><br /></td></tr>
<tr class="separator:a472b0ce37cc7e453b6564ced16f9f1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b25e0fac7979ab845ca1626cda67cec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1solv_1_1SimpleCellRobinBcCoefs.html">SimpleCellRobinBcCoefs</a>&lt; DIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a4b25e0fac7979ab845ca1626cda67cec">d_simple_bc</a></td></tr>
<tr class="separator:a4b25e0fac7979ab845ca1626cda67cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b6d9fdd33fa92036b24d04845960e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#ab1b6d9fdd33fa92036b24d04845960e5">d_hierarchy</a></td></tr>
<tr class="separator:ab1b6d9fdd33fa92036b24d04845960e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8f71b6af248469a90bdee3b263df47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a2b8f71b6af248469a90bdee3b263df47">d_ln_min</a></td></tr>
<tr class="separator:a2b8f71b6af248469a90bdee3b263df47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd1eb6c4a6df29d2dfcdda67adf734e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a0fd1eb6c4a6df29d2dfcdda67adf734e">d_ln_max</a></td></tr>
<tr class="separator:a0fd1eb6c4a6df29d2dfcdda67adf734e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb81a49882da25c84411b788c436b6f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#abb81a49882da25c84411b788c436b6f1">d_context</a></td></tr>
<tr class="memdesc:abb81a49882da25c84411b788c436b6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context for all internally maintained data.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#abb81a49882da25c84411b788c436b6f1">More...</a><br /></td></tr>
<tr class="separator:abb81a49882da25c84411b788c436b6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0275486bea707cd77493c4fca7dc2bda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a0275486bea707cd77493c4fca7dc2bda">d_uv</a></td></tr>
<tr class="separator:a0275486bea707cd77493c4fca7dc2bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60eecf79e5adf623b2de6b06a7b2f20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#ad60eecf79e5adf623b2de6b06a7b2f20">d_fv</a></td></tr>
<tr class="separator:ad60eecf79e5adf623b2de6b06a7b2f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c483950c321d2bb089b72a81cfcdeba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a7c483950c321d2bb089b72a81cfcdeba">d_solver_is_initialized</a></td></tr>
<tr class="separator:a7c483950c321d2bb089b72a81cfcdeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07325db0cd9252fe1cdc4be6f78b795"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#ae07325db0cd9252fe1cdc4be6f78b795">d_enable_logging</a></td></tr>
<tr class="separator:ae07325db0cd9252fe1cdc4be6f78b795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae008ed31ab44f935c8e7a9194fee46c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#ae008ed31ab44f935c8e7a9194fee46c2">s_weight_id</a></td></tr>
<tr class="separator:ae008ed31ab44f935c8e7a9194fee46c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5536ac4a0c1a9af80167dc1348b6b61c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a5536ac4a0c1a9af80167dc1348b6b61c">s_instance_counter</a></td></tr>
<tr class="separator:a5536ac4a0c1a9af80167dc1348b6b61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7faa66f88e870ef56c8fac6daaf8329f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a7faa66f88e870ef56c8fac6daaf8329f">getNumberOfIterations</a> () const</td></tr>
<tr class="memdesc:a7faa66f88e870ef56c8fac6daaf8329f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return FAC iteration count from last (or current if there is one) FAC iteration process.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a7faa66f88e870ef56c8fac6daaf8329f">More...</a><br /></td></tr>
<tr class="separator:a7faa66f88e870ef56c8fac6daaf8329f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64438cb8713efabfd3f943bb0cac4a1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a64438cb8713efabfd3f943bb0cac4a1d">getConvergenceFactors</a> (<a class="el" href="classdouble.html">double</a> &amp;avg_factor, <a class="el" href="classdouble.html">double</a> &amp;final_factor) const</td></tr>
<tr class="memdesc:a64438cb8713efabfd3f943bb0cac4a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get average convergance rate and convergence rate of the last (or current if there is one) FAC solve.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a64438cb8713efabfd3f943bb0cac4a1d">More...</a><br /></td></tr>
<tr class="separator:a64438cb8713efabfd3f943bb0cac4a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0ff0aeaf5192494a57f1c219bcf1ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a8a0ff0aeaf5192494a57f1c219bcf1ca">getResidualNorm</a> () const</td></tr>
<tr class="memdesc:a8a0ff0aeaf5192494a57f1c219bcf1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return residual norm from the just-completed FAC iteration.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a8a0ff0aeaf5192494a57f1c219bcf1ca">More...</a><br /></td></tr>
<tr class="separator:a8a0ff0aeaf5192494a57f1c219bcf1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d4acbb8bc63c41f60e6c7113392eb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a49d4acbb8bc63c41f60e6c7113392eb1">getFromInput</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; database)</td></tr>
<tr class="memdesc:a49d4acbb8bc63c41f60e6c7113392eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set state using database.  <a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a49d4acbb8bc63c41f60e6c7113392eb1">More...</a><br /></td></tr>
<tr class="separator:a49d4acbb8bc63c41f60e6c7113392eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af5463e42b10b3bd50fbf95719052c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a6af5463e42b10b3bd50fbf95719052c2">createVectorWrappers</a> (<a class="el" href="classint.html">int</a> u, <a class="el" href="classint.html">int</a> f)</td></tr>
<tr class="separator:a6af5463e42b10b3bd50fbf95719052c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cc47dbfb383d08f96d7868f9a46f1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#ac7cc47dbfb383d08f96d7868f9a46f1c">destroyVectorWrappers</a> ()</td></tr>
<tr class="separator:ac7cc47dbfb383d08f96d7868f9a46f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int DIM&gt;<br />
class SAMRAI::solv::CellPoissonFACSolver&lt; DIM &gt;</h3>

<p>Note: this class provides a backward-compatible interface to the soon-to-be obsolete PoissonHierarchySolver&lt;DIM&gt; class. Although this class hides the lower-level components (FAC cycling, Poisson equation operations and boundary conditions), it is perfectly acceptable to use those lower-level components directly.</p>
<p>We solve the equation div(D grad(u)) + Cu = f where D is a side-centered array and C is a cell-centered array. u and f are also cell-centered. Boundary conditions supported are Dirichlet, Neumann and mixed (Dirichlet on some faces and Neumann on others).</p>
<p>This class is a wrapper, providing a single class that coordinates three major components: the FAC solver, the cell-centered Poisson FAC operator and a default Robin bc coefficient implelemtation. It is perfectly acceptable to use those classes outside of this class.</p>
<p>The underlying solver is an FAC solver using cell-centered discretization. The difference scheme is second-order central-difference. On coarse-fine boundaries within the solution levels, the composite grid operator uses, by default, the discretization method of Ewing, Lazarov and Vassilevski ("Local Refinement Techniques for Elliptic Problems on
  Cell-Centered Grids, I. Error Analysis", Mathematics of Computation, Vol. 56, No. 194, April 1991, pp. 437-461).</p>
<p>Typical use of this class is:</p><ol type="1">
<li>Construct a CellPoissonFACSolver&lt;DIM&gt; object, providing it the hierarchy and range of levels participating in the solve.</li>
<li>Set the parameters C and D using the functions named <code>setC</code>... and <code>setD</code>... By default, D=1 and C=0 everywhere.</li>
<li>Call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#adb00f7e223f0a76fc14da82bfd1e4c43" title="Specify the boundary conditions that are to be used at the physical domain boundary.">setBoundaries()</a> to state the types boundary conditions, along with supplemental data for setting those boundary conditions.</li>
<li>Call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a5ec5748569a7b696063d9988c0e485ee" title="Prepare the solver&#39;s internal state for solving.">initializeSolverState()</a> to set up information internal to the solver. This is step is not required but will save setup costs if you are making multiple solves. This commits the object to the current hierarchy state and the specific <em>types</em> of boundary conditions you selected, It does NOT commit to the specific <em>values</em> of the boundary condition. A hierarchy change (through adaption or other means) invalidates the state, thus you must reinitialize or <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a033abc256279a7a82a1072dc7237b729" title="Remove the solver&#39;s internal state data.">deallocateSolverState()</a> the state before another solve.</li>
<li>Solve the equation with <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#aac843ba28e389a800fc42e80861c13bb" title="Solve Poisson&#39;s equation, assuming an uninitialized solver state.">solveSystem()</a>. You provide the patch data indices for the solution u and the right hand side f. u must have at least one ghost cell and where a Dirichlet boundary condition applies, those cells must be set to the value on the boundary. If only Neumann boundary conditions are used, the ghost cell values do not matter.</li>
<li>Call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a033abc256279a7a82a1072dc7237b729" title="Remove the solver&#39;s internal state data.">deallocateSolverState()</a> to free up internal resources, if <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a5ec5748569a7b696063d9988c0e485ee" title="Prepare the solver&#39;s internal state for solving.">initializeSolverState()</a> was called before the solve.</li>
</ol>
<p>After the solve, information on the solve can be obtained by calling one of these functions:</p><ul>
<li><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a7faa66f88e870ef56c8fac6daaf8329f" title="Return FAC iteration count from last (or current if there is one) FAC iteration process.">getNumberOfIterations()</a> gives the number of FAC cycles used.</li>
<li><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a64438cb8713efabfd3f943bb0cac4a1d" title="Get average convergance rate and convergence rate of the last (or current if there is one) FAC solve.">getConvergenceFactors()</a> gives the average and final convergence factors for the solve.</li>
<li><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a8a0ff0aeaf5192494a57f1c219bcf1ca" title="Return residual norm from the just-completed FAC iteration.">getResidualNorm()</a> gives the final residual</li>
</ul>
<p>Finer solver controls can be set using the functions in this class.</p>
<p>Object of this class can be set using input databases. The following parameters can be set. Each is shown with its default value in the case where hypre is used. </p><pre class="fragment">* enable_logging = TRUE // Bool flag to switch logging on/off
* max_cycles = 10       // Integer number of max FAC cycles to use
* residual_tol = 1.e-6  // Residual tolerance to solve for
* num_pre_sweeps = 1    // Number of presmoothing sweeps to use
* num_post_sweeps = 1   // Number of postsmoothing sweeps to use
* coarse_fine_discretization = "Ewing" // Name of coarse-fine discretization
* prolongation_method = "CONSTANT_REFINE" // Name of prolongation method
* coarse_solver_choice = "hypre"  // Name of coarse level solver
* coarse_solver_tolerance = 1e-10 // Coarse level tolerance
* coarse_solver_max_iterations = 20 // Coarse level max iterations
* use_smg = "FALSE"     // Whether to use hypre's smg solver
*                       // (alternative is the pfmg solver)
* </pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7daf699c06f69282279ea367c0690105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7daf699c06f69282279ea367c0690105">&#9670;&nbsp;</a></span>CellPoissonFACSolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">CellPoissonFACSolver</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&#160;</td>
          <td class="paramname"><em>database</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the database is not NULL, initial settings will be set using the database. The solver is uninitialized until <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a5ec5748569a7b696063d9988c0e485ee" title="Prepare the solver&#39;s internal state for solving.">initializeSolverState()</a> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object_name</td><td>Name of object used in outputs </td></tr>
    <tr><td class="paramname">database</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Database.html" title="Class Database is an abstract base class for the input, restart, and visualization databases.">tbox::Database</a> for initialization (may be NULL) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc01e13444a4d48a54d912841e15bc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc01e13444a4d48a54d912841e15bc61">&#9670;&nbsp;</a></span>~CellPoissonFACSolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">CellPoissonFACSolver</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a931c6f84231afadad697969f6f484449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931c6f84231afadad697969f6f484449">&#9670;&nbsp;</a></span>enableLogging()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::enableLogging </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>logging</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To disable, pass in <code>false</code>. </p>

</div>
</div>
<a id="aac843ba28e389a800fc42e80861c13bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac843ba28e389a800fc42e80861c13bb">&#9670;&nbsp;</a></span>solveSystem() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::solveSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarse_ln</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fine_ln</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Here, u is the "solution" patch data index and f is the right hand side patch data index. The return value is true if the solver converged and false otherwise.</p>
<p>This function is a wrapper. It simply initializes the solver state, call the <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a566d4d64d7eeec0d6e11029b85849867" title="Solve Poisson&#39;s equation using the current solver state set by initializeSolverState().">solveSystem(const int,const int)</a> for the initialized solver then deallocates the solver state.</p>
<p>Upon return from this function, solution will contain the result of the solve.</p>
<p>See <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a5ec5748569a7b696063d9988c0e485ee" title="Prepare the solver&#39;s internal state for solving.">initializeSolverState()</a> for opportunities to save overhead when using multiple consecutive solves.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a566d4d64d7eeec0d6e11029b85849867" title="Solve Poisson&#39;s equation using the current solver state set by initializeSolverState().">solveSystem(const int,const int)</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solution</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> data index for solution u </td></tr>
    <tr><td class="paramname">rhs</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> data index for right hand side f </td></tr>
    <tr><td class="paramname">hierarchy</td><td>The patch hierarchy to solve on </td></tr>
    <tr><td class="paramname">coarse_ln</td><td>The coarsest level in the solve. </td></tr>
    <tr><td class="paramname">fine_ln</td><td>The finest level in the solve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether solver converged to specified level</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a5ec5748569a7b696063d9988c0e485ee" title="Prepare the solver&#39;s internal state for solving.">initializeSolverState</a> </dd></dl>

</div>
</div>
<a id="a566d4d64d7eeec0d6e11029b85849867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566d4d64d7eeec0d6e11029b85849867">&#9670;&nbsp;</a></span>solveSystem() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::solveSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When the solver state has been initialized, this function may be called repeadedly with different values on the rhs. There is some cost savings for multiple solves when this is done.</p>
<p>Before calling this function, the solution and right-hand-side quantities should be set properly by the user on all patch interiors on the range of levels covered by the FAC iteration. All data for these patch data index should be allocated. Thus, the user is responsible for managing the storage for the solution and right-hand-side.</p>
<dl class="section return"><dt>Returns</dt><dd>whether solver converged to specified level</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#aac843ba28e389a800fc42e80861c13bb" title="Solve Poisson&#39;s equation, assuming an uninitialized solver state.">solveSystem( const int, const int, tbox::Pointer&lt; hier::PatchHierarchy&lt;DIM&gt; &gt;, int, int)</a>; </dd></dl>

</div>
</div>
<a id="adb00f7e223f0a76fc14da82bfd1e4c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb00f7e223f0a76fc14da82bfd1e4c43">&#9670;&nbsp;</a></span>setBoundaries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::setBoundaries </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>boundary_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fluxes</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a> *&#160;</td>
          <td class="paramname"><em>bdry_types</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is used to set up the default SimpleCellRobinBcCoefs&lt;DIM&gt; object for specifying boundary conditions. Note that you may alternatively provide your own implementation of the Robin boundary condition coefficients using the <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a415f63a49f809fe3e1b7a30aae6a6dda" title="Override internal implementation to set boundary condition coefficients with user-provided implementa...">setBcObject()</a> method.</p>
<p>The boundary conditions specified as the string argument "boundary_type." The boundary type argument can be "Dirichlet", "Neumann", or "Mixed".</p>
<p>If using Dirichlet boundary conditions, then before the solver is called, the storage for the unknown u must have a layer of ghost cells at least one cell wide that includes the Dirichlet boundary values.</p>
<p>If using Neumann boundary conditions, then before the solver is called, the outerface boundary flux data must be set for the Neumann conditions. The fluxes argument gives the patch data index of this flux data.</p>
<p>The mixed boundary type is for a mixture of Dirichlet and Neumann boundary conditions are used at the physical domain boundary. The fluxes argument gives the patch data index of the outerface data that specifies the flux data for the Neumann conditions. The flags array is an outerface data array of integer flags that specifies whether Dirichlet (flag == zero) or Neumann (flag == one) conditions are to be used at a particular cell boundary face. Note that the flag data must be set before the matrix entries can be computed and the flux data must be set before the solver is called. The bdry_types argument can be used if the boundary conditions are mixed but one or more of the faces of the physical boundary are entirely either Dirichlet or Neumann boundaries. The bdry_types argument should be an array of 2*DIM integers, specifying the boundary conditions on each side of the physical domain. It should be ordered {x_lo, x_hi, y_lo, y_hi, z_lo, z_hi}, with the values for each face being 0 for Dirichlet conditions, 1 for Neumann conditions, and 2 for mixed boundary conditions. The bdry_type argument is never required, but if used it can sometimes make the PoissonHYPRESolver class more efficient. </p>

</div>
</div>
<a id="a415f63a49f809fe3e1b7a30aae6a6dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415f63a49f809fe3e1b7a30aae6a6dda">&#9670;&nbsp;</a></span>setBcObject()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::setBcObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a>&lt; DIM &gt; *&#160;</td>
          <td class="paramname"><em>bc_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to override the default internal object for setting Robin boundary condition coefficients. You should override when you need to avoid the limitations of the SimpleCellRobinBcCoefs&lt;DIM&gt; class or you prefer to use your own implementation.</p>
<p>Note that an important limitation of the SimpleCellRobinBcCoefs&lt;DIM&gt; class is the inability to support linear interpolation in the prolongation step.</p>
<p>Once the boundary condition object is overwritten by this method, you must no longer call the <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#adb00f7e223f0a76fc14da82bfd1e4c43" title="Specify the boundary conditions that are to be used at the physical domain boundary.">setBoundaries()</a> method. </p>

</div>
</div>
<a id="a59e06b634a6d6b79bd3b7f5c40ad0402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e06b634a6d6b79bd3b7f5c40ad0402">&#9670;&nbsp;</a></span>setDPatchDataId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::setDPatchDataId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In addition, disregard any previous D specified by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a4ff8c6ef315c0aa0c1e45a77283d519d" title="Set the scalar value variable D.">setDConstant()</a>. </p>

</div>
</div>
<a id="a4ff8c6ef315c0aa0c1e45a77283d519d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff8c6ef315c0aa0c1e45a77283d519d">&#9670;&nbsp;</a></span>setDConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::setDConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In addition, disregard any previous D specified by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a59e06b634a6d6b79bd3b7f5c40ad0402" title="Set the patch data index for variable D.">setDPatchDataId()</a>. </p>

</div>
</div>
<a id="a4ad51a0ff5ea12d12c65a608c2352f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad51a0ff5ea12d12c65a608c2352f0f">&#9670;&nbsp;</a></span>setCPatchDataId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::setCPatchDataId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In addition, disregard any previous C specified by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a455143c9398eac7818c484215345d4af" title="Set the patch data index for variable C.">setCConstant()</a>. </p>

</div>
</div>
<a id="a455143c9398eac7818c484215345d4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455143c9398eac7818c484215345d4af">&#9670;&nbsp;</a></span>setCConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::setCConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In addition, disregard any previous C specified by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a455143c9398eac7818c484215345d4af" title="Set the patch data index for variable C.">setCConstant()</a>. </p>

</div>
</div>
<a id="a0d4eae977ff41177ec8cf690dfa8e92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4eae977ff41177ec8cf690dfa8e92b">&#9670;&nbsp;</a></span>setCoarsestLevelSolverChoice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::setCoarsestLevelSolverChoice </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>choice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select from these:</p><ul>
<li><code>"redblack"</code> </li>
<li><code>"hypre"</code> (only if the HYPRE library is available). </li>
</ul>

</div>
</div>
<a id="a315db4579c50fab9cbb81d1533714b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315db4579c50fab9cbb81d1533714b40">&#9670;&nbsp;</a></span>setCoarsestLevelSolverTolerance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::setCoarsestLevelSolverTolerance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the coarse level solver requires a tolerance (currently, they all do), the specified value is used. </p>

</div>
</div>
<a id="a7e3d581947697df6643a41d7e5d5250a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3d581947697df6643a41d7e5d5250a">&#9670;&nbsp;</a></span>setCoarsestLevelSolverMaxIterations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::setCoarsestLevelSolverMaxIterations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_iterations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the coarse level solver requires a max iteration limit (currently, they all do), the specified value is used. </p>

</div>
</div>
<a id="a8cb628677e3a79827deebe7f1b4d3a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb628677e3a79827deebe7f1b4d3a85">&#9670;&nbsp;</a></span>setCoarseFineDiscretization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::setCoarseFineDiscretization </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>coarsefine_method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify the <code>op_name</code> string which will be passed to <a class="el" href="classSAMRAI_1_1xfer_1_1Geometry.html#a919e9393894b37ef28652180d87cd6e3">xfer::Geometry&lt;DIM&gt;::lookupRefineOperator()</a> to get the operator for setting fine grid ghost cells from the coarse grid. Note that chosing this operator implicitly choses the discretization method at the coarse-fine boundary.</p>
<p>There is one important instance where this string is <em>not</em> passed to <a class="el" href="classSAMRAI_1_1xfer_1_1Geometry.html#a919e9393894b37ef28652180d87cd6e3">xfer::Geometry&lt;DIM&gt;::lookupRefineOperator()</a>. If this variable is set to "Ewing", a constant refinement method is used along with Ewing's correction. For a reference to the correction method, see "Local Refinement Techniques for Elliptic Problems on Cell-Centered
Grids, I. Error Analysis", Mathematics of Computation, Vol. 56, No. 194, April 1991, pp. 437-461.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coarsefine_method</td><td>String selecting the coarse-fine discretization method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5108e26c1d08517447ec9df60d04d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5108e26c1d08517447ec9df60d04d11">&#9670;&nbsp;</a></span>setProlongationMethod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::setProlongationMethod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prolongation_method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify the <code>op_name</code> string which will be passed to <a class="el" href="classSAMRAI_1_1xfer_1_1Geometry.html#a919e9393894b37ef28652180d87cd6e3">xfer::Geometry&lt;DIM&gt;::lookupRefineOperator()</a> to get the operator for prolonging the coarse-grid correction.</p>
<p>By default, "CONSTANT_REFINE" is used. "LINEAR_REFINE" seems to to lead to faster convergence, but it does NOT satisfy the Galerkin condition.</p>
<p>Prolonging using linear refinement requires a Robin bc coefficient implementation that is capable of delivering coefficients for non-hierarchy data, because linear refinement requires boundary conditions to be set on temporary levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prolongation_method</td><td>String selecting the coarse-fine discretization method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadc69a9279695499ee512fe8712d64c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc69a9279695499ee512fe8712d64c3">&#9670;&nbsp;</a></span>setPresmoothingSweeps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::setPresmoothingSweeps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_pre_sweeps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Presmoothing is applied during the fine-to-coarse phase of the iteration. The default is to use one sweep.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_pre_sweeps</td><td>Number of presmoothing sweeps </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9be4096775b7cef9dcb8fff94d1f373f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be4096775b7cef9dcb8fff94d1f373f">&#9670;&nbsp;</a></span>setPostsmoothingSweeps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::setPostsmoothingSweeps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_post_sweeps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Postsmoothing is applied during the coarse-to-fine phase of the iteration. The default is to use one sweep.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_post_sweeps</td><td>Number of postsmoothing sweeps </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76c06e1d0dd75e5af643b6101640591b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c06e1d0dd75e5af643b6101640591b">&#9670;&nbsp;</a></span>setMaxCycles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::setMaxCycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_cycles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f51f7a64ea6fb0af0c99cadee5041aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f51f7a64ea6fb0af0c99cadee5041aa">&#9670;&nbsp;</a></span>setResidualTolerance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::setResidualTolerance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>residual_tol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If you want the prescribed maximum number of cycles to always be taken, set the residual tolerance to a negative number. </p>

</div>
</div>
<a id="a5ec5748569a7b696063d9988c0e485ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec5748569a7b696063d9988c0e485ee">&#9670;&nbsp;</a></span>initializeSolverState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::initializeSolverState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarse_level</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fine_level</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In the interest of efficiency, this class may prepare and cache some hierarchy-dependent objects. Though it is not required, initializing the solver state makes for greater efficiency when you are doing multiple solves on the same system of equation. If you do not initialize the state, it is initialized and deallocated each time you call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a566d4d64d7eeec0d6e11029b85849867" title="Solve Poisson&#39;s equation using the current solver state set by initializeSolverState().">solveSystem(const int, const int)</a>. The state must be reinitialized if the hierarchy or a boundary condition type changes.</p>
<p>To unset the data set in this function, see <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a033abc256279a7a82a1072dc7237b729" title="Remove the solver&#39;s internal state data.">deallocateSolverState()</a>.</p>
<p>The <code>solution</code> and <code>rhs</code> patch data indices in the argument list are used to determine the <em>form</em> of the data you plan to use in the solve. They need not be the same data you solve on, but they should be similar. Both must represent cell-centered double data. The solution must have at least one ghost cell width, though this is not checked in the initialize phase, because data is not required yet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solution</td><td>solution patch data index for u </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side patch data index for f </td></tr>
    <tr><td class="paramname">hierarchy</td><td>The patch hierarchy to solve on </td></tr>
    <tr><td class="paramname">coarse_level</td><td>The coarsest level in the solve </td></tr>
    <tr><td class="paramname">fine_level</td><td>The finest level in the solve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a033abc256279a7a82a1072dc7237b729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033abc256279a7a82a1072dc7237b729">&#9670;&nbsp;</a></span>deallocateSolverState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::deallocateSolverState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all hierarchy-dependent data set by initializeSolverState. It is safe to call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a033abc256279a7a82a1072dc7237b729" title="Remove the solver&#39;s internal state data.">deallocateSolverState()</a> even state is already deallocated, but nothing is done in that case.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a5ec5748569a7b696063d9988c0e485ee" title="Prepare the solver&#39;s internal state for solving.">initializeSolverState()</a> </dd></dl>

</div>
</div>
<a id="a7faa66f88e870ef56c8fac6daaf8329f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7faa66f88e870ef56c8fac6daaf8329f">&#9670;&nbsp;</a></span>getNumberOfIterations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::getNumberOfIterations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64438cb8713efabfd3f943bb0cac4a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64438cb8713efabfd3f943bb0cac4a1d">&#9670;&nbsp;</a></span>getConvergenceFactors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::getConvergenceFactors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>avg_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>final_factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avg_factor</td><td>average convergence factor over current FAC cycles </td></tr>
    <tr><td class="paramname">final_factor</td><td>convergence factor of the last FAC cycle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a0ff0aeaf5192494a57f1c219bcf1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0ff0aeaf5192494a57f1c219bcf1ca">&#9670;&nbsp;</a></span>getResidualNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::getResidualNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The norm return value is computed as the maximum norm over all patch levels involved in the solve. The value corresponds to the norm applied in the user-defined residual computation.</p>
<p>The latest computed norm is the one returned. </p>

</div>
</div>
<a id="a49d4acbb8bc63c41f60e6c7113392eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d4acbb8bc63c41f60e6c7113392eb1">&#9670;&nbsp;</a></span>getFromInput()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::getFromInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&#160;</td>
          <td class="paramname"><em>database</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See the class description for the parameters that can be set from a database.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">database</td><td>Input database. If a NULL pointer is given, nothing is done. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6af5463e42b10b3bd50fbf95719052c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af5463e42b10b3bd50fbf95719052c2">&#9670;&nbsp;</a></span>createVectorWrappers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::createVectorWrappers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7cc47dbfb383d08f96d7868f9a46f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7cc47dbfb383d08f96d7868f9a46f1c">&#9670;&nbsp;</a></span>destroyVectorWrappers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::destroyVectorWrappers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6f913114fe27e21cbb2905499990aebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f913114fe27e21cbb2905499990aebf">&#9670;&nbsp;</a></span>d_object_name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::d_object_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7b3b35fdb670e0855dd9445d0eb3d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b3b35fdb670e0855dd9445d0eb3d92">&#9670;&nbsp;</a></span>d_poisson_spec</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1solv_1_1PoissonSpecifications.html">PoissonSpecifications</a> <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::d_poisson_spec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70631fec6de7e8590b9a5f392e4a9adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70631fec6de7e8590b9a5f392e4a9adf">&#9670;&nbsp;</a></span>d_fac_ops</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html">CellPoissonFACOps</a>&lt;DIM&gt; <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::d_fac_ops</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1c3c3b2e47329b742d7ce55e6cfe6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c3c3b2e47329b742d7ce55e6cfe6dc">&#9670;&nbsp;</a></span>d_fac_precond</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html">FACPreconditioner</a>&lt;DIM&gt; <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::d_fac_precond</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a472b0ce37cc7e453b6564ced16f9f1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472b0ce37cc7e453b6564ced16f9f1ea">&#9670;&nbsp;</a></span>d_bc_object</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a>&lt;DIM&gt;* <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::d_bc_object</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b25e0fac7979ab845ca1626cda67cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b25e0fac7979ab845ca1626cda67cec">&#9670;&nbsp;</a></span>d_simple_bc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1solv_1_1SimpleCellRobinBcCoefs.html">SimpleCellRobinBcCoefs</a>&lt;DIM&gt; <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::d_simple_bc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1b6d9fdd33fa92036b24d04845960e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b6d9fdd33fa92036b24d04845960e5">&#9670;&nbsp;</a></span>d_hierarchy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt;DIM&gt; &gt; <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::d_hierarchy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b8f71b6af248469a90bdee3b263df47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8f71b6af248469a90bdee3b263df47">&#9670;&nbsp;</a></span>d_ln_min</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::d_ln_min</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fd1eb6c4a6df29d2dfcdda67adf734e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd1eb6c4a6df29d2dfcdda67adf734e">&#9670;&nbsp;</a></span>d_ln_max</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::d_ln_max</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb81a49882da25c84411b788c436b6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb81a49882da25c84411b788c436b6f1">&#9670;&nbsp;</a></span>d_context</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a>&gt; <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::d_context</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0275486bea707cd77493c4fca7dc2bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0275486bea707cd77493c4fca7dc2bda">&#9670;&nbsp;</a></span>d_uv</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt;DIM,<a class="el" href="classdouble.html">double</a>&gt; &gt; <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::d_uv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad60eecf79e5adf623b2de6b06a7b2f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60eecf79e5adf623b2de6b06a7b2f20">&#9670;&nbsp;</a></span>d_fv</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt;DIM,<a class="el" href="classdouble.html">double</a>&gt; &gt; <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::d_fv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c483950c321d2bb089b72a81cfcdeba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c483950c321d2bb089b72a81cfcdeba">&#9670;&nbsp;</a></span>d_solver_is_initialized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::d_solver_is_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae07325db0cd9252fe1cdc4be6f78b795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07325db0cd9252fe1cdc4be6f78b795">&#9670;&nbsp;</a></span>d_enable_logging</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::d_enable_logging</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae008ed31ab44f935c8e7a9194fee46c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae008ed31ab44f935c8e7a9194fee46c2">&#9670;&nbsp;</a></span>s_weight_id</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::s_weight_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5536ac4a0c1a9af80167dc1348b6b61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5536ac4a0c1a9af80167dc1348b6b61c">&#9670;&nbsp;</a></span>s_instance_counter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a>&lt; DIM &gt;::s_instance_counter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/samrai/include/<a class="el" href="CellPoissonFACSolver_8h.html">CellPoissonFACSolver.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
