<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: SAMRAI::appu::CartesianBoundaryUtilities2 Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IBAMR
   &#160;<span id="projectnumber">IBAMR version 0.19.</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a></li><li class="navelem"><a class="el" href="namespaceSAMRAI_1_1appu.html">appu</a></li><li class="navelem"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html">CartesianBoundaryUtilities2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SAMRAI::appu::CartesianBoundaryUtilities2 Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class <a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html" title="Class CartesianBoundaryUtilities2 is a utility class that simplifies the implementation of simple phy...">CartesianBoundaryUtilities2</a> is a utility class that simplifies the implementation of simple physical boundary data in 2 spatial dimensions. It contains routines for reading boundary data information from input files, applying those boundary conditions, and error checking boundary data. These routines apply to the case of cell-centered double data only. One may use all of these capabilities, or use the input reading, boundary setting, and error checking routines independently.  
 <a href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html#details">More...</a></p>

<p><code>#include &lt;CartesianBoundaryUtilities2.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae6c98f93c2f0d99e10eb6672c8093aa4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html#ae6c98f93c2f0d99e10eb6672c8093aa4">readBoundaryInput</a> (<a class="el" href="classSAMRAI_1_1appu_1_1BoundaryUtilityStrategy.html">BoundaryUtilityStrategy</a> *bdry_strategy, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; bdry_db, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;edge_conds, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;node_conds, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; 2 &gt; &amp;periodic)</td></tr>
<tr class="separator:ae6c98f93c2f0d99e10eb6672c8093aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c283dff7aece2318ebedc8af9ab3b06"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html#a2c283dff7aece2318ebedc8af9ab3b06">fillEdgeBoundaryData</a> (const std::string &amp;varname, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">pdat::CellData</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;vardata, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; 2 &gt; &amp;patch, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; 2 &gt; &amp;ghost_width_to_fill, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;bdry_edge_conds, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;bdry_edge_values)</td></tr>
<tr class="separator:a2c283dff7aece2318ebedc8af9ab3b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edf21d4d28fc7809766684e7298ef95"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html#a1edf21d4d28fc7809766684e7298ef95">fillNodeBoundaryData</a> (const std::string &amp;varname, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">pdat::CellData</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;vardata, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; 2 &gt; &amp;patch, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; 2 &gt; &amp;ghost_width_to_fill, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;bdry_node_conds, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;bdry_edge_values)</td></tr>
<tr class="separator:a1edf21d4d28fc7809766684e7298ef95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e4825f55b5a99ef142e4c311cb39da"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html#a87e4825f55b5a99ef142e4c311cb39da">getEdgeLocationForNodeBdry</a> (<a class="el" href="classint.html">int</a> node_loc, <a class="el" href="classint.html">int</a> node_btype)</td></tr>
<tr class="separator:a87e4825f55b5a99ef142e4c311cb39da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d94a4e7f4833e39c48117d583062f3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html#ac0d94a4e7f4833e39c48117d583062f3">checkBdryData</a> (const std::string &amp;varname, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; 2 &gt; &amp;patch, <a class="el" href="classint.html">int</a> data_id, <a class="el" href="classint.html">int</a> depth, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; 2 &gt; &amp;gcw_to_check, const <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a>&lt; 2 &gt; &amp;bbox, <a class="el" href="classint.html">int</a> bcase, <a class="el" href="classdouble.html">double</a> bstate)</td></tr>
<tr class="separator:ac0d94a4e7f4833e39c48117d583062f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:adec76226db8e89329b69f596bc703b09"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html#adec76226db8e89329b69f596bc703b09">read2dBdryEdges</a> (<a class="el" href="classSAMRAI_1_1appu_1_1BoundaryUtilityStrategy.html">BoundaryUtilityStrategy</a> *bdry_strategy, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; bdry_db, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;edge_conds, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; 2 &gt; &amp;periodic)</td></tr>
<tr class="separator:adec76226db8e89329b69f596bc703b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e09c2de4c73dab357e1b116bf7e9baf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html#a6e09c2de4c73dab357e1b116bf7e9baf">read2dBdryNodes</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; bdry_db, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;edge_conds, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;node_conds, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; 2 &gt; &amp;periodic)</td></tr>
<tr class="separator:a6e09c2de4c73dab357e1b116bf7e9baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca38d9f3a268047b6001601af612291"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html#a1ca38d9f3a268047b6001601af612291">get2dBdryDirectionCheckValues</a> (<a class="el" href="classint.html">int</a> &amp;idir, <a class="el" href="classint.html">int</a> &amp;offsign, <a class="el" href="classint.html">int</a> btype, <a class="el" href="classint.html">int</a> bloc, <a class="el" href="classint.html">int</a> bcase)</td></tr>
<tr class="separator:a1ca38d9f3a268047b6001601af612291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a3fd629b109e42020e3b7cdd80e5b2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html#aa8a3fd629b109e42020e3b7cdd80e5b2">stuff2dBdryFortConst</a> ()</td></tr>
<tr class="separator:aa8a3fd629b109e42020e3b7cdd80e5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a7f2d1c227743d0f80f69dee1ede2767c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html#a7f2d1c227743d0f80f69dee1ede2767c">s_fortran_constants_stuffed</a></td></tr>
<tr class="separator:a7f2d1c227743d0f80f69dee1ede2767c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>To use the boundary condition input reading capabilities, the format of the input file section containing the boundary information must be as described next. Boundary node and edge entries are only required for those that are not filled automatically when periodic conditions apply.</p>
<p>The boundary condition for edge "*" is provided in a section as follows:</p>
<pre class="fragment">*
*    boundary_edge_* {   
*       boundary_condition  = ...  // boundary condition string identifier
*       // Any problem-specific boundary data read by user routines 
*       // is placed here...
*    }
* 
* Allowable edge identifiers (i.e., values for "*") are:
*       xlo, xhi, ylo, yhi
* Supported edge boundary_condition strin values are: 
*       "FLOW", "REFLECT", "DIRICHLET", "NEUMANN" 
* 
* </pre><p>The boundary condition for node "*" is provided in a section as follows:</p>
<pre class="fragment">*
*    boundary_node_* {   
*       boundary_condition  = ...  // boundary condition string identifier
*    }
* 
* Allowable node identifiers (i.e., values for "*") are:
*       xlo_ylo, xhi_ylo, xlo_yhi, xhi_yhi
* Supported node boundary_condition string values are:  
*       "XFLOW", "YFLOW", 
*       "XREFLECT", "YREFLECT", 
*       "XDIRICHLET", "YDIRICHLET", 
*       "XNEUMANN", "YNEUMANN" 
*
* </pre><p>Note that node conditions must be consistent with adjacent edge conditions.</p>
<p>See the include file <a class="el" href="CartesianBoundaryDefines_8h.html">CartesianBoundaryDefines.h</a> for integer constant definitions that apply for the various boundary types, locations, and boundary conditions. If you choose to use the input reading capabilities only and write your own boundary condition routines in FORTRAN, you should note that the integer constants for the various boundary condition types and locations are automatically "stuffed" into FORTRAN common blocks. This avoids potential problems with inconsistencies between C++ and FORTRAN usage. Please see the FORTRAN include file cartbdryparams2d.i for details.</p>
<dl class="section see"><dt>See also</dt><dd>appu::BoundaryUtilityStrategy2 </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae6c98f93c2f0d99e10eb6672c8093aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c98f93c2f0d99e10eb6672c8093aa4">&#9670;&nbsp;</a></span>readBoundaryInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SAMRAI::appu::CartesianBoundaryUtilities2::readBoundaryInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1appu_1_1BoundaryUtilityStrategy.html">BoundaryUtilityStrategy</a> *&#160;</td>
          <td class="paramname"><em>bdry_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&#160;</td>
          <td class="paramname"><em>bdry_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>periodic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to read 2d boundary data from input database. The integer boundary condition types are placed in the integer arrays supplied by the caller (typically, the concrete <a class="el" href="classSAMRAI_1_1appu_1_1BoundaryUtilityStrategy.html" title="Class BoundaryUtilityStrategy is an abstract base class that declares an interface that allows applic...">BoundaryUtilityStrategy</a> object provided). When DIRICHLET or NEUMANN conditions are specified, control is passed to the <a class="el" href="classSAMRAI_1_1appu_1_1BoundaryUtilityStrategy.html" title="Class BoundaryUtilityStrategy is an abstract base class that declares an interface that allows applic...">BoundaryUtilityStrategy</a> to read the boundary state data specific to the problem.</p>
<p>Errors will be reported and the program will abort whenever necessary boundary condition information is missing in the input database, or when the data read in is either unknown or inconsistent. The periodic domain information is used to determine which boundary edge or node entries are not required from input. Error checking requires that node boundary conditions are consistent with those specified for the edges.</p>
<p>When assertion checking is active, assertions will result when any of the pointer arguments is null, or an array is passed in with the the wrong size. <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdry_strategy</td><td>user-defined object that reads DIRICHLET or NEUMANN conditions </td></tr>
    <tr><td class="paramname">bdry_db</td><td>input database containing all boundary data </td></tr>
    <tr><td class="paramname">edge_conds</td><td>array into which integer edge boundary condition types are read </td></tr>
    <tr><td class="paramname">node_conds</td><td>array into which integer node boundary condition types are read </td></tr>
    <tr><td class="paramname">periodic</td><td>integer vector specifying which coordinate directions are periodic (e.g., value returned from GridGeometry2::getPeriodicShift()) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c283dff7aece2318ebedc8af9ab3b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c283dff7aece2318ebedc8af9ab3b06">&#9670;&nbsp;</a></span>fillEdgeBoundaryData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SAMRAI::appu::CartesianBoundaryUtilities2::fillEdgeBoundaryData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">pdat::CellData</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vardata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_width_to_fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bdry_edge_conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bdry_edge_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to fill 2d edge boundary values for a patch.</p>
<p>When assertion checking is active, assertions will result when any of the pointer arguments is null, or an array is passed in with the the wrong size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varname</td><td>String name of variable (for error reporting). </td></tr>
    <tr><td class="paramname">vardata</td><td>Cell-centered patch data object to fill. </td></tr>
    <tr><td class="paramname">patch</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> on which data object lives. </td></tr>
    <tr><td class="paramname">ghost_width_to_fill</td><td>Width of ghost region to fill. </td></tr>
    <tr><td class="paramname">bdry_edge_conds</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of boundary condition types for patch edges. </td></tr>
    <tr><td class="paramname">bdry_edge_values</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of boundary values for patch edges. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1edf21d4d28fc7809766684e7298ef95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1edf21d4d28fc7809766684e7298ef95">&#9670;&nbsp;</a></span>fillNodeBoundaryData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SAMRAI::appu::CartesianBoundaryUtilities2::fillNodeBoundaryData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">pdat::CellData</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vardata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_width_to_fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bdry_node_conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bdry_edge_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to fill 2d node boundary values for a patch.</p>
<p>When assertion checking is active, assertions will result when any of the pointer arguments is null, or an array is passed in with the the wrong size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varname</td><td>String name of variable (for error reporting). </td></tr>
    <tr><td class="paramname">vardata</td><td>Cell-centered patch data object to fill. </td></tr>
    <tr><td class="paramname">patch</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> on which data object lives. </td></tr>
    <tr><td class="paramname">ghost_width_to_fill</td><td>Width of ghost region to fill. </td></tr>
    <tr><td class="paramname">bdry_node_conds</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of boundary condition types for patch nodes. </td></tr>
    <tr><td class="paramname">bdry_edge_values</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of boundary values for patch edges. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87e4825f55b5a99ef142e4c311cb39da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e4825f55b5a99ef142e4c311cb39da">&#9670;&nbsp;</a></span>getEdgeLocationForNodeBdry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classint.html">int</a> SAMRAI::appu::CartesianBoundaryUtilities2::getEdgeLocationForNodeBdry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>node_loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>node_btype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that returns the integer edge boundary location corresponding to the given node location and node boundary condition.</p>
<p>If the node boundary condition type or node location are unknown, or the boundary condition type is inconsistant with the node location an error results.</p>
<dl class="section return"><dt>Returns</dt><dd>Integer edge location for node location and boundary condition type.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_loc</td><td>Integer location for node. </td></tr>
    <tr><td class="paramname">node_btype</td><td>Integer boundary condition type for node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0d94a4e7f4833e39c48117d583062f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d94a4e7f4833e39c48117d583062f3">&#9670;&nbsp;</a></span>checkBdryData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classint.html">int</a> SAMRAI::appu::CartesianBoundaryUtilities2::checkBdryData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>data_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gcw_to_check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>bcase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>bstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to check 2d boundary data for a patch data quantity on a patch after it is set. A warning message will be sent to log file for each bad boundary value that is found. <br  />
</p>
<p>When assertion checking is active, assertions will result when any of the pointer arguments is null, or an array is passed in with the the wrong size.</p>
<dl class="section return"><dt>Returns</dt><dd>Integer number of bad boundary values found.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varname</td><td>String name of variable (for error reporting). </td></tr>
    <tr><td class="paramname">patch</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> on which data object lives. </td></tr>
    <tr><td class="paramname">data_id</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> data index for data on patch. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth index of patch data to check. </td></tr>
    <tr><td class="paramname">gcw_to_check</td><td>Width of ghost region to check. </td></tr>
    <tr><td class="paramname">bbox</td><td>Boundary box to check. </td></tr>
    <tr><td class="paramname">bcase</td><td>Boundary condition type for given edge or node. </td></tr>
    <tr><td class="paramname">bstate</td><td>Boundary value that applies in DIRICHLET or NEUMANN case. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adec76226db8e89329b69f596bc703b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec76226db8e89329b69f596bc703b09">&#9670;&nbsp;</a></span>read2dBdryEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SAMRAI::appu::CartesianBoundaryUtilities2::read2dBdryEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1appu_1_1BoundaryUtilityStrategy.html">BoundaryUtilityStrategy</a> *&#160;</td>
          <td class="paramname"><em>bdry_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&#160;</td>
          <td class="paramname"><em>bdry_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>periodic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e09c2de4c73dab357e1b116bf7e9baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e09c2de4c73dab357e1b116bf7e9baf">&#9670;&nbsp;</a></span>read2dBdryNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SAMRAI::appu::CartesianBoundaryUtilities2::read2dBdryNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&#160;</td>
          <td class="paramname"><em>bdry_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>periodic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ca38d9f3a268047b6001601af612291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca38d9f3a268047b6001601af612291">&#9670;&nbsp;</a></span>get2dBdryDirectionCheckValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SAMRAI::appu::CartesianBoundaryUtilities2::get2dBdryDirectionCheckValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>idir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>offsign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>btype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>bloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>bcase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8a3fd629b109e42020e3b7cdd80e5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a3fd629b109e42020e3b7cdd80e5b2">&#9670;&nbsp;</a></span>stuff2dBdryFortConst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SAMRAI::appu::CartesianBoundaryUtilities2::stuff2dBdryFortConst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7f2d1c227743d0f80f69dee1ede2767c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2d1c227743d0f80f69dee1ede2767c">&#9670;&nbsp;</a></span>s_fortran_constants_stuffed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> SAMRAI::appu::CartesianBoundaryUtilities2::s_fortran_constants_stuffed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/samrai/include/<a class="el" href="CartesianBoundaryUtilities2_8h.html">CartesianBoundaryUtilities2.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
