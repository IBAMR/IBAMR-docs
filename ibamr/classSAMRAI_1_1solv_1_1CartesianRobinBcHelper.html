<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: SAMRAI::solv::CartesianRobinBcHelper&lt; DIM &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IBAMR
   &#160;<span id="projectnumber">IBAMR version 0.19.</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a></li><li class="navelem"><a class="el" href="namespaceSAMRAI_1_1solv.html">solv</a></li><li class="navelem"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">CartesianRobinBcHelper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SAMRAI::solv::CartesianRobinBcHelper&lt; DIM &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Helper utility for setting Robin boundary conditions.  
 <a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#details">More...</a></p>

<p><code>#include &lt;CartesianRobinBcHelper.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SAMRAI::solv::CartesianRobinBcHelper&lt; DIM &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper__inherit__graph.png" border="0" usemap="#SAMRAI_1_1solv_1_1CartesianRobinBcHelper_3_01DIM_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="SAMRAI_1_1solv_1_1CartesianRobinBcHelper_3_01DIM_01_4_inherit__map" id="SAMRAI_1_1solv_1_1CartesianRobinBcHelper_3_01DIM_01_4_inherit__map">
<area shape="rect" title="Helper utility for setting Robin boundary conditions." alt="" coords="7,169,222,211"/>
<area shape="rect" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Class RefinePatchStrategy&lt;DIM&gt; is an abstract base class that defines a Strategy pattern interface fo..." alt="" coords="19,80,211,121"/>
<area shape="rect" href="classSAMRAI_1_1tbox_1_1DescribedClass.html" title="Base class for all objects that use run&#45;time type identification (RTTI)." alt="" coords="5,5,224,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aba70cb1071fb3d777042669fa749ab43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#aba70cb1071fb3d777042669fa749ab43">CartesianRobinBcHelper</a> (std::string object_name=std::string(), <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a>&lt; DIM &gt; *coef_strategy=NULL)</td></tr>
<tr class="memdesc:aba70cb1071fb3d777042669fa749ab43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using.  <a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#aba70cb1071fb3d777042669fa749ab43">More...</a><br /></td></tr>
<tr class="separator:aba70cb1071fb3d777042669fa749ab43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1c210efe0cccd168821cae5647d922"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a0e1c210efe0cccd168821cae5647d922">~CartesianRobinBcHelper</a> ()</td></tr>
<tr class="memdesc:a0e1c210efe0cccd168821cae5647d922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a0e1c210efe0cccd168821cae5647d922">More...</a><br /></td></tr>
<tr class="separator:a0e1c210efe0cccd168821cae5647d922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409f4c209f009948f531dc8aac1f6347"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a409f4c209f009948f531dc8aac1f6347">setPhysicalBoundaryConditions</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;patch, const <a class="el" href="classdouble.html">double</a> fill_time, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ghost_width_to_fill)</td></tr>
<tr class="separator:a409f4c209f009948f531dc8aac1f6347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209193916e9bd92221b0349e95b479e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a209193916e9bd92221b0349e95b479e7">getRefineOpStencilWidth</a> () const</td></tr>
<tr class="separator:a209193916e9bd92221b0349e95b479e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e017a4ae14333c19dd834a012adbaf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a49e017a4ae14333c19dd834a012adbaf">preprocessRefineBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;fine_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ratio)</td></tr>
<tr class="separator:a49e017a4ae14333c19dd834a012adbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99edcf4c598104c1789c37f0bef3975"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#ae99edcf4c598104c1789c37f0bef3975">preprocessRefine</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;fine_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ratio)</td></tr>
<tr class="separator:ae99edcf4c598104c1789c37f0bef3975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00d8c3c91de04862ba70c2bfd539075"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#ac00d8c3c91de04862ba70c2bfd539075">postprocessRefineBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;fine_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ratio)</td></tr>
<tr class="separator:ac00d8c3c91de04862ba70c2bfd539075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ba39c53817c303806349a4f6d12fe1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#aa8ba39c53817c303806349a4f6d12fe1">postprocessRefine</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;fine_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ratio)</td></tr>
<tr class="separator:aa8ba39c53817c303806349a4f6d12fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions to set boundary condition values</div></td></tr>
<tr class="memitem:a80dfcb9b03fe08eb9db83f0a7e5a2113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a80dfcb9b03fe08eb9db83f0a7e5a2113">setBoundaryValuesInCells</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;patch, const <a class="el" href="classdouble.html">double</a> fill_time, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ghost_width_to_fill, <a class="el" href="classint.html">int</a> target_data_id, <a class="el" href="classbool.html">bool</a> homogeneous_bc=false) const</td></tr>
<tr class="memdesc:a80dfcb9b03fe08eb9db83f0a7e5a2113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the physical boundary condition by setting the value of the first ghost cells.  <a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a80dfcb9b03fe08eb9db83f0a7e5a2113">More...</a><br /></td></tr>
<tr class="separator:a80dfcb9b03fe08eb9db83f0a7e5a2113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50f61332b8038c5f65e8e4d4ab55e0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#ac50f61332b8038c5f65e8e4d4ab55e0c">setBoundaryValuesInCells</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &amp;level, const <a class="el" href="classdouble.html">double</a> fill_time, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ghost_width_to_fill, <a class="el" href="classint.html">int</a> target_data_id, <a class="el" href="classbool.html">bool</a> homogeneous_bc=false) const</td></tr>
<tr class="memdesc:ac50f61332b8038c5f65e8e4d4ab55e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ghost cells for an entire level.  <a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#ac50f61332b8038c5f65e8e4d4ab55e0c">More...</a><br /></td></tr>
<tr class="separator:ac50f61332b8038c5f65e8e4d4ab55e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b0ddfb1e5eca90a1527510d38f4acd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#ae8b0ddfb1e5eca90a1527510d38f4acd">setBoundaryValuesAtNodes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;patch, const <a class="el" href="classdouble.html">double</a> fill_time, <a class="el" href="classint.html">int</a> target_data_id, <a class="el" href="classbool.html">bool</a> homogeneous_bc=false) const</td></tr>
<tr class="memdesc:ae8b0ddfb1e5eca90a1527510d38f4acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the physical boundary condition by setting the value of the boundary nodes.  <a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#ae8b0ddfb1e5eca90a1527510d38f4acd">More...</a><br /></td></tr>
<tr class="separator:ae8b0ddfb1e5eca90a1527510d38f4acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Ways to provide the Robin bc coefficients</h2></td></tr>
<tr class="memitem:a6f28e06429660dc710c109287ae7826f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a6f28e06429660dc710c109287ae7826f">d_object_name</a></td></tr>
<tr class="separator:a6f28e06429660dc710c109287ae7826f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca83ace8de3b667cee24af51b9e30d6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a>&lt; DIM &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#acca83ace8de3b667cee24af51b9e30d6">d_coef_strategy</a></td></tr>
<tr class="memdesc:acca83ace8de3b667cee24af51b9e30d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coefficient strategy giving a way to get to Robin bc coefficients.  <a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#acca83ace8de3b667cee24af51b9e30d6">More...</a><br /></td></tr>
<tr class="separator:acca83ace8de3b667cee24af51b9e30d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8926718a527598dce3738fd4e646c6af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a8926718a527598dce3738fd4e646c6af">d_target_data_id</a></td></tr>
<tr class="memdesc:a8926718a527598dce3738fd4e646c6af"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> of target patch data when filling ghosts.  <a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a8926718a527598dce3738fd4e646c6af">More...</a><br /></td></tr>
<tr class="separator:a8926718a527598dce3738fd4e646c6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7213f96cf8cb6ef9f31da9967d853fcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a7213f96cf8cb6ef9f31da9967d853fcb">d_homogeneous_bc</a></td></tr>
<tr class="memdesc:a7213f96cf8cb6ef9f31da9967d853fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to assumg g=0 when filling ghosts.  <a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a7213f96cf8cb6ef9f31da9967d853fcb">More...</a><br /></td></tr>
<tr class="separator:a7213f96cf8cb6ef9f31da9967d853fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23e1669d99799373ce941863dd20ca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Timer.html">tbox::Timer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#ac23e1669d99799373ce941863dd20ca7">t_set_boundary_values_in_cells</a></td></tr>
<tr class="memdesc:ac23e1669d99799373ce941863dd20ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timers for performance measurement.  <a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#ac23e1669d99799373ce941863dd20ca7">More...</a><br /></td></tr>
<tr class="separator:ac23e1669d99799373ce941863dd20ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5e229c1df3724456ef755f4eea415d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Timer.html">tbox::Timer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a0a5e229c1df3724456ef755f4eea415d">t_use_set_bc_coefs</a></td></tr>
<tr class="separator:a0a5e229c1df3724456ef755f4eea415d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58483cb4b5b7d9ecb64cb2900fb8dfef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a58483cb4b5b7d9ecb64cb2900fb8dfef">setCoefImplementation</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a>&lt; DIM &gt; *coef_strategy)</td></tr>
<tr class="memdesc:a58483cb4b5b7d9ecb64cb2900fb8dfef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an implementation of the RobinBcCoefStrategy&lt;DIM&gt; for determining the boundary coefficients.  <a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a58483cb4b5b7d9ecb64cb2900fb8dfef">More...</a><br /></td></tr>
<tr class="separator:a58483cb4b5b7d9ecb64cb2900fb8dfef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62af7d7bfac3f637222e8f3bdbb6908"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#aa62af7d7bfac3f637222e8f3bdbb6908">setTargetDataId</a> (<a class="el" href="classint.html">int</a> target_data_id)</td></tr>
<tr class="memdesc:aa62af7d7bfac3f637222e8f3bdbb6908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data id that should be filled when setting physical boundary conditions.  <a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#aa62af7d7bfac3f637222e8f3bdbb6908">More...</a><br /></td></tr>
<tr class="separator:aa62af7d7bfac3f637222e8f3bdbb6908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dc36d2c87520489c61123e6403fcf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#ae7dc36d2c87520489c61123e6403fcf9">setHomogeneousBc</a> (<a class="el" href="classbool.html">bool</a> homogeneous_bc)</td></tr>
<tr class="memdesc:ae7dc36d2c87520489c61123e6403fcf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether boundary filling should assume homogeneous conditions.  <a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#ae7dc36d2c87520489c61123e6403fcf9">More...</a><br /></td></tr>
<tr class="separator:ae7dc36d2c87520489c61123e6403fcf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ab030b8c9ce3f9bc8c1a906ee41fca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a>&lt; DIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#aa1ab030b8c9ce3f9bc8c1a906ee41fca">trimBoundaryBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a>&lt; DIM &gt; &amp;boundary_box, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;limit_box) const</td></tr>
<tr class="memdesc:aa1ab030b8c9ce3f9bc8c1a906ee41fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim a boundary box so that it does not stick out past a given box.  <a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#aa1ab030b8c9ce3f9bc8c1a906ee41fca">More...</a><br /></td></tr>
<tr class="separator:aa1ab030b8c9ce3f9bc8c1a906ee41fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d91ca438c99142e5f93c74b252f8f55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a1d91ca438c99142e5f93c74b252f8f55">makeNodeBoundaryBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a>&lt; DIM &gt; &amp;boundary_box) const</td></tr>
<tr class="memdesc:a1d91ca438c99142e5f93c74b252f8f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return box describing the index space of boundary nodes defined by a boundary box.  <a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a1d91ca438c99142e5f93c74b252f8f55">More...</a><br /></td></tr>
<tr class="separator:a1d91ca438c99142e5f93c74b252f8f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0ebf4fec14da513ae7db4f63b923b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a1f0ebf4fec14da513ae7db4f63b923b2">makeFaceBoundaryBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a>&lt; DIM &gt; &amp;boundary_box) const</td></tr>
<tr class="memdesc:a1f0ebf4fec14da513ae7db4f63b923b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return box describing the index space of faces defined by a boundary box.  <a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#a1f0ebf4fec14da513ae7db4f63b923b2">More...</a><br /></td></tr>
<tr class="separator:a1f0ebf4fec14da513ae7db4f63b923b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int DIM&gt;<br />
class SAMRAI::solv::CartesianRobinBcHelper&lt; DIM &gt;</h3>

<p>This class is intended as a helper for performing the tedious task of setting boundary values for scalar quantities for the general case of boundary conditions known as the Robin boundary condition.</p>
<p>It uses the Robin boundary condition coefficients specified by a RobinBcCoefStrategy&lt;DIM&gt; object to determine the boundary value to set. The exact value set depends on the allignment of the data and is derived from various discrete approximations of the Robin formula. This class currently supports cell-centered alignment and will support node-centered alignment in the future.</p>
<p>See RobinBcCoefStrategy&lt;DIM&gt; for the description of the Robin boundary condition.</p>
<p>This class inherits and implements virtual functions from xfer::RefinePatchStrategy&lt;DIM&gt; so it may be used to help create communication schedules if desired. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aba70cb1071fb3d777042669fa749ab43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba70cb1071fb3d777042669fa749ab43">&#9670;&nbsp;</a></span>CartesianRobinBcHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">CartesianRobinBcHelper</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>object_name</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a>&lt; DIM &gt; *&#160;</td>
          <td class="paramname"><em>coef_strategy</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requires a concrete implementation of RobinBcCoefStrategy&lt;DIM&gt;.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object_name</td><td>Name of the object, for general referencing. </td></tr>
    <tr><td class="paramname">coef_strategy</td><td>Coefficients strategy being helped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e1c210efe0cccd168821cae5647d922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1c210efe0cccd168821cae5647d922">&#9670;&nbsp;</a></span>~CartesianRobinBcHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">CartesianRobinBcHelper</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a409f4c209f009948f531dc8aac1f6347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409f4c209f009948f531dc8aac1f6347">&#9670;&nbsp;</a></span>setPhysicalBoundaryConditions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::setPhysicalBoundaryConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_width_to_fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pure virtual function to set data associated with the given list of patch data indices at patch boundaries that intersect the physical domain boundary. The specific boundary conditions are determined by the user. The patch data components set in this routine correspond to the "scratch" components specified in calls to the registerRefine() function in the RefineAlgorithm&lt;DIM&gt; class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> on which to fill boundary data. </td></tr>
    <tr><td class="paramname">fill_time</td><td>Double simulation time for boundary filling. </td></tr>
    <tr><td class="paramname">ghost_width_to_fill</td><td>Integer vector describing maximum ghost width to fill over all registered scratch components. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#aece784dfaef6ec58bfbf678e68d2d2d3">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="a209193916e9bd92221b0349e95b479e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209193916e9bd92221b0349e95b479e7">&#9670;&nbsp;</a></span>getRefineOpStencilWidth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;DIM&gt; <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::getRefineOpStencilWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pure virtual function to return maximum stencil width needed over user-defined data interpolation operations. This is needed to determine the correct interpolation data dependencies. </p>

<p>Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a92c93cfbcc150cd3ba647f510a102d17">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="a49e017a4ae14333c19dd834a012adbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e017a4ae14333c19dd834a012adbaf">&#9670;&nbsp;</a></span>preprocessRefineBoxes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::preprocessRefineBoxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual function to perform user-defined refine operations. This member function is called before standard refining operations (expressed using concrete subclasses of the RefineOperator&lt;DIM&gt; base class). The preprocess function must refine data from the scratch components of the coarse patch into the scratch components of the fine patch on the specified fine box regions.</p>
<p>Typically, only the pure virtual members of this class are implemented in user-defined subclasses of this base class. This version of the preprocess function operates on an entire box list. By default, this version simply loops over the box list and calls the single-box version, which is a pure virtual function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fine</td><td>Fine patch containing destination data. </td></tr>
    <tr><td class="paramname">coarse</td><td>Coarse patch containing source data. </td></tr>
    <tr><td class="paramname">fine_boxes</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a> of box regions on fine patch into which data is refined. </td></tr>
    <tr><td class="paramname">ratio</td><td>Integer vector containing ratio relating index space between coarse and fine patches. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a133e4c3a0b27a9cf9e97ab4b5ec33111">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="ae99edcf4c598104c1789c37f0bef3975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99edcf4c598104c1789c37f0bef3975">&#9670;&nbsp;</a></span>preprocessRefine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::preprocessRefine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pure virtual function to perform user-defined preprocess data refine operations. This member function is called before standard refine operations (expressed using concrete subclasses of the RefineOperator&lt;DIM&gt; base class). The preprocess function must refine data from the scratch components of the coarse patch into the scratch components of the fine patch on the specified fine box region. Recall that the scratch components are specified in calls to the registerRefine() function in the RefineAlgorithm&lt;DIM&gt; class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fine</td><td>Fine patch containing destination data. </td></tr>
    <tr><td class="paramname">coarse</td><td>Coarse patch containing source data. </td></tr>
    <tr><td class="paramname">fine_box</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> region on fine patch into which data is refined. </td></tr>
    <tr><td class="paramname">ratio</td><td>Integer vector containing ratio relating index space between coarse and fine patches. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a4e647ae59b0d7b45ac8e3e3072f69912">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="ac00d8c3c91de04862ba70c2bfd539075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00d8c3c91de04862ba70c2bfd539075">&#9670;&nbsp;</a></span>postprocessRefineBoxes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::postprocessRefineBoxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual function to perform user-defined refine operations. This member function is called after standard refining operations (expressed using concrete subclasses of the RefineOperator&lt;DIM&gt; base class). The postprocess function must refine data from the scratch components of the coarse patch into the scratch components of the fine patch on the specified fine box regions.</p>
<p>Typically, only the pure virtual members of this class are implemented in user-defined subclasses of this base class. This version of the postprocess function operates on an entire box list. By default, this version simply loops over the box list and calls the single-box version, which is a pure virtual function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fine</td><td>Fine patch containing destination data. </td></tr>
    <tr><td class="paramname">coarse</td><td>Coarse patch containing source data. </td></tr>
    <tr><td class="paramname">fine_boxes</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a> of box regions on fine patch into which data is refined. </td></tr>
    <tr><td class="paramname">ratio</td><td>Integer vector containing ratio relating index space between coarse and fine patches. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#aa0f7581b8c4a5daf9997bbe6f579209d">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="aa8ba39c53817c303806349a4f6d12fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ba39c53817c303806349a4f6d12fe1">&#9670;&nbsp;</a></span>postprocessRefine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::postprocessRefine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pure virtual function to perform user-defined postprocess data refine operations. This member function is called after standard refine operations (expressed using concrete subclasses of the RefineOperator&lt;DIM&gt; base class). The postprocess function must refine data from the scratch components of the coarse patch into the scratch components of the fine patch on the specified fine box region. Recall that the scratch components are specified in calls to the registerRefine() function in the RefineAlgorithm&lt;DIM&gt; class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fine</td><td>Fine patch containing destination data. </td></tr>
    <tr><td class="paramname">coarse</td><td>Coarse patch containing source data. </td></tr>
    <tr><td class="paramname">fine_box</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> region on fine patch into which data is refined. </td></tr>
    <tr><td class="paramname">ratio</td><td>Integer vector containing ratio relating index space between coarse and fine patches. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#aa8630858c8464794242a469bbcd48672">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="a80dfcb9b03fe08eb9db83f0a7e5a2113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dfcb9b03fe08eb9db83f0a7e5a2113">&#9670;&nbsp;</a></span>setBoundaryValuesInCells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::setBoundaryValuesInCells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_width_to_fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>target_data_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>homogeneous_bc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function has an interface similar to the virtual function <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#aece784dfaef6ec58bfbf678e68d2d2d3">xfer::RefinePatchStrategy&lt;DIM&gt;::setPhysicalBoundaryConditions()</a>, and it may be used to help implement that function, but it does not serve the same purpose. The primary differences are:</p><ol type="1">
<li>It specializes to cell-centered variables.</li>
<li>Only one ghost cell width is filled. Setting a Robin boundary condition for cell-centered quantities requires only one ghost cell to be set. (More ghost cells can be filled by continuing the linear distribution of data beyond the first cell, but that is not implemented at this time.)</li>
<li>User must specify the index of the data whose ghost cells need to be filled. This index is used to determine the variable for which to set the boundary coefficients and to get the data to be set.</li>
</ol>
<p>This function calls RobinBcStrategy::setBcCoefs() to get the coefficients, then it sets the values in the first ghost cell on the boundary.</p>
<p>To determine the value for the ghost cell, a <em>linear</em> approximation in the direction normal to the boundary is assumed. We write the following discrete approximations: </p><p class="formulaDsp">
\[ u_b = \frac{ u_i + u_o }{2} \]
</p>
 <p class="formulaDsp">
\[ [u_n]_b = \frac{ u_o - u_i }{h} \]
</p>
<p> where the subscript b stands for the the boundary, i stands for the first cell inside the boundary and o stands for the first cell outside the boundary and h is the grid spacing normal to the boundary. Applying this to the Robin formula gives </p><p class="formulaDsp">
\[ u_o = \frac{ h\gamma + u_i( \beta - \frac{h}{2} \alpha ) } { \beta + \frac{h}{2} \alpha } \]
</p>
<p> or equivalently </p><p class="formulaDsp">
\[ u_o = \frac{ hg + u_i (1-a(1+\frac{h}{2})) }{ 1-a(1-\frac{h}{2}) } \]
</p>
<p>After setting the edge (face in 3D) boundary conditions, linear approximations are used to set the boundary conditions of higher boundary types (nodes in 2D, edges and nodes in 3D).</p>
<p>In some cases, the calling function wants to set the boundary condition homogeneously, with g=0. This is useful in problems where the the solution of the homogeneous problem is required in solving the inhomogeneous problem. This function respects such requests specified through the argument <code>homogeneous_bc</code>. </p>

</div>
</div>
<a id="ac50f61332b8038c5f65e8e4d4ab55e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50f61332b8038c5f65e8e4d4ab55e0c">&#9670;&nbsp;</a></span>setBoundaryValuesInCells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::setBoundaryValuesInCells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_width_to_fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>target_data_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>homogeneous_bc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop through all patches on the given level and call setBoundaryValuesInCells(hier::Patch&lt;DIM&gt; &amp;patch, const double fill_time , const hier::IntVector&lt;DIM&gt; &amp;ghost_width_to_fill , int target_data_id , bool homogeneous_bc=false ) for each.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>PatchLevel on which to set boundary condition </td></tr>
    <tr><td class="paramname">fill_time</td><td>Solution time corresponding to filling </td></tr>
    <tr><td class="paramname">ghost_width_to_fill</td><td>Max ghost width requiring fill </td></tr>
    <tr><td class="paramname">target_data_id</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> data index of data to be set. This data must be a cell-centered double. </td></tr>
    <tr><td class="paramname">homogeneous_bc</td><td>Set a homogeneous boundary condition. This means g=0 for the boundary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8b0ddfb1e5eca90a1527510d38f4acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b0ddfb1e5eca90a1527510d38f4acd">&#9670;&nbsp;</a></span>setBoundaryValuesAtNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::setBoundaryValuesAtNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>target_data_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>homogeneous_bc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is not yet implemented!</p>
<p>There are some decisions that must be made before the implementation can be written.</p><ol type="1">
<li>Do we set the values on the boundary or one cell away from the boundary?</li>
<li>What is the discrete formulation we should use to compute the value to be set?</li>
</ol>
<p>This function has an interface similar to the virtual function <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#aece784dfaef6ec58bfbf678e68d2d2d3">xfer::RefinePatchStrategy&lt;DIM&gt;::setPhysicalBoundaryConditions()</a>, and it may be used to help implement that function, but it does not serve the same purpose. The primary differences are:</p><ol type="1">
<li>It specializes to node-centered variables.</li>
<li>User must specify the index of the data whose ghost cells need to be filled. This index is used to determine the variable for which to set the boundary coefficients and to get the data to be set.</li>
</ol>
<p>This function calls RobinBcStrategy::setBcCoefs() to get the coefficients, then it sets the values at the boundary nodes.</p>
<p>In some cases, the calling function wants to set the boundary condition homogeneously, with g=0. This is useful in problems where the the solution of the homogeneous problem is required to solving the inhomogeneous problem. This function respects such requests specified through the argument <code>homogeneous_bc</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> on which to set boundary condition </td></tr>
    <tr><td class="paramname">fill_time</td><td>Solution time corresponding to filling </td></tr>
    <tr><td class="paramname">target_data_id</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> data index of data to be set. </td></tr>
    <tr><td class="paramname">homogeneous_bc</td><td>Set a homogeneous boundary condition. This means g=0 for the boundary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58483cb4b5b7d9ecb64cb2900fb8dfef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58483cb4b5b7d9ecb64cb2900fb8dfef">&#9670;&nbsp;</a></span>setCoefImplementation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::setCoefImplementation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a>&lt; DIM &gt; *&#160;</td>
          <td class="paramname"><em>coef_strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide the implementation that can be used to set the Robin bc coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coef_strategy</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a> to a concrete inmplementation of the coefficient strategy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa62af7d7bfac3f637222e8f3bdbb6908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62af7d7bfac3f637222e8f3bdbb6908">&#9670;&nbsp;</a></span>setTargetDataId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::setTargetDataId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>target_data_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When setPhysicalBoundaryConditions is called, the data specified will be set. This information is required because the it is not passed in through the argument list of setPhysicalBounaryConditions. </p>

</div>
</div>
<a id="ae7dc36d2c87520489c61123e6403fcf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7dc36d2c87520489c61123e6403fcf9">&#9670;&nbsp;</a></span>setHomogeneousBc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::setHomogeneousBc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>homogeneous_bc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In certain circumstances, only the value of a is needed, while the value of g is temporarily not required and taken to be zero. (An example is in setting the boundary condition for error value in an iterative method.) In such cases, use this function to set a flag that will cause a null pointer to be given to setBcCoefs() to indicate that fact. </p>

</div>
</div>
<a id="aa1ab030b8c9ce3f9bc8c1a906ee41fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ab030b8c9ce3f9bc8c1a906ee41fca">&#9670;&nbsp;</a></span>trimBoundaryBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a>&lt;DIM&gt; <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::trimBoundaryBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>limit_box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Certain boundary-related operations occur on patch data that do not or cannot extend past the edgr or corner of a patch. This function is used to trim down the parts of the boundary box that extend past those points so that a suitable index range is achieved.</p>
<p>The boundary box trimmed must be of type 1 or 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundary_box</td><td>Boundary box to be trimmed. </td></tr>
    <tr><td class="paramname">limit_box</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> to not stick past</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New trimmed boundary box. </dd></dl>

</div>
</div>
<a id="a1d91ca438c99142e5f93c74b252f8f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d91ca438c99142e5f93c74b252f8f55">&#9670;&nbsp;</a></span>makeNodeBoundaryBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt;DIM&gt; <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::makeNodeBoundaryBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_box</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Define a box describing the indices of the nodes corresponding to the input boundary box. These nodes lie on the boundary itself.</p>
<p>The input boundary_box must be of type 1 (see <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html#abc4d134885c6b0362a3749c122938261">hier::BoundaryBox::getBoundaryType()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundary_box</td><td>input boundary box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a box to define the node indices corresponding to boundary_box </dd></dl>

</div>
</div>
<a id="a1f0ebf4fec14da513ae7db4f63b923b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0ebf4fec14da513ae7db4f63b923b2">&#9670;&nbsp;</a></span>makeFaceBoundaryBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt;DIM&gt; <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::makeFaceBoundaryBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_box</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Define a box describing the indices of the codimension 1 surface corresponding to the input boundary box.</p>
<p>The input boundary_box must be of type 1 (see <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html#abc4d134885c6b0362a3749c122938261">hier::BoundaryBox::getBoundaryType()</a>).</p>
<p>This is a utility function for working with the indices coresponding to a boundary box but coincide with the patch boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundary_box</td><td>input boundary box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a box to define the face indices corresponding to boundary_box </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6f28e06429660dc710c109287ae7826f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f28e06429660dc710c109287ae7826f">&#9670;&nbsp;</a></span>d_object_name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::d_object_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acca83ace8de3b667cee24af51b9e30d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca83ace8de3b667cee24af51b9e30d6">&#9670;&nbsp;</a></span>d_coef_strategy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a>&lt;DIM&gt;* <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::d_coef_strategy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8926718a527598dce3738fd4e646c6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8926718a527598dce3738fd4e646c6af">&#9670;&nbsp;</a></span>d_target_data_id</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::d_target_data_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7213f96cf8cb6ef9f31da9967d853fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7213f96cf8cb6ef9f31da9967d853fcb">&#9670;&nbsp;</a></span>d_homogeneous_bc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::d_homogeneous_bc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac23e1669d99799373ce941863dd20ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23e1669d99799373ce941863dd20ca7">&#9670;&nbsp;</a></span>t_set_boundary_values_in_cells</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Timer.html">tbox::Timer</a>&gt; <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::t_set_boundary_values_in_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a5e229c1df3724456ef755f4eea415d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5e229c1df3724456ef755f4eea415d">&#9670;&nbsp;</a></span>t_use_set_bc_coefs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Timer.html">tbox::Timer</a>&gt; <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a>&lt; DIM &gt;::t_use_set_bc_coefs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/samrai/include/<a class="el" href="CartesianRobinBcHelper_8h.html">CartesianRobinBcHelper.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
