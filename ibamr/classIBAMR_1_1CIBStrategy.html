<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: IBAMR::CIBStrategy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IBAMR
   &#160;<span id="projectnumber">IBAMR version 0.18.</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceIBAMR.html">IBAMR</a></li><li class="navelem"><a class="el" href="classIBAMR_1_1CIBStrategy.html">CIBStrategy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classIBAMR_1_1CIBStrategy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IBAMR::CIBStrategy Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class <a class="el" href="classIBAMR_1_1CIBStrategy.html" title="Class CIBStrategy is a lightweight abstract strategy class which provides support for constraint base...">CIBStrategy</a> is a lightweight abstract strategy class which provides support for constraint based IB methods for rigid bodies.  
</p>

<p><code>#include &lt;ibamr/CIBStrategy.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IBAMR::CIBStrategy:</div>
<div class="dyncontent">
<div class="center"><img src="classIBAMR_1_1CIBStrategy__inherit__graph.png" border="0" usemap="#IBAMR_1_1CIBStrategy_inherit__map" alt="Inheritance graph"/></div>
<map name="IBAMR_1_1CIBStrategy_inherit__map" id="IBAMR_1_1CIBStrategy_inherit__map">
<area shape="rect" title="Class CIBStrategy is a lightweight abstract strategy class which provides support for constraint base..." alt="" coords="39,80,190,107"/>
<area shape="rect" href="classIBAMR_1_1CIBMethod.html" title="Class CIBMethod is a concrete CIBStrategy and IBMethod class which implements the motion of rigid bod..." alt="" coords="43,155,187,181"/>
<area shape="rect" href="classSAMRAI_1_1tbox_1_1DescribedClass.html" title="Base class for all objects that use run&#45;time type identification (RTTI)." alt="" coords="5,5,224,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e705bfc074714dabd25ae9c8350dda2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a3e705bfc074714dabd25ae9c8350dda2">CIBStrategy</a> (const unsigned <a class="el" href="classint.html">int</a> parts)</td></tr>
<tr class="memdesc:a3e705bfc074714dabd25ae9c8350dda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class.  <a href="classIBAMR_1_1CIBStrategy.html#a3e705bfc074714dabd25ae9c8350dda2">More...</a><br /></td></tr>
<tr class="separator:a3e705bfc074714dabd25ae9c8350dda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6417d647f13082764b5c33eb6593fefc"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a6417d647f13082764b5c33eb6593fefc">~CIBStrategy</a> ()</td></tr>
<tr class="memdesc:a6417d647f13082764b5c33eb6593fefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the class.  <a href="classIBAMR_1_1CIBStrategy.html#a6417d647f13082764b5c33eb6593fefc">More...</a><br /></td></tr>
<tr class="separator:a6417d647f13082764b5c33eb6593fefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573493dce74f45976fb62db1c4102f17"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a573493dce74f45976fb62db1c4102f17">setConstraintForce</a> (Vec L, const <a class="el" href="classdouble.html">double</a> data_time, const <a class="el" href="classdouble.html">double</a> scale=1.0)=0</td></tr>
<tr class="memdesc:a573493dce74f45976fb62db1c4102f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the implementation class for sprading constraint force. In particular, set the constraint Lagrangian force in the internal data structure of the class.  <a href="classIBAMR_1_1CIBStrategy.html#a573493dce74f45976fb62db1c4102f17">More...</a><br /></td></tr>
<tr class="separator:a573493dce74f45976fb62db1c4102f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4682dd04b56f42e5fb3a12d1ed24efed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a4682dd04b56f42e5fb3a12d1ed24efed">getConstraintForce</a> (Vec *L, const <a class="el" href="classdouble.html">double</a> data_time)=0</td></tr>
<tr class="memdesc:a4682dd04b56f42e5fb3a12d1ed24efed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the constraint rigid body force at the specified time within the current time interval. Generally, the implementation class maintains and stores the constraint force. This routine is called by constraint solver to update the contraint force after the (converged) solution is obtained.  <a href="classIBAMR_1_1CIBStrategy.html#a4682dd04b56f42e5fb3a12d1ed24efed">More...</a><br /></td></tr>
<tr class="separator:a4682dd04b56f42e5fb3a12d1ed24efed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5dc4783ab0a540a8768403dfcd5eb1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#aba5dc4783ab0a540a8768403dfcd5eb1">getFreeRigidVelocities</a> (Vec *U, const <a class="el" href="classdouble.html">double</a> data_time)</td></tr>
<tr class="memdesc:aba5dc4783ab0a540a8768403dfcd5eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the free rigid velocities (DOFs) at the specified time within the current time interval. This routine is called by constraint solver to update the free rigid DOFs after the (converged) solution is obtained.  <a href="classIBAMR_1_1CIBStrategy.html#aba5dc4783ab0a540a8768403dfcd5eb1">More...</a><br /></td></tr>
<tr class="separator:aba5dc4783ab0a540a8768403dfcd5eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e6796cde1fa8582962ae1c0cc63012"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a82e6796cde1fa8582962ae1c0cc63012">getNetExternalForceTorque</a> (Vec *F, const <a class="el" href="classdouble.html">double</a> data_time)</td></tr>
<tr class="memdesc:a82e6796cde1fa8582962ae1c0cc63012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get net external force and torque at the specified time within the current time interval. This routine is called by constraint solver to form the appropriate RHS.  <a href="classIBAMR_1_1CIBStrategy.html#a82e6796cde1fa8582962ae1c0cc63012">More...</a><br /></td></tr>
<tr class="separator:a82e6796cde1fa8582962ae1c0cc63012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d78c835e925b0f5f55b93edadaacfd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ad9d78c835e925b0f5f55b93edadaacfd">subtractMeanConstraintForce</a> (Vec L, <a class="el" href="classint.html">int</a> f_data_idx, const <a class="el" href="classdouble.html">double</a> scale=1.0)=0</td></tr>
<tr class="memdesc:ad9d78c835e925b0f5f55b93edadaacfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract the mean of constraint force from the background Eulerian grid. This is required for certain cases like periodic steady Stokes.  <a href="classIBAMR_1_1CIBStrategy.html#ad9d78c835e925b0f5f55b93edadaacfd">More...</a><br /></td></tr>
<tr class="separator:ad9d78c835e925b0f5f55b93edadaacfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a497d05a2db8d13d5a3169bb8d3802"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a35a497d05a2db8d13d5a3169bb8d3802">setInterpolatedVelocityVector</a> (Vec V, const <a class="el" href="classdouble.html">double</a> data_time)</td></tr>
<tr class="memdesc:a35a497d05a2db8d13d5a3169bb8d3802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the implementation class for getting the interpolated fluid velocity on the Lagrangian vector <code>V</code>.  <a href="classIBAMR_1_1CIBStrategy.html#a35a497d05a2db8d13d5a3169bb8d3802">More...</a><br /></td></tr>
<tr class="separator:a35a497d05a2db8d13d5a3169bb8d3802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778c86c5fadf9ea9ea5657b02a2d5ef2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a778c86c5fadf9ea9ea5657b02a2d5ef2">getInterpolatedVelocity</a> (Vec V, const <a class="el" href="classdouble.html">double</a> data_time, const <a class="el" href="classdouble.html">double</a> scale=1.0)=0</td></tr>
<tr class="memdesc:a778c86c5fadf9ea9ea5657b02a2d5ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interpolated velocity from the Eulerian grid at the specified time.  <a href="classIBAMR_1_1CIBStrategy.html#a778c86c5fadf9ea9ea5657b02a2d5ef2">More...</a><br /></td></tr>
<tr class="separator:a778c86c5fadf9ea9ea5657b02a2d5ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381066ff0fe88d278f3a0d07d4d3a633"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a381066ff0fe88d278f3a0d07d4d3a633">computeMobilityRegularization</a> (Vec D, Vec L, const <a class="el" href="classdouble.html">double</a> scale=1.0)=0</td></tr>
<tr class="memdesc:a381066ff0fe88d278f3a0d07d4d3a633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute regularization vector for the mobility problem.  <a href="classIBAMR_1_1CIBStrategy.html#a381066ff0fe88d278f3a0d07d4d3a633">More...</a><br /></td></tr>
<tr class="separator:a381066ff0fe88d278f3a0d07d4d3a633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac28b98c635db5889693d71f67456cd8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#aac28b98c635db5889693d71f67456cd8">getNumberOfRigidStructures</a> () const</td></tr>
<tr class="memdesc:aac28b98c635db5889693d71f67456cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of rigid structures registered with this class.  <a href="classIBAMR_1_1CIBStrategy.html#aac28b98c635db5889693d71f67456cd8">More...</a><br /></td></tr>
<tr class="separator:aac28b98c635db5889693d71f67456cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22c5d41e5e385eb7720691e0050b4b0"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#af22c5d41e5e385eb7720691e0050b4b0">getNumberOfNodes</a> (const unsigned <a class="el" href="classint.html">int</a> part) const =0</td></tr>
<tr class="memdesc:af22c5d41e5e385eb7720691e0050b4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of nodes associated with the particular structure.  <a href="classIBAMR_1_1CIBStrategy.html#af22c5d41e5e385eb7720691e0050b4b0">More...</a><br /></td></tr>
<tr class="separator:af22c5d41e5e385eb7720691e0050b4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc7a6bedd44f4cd0a06df8af06461a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a0fc7a6bedd44f4cd0a06df8af06461a1">setInitialCenterOfMass</a> (const unsigned <a class="el" href="classint.html">int</a> part, const Eigen::Vector3d &amp;XCOM_0)</td></tr>
<tr class="memdesc:a0fc7a6bedd44f4cd0a06df8af06461a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the initial center of mass location for the structures.  <a href="classIBAMR_1_1CIBStrategy.html#a0fc7a6bedd44f4cd0a06df8af06461a1">More...</a><br /></td></tr>
<tr class="separator:a0fc7a6bedd44f4cd0a06df8af06461a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c84ef0df606bb8dad89923392de5491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a0c84ef0df606bb8dad89923392de5491">setSolveRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, const <a class="el" href="namespaceIBTK.html#ad17100e3633baaf42d5aae6933b8e5db">IBTK::FreeRigidDOFVector</a> &amp;solve_rigid_dofs)</td></tr>
<tr class="memdesc:a0c84ef0df606bb8dad89923392de5491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set what rigid DOFs need to be solved for this particular structure.  <a href="classIBAMR_1_1CIBStrategy.html#a0c84ef0df606bb8dad89923392de5491">More...</a><br /></td></tr>
<tr class="separator:a0c84ef0df606bb8dad89923392de5491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cacbaae5916c93077d50b1c1a36f69"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceIBTK.html#ad17100e3633baaf42d5aae6933b8e5db">IBTK::FreeRigidDOFVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ac8cacbaae5916c93077d50b1c1a36f69">getSolveRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, <a class="el" href="classint.html">int</a> &amp;num_free_dofs) const</td></tr>
<tr class="memdesc:ac8cacbaae5916c93077d50b1c1a36f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query what rigid DOFs need to be solved for.  <a href="classIBAMR_1_1CIBStrategy.html#ac8cacbaae5916c93077d50b1c1a36f69">More...</a><br /></td></tr>
<tr class="separator:ac8cacbaae5916c93077d50b1c1a36f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b814e860e4713dc9f437f43856a2a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a74b814e860e4713dc9f437f43856a2a0">setRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;U, Vec V)=0</td></tr>
<tr class="memdesc:a74b814e860e4713dc9f437f43856a2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the rigid body velocity at the nodal/marker points contained in the Vec <em>V</em>.  <a href="classIBAMR_1_1CIBStrategy.html#a74b814e860e4713dc9f437f43856a2a0">More...</a><br /></td></tr>
<tr class="separator:a74b814e860e4713dc9f437f43856a2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08097027463a8986efc35a294ab10f4d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a08097027463a8986efc35a294ab10f4d">setRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, Vec U, Vec V)</td></tr>
<tr class="memdesc:a08097027463a8986efc35a294ab10f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the rigid body velocity at the nodal/marker points contained in the Vec <em>V</em>.  <a href="classIBAMR_1_1CIBStrategy.html#a08097027463a8986efc35a294ab10f4d">More...</a><br /></td></tr>
<tr class="separator:a08097027463a8986efc35a294ab10f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed839bba3c6ae73fe3ceaa6ee548a0a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#aed839bba3c6ae73fe3ceaa6ee548a0a6">setRigidBodyVelocity</a> (Vec U, Vec V, const <a class="el" href="classbool.html">bool</a> only_free_dofs, const <a class="el" href="classbool.html">bool</a> only_imposed_dofs, const <a class="el" href="classbool.html">bool</a> all_dofs=false)</td></tr>
<tr class="memdesc:aed839bba3c6ae73fe3ceaa6ee548a0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the rigid body velocity at the nodal/marker points contained in the Vec V.  <a href="classIBAMR_1_1CIBStrategy.html#aed839bba3c6ae73fe3ceaa6ee548a0a6">More...</a><br /></td></tr>
<tr class="separator:aed839bba3c6ae73fe3ceaa6ee548a0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3387134bbce5257db7969ef019a1a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a9f3387134bbce5257db7969ef019a1a2">computeNetRigidGeneralizedForce</a> (const unsigned <a class="el" href="classint.html">int</a> part, Vec L, <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;F)=0</td></tr>
<tr class="memdesc:a9f3387134bbce5257db7969ef019a1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute total force and torque on the structure.  <a href="classIBAMR_1_1CIBStrategy.html#a9f3387134bbce5257db7969ef019a1a2">More...</a><br /></td></tr>
<tr class="separator:a9f3387134bbce5257db7969ef019a1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a54517eaec6816edb0e06cffe8f08d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ad6a54517eaec6816edb0e06cffe8f08d">computeNetRigidGeneralizedForce</a> (const unsigned <a class="el" href="classint.html">int</a> part, Vec L, Vec F)</td></tr>
<tr class="memdesc:ad6a54517eaec6816edb0e06cffe8f08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute total force and torque on the structure.  <a href="classIBAMR_1_1CIBStrategy.html#ad6a54517eaec6816edb0e06cffe8f08d">More...</a><br /></td></tr>
<tr class="separator:ad6a54517eaec6816edb0e06cffe8f08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b3429e6b49d50e385af370874acf42"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ac1b3429e6b49d50e385af370874acf42">computeNetRigidGeneralizedForce</a> (Vec L, Vec F, const <a class="el" href="classbool.html">bool</a> only_free_dofs, const <a class="el" href="classbool.html">bool</a> only_imposed_dofs, const <a class="el" href="classbool.html">bool</a> all_dofs=false)</td></tr>
<tr class="memdesc:ac1b3429e6b49d50e385af370874acf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute total force and torque on the structure.  <a href="classIBAMR_1_1CIBStrategy.html#ac1b3429e6b49d50e385af370874acf42">More...</a><br /></td></tr>
<tr class="separator:ac1b3429e6b49d50e385af370874acf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446a8e750171ee90f51658e645fc0bc6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a446a8e750171ee90f51658e645fc0bc6">getNetRigidGeneralizedForce</a> (const unsigned <a class="el" href="classint.html">int</a> part)</td></tr>
<tr class="memdesc:a446a8e750171ee90f51658e645fc0bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total torque and force on the structure at new_time within the current time interval.  <a href="classIBAMR_1_1CIBStrategy.html#a446a8e750171ee90f51658e645fc0bc6">More...</a><br /></td></tr>
<tr class="separator:a446a8e750171ee90f51658e645fc0bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc476b84ad7a6b45321e48474992f7ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#adc476b84ad7a6b45321e48474992f7ff">updateFreeDOFsMapping</a> ()</td></tr>
<tr class="memdesc:adc476b84ad7a6b45321e48474992f7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the mapping of free DOFs for all structures if they are collected in a global vector.  <a href="classIBAMR_1_1CIBStrategy.html#adc476b84ad7a6b45321e48474992f7ff">More...</a><br /></td></tr>
<tr class="separator:adc476b84ad7a6b45321e48474992f7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46aa12a75eec15beeed92da1a05bf297"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a46aa12a75eec15beeed92da1a05bf297">updateNewRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;U)</td></tr>
<tr class="memdesc:a46aa12a75eec15beeed92da1a05bf297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the rigid body velocity obtained from the constraint Stokes solver for free-moving case.  <a href="classIBAMR_1_1CIBStrategy.html#a46aa12a75eec15beeed92da1a05bf297">More...</a><br /></td></tr>
<tr class="separator:a46aa12a75eec15beeed92da1a05bf297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadb163509d0ca86f327fa9e9580b529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#aaadb163509d0ca86f327fa9e9580b529">updateNewRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, Vec U)</td></tr>
<tr class="memdesc:aaadb163509d0ca86f327fa9e9580b529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the rigid body velocity obtained from the constraint Stokes solver for free-moving case.  <a href="classIBAMR_1_1CIBStrategy.html#aaadb163509d0ca86f327fa9e9580b529">More...</a><br /></td></tr>
<tr class="separator:aaadb163509d0ca86f327fa9e9580b529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ba22af2d0b3afde292157273f933ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a01ba22af2d0b3afde292157273f933ff">updateNewRigidBodyVelocity</a> (Vec U, const <a class="el" href="classbool.html">bool</a> only_free_dofs, const <a class="el" href="classbool.html">bool</a> only_imposed_dofs, const <a class="el" href="classbool.html">bool</a> all_dofs=false)</td></tr>
<tr class="memdesc:a01ba22af2d0b3afde292157273f933ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the rigid body velocity obtained from the constraint Stokes solver for free-moving case.  <a href="classIBAMR_1_1CIBStrategy.html#a01ba22af2d0b3afde292157273f933ff">More...</a><br /></td></tr>
<tr class="separator:a01ba22af2d0b3afde292157273f933ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b924ba210e1f10cba28705f94015f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ac5b924ba210e1f10cba28705f94015f2">copyVecToArray</a> (Vec b, <a class="el" href="classdouble.html">double</a> *array, const std::vector&lt; unsigned &gt; &amp;struct_ids, const <a class="el" href="classint.html">int</a> data_depth, const <a class="el" href="classint.html">int</a> array_rank)</td></tr>
<tr class="memdesc:ac5b924ba210e1f10cba28705f94015f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from distributed PETSc Vec for specified stucture indices to an array defined on a single processor. A default empty implementation is provided.  <a href="classIBAMR_1_1CIBStrategy.html#ac5b924ba210e1f10cba28705f94015f2">More...</a><br /></td></tr>
<tr class="separator:ac5b924ba210e1f10cba28705f94015f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05378698c6caf299c83d5a53e2a16199"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a05378698c6caf299c83d5a53e2a16199">copyFreeDOFsVecToArray</a> (Vec b, <a class="el" href="classdouble.html">double</a> *array, const std::vector&lt; unsigned &gt; &amp;struct_ids, const <a class="el" href="classint.html">int</a> array_rank)</td></tr>
<tr class="memdesc:a05378698c6caf299c83d5a53e2a16199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from distributed PETSc Vec for specified stucture indices to an array defined on a single processor. A default implementation is provided.  <a href="classIBAMR_1_1CIBStrategy.html#a05378698c6caf299c83d5a53e2a16199">More...</a><br /></td></tr>
<tr class="separator:a05378698c6caf299c83d5a53e2a16199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da0e483af91e696d6105e5be771c0c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a8da0e483af91e696d6105e5be771c0c4">copyArrayToVec</a> (Vec b, <a class="el" href="classdouble.html">double</a> *array, const std::vector&lt; unsigned &gt; &amp;struct_ids, const <a class="el" href="classint.html">int</a> data_depth, const <a class="el" href="classint.html">int</a> array_rank)</td></tr>
<tr class="memdesc:a8da0e483af91e696d6105e5be771c0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from array defined on a single processor for specified stucture indices to distributed PETScVec. A default empty implementation is provided.  <a href="classIBAMR_1_1CIBStrategy.html#a8da0e483af91e696d6105e5be771c0c4">More...</a><br /></td></tr>
<tr class="separator:a8da0e483af91e696d6105e5be771c0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93ce15b714d03af6b80ba23dbaa5c79"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#af93ce15b714d03af6b80ba23dbaa5c79">copyFreeDOFsArrayToVec</a> (Vec b, <a class="el" href="classdouble.html">double</a> *array, const std::vector&lt; unsigned &gt; &amp;struct_ids, const <a class="el" href="classint.html">int</a> array_rank)</td></tr>
<tr class="memdesc:af93ce15b714d03af6b80ba23dbaa5c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from array defined on a single processor for specified stucture indices to distributed PETScVec. A default implementation is provided.  <a href="classIBAMR_1_1CIBStrategy.html#af93ce15b714d03af6b80ba23dbaa5c79">More...</a><br /></td></tr>
<tr class="separator:af93ce15b714d03af6b80ba23dbaa5c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e57bb1d7568e9f2e1ba1954c603eb35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a6e57bb1d7568e9f2e1ba1954c603eb35">getCurrentRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;U)</td></tr>
<tr class="memdesc:a6e57bb1d7568e9f2e1ba1954c603eb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rigid body translational velocity at the beginning of the timestep.  <a href="classIBAMR_1_1CIBStrategy.html#a6e57bb1d7568e9f2e1ba1954c603eb35">More...</a><br /></td></tr>
<tr class="separator:a6e57bb1d7568e9f2e1ba1954c603eb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eff8796b3637e0f4731b32762d9154f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a5eff8796b3637e0f4731b32762d9154f">getNewRigidBodyVelocity</a> (const unsigned <a class="el" href="classint.html">int</a> part, <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;U)</td></tr>
<tr class="memdesc:a5eff8796b3637e0f4731b32762d9154f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rigid body translational velocity at the end of the timestep.  <a href="classIBAMR_1_1CIBStrategy.html#a5eff8796b3637e0f4731b32762d9154f">More...</a><br /></td></tr>
<tr class="separator:a5eff8796b3637e0f4731b32762d9154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71594fce589c121dc7cb81f0ae8e8ef3"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector3d &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a71594fce589c121dc7cb81f0ae8e8ef3">getCurrentBodyCenterOfMass</a> (const unsigned <a class="el" href="classint.html">int</a> part)</td></tr>
<tr class="memdesc:a71594fce589c121dc7cb81f0ae8e8ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get body center of mass at the current time step.  <a href="classIBAMR_1_1CIBStrategy.html#a71594fce589c121dc7cb81f0ae8e8ef3">More...</a><br /></td></tr>
<tr class="separator:a71594fce589c121dc7cb81f0ae8e8ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a71cf057095365cb0a1bf0cb4ebe486"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector3d &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a8a71cf057095365cb0a1bf0cb4ebe486">getNewBodyCenterOfMass</a> (const unsigned <a class="el" href="classint.html">int</a> part)</td></tr>
<tr class="memdesc:a8a71cf057095365cb0a1bf0cb4ebe486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get body center of mass at half time step.  <a href="classIBAMR_1_1CIBStrategy.html#a8a71cf057095365cb0a1bf0cb4ebe486">More...</a><br /></td></tr>
<tr class="separator:a8a71cf057095365cb0a1bf0cb4ebe486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169be9cab6a1917986d421d29dbe303d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a169be9cab6a1917986d421d29dbe303d">constructMobilityMatrix</a> (const std::string &amp;mat_name, <a class="el" href="namespaceIBAMR.html#a591304f336aef144a5ae4595cffc3f70">MobilityMatrixType</a> mat_type, Mat &amp;mobility_mat, const std::vector&lt; unsigned &gt; &amp;prototype_struct_ids, const <a class="el" href="classdouble.html">double</a> *grid_dx, const <a class="el" href="classdouble.html">double</a> *domain_extents, const <a class="el" href="classbool.html">bool</a> initial_time, <a class="el" href="classdouble.html">double</a> rho, <a class="el" href="classdouble.html">double</a> mu, const std::pair&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;scale, <a class="el" href="classdouble.html">double</a> f_periodic_corr, const <a class="el" href="classint.html">int</a> managing_rank)</td></tr>
<tr class="memdesc:a169be9cab6a1917986d421d29dbe303d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct dense mobility matrix for the prototypical structures identified by their indices.  <a href="classIBAMR_1_1CIBStrategy.html#a169be9cab6a1917986d421d29dbe303d">More...</a><br /></td></tr>
<tr class="separator:a169be9cab6a1917986d421d29dbe303d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca98046bbb01951fd5cc687148f59c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a6ca98046bbb01951fd5cc687148f59c9">constructGeometricMatrix</a> (const std::string &amp;mat_name, Mat &amp;geometric_mat, const std::vector&lt; unsigned &gt; &amp;prototype_struct_ids, const <a class="el" href="classbool.html">bool</a> initial_time, const <a class="el" href="classint.html">int</a> managing_rank)</td></tr>
<tr class="memdesc:a6ca98046bbb01951fd5cc687148f59c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a geometric matrix for the prototypical structures identified by their indices. A geometric matrix maps center of mass rigid body velocity to nodal velocities. Geometric matrix is generally used with a dense mobility matrices to construct an associated body-mobility matrix algebrically.  <a href="classIBAMR_1_1CIBStrategy.html#a6ca98046bbb01951fd5cc687148f59c9">More...</a><br /></td></tr>
<tr class="separator:a6ca98046bbb01951fd5cc687148f59c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37efaea07ac44c8caf881723adc972e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a37efaea07ac44c8caf881723adc972e4">rotateArray</a> (<a class="el" href="classdouble.html">double</a> *array, const std::vector&lt; unsigned &gt; &amp;struct_ids, const <a class="el" href="classbool.html">bool</a> use_transpose, const <a class="el" href="classint.html">int</a> managing_rank, const <a class="el" href="classint.html">int</a> depth)</td></tr>
<tr class="memdesc:a37efaea07ac44c8caf881723adc972e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate vector using rotation matrix to/from the reference frame of the structures (which is at the initial time of the simulation).  <a href="classIBAMR_1_1CIBStrategy.html#a37efaea07ac44c8caf881723adc972e4">More...</a><br /></td></tr>
<tr class="separator:a37efaea07ac44c8caf881723adc972e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a91d5b6beeee95b9e560871e271f0a42f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a91d5b6beeee95b9e560871e271f0a42f">vecToRDV</a> (Vec U, <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;Ur)</td></tr>
<tr class="memdesc:a91d5b6beeee95b9e560871e271f0a42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the DOFs from PETSc Vec <code>U</code> to RigidDOFVector <code>Ur</code>.  <a href="classIBAMR_1_1CIBStrategy.html#a91d5b6beeee95b9e560871e271f0a42f">More...</a><br /></td></tr>
<tr class="separator:a91d5b6beeee95b9e560871e271f0a42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c3fa8472562a4d21f30e3a0a0c69c7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a96c3fa8472562a4d21f30e3a0a0c69c7">rdvToVec</a> (const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;Ur, Vec &amp;U)</td></tr>
<tr class="memdesc:a96c3fa8472562a4d21f30e3a0a0c69c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the DOFs from RigidDOFVector <code>Ur</code> to PETSc Vec <code>U</code>.  <a href="classIBAMR_1_1CIBStrategy.html#a96c3fa8472562a4d21f30e3a0a0c69c7">More...</a><br /></td></tr>
<tr class="separator:a96c3fa8472562a4d21f30e3a0a0c69c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630d7d9172d5a9284235783f238181cb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a630d7d9172d5a9284235783f238181cb">eigenToRDV</a> (const Eigen::Vector3d &amp;U, const Eigen::Vector3d &amp;W, <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;UW)</td></tr>
<tr class="memdesc:a630d7d9172d5a9284235783f238181cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the DOFs from Eigen::Vector3d <code>U</code> and <code>W</code> to RigidDOFVector <code>UW</code>.  <a href="classIBAMR_1_1CIBStrategy.html#a630d7d9172d5a9284235783f238181cb">More...</a><br /></td></tr>
<tr class="separator:a630d7d9172d5a9284235783f238181cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ced3674edd5d2a7609789473496e62"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a06ced3674edd5d2a7609789473496e62">rdvToEigen</a> (const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;UW, Eigen::Vector3d &amp;U, Eigen::Vector3d &amp;W)</td></tr>
<tr class="memdesc:a06ced3674edd5d2a7609789473496e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the DOFs from RigidDOFVector <code>UW</code> to Eigen::Vector3d <code>U</code> and <code>W</code>.  <a href="classIBAMR_1_1CIBStrategy.html#a06ced3674edd5d2a7609789473496e62">More...</a><br /></td></tr>
<tr class="separator:a06ced3674edd5d2a7609789473496e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a087733d93ea9af2d37c730dbb86f83a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a087733d93ea9af2d37c730dbb86f83a2">setRotationMatrix</a> (const std::vector&lt; Eigen::Vector3d &gt; &amp;rot_vel, const std::vector&lt; Eigen::Quaterniond &gt; &amp;q_old, std::vector&lt; Eigen::Quaterniond &gt; &amp;q_new, std::vector&lt; Eigen::Matrix3d &gt; &amp;rot_mat, const <a class="el" href="classdouble.html">double</a> dt)</td></tr>
<tr class="memdesc:a087733d93ea9af2d37c730dbb86f83a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the rotation matrix.  <a href="classIBAMR_1_1CIBStrategy.html#a087733d93ea9af2d37c730dbb86f83a2">More...</a><br /></td></tr>
<tr class="separator:a087733d93ea9af2d37c730dbb86f83a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a78c7b5094d5a3d78ea27f119d13a84cb"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a78c7b5094d5a3d78ea27f119d13a84cb">d_num_rigid_parts</a></td></tr>
<tr class="separator:a78c7b5094d5a3d78ea27f119d13a84cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9605c08a1475a205eff9afe1aa6a6697"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a9605c08a1475a205eff9afe1aa6a6697">d_center_of_mass_initial</a></td></tr>
<tr class="separator:a9605c08a1475a205eff9afe1aa6a6697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe66c1c916ebf8cc41a50e0d176de75a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#abe66c1c916ebf8cc41a50e0d176de75a">d_center_of_mass_current</a></td></tr>
<tr class="separator:abe66c1c916ebf8cc41a50e0d176de75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac8a64acf8f7af721cad92aee80bbb1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a9ac8a64acf8f7af721cad92aee80bbb1">d_center_of_mass_half</a></td></tr>
<tr class="separator:a9ac8a64acf8f7af721cad92aee80bbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c8cc709ffdd9adb602d079665fcf48"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ac7c8cc709ffdd9adb602d079665fcf48">d_center_of_mass_new</a></td></tr>
<tr class="separator:ac7c8cc709ffdd9adb602d079665fcf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b378a544fd6b8a871abe3ec3807d98"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#af5b378a544fd6b8a871abe3ec3807d98">d_compute_center_of_mass_initial</a></td></tr>
<tr class="separator:af5b378a544fd6b8a871abe3ec3807d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0997a2def8f09191bfa55a29e90c969"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Quaterniond &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#af0997a2def8f09191bfa55a29e90c969">d_quaternion_current</a></td></tr>
<tr class="separator:af0997a2def8f09191bfa55a29e90c969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac429d5ed3731531af860043d007aec6a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Quaterniond &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ac429d5ed3731531af860043d007aec6a">d_quaternion_half</a></td></tr>
<tr class="separator:ac429d5ed3731531af860043d007aec6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac219c2dad3198f4452eb91caa19d2d80"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Quaterniond &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ac219c2dad3198f4452eb91caa19d2d80">d_quaternion_new</a></td></tr>
<tr class="separator:ac219c2dad3198f4452eb91caa19d2d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd7755ec6ff2466d39205ba1eb007fe"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceIBTK.html#aac19301c6fd0897bd5254ffad040e24c">IBTK::FRDV</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#adfd7755ec6ff2466d39205ba1eb007fe">d_solve_rigid_vel</a></td></tr>
<tr class="separator:adfd7755ec6ff2466d39205ba1eb007fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22ae8b85ca8df0fd9b812fdb4b5692b"><td class="memItemLeft" align="right" valign="top">Vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ab22ae8b85ca8df0fd9b812fdb4b5692b">d_U</a></td></tr>
<tr class="separator:ab22ae8b85ca8df0fd9b812fdb4b5692b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b7f78c9725bab72d66fbe6af279fea"><td class="memItemLeft" align="right" valign="top">Vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a08b7f78c9725bab72d66fbe6af279fea">d_F</a></td></tr>
<tr class="separator:a08b7f78c9725bab72d66fbe6af279fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7fd46d9caa77a2a5c73d300fecc1ac"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a2b7fd46d9caa77a2a5c73d300fecc1ac">d_free_dofs_map</a></td></tr>
<tr class="separator:a2b7fd46d9caa77a2a5c73d300fecc1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07a284a69aeca5ca96bf5b973e79ebf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#ab07a284a69aeca5ca96bf5b973e79ebf">d_free_dofs_map_updated</a></td></tr>
<tr class="separator:ab07a284a69aeca5ca96bf5b973e79ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f327733ed226b3dab4570a091b8f320"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a1f327733ed226b3dab4570a091b8f320">d_trans_vel_current</a></td></tr>
<tr class="separator:a1f327733ed226b3dab4570a091b8f320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aec9a253505c8aec29c7fa61d1fb679"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a8aec9a253505c8aec29c7fa61d1fb679">d_trans_vel_half</a></td></tr>
<tr class="separator:a8aec9a253505c8aec29c7fa61d1fb679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72aa507b4762f5e2ab47f04b7c7a975f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a72aa507b4762f5e2ab47f04b7c7a975f">d_trans_vel_new</a></td></tr>
<tr class="separator:a72aa507b4762f5e2ab47f04b7c7a975f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84feb76bf0b3cdfdcbffab8d876cde9f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a84feb76bf0b3cdfdcbffab8d876cde9f">d_rot_vel_current</a></td></tr>
<tr class="separator:a84feb76bf0b3cdfdcbffab8d876cde9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afc85a233ca21712f4ad4e785676083"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a3afc85a233ca21712f4ad4e785676083">d_rot_vel_half</a></td></tr>
<tr class="separator:a3afc85a233ca21712f4ad4e785676083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d45fbba4a53b330b711f8e1eb869dbb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a3d45fbba4a53b330b711f8e1eb869dbb">d_rot_vel_new</a></td></tr>
<tr class="separator:a3d45fbba4a53b330b711f8e1eb869dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a571c74a9f31de87ea505275f416f7e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a8a571c74a9f31de87ea505275f416f7e">d_net_rigid_generalized_force</a></td></tr>
<tr class="separator:a8a571c74a9f31de87ea505275f416f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:acb875a368f09b88a35d1e0faea81d643"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#acb875a368f09b88a35d1e0faea81d643">CIBStrategy</a> (const <a class="el" href="classIBAMR_1_1CIBStrategy.html">CIBStrategy</a> &amp;from)=delete</td></tr>
<tr class="memdesc:acb875a368f09b88a35d1e0faea81d643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classIBAMR_1_1CIBStrategy.html#acb875a368f09b88a35d1e0faea81d643">More...</a><br /></td></tr>
<tr class="separator:acb875a368f09b88a35d1e0faea81d643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4292fedb63d60a4071f09f0df309ce16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBAMR_1_1CIBStrategy.html">CIBStrategy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBAMR_1_1CIBStrategy.html#a4292fedb63d60a4071f09f0df309ce16">operator=</a> (const <a class="el" href="classIBAMR_1_1CIBStrategy.html">CIBStrategy</a> &amp;that)=delete</td></tr>
<tr class="memdesc:a4292fedb63d60a4071f09f0df309ce16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classIBAMR_1_1CIBStrategy.html#a4292fedb63d60a4071f09f0df309ce16">More...</a><br /></td></tr>
<tr class="separator:a4292fedb63d60a4071f09f0df309ce16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3e705bfc074714dabd25ae9c8350dda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e705bfc074714dabd25ae9c8350dda2">&#9670;&nbsp;</a></span>CIBStrategy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IBAMR::CIBStrategy::CIBStrategy </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>parts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6417d647f13082764b5c33eb6593fefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6417d647f13082764b5c33eb6593fefc">&#9670;&nbsp;</a></span>~CIBStrategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual IBAMR::CIBStrategy::~CIBStrategy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb875a368f09b88a35d1e0faea81d643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb875a368f09b88a35d1e0faea81d643">&#9670;&nbsp;</a></span>CIBStrategy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IBAMR::CIBStrategy::CIBStrategy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIBAMR_1_1CIBStrategy.html">CIBStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This constructor is not implemented and should not be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The value to copy to this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a573493dce74f45976fb62db1c4102f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573493dce74f45976fb62db1c4102f17">&#9670;&nbsp;</a></span>setConstraintForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::setConstraintForce </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Vec containing the constraint force for all structures.</td></tr>
    <tr><td class="paramname">data_time</td><td>Time at which constraint force is to be spread.</td></tr>
    <tr><td class="paramname">scale</td><td>Scales the constraint force before spreading. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#ab5b21e4a631bea521aaa8e7bc39707c3">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a4682dd04b56f42e5fb3a12d1ed24efed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4682dd04b56f42e5fb3a12d1ed24efed">&#9670;&nbsp;</a></span>getConstraintForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::getConstraintForce </td>
          <td>(</td>
          <td class="paramtype">Vec *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Time (current_time or new_time) at which constraint force is required. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#af45b029cc8728c27286c2bcc694fc310">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="aba5dc4783ab0a540a8768403dfcd5eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5dc4783ab0a540a8768403dfcd5eb1">&#9670;&nbsp;</a></span>getFreeRigidVelocities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::getFreeRigidVelocities </td>
          <td>(</td>
          <td class="paramtype">Vec *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>A default implementation is provided that returns the vector of free DOFs.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Time (current_time or new_time) at which constraint force is required. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#a3a22a6c03f6e31c8922651cd1b7946fd">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a82e6796cde1fa8582962ae1c0cc63012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e6796cde1fa8582962ae1c0cc63012">&#9670;&nbsp;</a></span>getNetExternalForceTorque()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::getNetExternalForceTorque </td>
          <td>(</td>
          <td class="paramtype">Vec *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>A default implementation is provided that returns the vector of net external force and torque for the corresponding free DOFs.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Time (current_time or new_time) at which external force and torque is required. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#a6784590dcd6f5495cc7d4a49eb9b53a8">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="ad9d78c835e925b0f5f55b93edadaacfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d78c835e925b0f5f55b93edadaacfd">&#9670;&nbsp;</a></span>subtractMeanConstraintForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::subtractMeanConstraintForce </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Vec containing the constraint force.</td></tr>
    <tr><td class="paramname">f_data_idx</td><td>Patch data index of Eulerian body force.</td></tr>
    <tr><td class="paramname">scale</td><td>Factor by which <code>L</code> is scaled. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#a641234ee6e8d986a5d4d4a8ad72730cd">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a35a497d05a2db8d13d5a3169bb8d3802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a497d05a2db8d13d5a3169bb8d3802">&#9670;&nbsp;</a></span>setInterpolatedVelocityVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::setInterpolatedVelocityVector </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>Vector that should contain the interpolated velocity.</td></tr>
    <tr><td class="paramname">data_time</td><td>Time at which Eulerian velocity is to be interpolated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A default implementation is provided that does nothing. </dd></dl>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#af71152ec5820e42360c48c63eaeeb408">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a778c86c5fadf9ea9ea5657b02a2d5ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778c86c5fadf9ea9ea5657b02a2d5ef2">&#9670;&nbsp;</a></span>getInterpolatedVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::getInterpolatedVelocity </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>Vector that should contain the interpolated velocity.</td></tr>
    <tr><td class="paramname">data_time</td><td>Time at which Eulerian velocity is to be interpolated.</td></tr>
    <tr><td class="paramname">scale</td><td>Scales the velocity vector after interpolating from the Eulerian grid. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#a0ed97c5c4495ccd3b4f58dcde10e871e">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a381066ff0fe88d278f3a0d07d4d3a633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381066ff0fe88d278f3a0d07d4d3a633">&#9670;&nbsp;</a></span>computeMobilityRegularization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::computeMobilityRegularization </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Vector containing the regularization for the mobility problem.</td></tr>
    <tr><td class="paramname">L</td><td>Vector from which regularization is to be computed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#a83a48b1fb791aa8944ac5fcdd0ba40b8">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="aac28b98c635db5889693d71f67456cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac28b98c635db5889693d71f67456cd8">&#9670;&nbsp;</a></span>getNumberOfRigidStructures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> IBAMR::CIBStrategy::getNumberOfRigidStructures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af22c5d41e5e385eb7720691e0050b4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22c5d41e5e385eb7720691e0050b4b0">&#9670;&nbsp;</a></span>getNumberOfNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned <a class="el" href="classint.html">int</a> IBAMR::CIBStrategy::getNumberOfNodes </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#ad117216876ac8f3ba82873f9732f7774">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a0fc7a6bedd44f4cd0a06df8af06461a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc7a6bedd44f4cd0a06df8af06461a1">&#9670;&nbsp;</a></span>setInitialCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::setInitialCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>XCOM_0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The rigid body for which we are setting the initial center of mass position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c84ef0df606bb8dad89923392de5491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c84ef0df606bb8dad89923392de5491">&#9670;&nbsp;</a></span>setSolveRigidBodyVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::setSolveRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#ad17100e3633baaf42d5aae6933b8e5db">IBTK::FreeRigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>solve_rigid_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The rigid body for which we are setting the free DOFs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8cacbaae5916c93077d50b1c1a36f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cacbaae5916c93077d50b1c1a36f69">&#9670;&nbsp;</a></span>getSolveRigidBodyVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceIBTK.html#ad17100e3633baaf42d5aae6933b8e5db">IBTK::FreeRigidDOFVector</a>&amp; IBAMR::CIBStrategy::getSolveRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>num_free_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74b814e860e4713dc9f437f43856a2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b814e860e4713dc9f437f43856a2a0">&#9670;&nbsp;</a></span>setRigidBodyVelocity() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::setRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The rigid part for which velocity needs to be set.</td></tr>
    <tr><td class="paramname">U</td><td>RDV contains the rigid component of velocities. For two-dimensions the vector contains the values \([u,v,\omega_z]\) and for three-dimensions the vector values are \([u,v,w,\omega_x,\omega_y,\omega_z]\). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#a9098bc848b12dab953743a64fd946f74">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a08097027463a8986efc35a294ab10f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08097027463a8986efc35a294ab10f4d">&#9670;&nbsp;</a></span>setRigidBodyVelocity() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::setRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The rigid part for which velocity needs to be set.</td></tr>
    <tr><td class="paramname">U</td><td>Vec contains the rigid component of velocities. For two-dimensions the vector contains the values \([u,v,\omega_z]\) and for three-dimensions the vector values are \([u,v,w,\omega_x,\omega_y,\omega_z]\). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed839bba3c6ae73fe3ceaa6ee548a0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed839bba3c6ae73fe3ceaa6ee548a0a6">&#9670;&nbsp;</a></span>setRigidBodyVelocity() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::setRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>only_free_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>only_imposed_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>all_dofs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>Vec that contains the rigid component of velocities for the required components. For two-dimensions each sub Vec contains the values \([u,v,\omega_z]\) and for three-dimensions the vector values are \([u,v,w,\omega_x,\omega_y,\omega_z]\).</td></tr>
    <tr><td class="paramname">only_free_dofs</td><td>Boolean indicating if the rigid body velocity is to be set only for free DOFS for all parts. The corresponding size of U_sub would be \( U_{sub} \leq NDIM * (NDIM + 1) / 2 \).</td></tr>
    <tr><td class="paramname">only_imposed_dofs</td><td>Boolean indicating if the rigid body velocity is to be set only for prescribed kinematics dofs for all parts. The corresponding size of U_sub would be \( U_{sub} \leq NDIM * (NDIM + 1) / 2 \).</td></tr>
    <tr><td class="paramname">all_dofs</td><td>Boolean indicating if the rigid body velocity is to be set for all parts. The corresponding size of U_sub would be \( U_{sub} = NDIM * (NDIM + 1) / 2 \).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>User is responsible for setting correct number of subvecs in U that corresponds to the particular combination of booleans. </dd></dl>

</div>
</div>
<a id="a9f3387134bbce5257db7969ef019a1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3387134bbce5257db7969ef019a1a2">&#9670;&nbsp;</a></span>computeNetRigidGeneralizedForce() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::computeNetRigidGeneralizedForce </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The Lagrange multiplier vector.</td></tr>
    <tr><td class="paramname">F</td><td>Vector RDV storing the net generalized force.</td></tr>
    <tr><td class="paramname">F</td><td>RDV storing the net generalized force. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#a1351588b3bbeda76d138b1565bec1776">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="ad6a54517eaec6816edb0e06cffe8f08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a54517eaec6816edb0e06cffe8f08d">&#9670;&nbsp;</a></span>computeNetRigidGeneralizedForce() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::computeNetRigidGeneralizedForce </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The structure index.</td></tr>
    <tr><td class="paramname">L</td><td>The Lagrange multiplier vector.</td></tr>
    <tr><td class="paramname">F</td><td>Vec storing the net generalized force. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1b3429e6b49d50e385af370874acf42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b3429e6b49d50e385af370874acf42">&#9670;&nbsp;</a></span>computeNetRigidGeneralizedForce() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::computeNetRigidGeneralizedForce </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>only_free_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>only_imposed_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>all_dofs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The Lagrange multiplier vector. </td></tr>
    <tr><td class="paramname">F</td><td>Vec storing the net generalized force.</td></tr>
    <tr><td class="paramname">only_free_dofs</td><td>Boolean indicating if the net generalized force and torque is to be computed only for free dofs of all bodies.</td></tr>
    <tr><td class="paramname">only_imposed_dofs</td><td>Boolean indicating if the net generalized force and torque is to be computed for imposed dofs of all bodies.</td></tr>
    <tr><td class="paramname">all_dofs</td><td>Boolean indicating if the net generalized force and torque is to be computed for all dofs of all bodies.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>User is responsible for setting correct number of subvecs in F that corresponds to the particular combination of booleans. </dd></dl>

</div>
</div>
<a id="a446a8e750171ee90f51658e645fc0bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446a8e750171ee90f51658e645fc0bc6">&#9670;&nbsp;</a></span>getNetRigidGeneralizedForce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a>&amp; IBAMR::CIBStrategy::getNetRigidGeneralizedForce </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The rigid part. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc476b84ad7a6b45321e48474992f7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc476b84ad7a6b45321e48474992f7ff">&#9670;&nbsp;</a></span>updateFreeDOFsMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::updateFreeDOFsMapping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46aa12a75eec15beeed92da1a05bf297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46aa12a75eec15beeed92da1a05bf297">&#9670;&nbsp;</a></span>updateNewRigidBodyVelocity() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::updateNewRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaadb163509d0ca86f327fa9e9580b529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaadb163509d0ca86f327fa9e9580b529">&#9670;&nbsp;</a></span>updateNewRigidBodyVelocity() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::updateNewRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01ba22af2d0b3afde292157273f933ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ba22af2d0b3afde292157273f933ff">&#9670;&nbsp;</a></span>updateNewRigidBodyVelocity() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::updateNewRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>only_free_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>only_imposed_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>all_dofs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5b924ba210e1f10cba28705f94015f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b924ba210e1f10cba28705f94015f2">&#9670;&nbsp;</a></span>copyVecToArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::copyVecToArray </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>data_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>array_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>PETSc Vec to copy from. The Vec stores data for nodal/marker points.</td></tr>
    <tr><td class="paramname">array</td><td>Data pointer to copy to.</td></tr>
    <tr><td class="paramname">struct_ids</td><td>Vector of structure indices.</td></tr>
    <tr><td class="paramname">data_depth</td><td>Depth of the data stored at each Lagrangian node.</td></tr>
    <tr><td class="paramname">array_rank</td><td>Rank of the processor on which the array is located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The size of <em>array</em> is assummed to be sum of nodes of all the structures given in <em>struct_ids</em> times the <em>data_depth</em>. </dd></dl>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#a2fefde49aaede47f291596c329e65653">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a05378698c6caf299c83d5a53e2a16199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05378698c6caf299c83d5a53e2a16199">&#9670;&nbsp;</a></span>copyFreeDOFsVecToArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::copyFreeDOFsVecToArray </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>array_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>PETSc Vec to copy from. The Vec stores only free DOFs of <em>all</em> the structures.</td></tr>
    <tr><td class="paramname">array</td><td>Data pointer to copy to. It is a linear array of maximum free DOFs of the passed structure IDs.</td></tr>
    <tr><td class="paramname">struct_ids</td><td>Vector of structure indices.</td></tr>
    <tr><td class="paramname">array_rank</td><td>Rank of the processor on which the array is located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The size of <em>array</em> is assummed to be sum of maximum number of free degrees of freedom of all the structures given in <em>struct_ids</em>. The caller is responsible for allocating and destroying array memory outside of this routine. </dd></dl>

</div>
</div>
<a id="a8da0e483af91e696d6105e5be771c0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da0e483af91e696d6105e5be771c0c4">&#9670;&nbsp;</a></span>copyArrayToVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::copyArrayToVec </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>data_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>array_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Copy to PETSc Vec.</td></tr>
    <tr><td class="paramname">array</td><td>Copy from data pointer.</td></tr>
    <tr><td class="paramname">struct_ids</td><td>Vector of structure indices.</td></tr>
    <tr><td class="paramname">data_depth</td><td>Depth of the data stored at each Lagrangian node.</td></tr>
    <tr><td class="paramname">array_rank</td><td>Rank of the processor on which the array is located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The size of <em>array</em> is assummed to be sum of nodes of all the structures given in <em>struct_ids</em> times the <em>data_depth</em>. The caller is responsible for allocating and destroying array memory outside of this routine. </dd></dl>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#aed267e3dc9ec08c21ea8bab8bf4bb7fd">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="af93ce15b714d03af6b80ba23dbaa5c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93ce15b714d03af6b80ba23dbaa5c79">&#9670;&nbsp;</a></span>copyFreeDOFsArrayToVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::copyFreeDOFsArrayToVec </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>array_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Copy to PETSc Vec. The Vec stores only free DOFs of <em>all</em> the structures.</td></tr>
    <tr><td class="paramname">array</td><td>Copy from data pointer. It is a linear array of maximum free DOFs of the passed structure IDs.</td></tr>
    <tr><td class="paramname">struct_ids</td><td>Vector of structure indices.</td></tr>
    <tr><td class="paramname">array_rank</td><td>Rank of the processor on which the array is located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The size of <em>array</em> is assummed to be sum of maximum number of free degrees of freedom of all the structures given in <em>struct_ids</em>. The caller is responsible for allocating and destroying array memory outside of this routine. </dd></dl>

</div>
</div>
<a id="a91d5b6beeee95b9e560871e271f0a42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d5b6beeee95b9e560871e271f0a42f">&#9670;&nbsp;</a></span>vecToRDV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IBAMR::CIBStrategy::vecToRDV </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Ur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96c3fa8472562a4d21f30e3a0a0c69c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c3fa8472562a4d21f30e3a0a0c69c7">&#9670;&nbsp;</a></span>rdvToVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IBAMR::CIBStrategy::rdvToVec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Ur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a630d7d9172d5a9284235783f238181cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630d7d9172d5a9284235783f238181cb">&#9670;&nbsp;</a></span>eigenToRDV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IBAMR::CIBStrategy::eigenToRDV </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>UW</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06ced3674edd5d2a7609789473496e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ced3674edd5d2a7609789473496e62">&#9670;&nbsp;</a></span>rdvToEigen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IBAMR::CIBStrategy::rdvToEigen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>UW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e57bb1d7568e9f2e1ba1954c603eb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e57bb1d7568e9f2e1ba1954c603eb35">&#9670;&nbsp;</a></span>getCurrentRigidBodyVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::getCurrentRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5eff8796b3637e0f4731b32762d9154f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eff8796b3637e0f4731b32762d9154f">&#9670;&nbsp;</a></span>getNewRigidBodyVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::getNewRigidBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a71594fce589c121dc7cb81f0ae8e8ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71594fce589c121dc7cb81f0ae8e8ef3">&#9670;&nbsp;</a></span>getCurrentBodyCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector3d&amp; IBAMR::CIBStrategy::getCurrentBodyCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a71cf057095365cb0a1bf0cb4ebe486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a71cf057095365cb0a1bf0cb4ebe486">&#9670;&nbsp;</a></span>getNewBodyCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector3d&amp; IBAMR::CIBStrategy::getNewBodyCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a169be9cab6a1917986d421d29dbe303d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169be9cab6a1917986d421d29dbe303d">&#9670;&nbsp;</a></span>constructMobilityMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::constructMobilityMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIBAMR.html#a591304f336aef144a5ae4595cffc3f70">MobilityMatrixType</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>mobility_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>prototype_struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>grid_dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>domain_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>f_periodic_corr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>managing_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>A default empty implementation is provided in this class. The derived class provides the actual implementation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_name</td><td>Matrix handle.</td></tr>
    <tr><td class="paramname">mat_type</td><td>Mobility matrix type, e.g., RPY, EMPIRICAL, etc.</td></tr>
    <tr><td class="paramname">mobility_mat</td><td>Dense sequential mobility matrix. The matrix is stored in column-major(FORTRAN) order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Must be allocated prior to entering this routine.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prototype_struct_ids</td><td>Indices of the structures as registered with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classIBAMR_1_1IBStrategy.html" title="Class IBStrategy provides a generic interface for specifying the implementation details of a particul...">IBAMR::IBStrategy</a> class. A combined dense mobility matrix will formed for multiple structures.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid_dx</td><td>NDIM vector of grid spacing of structure level.</td></tr>
    <tr><td class="paramname">domain_extents</td><td>NDIM vector of domain length.</td></tr>
    <tr><td class="paramname">initial_time</td><td>Boolean to indicate if the mobility matrix is to be generated for the initial position of the structures.</td></tr>
    <tr><td class="paramname">rho</td><td>Fluid density</td></tr>
    <tr><td class="paramname">mu</td><td>Fluid viscosity.</td></tr>
    <tr><td class="paramname">scale</td><td>Scale for improving the conditioning number of dense mobility matrix. The matrix is scaled as: \( = \alpha * mobility_mat + \beta * identity_mat. \)</td></tr>
    <tr><td class="paramname">managing_rank</td><td>Rank of the processor managing this dense matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#a7a6d6ef7fa9cfcc376571763c27f5375">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a6ca98046bbb01951fd5cc687148f59c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca98046bbb01951fd5cc687148f59c9">&#9670;&nbsp;</a></span>constructGeometricMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::constructGeometricMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>geometric_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>prototype_struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>managing_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>A default empty implementation is provided in this class. The derived class provides the actual implementation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_name</td><td>Matrix handle.</td></tr>
    <tr><td class="paramname">geometric_mat</td><td>Dense sequential geometric matrix. The matrix is stored in column-major(FORTRAN) order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Must be allocated prior to entering this routine.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prototype_struct_ids</td><td>Indices of the structures as registered with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classIBAMR_1_1IBStrategy.html" title="Class IBStrategy provides a generic interface for specifying the implementation details of a particul...">IBAMR::IBStrategy</a> class. A combined block-diagonal geometric matrix will be formed for multiple structures.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_time</td><td>Boolean to indicate if the corresponding geometric matrix is to be generated for the initial position of the structures.</td></tr>
    <tr><td class="paramname">managing_rank</td><td>Rank of the processor managing this dense matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#a649e4ca9381f49dc39a90b7411fccd3a">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a37efaea07ac44c8caf881723adc972e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37efaea07ac44c8caf881723adc972e4">&#9670;&nbsp;</a></span>rotateArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBAMR::CIBStrategy::rotateArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>struct_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_transpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>managing_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Raw data pointer containing the vector enteries.</td></tr>
    <tr><td class="paramname">struct_ids</td><td>Structure ID indices.</td></tr>
    <tr><td class="paramname">use_transpose</td><td>Use transpose of rotation matrix to rotate the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Transpose of rotation matrix is its inverse and it takes the vector back to its reference frame.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">managing_rank</td><td>Rank of the processor managing the matrix.</td></tr>
    <tr><td class="paramname">depth</td><td>Depth of the data array components. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classIBAMR_1_1CIBMethod.html#aa5361e9c9f9875c55a82c6185886592b">IBAMR::CIBMethod</a>.</p>

</div>
</div>
<a id="a087733d93ea9af2d37c730dbb86f83a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087733d93ea9af2d37c730dbb86f83a2">&#9670;&nbsp;</a></span>setRotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBAMR::CIBStrategy::setRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>rot_vel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Quaterniond &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Quaterniond &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Matrix3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>rot_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_old</td><td>Previous applied quaternion. </td></tr>
    <tr><td class="paramname">q_new</td><td>New quaternion to set. </td></tr>
    <tr><td class="paramname">rot_mat</td><td>Matrix to set. </td></tr>
    <tr><td class="paramname">dt</td><td>Time interval of rotation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4292fedb63d60a4071f09f0df309ce16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4292fedb63d60a4071f09f0df309ce16">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBAMR_1_1CIBStrategy.html">CIBStrategy</a>&amp; IBAMR::CIBStrategy::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIBAMR_1_1CIBStrategy.html">CIBStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This operator is not implemented and should not be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>The value to assign to this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a78c7b5094d5a3d78ea27f119d13a84cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c7b5094d5a3d78ea27f119d13a84cb">&#9670;&nbsp;</a></span>d_num_rigid_parts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> IBAMR::CIBStrategy::d_num_rigid_parts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9605c08a1475a205eff9afe1aa6a6697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9605c08a1475a205eff9afe1aa6a6697">&#9670;&nbsp;</a></span>d_center_of_mass_initial</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_center_of_mass_initial</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Center of mass. </p>

</div>
</div>
<a id="abe66c1c916ebf8cc41a50e0d176de75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe66c1c916ebf8cc41a50e0d176de75a">&#9670;&nbsp;</a></span>d_center_of_mass_current</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_center_of_mass_current</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ac8a64acf8f7af721cad92aee80bbb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac8a64acf8f7af721cad92aee80bbb1">&#9670;&nbsp;</a></span>d_center_of_mass_half</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_center_of_mass_half</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7c8cc709ffdd9adb602d079665fcf48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c8cc709ffdd9adb602d079665fcf48">&#9670;&nbsp;</a></span>d_center_of_mass_new</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_center_of_mass_new</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5b378a544fd6b8a871abe3ec3807d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b378a544fd6b8a871abe3ec3807d98">&#9670;&nbsp;</a></span>d_compute_center_of_mass_initial</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; IBAMR::CIBStrategy::d_compute_center_of_mass_initial</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af0997a2def8f09191bfa55a29e90c969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0997a2def8f09191bfa55a29e90c969">&#9670;&nbsp;</a></span>d_quaternion_current</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Quaterniond&gt; IBAMR::CIBStrategy::d_quaternion_current</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Quaternion of the body. </p>

</div>
</div>
<a id="ac429d5ed3731531af860043d007aec6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac429d5ed3731531af860043d007aec6a">&#9670;&nbsp;</a></span>d_quaternion_half</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Quaterniond&gt; IBAMR::CIBStrategy::d_quaternion_half</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac219c2dad3198f4452eb91caa19d2d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac219c2dad3198f4452eb91caa19d2d80">&#9670;&nbsp;</a></span>d_quaternion_new</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Quaterniond&gt; IBAMR::CIBStrategy::d_quaternion_new</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adfd7755ec6ff2466d39205ba1eb007fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd7755ec6ff2466d39205ba1eb007fe">&#9670;&nbsp;</a></span>d_solve_rigid_vel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceIBTK.html#aac19301c6fd0897bd5254ffad040e24c">IBTK::FRDV</a>&gt; IBAMR::CIBStrategy::d_solve_rigid_vel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab22ae8b85ca8df0fd9b812fdb4b5692b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22ae8b85ca8df0fd9b812fdb4b5692b">&#9670;&nbsp;</a></span>d_U</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vec IBAMR::CIBStrategy::d_U</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08b7f78c9725bab72d66fbe6af279fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b7f78c9725bab72d66fbe6af279fea">&#9670;&nbsp;</a></span>d_F</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vec IBAMR::CIBStrategy::d_F</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b7fd46d9caa77a2a5c73d300fecc1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7fd46d9caa77a2a5c73d300fecc1ac">&#9670;&nbsp;</a></span>d_free_dofs_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;<a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>&gt; &gt; IBAMR::CIBStrategy::d_free_dofs_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab07a284a69aeca5ca96bf5b973e79ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07a284a69aeca5ca96bf5b973e79ebf">&#9670;&nbsp;</a></span>d_free_dofs_map_updated</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBAMR::CIBStrategy::d_free_dofs_map_updated</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f327733ed226b3dab4570a091b8f320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f327733ed226b3dab4570a091b8f320">&#9670;&nbsp;</a></span>d_trans_vel_current</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_trans_vel_current</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rigid body velocity of the structures. </p>

</div>
</div>
<a id="a8aec9a253505c8aec29c7fa61d1fb679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aec9a253505c8aec29c7fa61d1fb679">&#9670;&nbsp;</a></span>d_trans_vel_half</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_trans_vel_half</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a72aa507b4762f5e2ab47f04b7c7a975f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aa507b4762f5e2ab47f04b7c7a975f">&#9670;&nbsp;</a></span>d_trans_vel_new</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_trans_vel_new</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a84feb76bf0b3cdfdcbffab8d876cde9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84feb76bf0b3cdfdcbffab8d876cde9f">&#9670;&nbsp;</a></span>d_rot_vel_current</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_rot_vel_current</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3afc85a233ca21712f4ad4e785676083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afc85a233ca21712f4ad4e785676083">&#9670;&nbsp;</a></span>d_rot_vel_half</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_rot_vel_half</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d45fbba4a53b330b711f8e1eb869dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d45fbba4a53b330b711f8e1eb869dbb">&#9670;&nbsp;</a></span>d_rot_vel_new</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; IBAMR::CIBStrategy::d_rot_vel_new</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a571c74a9f31de87ea505275f416f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a571c74a9f31de87ea505275f416f7e">&#9670;&nbsp;</a></span>d_net_rigid_generalized_force</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceIBTK.html#a0d5c7844e08cab1447e1ce7423a5fa3c">IBTK::RigidDOFVector</a>&gt; IBAMR::CIBStrategy::d_net_rigid_generalized_force</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ibamr/<a class="el" href="CIBStrategy_8h.html">CIBStrategy.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
