<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: IBTK::FEDataManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IBAMR
   &#160;<span id="projectnumber">IBAMR version 0.18.</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceIBTK.html">IBTK</a></li><li class="navelem"><a class="el" href="classIBTK_1_1FEDataManager.html">FEDataManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classIBTK_1_1FEDataManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IBTK::FEDataManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class <a class="el" href="classIBTK_1_1FEDataManager.html" title="Class FEDataManager coordinates data required for Lagrangian-Eulerian interaction between a Lagrangia...">FEDataManager</a> coordinates data required for Lagrangian-Eulerian interaction between a Lagrangian finite element (FE) mesh. In particular, the <a class="el" href="classIBTK_1_1FEData.html">FEData</a> member object stores the necessary finite element data while this class stores additional data dependent on the Eulerian grid.  
 <a href="classIBTK_1_1FEDataManager.html#details">More...</a></p>

<p><code>#include &lt;ibtk/FEDataManager.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IBTK::FEDataManager:</div>
<div class="dyncontent">
<div class="center"><img src="classIBTK_1_1FEDataManager__inherit__graph.png" border="0" usemap="#IBTK_1_1FEDataManager_inherit__map" alt="Inheritance graph"/></div>
<map name="IBTK_1_1FEDataManager_inherit__map" id="IBTK_1_1FEDataManager_inherit__map">
<area shape="rect" title="Class FEDataManager coordinates data required for Lagrangian&#45;Eulerian interaction between a Lagrangia..." alt="" coords="33,155,197,181"/>
<area shape="rect" href="classSAMRAI_1_1tbox_1_1Serializable.html" title=" " alt="" coords="17,80,212,107"/>
<area shape="rect" href="classSAMRAI_1_1tbox_1_1DescribedClass.html" title="Base class for all objects that use run&#45;time type identification (RTTI)." alt="" coords="5,5,224,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">InterpSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct <a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html" title="Struct InterpSpec encapsulates data needed to specify the manner in which Eulerian-to-Lagrangian inte...">InterpSpec</a> encapsulates data needed to specify the manner in which Eulerian-to-Lagrangian interpolation is performed when using an FE structural discretization.  <a href="structIBTK_1_1FEDataManager_1_1InterpSpec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">SpreadSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct <a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html" title="Struct SpreadSpec encapsulates data needed to specify the manner in which Lagrangian-to-Eulerian spre...">SpreadSpec</a> encapsulates data needed to specify the manner in which Lagrangian-to-Eulerian spreading is performed when using an FE structural discretization.  <a href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIBTK_1_1FEDataManager_1_1WorkloadSpec.html">WorkloadSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct <a class="el" href="structIBTK_1_1FEDataManager_1_1WorkloadSpec.html" title="Struct WorkloadSpec encapsulates the parameters used to calculate workload estimates (i....">WorkloadSpec</a> encapsulates the parameters used to calculate workload estimates (i.e., the input to the load balancing algorithm).  <a href="structIBTK_1_1FEDataManager_1_1WorkloadSpec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a11864a323c95e0830a6df1723ae9a1b2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a11864a323c95e0830a6df1723ae9a1b2">SystemDofMapCache</a> = <a class="el" href="classIBTK_1_1FEData_1_1SystemDofMapCache.html">FEData::SystemDofMapCache</a></td></tr>
<tr class="separator:a11864a323c95e0830a6df1723ae9a1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9aa705d9140f2a71d314d8fe76bfe0ca"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a9aa705d9140f2a71d314d8fe76bfe0ca">getCurrentCoordinatesSystemName</a> () const</td></tr>
<tr class="memdesc:a9aa705d9140f2a71d314d8fe76bfe0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the equation system which stores the spatial position data. The actual string is stored by <a class="el" href="classIBTK_1_1FEData.html">FEData</a>.  <a href="classIBTK_1_1FEDataManager.html#a9aa705d9140f2a71d314d8fe76bfe0ca">More...</a><br /></td></tr>
<tr class="separator:a9aa705d9140f2a71d314d8fe76bfe0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fafe40cb41eba8ad2ea8b09c790dfc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a0fafe40cb41eba8ad2ea8b09c790dfc7">setCurrentCoordinatesSystemName</a> (const std::string &amp;coordinates_system_name) const</td></tr>
<tr class="memdesc:a0fafe40cb41eba8ad2ea8b09c790dfc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set name of the equation system which stores the spatial position data. The actual string is stored by <a class="el" href="classIBTK_1_1FEData.html">FEData</a>.  <a href="classIBTK_1_1FEDataManager.html#a0fafe40cb41eba8ad2ea8b09c790dfc7">More...</a><br /></td></tr>
<tr class="separator:a0fafe40cb41eba8ad2ea8b09c790dfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab2051403b2a6d0038cb5792c0017e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a7ab2051403b2a6d0038cb5792c0017e1">setEquationSystems</a> (libMesh::EquationSystems *equation_systems, <a class="el" href="classint.html">int</a> level_number)</td></tr>
<tr class="memdesc:a7ab2051403b2a6d0038cb5792c0017e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the equations systems object that is associated with the <a class="el" href="classIBTK_1_1FEData.html">FEData</a> object. Currently, each set of equation systems must be assigned to a particular level of the AMR grid.  <a href="classIBTK_1_1FEDataManager.html#a7ab2051403b2a6d0038cb5792c0017e1">More...</a><br /></td></tr>
<tr class="separator:a7ab2051403b2a6d0038cb5792c0017e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f2bc7d060607618186adc9b29a9777"><td class="memItemLeft" align="right" valign="top">libMesh::EquationSystems *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#af0f2bc7d060607618186adc9b29a9777">getEquationSystems</a> () const</td></tr>
<tr class="separator:af0f2bc7d060607618186adc9b29a9777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280118f8a7501220be6892e8592a0436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBTK_1_1FEDataManager.html#a11864a323c95e0830a6df1723ae9a1b2">SystemDofMapCache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a280118f8a7501220be6892e8592a0436">getDofMapCache</a> (const std::string &amp;system_name)</td></tr>
<tr class="separator:a280118f8a7501220be6892e8592a0436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a6afa06b795fd8827bd48c07bbc77d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBTK_1_1FEDataManager.html#a11864a323c95e0830a6df1723ae9a1b2">SystemDofMapCache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a82a6afa06b795fd8827bd48c07bbc77d">getDofMapCache</a> (unsigned <a class="el" href="classint.html">int</a> system_num)</td></tr>
<tr class="separator:a82a6afa06b795fd8827bd48c07bbc77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e5d4a3e7063e2e25890d6d4a44875e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ac3e5d4a3e7063e2e25890d6d4a44875e">setLoggingEnabled</a> (<a class="el" href="classbool.html">bool</a> enable_logging=true)</td></tr>
<tr class="memdesc:ac3e5d4a3e7063e2e25890d6d4a44875e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable logging.  <a href="classIBTK_1_1FEDataManager.html#ac3e5d4a3e7063e2e25890d6d4a44875e">More...</a><br /></td></tr>
<tr class="separator:ac3e5d4a3e7063e2e25890d6d4a44875e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3ded192467edb5d1767057a0356d28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#aae3ded192467edb5d1767057a0356d28">getLoggingEnabled</a> () const</td></tr>
<tr class="memdesc:aae3ded192467edb5d1767057a0356d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether logging is enabled or disabled.  <a href="classIBTK_1_1FEDataManager.html#aae3ded192467edb5d1767057a0356d28">More...</a><br /></td></tr>
<tr class="separator:aae3ded192467edb5d1767057a0356d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae28ef5e4f2d472abdf0a961f8d2b6bd7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classIBTK_1_1FEDataManager.html">FEDataManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ae28ef5e4f2d472abdf0a961f8d2b6bd7">getManager</a> (std::shared_ptr&lt; <a class="el" href="classIBTK_1_1FEData.html">FEData</a> &gt; fe_data, const std::string &amp;name, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; &amp;input_db, const <a class="el" href="classint.html">int</a> max_levels, const <a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">InterpSpec</a> &amp;default_interp_spec, const <a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">SpreadSpec</a> &amp;default_spread_spec, const <a class="el" href="structIBTK_1_1FEDataManager_1_1WorkloadSpec.html">WorkloadSpec</a> &amp;default_workload_spec, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;min_ghost_width=<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt;(0), std::shared_ptr&lt; <a class="el" href="classIBTK_1_1SAMRAIDataCache.html">SAMRAIDataCache</a> &gt; eulerian_data_cache=nullptr, <a class="el" href="classbool.html">bool</a> register_for_restart=true)</td></tr>
<tr class="separator:ae28ef5e4f2d472abdf0a961f8d2b6bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df5834ff41ddf74a0f438dcb22940b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a4df5834ff41ddf74a0f438dcb22940b7">freeAllManagers</a> ()</td></tr>
<tr class="separator:a4df5834ff41ddf74a0f438dcb22940b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a450f2ab850794758221e91baba82c9a7"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a450f2ab850794758221e91baba82c9a7">COORDINATES_SYSTEM_NAME</a></td></tr>
<tr class="memdesc:a450f2ab850794758221e91baba82c9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the equation system which stores the spatial position data. The actual string is stored by <a class="el" href="classIBTK_1_1FEData.html">FEData</a>.  <a href="classIBTK_1_1FEDataManager.html#a450f2ab850794758221e91baba82c9a7">More...</a><br /></td></tr>
<tr class="separator:a450f2ab850794758221e91baba82c9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac4ee2a95496546d7d4812e34847c4680"><td class="memItemLeft" align="right" valign="top">static const libMesh::boundary_id_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ac4ee2a95496546d7d4812e34847c4680">ZERO_DISPLACEMENT_X_BDRY_ID</a></td></tr>
<tr class="memdesc:ac4ee2a95496546d7d4812e34847c4680"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespacelibMesh.html">libMesh</a> boundary IDs to use for specifying essential boundary conditions.  <a href="classIBTK_1_1FEDataManager.html#ac4ee2a95496546d7d4812e34847c4680">More...</a><br /></td></tr>
<tr class="separator:ac4ee2a95496546d7d4812e34847c4680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e586810f0eeebff95ac938a5f24ed39"><td class="memItemLeft" align="right" valign="top">static const libMesh::boundary_id_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a8e586810f0eeebff95ac938a5f24ed39">ZERO_DISPLACEMENT_Y_BDRY_ID</a></td></tr>
<tr class="separator:a8e586810f0eeebff95ac938a5f24ed39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245efaf42da4a5debdfd9fa5d77334ec"><td class="memItemLeft" align="right" valign="top">static const libMesh::boundary_id_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a245efaf42da4a5debdfd9fa5d77334ec">ZERO_DISPLACEMENT_Z_BDRY_ID</a></td></tr>
<tr class="separator:a245efaf42da4a5debdfd9fa5d77334ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c7db6e07d8b71e0e66d3c6a7864b8e"><td class="memItemLeft" align="right" valign="top">static const libMesh::boundary_id_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a80c7db6e07d8b71e0e66d3c6a7864b8e">ZERO_DISPLACEMENT_XY_BDRY_ID</a></td></tr>
<tr class="separator:a80c7db6e07d8b71e0e66d3c6a7864b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac971b56547b458c33cf2450ee2a2c99e"><td class="memItemLeft" align="right" valign="top">static const libMesh::boundary_id_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ac971b56547b458c33cf2450ee2a2c99e">ZERO_DISPLACEMENT_XZ_BDRY_ID</a></td></tr>
<tr class="separator:ac971b56547b458c33cf2450ee2a2c99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793eafb8efdc3de0b411ae8614e1084b"><td class="memItemLeft" align="right" valign="top">static const libMesh::boundary_id_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a793eafb8efdc3de0b411ae8614e1084b">ZERO_DISPLACEMENT_YZ_BDRY_ID</a></td></tr>
<tr class="separator:a793eafb8efdc3de0b411ae8614e1084b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb033bb232f10033d603c9d81c714acb"><td class="memItemLeft" align="right" valign="top">static const libMesh::boundary_id_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#acb033bb232f10033d603c9d81c714acb">ZERO_DISPLACEMENT_XYZ_BDRY_ID</a></td></tr>
<tr class="separator:acb033bb232f10033d603c9d81c714acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a46ad4df2258656ae6d77d14e0326bd04"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classIBTK_1_1FEData.html">FEData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a46ad4df2258656ae6d77d14e0326bd04">d_fe_data</a></td></tr>
<tr class="separator:a46ad4df2258656ae6d77d14e0326bd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59687d321608e53ee79077b9f56102e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classIBTK_1_1FEProjector.html">FEProjector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ad59687d321608e53ee79077b9f56102e">d_fe_projector</a></td></tr>
<tr class="separator:ad59687d321608e53ee79077b9f56102e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af894887cefa006c2d9cb517867d18617"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::unique_ptr&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#af894887cefa006c2d9cb517867d18617">d_L2_proj_matrix_diag_ghost</a></td></tr>
<tr class="separator:af894887cefa006c2d9cb517867d18617"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Methods to set and get the patch hierarchy and range of patch</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp857dc8ff43dbf6f11c88be587bf5a7d2"></a>levels associated with this manager class. </p>
</td></tr>
<tr class="memitem:adadb1d47428c3a4d58a1a1d57d5428b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBTK_1_1SubdomainToPatchLevelTranslation.html">SubdomainToPatchLevelTranslation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#adadb1d47428c3a4d58a1a1d57d5428b5">d_level_lookup</a></td></tr>
<tr class="separator:adadb1d47428c3a4d58a1a1d57d5428b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2381d39e94788aa41d0f90cf8558f187"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a2381d39e94788aa41d0f90cf8558f187">d_object_name</a></td></tr>
<tr class="separator:a2381d39e94788aa41d0f90cf8558f187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cb941f86e343dee24e2b78198e7a0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a82cb941f86e343dee24e2b78198e7a0c">d_registered_for_restart</a></td></tr>
<tr class="separator:a82cb941f86e343dee24e2b78198e7a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35c615c7b1eca329b08c8a59899da8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ad35c615c7b1eca329b08c8a59899da8b">d_enable_logging</a> = false</td></tr>
<tr class="separator:ad35c615c7b1eca329b08c8a59899da8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f0e07478c4a2890f12cbd223fb50e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a04f0e07478c4a2890f12cbd223fb50e8">d_hierarchy</a></td></tr>
<tr class="separator:a04f0e07478c4a2890f12cbd223fb50e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a9d16906880a8fac5f22d3814776ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a18a9d16906880a8fac5f22d3814776ee">d_max_level_number</a> = <a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">IBTK::invalid_level_number</a></td></tr>
<tr class="separator:a18a9d16906880a8fac5f22d3814776ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf901fddc8f1ff70875f0dc624901145"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classIBTK_1_1SAMRAIDataCache.html">SAMRAIDataCache</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#aaf901fddc8f1ff70875f0dc624901145">d_eulerian_data_cache</a></td></tr>
<tr class="separator:aaf901fddc8f1ff70875f0dc624901145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2855ef88a50e0d541cb2af01db20fb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">SAMRAI::hier::VariableContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#af2855ef88a50e0d541cb2af01db20fb1">d_context</a></td></tr>
<tr class="separator:af2855ef88a50e0d541cb2af01db20fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac739b5015590b7883de7f5b50b446bf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt; NDIM, <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ac739b5015590b7883de7f5b50b446bf8">d_qp_count_var</a></td></tr>
<tr class="separator:ac739b5015590b7883de7f5b50b446bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d29ec75435f0de5203520c7ceb1fef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a41d29ec75435f0de5203520c7ceb1fef">d_qp_count_idx</a></td></tr>
<tr class="separator:a41d29ec75435f0de5203520c7ceb1fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdee82e550c721afd1a45ef828cfe78a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structIBTK_1_1FEDataManager_1_1WorkloadSpec.html">WorkloadSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#afdee82e550c721afd1a45ef828cfe78a">d_default_workload_spec</a></td></tr>
<tr class="separator:afdee82e550c721afd1a45ef828cfe78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68d1a92b645f65b9f923fef22ed28a1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">InterpSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ab68d1a92b645f65b9f923fef22ed28a1">d_default_interp_spec</a></td></tr>
<tr class="separator:ab68d1a92b645f65b9f923fef22ed28a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9fbe4842dfc614049ce7e4a5201015"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">SpreadSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#aaf9fbe4842dfc614049ce7e4a5201015">d_default_spread_spec</a></td></tr>
<tr class="separator:aaf9fbe4842dfc614049ce7e4a5201015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714ce1ada783d89b4e974fc9786d0355"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIBTK.html#a4f11b6d5086d88dfb13c1518bf8b6afd">NodeOutsidePatchCheckType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a714ce1ada783d89b4e974fc9786d0355">d_node_patch_check</a> = <a class="el" href="namespaceIBTK.html#a4f11b6d5086d88dfb13c1518bf8b6afda3ac623c23d3170654eb95589df58b3d3">NODE_OUTSIDE_ERROR</a></td></tr>
<tr class="separator:a714ce1ada783d89b4e974fc9786d0355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75d28d4330d6295bc0775443aa83915"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ac75d28d4330d6295bc0775443aa83915">d_ghost_width</a></td></tr>
<tr class="separator:ac75d28d4330d6295bc0775443aa83915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af61a3c3d1a47310488126a1bc2b822"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a5af61a3c3d1a47310488126a1bc2b822">d_associated_elem_ghost_width</a> = <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt;NDIM&gt;(1)</td></tr>
<tr class="separator:a5af61a3c3d1a47310488126a1bc2b822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a9a1ad285cc9c0ac2dec03fb9d7598"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; libMesh::Elem * &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ab8a9a1ad285cc9c0ac2dec03fb9d7598">d_active_patch_elem_map</a></td></tr>
<tr class="separator:ab8a9a1ad285cc9c0ac2dec03fb9d7598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e60ee2ea02f09ef44bb679c7eea90ba"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; libMesh::Node * &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a3e60ee2ea02f09ef44bb679c7eea90ba">d_active_patch_node_map</a></td></tr>
<tr class="separator:a3e60ee2ea02f09ef44bb679c7eea90ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec1274a43f69195addbe38edaff0614"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a9ec1274a43f69195addbe38edaff0614">d_active_patch_ghost_dofs</a></td></tr>
<tr class="separator:a9ec1274a43f69195addbe38edaff0614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d238fa770ff7b304a423d0f9c4e77bb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libMesh::Elem * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a8d238fa770ff7b304a423d0f9c4e77bb">d_active_elems</a></td></tr>
<tr class="separator:a8d238fa770ff7b304a423d0f9c4e77bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fb3d692d682d10fa81120cc3b5b4c1"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::unique_ptr&lt; <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a13fb3d692d682d10fa81120cc3b5b4c1">d_system_ghost_vec</a></td></tr>
<tr class="separator:a13fb3d692d682d10fa81120cc3b5b4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fbdf05a7919c9e691a8936fb106c1e"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::unique_ptr&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a91fbdf05a7919c9e691a8936fb106c1e">d_system_ib_ghost_vec</a></td></tr>
<tr class="separator:a91fbdf05a7919c9e691a8936fb106c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7636c790a5718525b23180e916434579"><td class="memItemLeft" align="right" valign="top">static std::map&lt; std::string, <a class="el" href="classIBTK_1_1FEDataManager.html">FEDataManager</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a7636c790a5718525b23180e916434579">s_data_manager_instances</a></td></tr>
<tr class="separator:a7636c790a5718525b23180e916434579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55eeadf37c8e52b627c6704ae8fdee5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ad55eeadf37c8e52b627c6704ae8fdee5">s_registered_callback</a></td></tr>
<tr class="separator:ad55eeadf37c8e52b627c6704ae8fdee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd28fa43b498507df4ffaf1c4f51dc51"><td class="memItemLeft" align="right" valign="top">static unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#abd28fa43b498507df4ffaf1c4f51dc51">s_shutdown_priority</a></td></tr>
<tr class="separator:abd28fa43b498507df4ffaf1c4f51dc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd0c81a11489e5d334cafa744253e70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a7cd0c81a11489e5d334cafa744253e70">setPatchHierarchy</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy)</td></tr>
<tr class="memdesc:a7cd0c81a11489e5d334cafa744253e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset patch hierarchy over which operations occur.  <a href="classIBTK_1_1FEDataManager.html#a7cd0c81a11489e5d334cafa744253e70">More...</a><br /></td></tr>
<tr class="separator:a7cd0c81a11489e5d334cafa744253e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d6cdb72bed5c8b6e577b098d11a756"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ab6d6cdb72bed5c8b6e577b098d11a756">getPatchHierarchy</a> () const</td></tr>
<tr class="memdesc:ab6d6cdb72bed5c8b6e577b098d11a756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the patch hierarchy used by this object.  <a href="classIBTK_1_1FEDataManager.html#ab6d6cdb72bed5c8b6e577b098d11a756">More...</a><br /></td></tr>
<tr class="separator:ab6d6cdb72bed5c8b6e577b098d11a756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfe3ea5aca154ff5b05aaff0808fc49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#acdfe3ea5aca154ff5b05aaff0808fc49">getCoarsestPatchLevelNumber</a> () const</td></tr>
<tr class="separator:acdfe3ea5aca154ff5b05aaff0808fc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81005b53844fc5bde5abf2dbd9353899"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a81005b53844fc5bde5abf2dbd9353899">getFinestPatchLevelNumber</a> () const</td></tr>
<tr class="separator:a81005b53844fc5bde5abf2dbd9353899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71c8cbccae20e05e087d8cd5e030c29"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ab71c8cbccae20e05e087d8cd5e030c29">getGhostCellWidth</a> () const</td></tr>
<tr class="separator:ab71c8cbccae20e05e087d8cd5e030c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58d7d850df96dd15f9168d79b61688e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">InterpSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ab58d7d850df96dd15f9168d79b61688e">getDefaultInterpSpec</a> () const</td></tr>
<tr class="separator:ab58d7d850df96dd15f9168d79b61688e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53be46bc2d79c337691f9ccefabee1f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">SpreadSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ad53be46bc2d79c337691f9ccefabee1f">getDefaultSpreadSpec</a> () const</td></tr>
<tr class="separator:ad53be46bc2d79c337691f9ccefabee1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe809fa165fc50e79644f179d409d7e"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; libMesh::Elem * &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#adfe809fa165fc50e79644f179d409d7e">getActivePatchElementMap</a> () const</td></tr>
<tr class="separator:adfe809fa165fc50e79644f179d409d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b993111e30386cc94f074be9be15dc0"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; libMesh::Node * &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a9b993111e30386cc94f074be9be15dc0">getActivePatchNodeMap</a> () const</td></tr>
<tr class="separator:a9b993111e30386cc94f074be9be15dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d232e10e554539a93a127e02a48dc21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a3d232e10e554539a93a127e02a48dc21">reinitElementMappings</a> ()</td></tr>
<tr class="memdesc:a3d232e10e554539a93a127e02a48dc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize the mappings from elements to Cartesian grid patches.  <a href="classIBTK_1_1FEDataManager.html#a3d232e10e554539a93a127e02a48dc21">More...</a><br /></td></tr>
<tr class="separator:a3d232e10e554539a93a127e02a48dc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd0135c430174915d9a3551c3beaa65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a5cd0135c430174915d9a3551c3beaa65">getSolutionVector</a> (const std::string &amp;system_name) const</td></tr>
<tr class="separator:a5cd0135c430174915d9a3551c3beaa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3129f3a1db8388b73d88854b7a7fe6d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a3129f3a1db8388b73d88854b7a7fe6d0">buildGhostedSolutionVector</a> (const std::string &amp;system_name, <a class="el" href="classbool.html">bool</a> localize_data=true)</td></tr>
<tr class="separator:a3129f3a1db8388b73d88854b7a7fe6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc97e66df1b188312235dc8b6a2c58b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a6dc97e66df1b188312235dc8b6a2c58b">buildIBGhostedVector</a> (const std::string &amp;system_name)</td></tr>
<tr class="separator:a6dc97e66df1b188312235dc8b6a2c58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc2d33c02ac14e7e36eb8df1da84474"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a8cc2d33c02ac14e7e36eb8df1da84474">getCoordsVector</a> () const</td></tr>
<tr class="separator:a8cc2d33c02ac14e7e36eb8df1da84474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1074e8ca27c8501cf47fb03c1443e50a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a1074e8ca27c8501cf47fb03c1443e50a">buildGhostedCoordsVector</a> (<a class="el" href="classbool.html">bool</a> localize_data=true)</td></tr>
<tr class="separator:a1074e8ca27c8501cf47fb03c1443e50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bfe491931ccf62ead4f208f6884e59"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classIBTK_1_1FEData.html">FEData</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#aa0bfe491931ccf62ead4f208f6884e59">getFEData</a> ()</td></tr>
<tr class="separator:aa0bfe491931ccf62ead4f208f6884e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10efefed973472ec9b819b6ae6d5492"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classIBTK_1_1FEData.html">FEData</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#aa10efefed973472ec9b819b6ae6d5492">getFEData</a> () const</td></tr>
<tr class="separator:aa10efefed973472ec9b819b6ae6d5492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee2005092bda7e38759f8c28c609d90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a1ee2005092bda7e38759f8c28c609d90">spread</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X, const std::string &amp;system_name)</td></tr>
<tr class="memdesc:a1ee2005092bda7e38759f8c28c609d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spread a density from the FE mesh to the Cartesian grid using the default spreading spec.  <a href="classIBTK_1_1FEDataManager.html#a1ee2005092bda7e38759f8c28c609d90">More...</a><br /></td></tr>
<tr class="separator:a1ee2005092bda7e38759f8c28c609d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8198f8cf9fb226a442280d3b5bf8088f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a8198f8cf9fb226a442280d3b5bf8088f">spread</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X, const std::string &amp;system_name, const <a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">SpreadSpec</a> &amp;spread_spec)</td></tr>
<tr class="memdesc:a8198f8cf9fb226a442280d3b5bf8088f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spread a density from the FE mesh to the Cartesian grid.  <a href="classIBTK_1_1FEDataManager.html#a8198f8cf9fb226a442280d3b5bf8088f">More...</a><br /></td></tr>
<tr class="separator:a8198f8cf9fb226a442280d3b5bf8088f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137108543cafe18e8535e917ff375586"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a137108543cafe18e8535e917ff375586">spread</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X, const std::string &amp;system_name, <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *f_phys_bdry_op, <a class="el" href="classdouble.html">double</a> fill_data_time, <a class="el" href="classbool.html">bool</a> close_F=true, <a class="el" href="classbool.html">bool</a> close_X=true)</td></tr>
<tr class="memdesc:a137108543cafe18e8535e917ff375586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spread a density from the FE mesh to the Cartesian grid using the default spreading spec. This is a convenience overload of spread where <code>f_phys_bdry_op</code> is used to correctly accumulate force values spread outside the physical domain into it.  <a href="classIBTK_1_1FEDataManager.html#a137108543cafe18e8535e917ff375586">More...</a><br /></td></tr>
<tr class="separator:a137108543cafe18e8535e917ff375586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165498e1d6e45be24d5fb21f96d71cf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a165498e1d6e45be24d5fb21f96d71cf6">spread</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X, const std::string &amp;system_name, const <a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">SpreadSpec</a> &amp;spread_spec, <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *f_phys_bdry_op, <a class="el" href="classdouble.html">double</a> fill_data_time, <a class="el" href="classbool.html">bool</a> close_F=true, <a class="el" href="classbool.html">bool</a> close_X=true)</td></tr>
<tr class="memdesc:a165498e1d6e45be24d5fb21f96d71cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spread a density from the FE mesh to the Cartesian grid using a specified spreading spec. This is a convenience overload of spread where <code>f_phys_bdry_op</code> is used to correctly accumulate force values spread outside the physical domain into it.  <a href="classIBTK_1_1FEDataManager.html#a165498e1d6e45be24d5fb21f96d71cf6">More...</a><br /></td></tr>
<tr class="separator:a165498e1d6e45be24d5fb21f96d71cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799acbf460e4e1df9fb2ebdc8ac59469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a799acbf460e4e1df9fb2ebdc8ac59469">prolongData</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X, const std::string &amp;system_name, <a class="el" href="classbool.html">bool</a> is_density=true, <a class="el" href="classbool.html">bool</a> accumulate_on_grid=true, <a class="el" href="classbool.html">bool</a> close_F=true, <a class="el" href="classbool.html">bool</a> close_X=true)</td></tr>
<tr class="memdesc:a799acbf460e4e1df9fb2ebdc8ac59469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prolong a value or a density from the FE mesh to the Cartesian grid.  <a href="classIBTK_1_1FEDataManager.html#a799acbf460e4e1df9fb2ebdc8ac59469">More...</a><br /></td></tr>
<tr class="separator:a799acbf460e4e1df9fb2ebdc8ac59469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7cb3a78eb4576d22a9b00f7601faca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#abc7cb3a78eb4576d22a9b00f7601faca">interpWeighted</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X, const std::string &amp;system_name, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_refine_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;(), <a class="el" href="classdouble.html">double</a> fill_data_time=0.0, <a class="el" href="classbool.html">bool</a> close_F=true, <a class="el" href="classbool.html">bool</a> close_X=true)</td></tr>
<tr class="memdesc:abc7cb3a78eb4576d22a9b00f7601faca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up the right-hand side <code>F</code> of an L2 projection problem where Eulerian data given by <code>f_data_idx</code> is projected onto the finite element space given by <code>system_name</code>.  <a href="classIBTK_1_1FEDataManager.html#abc7cb3a78eb4576d22a9b00f7601faca">More...</a><br /></td></tr>
<tr class="separator:abc7cb3a78eb4576d22a9b00f7601faca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af150b78b5bd4fc2464ec88a883a8fb07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#af150b78b5bd4fc2464ec88a883a8fb07">interpWeighted</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X, const std::string &amp;system_name, const <a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">InterpSpec</a> &amp;interp_spec, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_refine_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;(), <a class="el" href="classdouble.html">double</a> fill_data_time=0.0, <a class="el" href="classbool.html">bool</a> close_F=true, <a class="el" href="classbool.html">bool</a> close_X=true)</td></tr>
<tr class="memdesc:af150b78b5bd4fc2464ec88a883a8fb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a value from the Cartesian grid to the FE mesh using a specified interpolation spec. This interpolation function does NOT do an L2-projection of the interpolated quantity. It does however weighs/filters the interpolated quantity at the quadrature points to the nodes. Here, the basis functions of the deformational field is used as the filter.  <a href="classIBTK_1_1FEDataManager.html#af150b78b5bd4fc2464ec88a883a8fb07">More...</a><br /></td></tr>
<tr class="separator:af150b78b5bd4fc2464ec88a883a8fb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83caf25ad2a7e87b48c7087e3a3f795"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ad83caf25ad2a7e87b48c7087e3a3f795">interp</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X, const std::string &amp;system_name, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_refine_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;(), <a class="el" href="classdouble.html">double</a> fill_data_time=0.0, <a class="el" href="classbool.html">bool</a> close_X=true)</td></tr>
<tr class="memdesc:ad83caf25ad2a7e87b48c7087e3a3f795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a value from the Cartesian grid to the FE mesh using the default interpolation spec.  <a href="classIBTK_1_1FEDataManager.html#ad83caf25ad2a7e87b48c7087e3a3f795">More...</a><br /></td></tr>
<tr class="separator:ad83caf25ad2a7e87b48c7087e3a3f795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5a5b12b7252c7be5c04e65c4e4b89e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#adb5a5b12b7252c7be5c04e65c4e4b89e">interp</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X, const std::string &amp;system_name, const <a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">InterpSpec</a> &amp;interp_spec, const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;f_refine_scheds=std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt;(), <a class="el" href="classdouble.html">double</a> fill_data_time=0.0, <a class="el" href="classbool.html">bool</a> close_X=true)</td></tr>
<tr class="memdesc:adb5a5b12b7252c7be5c04e65c4e4b89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a value from the Cartesian grid to the FE mesh using a specified interpolation spec.  <a href="classIBTK_1_1FEDataManager.html#adb5a5b12b7252c7be5c04e65c4e4b89e">More...</a><br /></td></tr>
<tr class="separator:adb5a5b12b7252c7be5c04e65c4e4b89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bd251e64f416434ac4530cfd55cb07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a19bd251e64f416434ac4530cfd55cb07">restrictData</a> (<a class="el" href="classint.html">int</a> f_data_idx, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X, const std::string &amp;system_name, <a class="el" href="classbool.html">bool</a> use_consistent_mass_matrix=true, <a class="el" href="classbool.html">bool</a> close_X=true)</td></tr>
<tr class="memdesc:a19bd251e64f416434ac4530cfd55cb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restrict a value from the Cartesian grid to the FE mesh.  <a href="classIBTK_1_1FEDataManager.html#a19bd251e64f416434ac4530cfd55cb07">More...</a><br /></td></tr>
<tr class="separator:a19bd251e64f416434ac4530cfd55cb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9924f60ac0524f4db7efac8dd9510820"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a9924f60ac0524f4db7efac8dd9510820">buildDiagonalL2MassMatrix</a> (const std::string &amp;system_name)</td></tr>
<tr class="separator:a9924f60ac0524f4db7efac8dd9510820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7791cae3aebd299d475b94d72eccc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#acb7791cae3aebd299d475b94d72eccc7">buildIBGhostedDiagonalL2MassMatrix</a> (const std::string &amp;system_name)</td></tr>
<tr class="separator:acb7791cae3aebd299d475b94d72eccc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acdfa531c0e46cf73ff812d13f26043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a0acdfa531c0e46cf73ff812d13f26043">computeL2Projection</a> (<a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;U, <a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F, const std::string &amp;system_name, <a class="el" href="classbool.html">bool</a> consistent_mass_matrix=true, <a class="el" href="classbool.html">bool</a> close_U=true, <a class="el" href="classbool.html">bool</a> close_F=true, <a class="el" href="classdouble.html">double</a> tol=1.0e-6, unsigned <a class="el" href="classint.html">int</a> max_its=100)</td></tr>
<tr class="memdesc:a0acdfa531c0e46cf73ff812d13f26043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set U to be the L2 projection of F.  <a href="classIBTK_1_1FEDataManager.html#a0acdfa531c0e46cf73ff812d13f26043">More...</a><br /></td></tr>
<tr class="separator:a0acdfa531c0e46cf73ff812d13f26043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6423d2a09838855d7298dcf89c62dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#acc6423d2a09838855d7298dcf89c62dc">addWorkloadEstimate</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, const <a class="el" href="classint.html">int</a> workload_data_idx, const <a class="el" href="classint.html">int</a> coarsest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>, const <a class="el" href="classint.html">int</a> finest_ln=<a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a>)</td></tr>
<tr class="memdesc:acc6423d2a09838855d7298dcf89c62dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the cell workload estimate by adding a value (see the main documentation of this class for information on how this is computed) to the <code>d_workload_idx</code> cell variable.  <a href="classIBTK_1_1FEDataManager.html#acc6423d2a09838855d7298dcf89c62dc">More...</a><br /></td></tr>
<tr class="separator:acc6423d2a09838855d7298dcf89c62dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2532c268ca81bf0c31ee95298d22c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a6e2532c268ca81bf0c31ee95298d22c1">applyGradientDetector</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt; hierarchy, <a class="el" href="classint.html">int</a> level_number, <a class="el" href="classdouble.html">double</a> error_data_time, <a class="el" href="classint.html">int</a> tag_index, <a class="el" href="classbool.html">bool</a> initial_time, <a class="el" href="classbool.html">bool</a> uses_richardson_extrapolation_too)</td></tr>
<tr class="separator:a6e2532c268ca81bf0c31ee95298d22c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8b18fdfa1f9fd279a1e3b7074e7743"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a9b8b18fdfa1f9fd279a1e3b7074e7743">putToDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; db) override</td></tr>
<tr class="separator:a9b8b18fdfa1f9fd279a1e3b7074e7743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ed30182580bdcb694def0583fff81c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ae4ed30182580bdcb694def0583fff81c">updateQuadratureRule</a> (std::unique_ptr&lt; libMesh::QBase &gt; &amp;qrule, libMesh::QuadratureType quad_type, libMesh::Order quad_order, <a class="el" href="classbool.html">bool</a> use_adaptive_quadrature, <a class="el" href="classdouble.html">double</a> point_density, <a class="el" href="classbool.html">bool</a> allow_rules_with_negative_weights, const libMesh::Elem *elem, const boost::multi_array&lt; <a class="el" href="classdouble.html">double</a>, 2 &gt; &amp;X_node, <a class="el" href="classdouble.html">double</a> dx_min)</td></tr>
<tr class="separator:ae4ed30182580bdcb694def0583fff81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec89b4580e6a6071efc6df0a9727c7a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a0ec89b4580e6a6071efc6df0a9727c7a">updateInterpQuadratureRule</a> (std::unique_ptr&lt; libMesh::QBase &gt; &amp;qrule, const <a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">InterpSpec</a> &amp;spec, const libMesh::Elem *elem, const boost::multi_array&lt; <a class="el" href="classdouble.html">double</a>, 2 &gt; &amp;X_node, <a class="el" href="classdouble.html">double</a> dx_min)</td></tr>
<tr class="separator:a0ec89b4580e6a6071efc6df0a9727c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f6cd0e2a0247761c89ccc83b52348f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a83f6cd0e2a0247761c89ccc83b52348f">updateSpreadQuadratureRule</a> (std::unique_ptr&lt; libMesh::QBase &gt; &amp;qrule, const <a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">SpreadSpec</a> &amp;spec, const libMesh::Elem *elem, const boost::multi_array&lt; <a class="el" href="classdouble.html">double</a>, 2 &gt; &amp;X_node, <a class="el" href="classdouble.html">double</a> dx_min)</td></tr>
<tr class="separator:a83f6cd0e2a0247761c89ccc83b52348f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ecdb098d92636628c0bb3bf10e57a2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ae2ecdb098d92636628c0bb3bf10e57a2">zeroExteriorValues</a> (const <a class="el" href="classSAMRAI_1_1geom_1_1CartesianPatchGeometry.html">SAMRAI::geom::CartesianPatchGeometry</a>&lt; NDIM &gt; &amp;patch_geom, const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_qp, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;F_qp, <a class="el" href="classint.html">int</a> n_vars)</td></tr>
<tr class="memdesc:ae2ecdb098d92636628c0bb3bf10e57a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero the values corresponding to points on the given patch (described by <code>patch_geometry</code>) that might be duplicated on another patch.  <a href="classIBTK_1_1FEDataManager.html#ae2ecdb098d92636628c0bb3bf10e57a2">More...</a><br /></td></tr>
<tr class="separator:ae2ecdb098d92636628c0bb3bf10e57a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442100d56686cf0756922696c7ce73c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a442100d56686cf0756922696c7ce73c4">FEDataManager</a> (std::string object_name, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; &amp;input_db, const <a class="el" href="classint.html">int</a> max_levels, <a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">InterpSpec</a> default_interp_spec, <a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">SpreadSpec</a> default_spread_spec, <a class="el" href="structIBTK_1_1FEDataManager_1_1WorkloadSpec.html">WorkloadSpec</a> default_workload_spec, <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; ghost_width, std::shared_ptr&lt; <a class="el" href="classIBTK_1_1SAMRAIDataCache.html">SAMRAIDataCache</a> &gt; eulerian_data_cache, std::shared_ptr&lt; <a class="el" href="classIBTK_1_1FEData.html">FEData</a> &gt; fe_data, <a class="el" href="classbool.html">bool</a> register_for_restart=true)</td></tr>
<tr class="memdesc:a442100d56686cf0756922696c7ce73c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, where the <a class="el" href="classIBTK_1_1FEData.html">FEData</a> object owned by this class may be co-owned by other objects.  <a href="classIBTK_1_1FEDataManager.html#a442100d56686cf0756922696c7ce73c4">More...</a><br /></td></tr>
<tr class="separator:a442100d56686cf0756922696c7ce73c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefddb2a11c0a9c77fdbcdf6f6be6896"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#afefddb2a11c0a9c77fdbcdf6f6be6896">~FEDataManager</a> ()</td></tr>
<tr class="memdesc:afefddb2a11c0a9c77fdbcdf6f6be6896"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classIBTK_1_1FEDataManager.html" title="Class FEDataManager coordinates data required for Lagrangian-Eulerian interaction between a Lagrangia...">FEDataManager</a> destructor cleans up any allocated data objects.  <a href="classIBTK_1_1FEDataManager.html#afefddb2a11c0a9c77fdbcdf6f6be6896">More...</a><br /></td></tr>
<tr class="separator:afefddb2a11c0a9c77fdbcdf6f6be6896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77fa10dd36883a3d39bb96942bbe90b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ae77fa10dd36883a3d39bb96942bbe90b">FEDataManager</a> ()=delete</td></tr>
<tr class="memdesc:ae77fa10dd36883a3d39bb96942bbe90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classIBTK_1_1FEDataManager.html#ae77fa10dd36883a3d39bb96942bbe90b">More...</a><br /></td></tr>
<tr class="separator:ae77fa10dd36883a3d39bb96942bbe90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a7558b6c64c142097e585e6fff9569"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#af2a7558b6c64c142097e585e6fff9569">FEDataManager</a> (const <a class="el" href="classIBTK_1_1FEDataManager.html">FEDataManager</a> &amp;from)=delete</td></tr>
<tr class="memdesc:af2a7558b6c64c142097e585e6fff9569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classIBTK_1_1FEDataManager.html#af2a7558b6c64c142097e585e6fff9569">More...</a><br /></td></tr>
<tr class="separator:af2a7558b6c64c142097e585e6fff9569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4d822274585df1f230c2523fbc0e28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIBTK_1_1FEDataManager.html">FEDataManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#add4d822274585df1f230c2523fbc0e28">operator=</a> (const <a class="el" href="classIBTK_1_1FEDataManager.html">FEDataManager</a> &amp;that)=delete</td></tr>
<tr class="memdesc:add4d822274585df1f230c2523fbc0e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classIBTK_1_1FEDataManager.html#add4d822274585df1f230c2523fbc0e28">More...</a><br /></td></tr>
<tr class="separator:add4d822274585df1f230c2523fbc0e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7350da9455c6e6b65ee5a3c7186c258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#ae7350da9455c6e6b65ee5a3c7186c258">updateQuadPointCountData</a> (<a class="el" href="classint.html">int</a> coarsest_ln, <a class="el" href="classint.html">int</a> finest_ln)</td></tr>
<tr class="separator:ae7350da9455c6e6b65ee5a3c7186c258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3694a81a57efd44551e053d25584e032"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a3694a81a57efd44551e053d25584e032">collectActivePatchElements</a> (std::vector&lt; std::vector&lt; libMesh::Elem * &gt; &gt; &amp;active_patch_elems, <a class="el" href="classint.html">int</a> level_number, <a class="el" href="classint.html">int</a> coarsest_elem_ln, <a class="el" href="classint.html">int</a> finest_elem_ln)</td></tr>
<tr class="separator:a3694a81a57efd44551e053d25584e032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4b2074219ad3f636cfb3231597fe30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#acc4b2074219ad3f636cfb3231597fe30">collectActivePatchNodes</a> (std::vector&lt; std::vector&lt; libMesh::Node * &gt; &gt; &amp;active_patch_nodes, const std::vector&lt; std::vector&lt; libMesh::Elem * &gt; &gt; &amp;active_patch_elems)</td></tr>
<tr class="separator:acc4b2074219ad3f636cfb3231597fe30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d6b506a6dabf69b225ed51a2db52e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a72d6b506a6dabf69b225ed51a2db52e8">getPatchLevel</a> (const libMesh::Elem *elem) const</td></tr>
<tr class="separator:a72d6b506a6dabf69b225ed51a2db52e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49596eaf51c20ef7167ccce633a9a3a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a49596eaf51c20ef7167ccce633a9a3a1">collectGhostDOFIndices</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;ghost_dofs, const std::vector&lt; libMesh::Elem * &gt; &amp;active_elems, const std::string &amp;system_name)</td></tr>
<tr class="separator:a49596eaf51c20ef7167ccce633a9a3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0950e57bc506aeec1e02dc4330785641"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a0950e57bc506aeec1e02dc4330785641">reinitializeIBGhostedDOFs</a> (const std::string &amp;system_name)</td></tr>
<tr class="separator:a0950e57bc506aeec1e02dc4330785641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75398d9797ba12971b85761ca4eb370d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIBTK_1_1FEDataManager.html#a75398d9797ba12971b85761ca4eb370d">getFromRestart</a> ()</td></tr>
<tr class="separator:a75398d9797ba12971b85761ca4eb370d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h2>Parameters read from the input database</h2>
<p><code>node_outside_patch_check</code>: parameter controlling how this class responds to mesh nodes outside the finest patch level. In all cases, for backwards compatibility, nodes that are outside the computational domain are permitted and are ignored by this check. Possible values are: </p><ol>
<li>
<code>node_outside_permit</code>: Permit nodes to be outside the finest patch level. </li>
<li>
<code>node_outside_warn</code>: Permit nodes to be outside the finest patch level, but log a warning whenever this is detected. </li>
<li>
<code>node_outside_error</code>: Abort the program when nodes are detected outside the finest patch level. </li>
</ol>
<p>The default value is <code>node_outside_error</code>.</p>
<p><code>subdomain_ids_on_levels</code>: a database correlating <a class="el" href="namespacelibMesh.html">libMesh</a> subdomain IDs to patch levels. A possible value for this is </p><div class="fragment"><div class="line">subdomain_ids_on_levels</div>
<div class="line">{</div>
<div class="line">  level_1 = 4</div>
<div class="line">  level_3 = 10, 12, 14</div>
<div class="line">  level_5 = 1000, 1003, 1006, 1009</div>
<div class="line">}</div>
</div><!-- fragment --><p> This particular input will associate all elements with subdomain id 4 with patch level 1, all elements with subdomain ids 10, 12, or 14 with patch level 3, etc. All unspecified subdomain ids will be associated with the finest patch level. All inputs in this database for levels finer than the finest level are ignored (e.g., if the maximum patch level number is 4, then the values given in the example for level 5 ultimately end up on level 4). <em>This feature is experimental</em>: at the current time it is known that it produces some artifacts at the coarse-fine interface, but that these generally don't effect the overall solution quality.</p>
<h2>Parameters effecting workload estimate calculations</h2>
<p><a class="el" href="classIBTK_1_1FEDataManager.html" title="Class FEDataManager coordinates data required for Lagrangian-Eulerian interaction between a Lagrangia...">FEDataManager</a> can estimate the amount of work done in IBFE calculations (such as <a class="el" href="classIBTK_1_1FEDataManager.html#a1ee2005092bda7e38759f8c28c609d90" title="Spread a density from the FE mesh to the Cartesian grid using the default spreading spec.">FEDataManager::spread</a>). Since most calculations use a variable number of quadrature points on each <a class="el" href="namespacelibMesh.html">libMesh</a> element this estimate can vary quite a bit over different Eulerian cells corresponding to a single mesh. The current implementation estimates the workload on each cell of the background Eulerian grid by applying a background value representing the work on the Eulerian cell itself and a weight times the number of quadrature points on that cell. These values are set at the time of object construction through the <a class="el" href="structIBTK_1_1FEDataManager_1_1WorkloadSpec.html" title="Struct WorkloadSpec encapsulates the parameters used to calculate workload estimates (i....">FEDataManager::WorkloadSpec</a> object, which contains reasonable defaults.</p>
<dl class="section note"><dt>Note</dt><dd>Multiple <a class="el" href="classIBTK_1_1FEDataManager.html" title="Class FEDataManager coordinates data required for Lagrangian-Eulerian interaction between a Lagrangia...">FEDataManager</a> objects may be instantiated simultaneously. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a11864a323c95e0830a6df1723ae9a1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11864a323c95e0830a6df1723ae9a1b2">&#9670;&nbsp;</a></span>SystemDofMapCache</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIBTK_1_1FEDataManager.html#a11864a323c95e0830a6df1723ae9a1b2">IBTK::FEDataManager::SystemDofMapCache</a> =  <a class="el" href="classIBTK_1_1FEData_1_1SystemDofMapCache.html">FEData::SystemDofMapCache</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias <a class="el" href="classIBTK_1_1FEData_1_1SystemDofMapCache.html">FEData::SystemDofMapCache</a> for backwards compatibility. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a442100d56686cf0756922696c7ce73c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442100d56686cf0756922696c7ce73c4">&#9670;&nbsp;</a></span>FEDataManager() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::FEDataManager::FEDataManager </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_levels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">InterpSpec</a>&#160;</td>
          <td class="paramname"><em>default_interp_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">SpreadSpec</a>&#160;</td>
          <td class="paramname"><em>default_spread_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structIBTK_1_1FEDataManager_1_1WorkloadSpec.html">WorkloadSpec</a>&#160;</td>
          <td class="paramname"><em>default_workload_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt;&#160;</td>
          <td class="paramname"><em>ghost_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classIBTK_1_1SAMRAIDataCache.html">SAMRAIDataCache</a> &gt;&#160;</td>
          <td class="paramname"><em>eulerian_data_cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classIBTK_1_1FEData.html">FEData</a> &gt;&#160;</td>
          <td class="paramname"><em>fe_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>register_for_restart</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afefddb2a11c0a9c77fdbcdf6f6be6896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afefddb2a11c0a9c77fdbcdf6f6be6896">&#9670;&nbsp;</a></span>~FEDataManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::FEDataManager::~FEDataManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae77fa10dd36883a3d39bb96942bbe90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77fa10dd36883a3d39bb96942bbe90b">&#9670;&nbsp;</a></span>FEDataManager() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::FEDataManager::FEDataManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This constructor is not implemented and should not be used. </dd></dl>

</div>
</div>
<a id="af2a7558b6c64c142097e585e6fff9569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a7558b6c64c142097e585e6fff9569">&#9670;&nbsp;</a></span>FEDataManager() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IBTK::FEDataManager::FEDataManager </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIBTK_1_1FEDataManager.html">FEDataManager</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This constructor is not implemented and should not be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The value to copy to this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9aa705d9140f2a71d314d8fe76bfe0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa705d9140f2a71d314d8fe76bfe0ca">&#9670;&nbsp;</a></span>getCurrentCoordinatesSystemName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; IBTK::FEDataManager::getCurrentCoordinatesSystemName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The default value for this string is "coordinates system". </dd></dl>

</div>
</div>
<a id="a0fafe40cb41eba8ad2ea8b09c790dfc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fafe40cb41eba8ad2ea8b09c790dfc7">&#9670;&nbsp;</a></span>setCurrentCoordinatesSystemName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::setCurrentCoordinatesSystemName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>coordinates_system_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The default value for this string is "coordinates system". </dd></dl>

</div>
</div>
<a id="ae28ef5e4f2d472abdf0a961f8d2b6bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28ef5e4f2d472abdf0a961f8d2b6bd7">&#9670;&nbsp;</a></span>getManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classIBTK_1_1FEDataManager.html">FEDataManager</a>* IBTK::FEDataManager::getManager </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classIBTK_1_1FEData.html">FEData</a> &gt;&#160;</td>
          <td class="paramname"><em>fe_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_levels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">InterpSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>default_interp_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">SpreadSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>default_spread_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structIBTK_1_1FEDataManager_1_1WorkloadSpec.html">WorkloadSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>default_workload_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>min_ghost_width</em> = <code><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt;&#160;NDIM&#160;&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classIBTK_1_1SAMRAIDataCache.html">SAMRAIDataCache</a> &gt;&#160;</td>
          <td class="paramname"><em>eulerian_data_cache</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>register_for_restart</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the instance of the Lagrangian data manager corresponding to the specified name. Access to <a class="el" href="classIBTK_1_1FEDataManager.html" title="Class FEDataManager coordinates data required for Lagrangian-Eulerian interaction between a Lagrangia...">FEDataManager</a> objects is mediated by the <a class="el" href="classIBTK_1_1FEDataManager.html#ae28ef5e4f2d472abdf0a961f8d2b6bd7">getManager()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>When a manager is accessed for the first time, the <a class="el" href="classIBTK_1_1FEDataManager.html#a4df5834ff41ddf74a0f438dcb22940b7">FEDataManager::freeAllManagers()</a> static method is registered with the <a class="el" href="structSAMRAI_1_1tbox_1_1ShutdownRegistry.html" title="Class ShutdownRegistry is a utility for managing callbacks at program completion.">SAMRAI::tbox::ShutdownRegistry</a> class. Consequently, all allocated managers are freed at program completion. Thus, users of this class do not explicitly allocate or deallocate the <a class="el" href="classIBTK_1_1FEDataManager.html" title="Class FEDataManager coordinates data required for Lagrangian-Eulerian interaction between a Lagrangia...">FEDataManager</a> instances.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the data manager instance. </dd></dl>

</div>
</div>
<a id="a4df5834ff41ddf74a0f438dcb22940b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df5834ff41ddf74a0f438dcb22940b7">&#9670;&nbsp;</a></span>freeAllManagers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IBTK::FEDataManager::freeAllManagers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deallocate all of the <a class="el" href="classIBTK_1_1FEDataManager.html" title="Class FEDataManager coordinates data required for Lagrangian-Eulerian interaction between a Lagrangia...">FEDataManager</a> instances.</p>
<p>It is not necessary to call this function at program termination since it is automatically called by the <a class="el" href="structSAMRAI_1_1tbox_1_1ShutdownRegistry.html" title="Class ShutdownRegistry is a utility for managing callbacks at program completion.">SAMRAI::tbox::ShutdownRegistry</a> class. </p>

</div>
</div>
<a id="a7ab2051403b2a6d0038cb5792c0017e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab2051403b2a6d0038cb5792c0017e1">&#9670;&nbsp;</a></span>setEquationSystems()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::setEquationSystems </td>
          <td>(</td>
          <td class="paramtype">libMesh::EquationSystems *&#160;</td>
          <td class="paramname"><em>equation_systems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>This function is deprecated since the <a class="el" href="classIBTK_1_1FEData.html">FEData</a> constructor now requires an EquationSystems argument. </dd></dl>

</div>
</div>
<a id="af0f2bc7d060607618186adc9b29a9777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f2bc7d060607618186adc9b29a9777">&#9670;&nbsp;</a></span>getEquationSystems()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::EquationSystems* IBTK::FEDataManager::getEquationSystems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A pointer to the equations systems object that is associated with the <a class="el" href="classIBTK_1_1FEData.html">FEData</a> object. </dd></dl>

</div>
</div>
<a id="a280118f8a7501220be6892e8592a0436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280118f8a7501220be6892e8592a0436">&#9670;&nbsp;</a></span>getDofMapCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBTK_1_1FEDataManager.html#a11864a323c95e0830a6df1723ae9a1b2">SystemDofMapCache</a>* IBTK::FEDataManager::getDofMapCache </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The DofMapCache for a specified system. </dd></dl>

</div>
</div>
<a id="a82a6afa06b795fd8827bd48c07bbc77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a6afa06b795fd8827bd48c07bbc77d">&#9670;&nbsp;</a></span>getDofMapCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBTK_1_1FEDataManager.html#a11864a323c95e0830a6df1723ae9a1b2">SystemDofMapCache</a>* IBTK::FEDataManager::getDofMapCache </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>system_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The DofMapCache for a specified system. </dd></dl>

</div>
</div>
<a id="ac3e5d4a3e7063e2e25890d6d4a44875e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e5d4a3e7063e2e25890d6d4a44875e">&#9670;&nbsp;</a></span>setLoggingEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::setLoggingEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>enable_logging</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is usually set by the IBFEMethod which owns the current <a class="el" href="classIBTK_1_1FEDataManager.html" title="Class FEDataManager coordinates data required for Lagrangian-Eulerian interaction between a Lagrangia...">FEDataManager</a>, which reads the relevant boolean from the database. </dd></dl>

</div>
</div>
<a id="aae3ded192467edb5d1767057a0356d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3ded192467edb5d1767057a0356d28">&#9670;&nbsp;</a></span>getLoggingEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::FEDataManager::getLoggingEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cd0c81a11489e5d334cafa744253e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd0c81a11489e5d334cafa744253e70">&#9670;&nbsp;</a></span>setPatchHierarchy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::setPatchHierarchy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The patch hierarchy must be fully set up (i.e., contain all the levels it is expected to have) at the point this function is called. If you need to tag cells for refinement to create the initial hierarchy then use applyGradientDetector, which does not use the stored patch hierarchy. </p>

</div>
</div>
<a id="ab6d6cdb72bed5c8b6e577b098d11a756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d6cdb72bed5c8b6e577b098d11a756">&#9670;&nbsp;</a></span>getPatchHierarchy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt;NDIM&gt; &gt; IBTK::FEDataManager::getPatchHierarchy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acdfe3ea5aca154ff5b05aaff0808fc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfe3ea5aca154ff5b05aaff0808fc49">&#9670;&nbsp;</a></span>getCoarsestPatchLevelNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::FEDataManager::getCoarsestPatchLevelNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the coarsest patch level number on which elements are assigned. </p>

</div>
</div>
<a id="a81005b53844fc5bde5abf2dbd9353899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81005b53844fc5bde5abf2dbd9353899">&#9670;&nbsp;</a></span>getFinestPatchLevelNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::FEDataManager::getFinestPatchLevelNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the finest patch level number on which elements are assigned. </p>

</div>
</div>
<a id="ab71c8cbccae20e05e087d8cd5e030c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71c8cbccae20e05e087d8cd5e030c29">&#9670;&nbsp;</a></span>getGhostCellWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt;NDIM&gt;&amp; IBTK::FEDataManager::getGhostCellWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The ghost cell width used for quantities that are to be interpolated from the Cartesian grid to the FE mesh. </dd></dl>

</div>
</div>
<a id="ab58d7d850df96dd15f9168d79b61688e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58d7d850df96dd15f9168d79b61688e">&#9670;&nbsp;</a></span>getDefaultInterpSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">InterpSpec</a>&amp; IBTK::FEDataManager::getDefaultInterpSpec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The specifications of the scheme used for interpolating from the Cartesian grid to the FE mesh. </dd></dl>

</div>
</div>
<a id="ad53be46bc2d79c337691f9ccefabee1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53be46bc2d79c337691f9ccefabee1f">&#9670;&nbsp;</a></span>getDefaultSpreadSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">SpreadSpec</a>&amp; IBTK::FEDataManager::getDefaultSpreadSpec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The specifications of the scheme used for spreading densities from the FE mesh to the Cartesian grid </dd></dl>

</div>
</div>
<a id="adfe809fa165fc50e79644f179d409d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe809fa165fc50e79644f179d409d7e">&#9670;&nbsp;</a></span>getActivePatchElementMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;libMesh::Elem*&gt; &gt;&amp; IBTK::FEDataManager::getActivePatchElementMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A const reference to the map from local patch number to local active elements. </dd></dl>

</div>
</div>
<a id="a9b993111e30386cc94f074be9be15dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b993111e30386cc94f074be9be15dc0">&#9670;&nbsp;</a></span>getActivePatchNodeMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;libMesh::Node*&gt; &gt;&amp; IBTK::FEDataManager::getActivePatchNodeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A const reference to the map from local patch number to local active nodes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The local active nodes are the nodes of the local active elements. </dd></dl>

</div>
</div>
<a id="a3d232e10e554539a93a127e02a48dc21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d232e10e554539a93a127e02a48dc21">&#9670;&nbsp;</a></span>reinitElementMappings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::reinitElementMappings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cd0135c430174915d9a3551c3beaa65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd0135c430174915d9a3551c3beaa65">&#9670;&nbsp;</a></span>getSolutionVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;* IBTK::FEDataManager::getSolutionVector </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A pointer to the unghosted solution vector associated with the specified system. </dd></dl>

</div>
</div>
<a id="a3129f3a1db8388b73d88854b7a7fe6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3129f3a1db8388b73d88854b7a7fe6d0">&#9670;&nbsp;</a></span>buildGhostedSolutionVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;* IBTK::FEDataManager::buildGhostedSolutionVector </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>localize_data</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A pointer to the ghosted solution vector associated with the specified system. The vector contains positions for values in the relevant IB ghost region which are populated if <code>localize_data</code> is <code>true</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vector returned by pointer is owned by this class (i.e., no copying is done).</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>Use <a class="el" href="classIBTK_1_1FEDataManager.html#a6dc97e66df1b188312235dc8b6a2c58b">buildIBGhostedVector()</a> instead which clones a vector with the same ghost region. </dd></dl>

</div>
</div>
<a id="a6dc97e66df1b188312235dc8b6a2c58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc97e66df1b188312235dc8b6a2c58b">&#9670;&nbsp;</a></span>buildIBGhostedVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; IBTK::FEDataManager::buildIBGhostedVector </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A pointer to a vector, with ghost entries corresponding to relevant IB data, associated with the specified system. </dd></dl>

</div>
</div>
<a id="a8cc2d33c02ac14e7e36eb8df1da84474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc2d33c02ac14e7e36eb8df1da84474">&#9670;&nbsp;</a></span>getCoordsVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;* IBTK::FEDataManager::getCoordsVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A pointer to the unghosted coordinates (nodal position) vector. </dd></dl>

</div>
</div>
<a id="a1074e8ca27c8501cf47fb03c1443e50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1074e8ca27c8501cf47fb03c1443e50a">&#9670;&nbsp;</a></span>buildGhostedCoordsVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;* IBTK::FEDataManager::buildGhostedCoordsVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>localize_data</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A pointer to the ghosted coordinates (nodal position) vector.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>Use <a class="el" href="classIBTK_1_1FEDataManager.html#a6dc97e66df1b188312235dc8b6a2c58b">buildIBGhostedVector()</a> instead. </dd></dl>

</div>
</div>
<a id="aa0bfe491931ccf62ead4f208f6884e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0bfe491931ccf62ead4f208f6884e59">&#9670;&nbsp;</a></span>getFEData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classIBTK_1_1FEData.html">FEData</a>&gt;&amp; IBTK::FEDataManager::getFEData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The shared pointer to the object managing the Lagrangian data. </dd></dl>

</div>
</div>
<a id="aa10efefed973472ec9b819b6ae6d5492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10efefed973472ec9b819b6ae6d5492">&#9670;&nbsp;</a></span>getFEData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classIBTK_1_1FEData.html">FEData</a>&gt;&amp; IBTK::FEDataManager::getFEData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The shared pointer to the object managing the Lagrangian data. </dd></dl>

</div>
</div>
<a id="a1ee2005092bda7e38759f8c28c609d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee2005092bda7e38759f8c28c609d90">&#9670;&nbsp;</a></span>spread() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::spread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function may spread forces from points near the physical boundary into ghost cells outside the physical domain. To account for these forces one should usually call <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a4f927d1b5c3ac69106e3fb7d10869948">IBTK::RobinPhysBdryPatchStrategy::accumulateFromPhysicalBoundaryData()</a> after this function to move said force values into the physical domain. </dd></dl>

</div>
</div>
<a id="a8198f8cf9fb226a442280d3b5bf8088f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8198f8cf9fb226a442280d3b5bf8088f">&#9670;&nbsp;</a></span>spread() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::spread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">SpreadSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>spread_spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f_data_idx</td><td><a class="el" href="namespaceSAMRAI.html">SAMRAI</a> index into the <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a> object owned by this class. The spread force values will be added into this index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>Finite element solution vector containing the field which will be spread onto the Eulerian grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>Finite element solution vector containing the current position of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">system_name</td><td>name of the system corresponding to <code>F</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Both <code>X</code> and <code>F</code> should contain ghost values corresponding to the IB partitioning of the Lagrangian data, i.e., vectors returned from buildIBGhostedVector.</p>
<dl class="section note"><dt>Note</dt><dd>This function may spread forces from points near the physical boundary into ghost cells outside the physical domain. To account for these forces one should usually call <a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html#a4f927d1b5c3ac69106e3fb7d10869948">IBTK::RobinPhysBdryPatchStrategy::accumulateFromPhysicalBoundaryData()</a> after this function to move said force values into the physical domain. </dd></dl>

</div>
</div>
<a id="a137108543cafe18e8535e917ff375586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137108543cafe18e8535e917ff375586">&#9670;&nbsp;</a></span>spread() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::spread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *&#160;</td>
          <td class="paramname"><em>f_phys_bdry_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close_F</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close_X</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a165498e1d6e45be24d5fb21f96d71cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165498e1d6e45be24d5fb21f96d71cf6">&#9670;&nbsp;</a></span>spread() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::spread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">SpreadSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>spread_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBTK_1_1RobinPhysBdryPatchStrategy.html">RobinPhysBdryPatchStrategy</a> *&#160;</td>
          <td class="paramname"><em>f_phys_bdry_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close_F</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close_X</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a799acbf460e4e1df9fb2ebdc8ac59469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799acbf460e4e1df9fb2ebdc8ac59469">&#9670;&nbsp;</a></span>prolongData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::prolongData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_density</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>accumulate_on_grid</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close_F</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close_X</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc7cb3a78eb4576d22a9b00f7601faca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7cb3a78eb4576d22a9b00f7601faca">&#9670;&nbsp;</a></span>interpWeighted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::interpWeighted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_refine_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close_F</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close_X</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f_data_idx</td><td>Index of the variable being projected.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IB-ghosted</td><td>position vector containing the current position of all dofs whose basis functions have support (in the deformed configuration) on the locally owned set of patches.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>Vector into which the L2-projection RHS vector will be assembled. If this vector is ghosted then off-processor entries are assembled into the ghost value region of the vector and callers should complete the assembly process with, e.g., <div class="fragment"><div class="line">ierr = VecGhostUpdateBegin(F.vec(), ADD_VALUES, SCATTER_REVERSE);</div>
<div class="line"><a class="code" href="IBTK__CHKERRQ_8h.html#a82134efd79614179ddc74839a56497ef">IBTK_CHKERRQ</a>(ierr);</div>
<div class="line">ierr = VecGhostUpdateEnd(F.vec(), INSERT_VALUES, SCATTER_FORWARD);</div>
<div class="line"><a class="code" href="IBTK__CHKERRQ_8h.html#a82134efd79614179ddc74839a56497ef">IBTK_CHKERRQ</a>(ierr);</div>
</div><!-- fragment --> otherwise values are added into the vector directly (which, for a <a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>, will involve the use of the PETSc VecCache object to track off-processor entries). It is strongly recommended, for performance reasons, that one assemble into a ghosted vector instead of the approach with VecCache.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">system_name</td><td>Name of the <a class="el" href="namespacelibMesh.html">libMesh</a> system corresponding to the vector <code>F</code>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_refine_scheds</td><td>Refinement schedules to process before actually running this function.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fill_data_time</td><td>Time at which the data in <code>f_data_idx</code> was filled.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Whether</td><td>or not to close <code>F</code> after assembly.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Whether</td><td>or not to close <code>X</code> before assembly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>We recommend against using the last two booleans: it is usually better to do any vector communication before calling this function.</dd>
<dd>
This function is poorly named: it actually sets up a dual-space vector <code>F</code> which is the right-hand side of an L2 projection problem. Callers will still need to solve the resulting linear system. The result, therefore, is projected, not interpolated.</dd>
<dd>
The vector set up by this function is set up without applying any constraints (e.g., hanging node or periodicity constraints) during assembly. This is because we do not store the constraints on the IB data partitioning, only on <a class="el" href="namespacelibMesh.html">libMesh</a>'s own data partitioning. For more information on how to assemble RHS vectors in this case, see the documentation of the function <a class="el" href="namespaceIBTK.html#a6e1b936ae530a4aacdc032c8edbb3475">apply_transposed_constraint_matrix()</a>. </dd></dl>

</div>
</div>
<a id="af150b78b5bd4fc2464ec88a883a8fb07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af150b78b5bd4fc2464ec88a883a8fb07">&#9670;&nbsp;</a></span>interpWeighted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::interpWeighted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">InterpSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>interp_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_refine_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close_F</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close_X</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad83caf25ad2a7e87b48c7087e3a3f795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83caf25ad2a7e87b48c7087e3a3f795">&#9670;&nbsp;</a></span>interp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::interp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_refine_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close_X</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb5a5b12b7252c7be5c04e65c4e4b89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5a5b12b7252c7be5c04e65c4e4b89e">&#9670;&nbsp;</a></span>interp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::interp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">InterpSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>interp_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt; NDIM &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_refine_scheds</em> = <code>std::vector&lt;&#160;<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;&#160;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a>&lt;&#160;NDIM&#160;&gt;&#160;&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>fill_data_time</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close_X</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19bd251e64f416434ac4530cfd55cb07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19bd251e64f416434ac4530cfd55cb07">&#9670;&nbsp;</a></span>restrictData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::restrictData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>f_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_consistent_mass_matrix</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close_X</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9924f60ac0524f4db7efac8dd9510820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9924f60ac0524f4db7efac8dd9510820">&#9670;&nbsp;</a></span>buildDiagonalL2MassMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;* IBTK::FEDataManager::buildDiagonalL2MassMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Pointer to vector representation of diagonal L2 mass matrix. </dd></dl>

</div>
</div>
<a id="acb7791cae3aebd299d475b94d72eccc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7791cae3aebd299d475b94d72eccc7">&#9670;&nbsp;</a></span>buildIBGhostedDiagonalL2MassMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;* IBTK::FEDataManager::buildIBGhostedDiagonalL2MassMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Pointer to IB ghosted vector representation of diagonal L2 mass matrix. </dd></dl>

</div>
</div>
<a id="a0acdfa531c0e46cf73ff812d13f26043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acdfa531c0e46cf73ff812d13f26043">&#9670;&nbsp;</a></span>computeL2Projection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::FEDataManager::computeL2Projection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>consistent_mass_matrix</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close_U</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close_F</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1.0e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_its</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4ed30182580bdcb694def0583fff81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ed30182580bdcb694def0583fff81c">&#9670;&nbsp;</a></span>updateQuadratureRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> IBTK::FEDataManager::updateQuadratureRule </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; libMesh::QBase &gt; &amp;&#160;</td>
          <td class="paramname"><em>qrule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libMesh::QuadratureType&#160;</td>
          <td class="paramname"><em>quad_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libMesh::Order&#160;</td>
          <td class="paramname"><em>quad_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_adaptive_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>point_density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_rules_with_negative_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::Elem *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; <a class="el" href="classdouble.html">double</a>, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dx_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the quadrature rule for the current element. If the provided qrule is already configured appropriately, it is not modified.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the quadrature rule is updated or otherwise requires reinitialization (e.g. because the element type or p_level changed); false otherwise. </dd></dl>

</div>
</div>
<a id="a0ec89b4580e6a6071efc6df0a9727c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec89b4580e6a6071efc6df0a9727c7a">&#9670;&nbsp;</a></span>updateInterpQuadratureRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> IBTK::FEDataManager::updateInterpQuadratureRule </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; libMesh::QBase &gt; &amp;&#160;</td>
          <td class="paramname"><em>qrule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">InterpSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::Elem *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; <a class="el" href="classdouble.html">double</a>, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dx_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the quadrature rule for the current element used by the Lagrangian-Eulerian interaction scheme. If the provided qrule is already configured appropriately, it is not modified.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the quadrature rule is updated or otherwise requires reinitialization (e.g. because the element type or p_level changed); false otherwise. </dd></dl>

</div>
</div>
<a id="a83f6cd0e2a0247761c89ccc83b52348f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f6cd0e2a0247761c89ccc83b52348f">&#9670;&nbsp;</a></span>updateSpreadQuadratureRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> IBTK::FEDataManager::updateSpreadQuadratureRule </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; libMesh::QBase &gt; &amp;&#160;</td>
          <td class="paramname"><em>qrule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">SpreadSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::Elem *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; <a class="el" href="classdouble.html">double</a>, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dx_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the quadrature rule for the current element used by the Lagrangian-Eulerian interaction scheme. If the provided qrule is already configured appropriately, it is not modified.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the quadrature rule is updated or otherwise requires reinitialization (e.g. because the element type or p_level changed); false otherwise. </dd></dl>

</div>
</div>
<a id="acc6423d2a09838855d7298dcf89c62dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6423d2a09838855d7298dcf89c62dc">&#9670;&nbsp;</a></span>addWorkloadEstimate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::addWorkloadEstimate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>workload_data_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em> = <code><a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">invalid_level_number</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e2532c268ca81bf0c31ee95298d22c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2532c268ca81bf0c31ee95298d22c1">&#9670;&nbsp;</a></span>applyGradientDetector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::applyGradientDetector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">SAMRAI::hier::BasePatchHierarchy</a>&lt; NDIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>uses_richardson_extrapolation_too</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set integer tags to "one" in cells where refinement of the given level should occur due to the presence of Lagrangian data. The double time argument is the regrid time. The integer "tag_index" argument is the patch descriptor index of the cell centered integer tag array on each patch in the hierarchy. The boolean argument initial_time indicates whether the level is being subject to refinement at the initial simulation time. If it is false, then the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. The boolean argument uses_richardson_extrapolation_too is true when Richardson extrapolation error estimation is used in addition to the gradient detector, and false otherwise. This argument helps the user to manage multiple regridding criteria.</p>
<p>When assertion checking is active, an unrecoverable exception will result if the hierarchy pointer is null or the level number does not match any existing level in the hierarchy.</p>
<dl class="section note"><dt>Note</dt><dd>This function is analogous to <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#ac201b9cd28087aa92f9c1370f147667a">SAMRAI::mesh::StandardTagAndInitStrategy::applyGradientDetector()</a> and is only meant to be called from <a class="el" href="classIBAMR_1_1IBFEMethod.html#a1032e0a37c2d874a18403a8ceb534d1d">IBAMR::IBFEMethod::applyGradientDetector()</a>. </dd></dl>

</div>
</div>
<a id="a9b8b18fdfa1f9fd279a1e3b7074e7743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8b18fdfa1f9fd279a1e3b7074e7743">&#9670;&nbsp;</a></span>putToDatabase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::putToDatabase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a> &gt;&#160;</td>
          <td class="paramname"><em>db</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write out object state to the given database.</p>
<p>When assertion checking is active, database pointer must be non-null. </p>

<p>Implements <a class="el" href="classSAMRAI_1_1tbox_1_1Serializable.html#ad90b74ae3fd7af9a7bb9cbf7f3ebc08a">SAMRAI::tbox::Serializable</a>.</p>

</div>
</div>
<a id="ae2ecdb098d92636628c0bb3bf10e57a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ecdb098d92636628c0bb3bf10e57a2">&#9670;&nbsp;</a></span>zeroExteriorValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IBTK::FEDataManager::zeroExteriorValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1geom_1_1CartesianPatchGeometry.html">SAMRAI::geom::CartesianPatchGeometry</a>&lt; NDIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch_geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In the process of computing either forces on the Lagrangian mesh to spread to the Eulerian grid or interpolating values from the Eulerian grid to use in the Lagrangian structure we may, under extraordinary circumstances, double-count a point that lies on the boundary between two patches. Note that due to the CFL condition assumed by this class and the width of the tag buffer used by <a class="el" href="classIBAMR_1_1IBFEMethod.html" title="Class IBFEMethod is an implementation of the abstract base class IBStrategy that provides functionali...">IBAMR::IBFEMethod</a> we can assume that no IB point will ever lie on the boundary of the finest grid level: hence, if a point lies on the boundary of a patch, it must also lie on the boundary of a neighboring patch.</p>
<p>Hence, to establish uniqueness, we zero data that lies on the 'upper' face (corresponding to the unit normal vector pointing towards infinity) since we are guaranteed, by the previous assumptions, that that data must also lie on the lower face of a neighboring patch. </p>

</div>
</div>
<a id="add4d822274585df1f230c2523fbc0e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4d822274585df1f230c2523fbc0e28">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBTK_1_1FEDataManager.html">FEDataManager</a>&amp; IBTK::FEDataManager::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIBTK_1_1FEDataManager.html">FEDataManager</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This operator is not implemented and should not be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>The value to assign to this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<a id="ae7350da9455c6e6b65ee5a3c7186c258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7350da9455c6e6b65ee5a3c7186c258">&#9670;&nbsp;</a></span>updateQuadPointCountData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::updateQuadPointCountData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_ln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the quadrature point counts in each cell of the level in which the FE mesh is embedded. Also zeros out node count data for other levels within the specified range of level numbers. </p>

</div>
</div>
<a id="a3694a81a57efd44551e053d25584e032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3694a81a57efd44551e053d25584e032">&#9670;&nbsp;</a></span>collectActivePatchElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::collectActivePatchElements </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; libMesh::Elem * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_patch_elems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_elem_ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>finest_elem_ln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collect all of the active elements which are located within a local Cartesian grid patch grown by a ghost width of 1 (like <a class="el" href="classIBTK_1_1LEInteractor.html#acbfd13d715d5873f3042e3e4ff5f3b30" title="Returns the minimum ghost width size corresponding to the specified kernel function.">IBTK::LEInteractor::getMinimumGhostWidth()</a>, we assume that IB points are allowed to move no more than one cell width between regridding operations).</p>
<p>The parameters refer to the levels of different objects: </p><ol>
<li>
<code>level_number</code> - the level number in the patch hierarchy on which we are identifying intersections. </li>
<li>
<code>coarsest_elem_ln</code> - The minimum level number of elements we should consider (see the main documentation of this class for an explanation on how elements are assigned to particular levels) </li>
<li>
<code>finest_elem_ln</code> - The maximum level number of elements we should consider. </li>
</ol>
<p>All three parameters are necessary because we use this function both to tag cells for refinement (i.e., we want to refine cells containing elements on levels higher than the present level) and to do IB calculations (where all three numbers will be the same).</p>
<p>In this method, the determination as to whether an element is local or not is based on the position of the bounding box of the element. </p>

</div>
</div>
<a id="acc4b2074219ad3f636cfb3231597fe30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4b2074219ad3f636cfb3231597fe30">&#9670;&nbsp;</a></span>collectActivePatchNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::collectActivePatchNodes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; libMesh::Node * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_patch_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; libMesh::Elem * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_patch_elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collect all of the nodes of the active elements that are located within a local Cartesian grid patch grown by the specified ghost cell width. </p>

</div>
</div>
<a id="a72d6b506a6dabf69b225ed51a2db52e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d6b506a6dabf69b225ed51a2db52e8">&#9670;&nbsp;</a></span>getPatchLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::FEDataManager::getPatchLevel </td>
          <td>(</td>
          <td class="paramtype">const libMesh::Elem *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the patch level on which an element lives. </p>

</div>
</div>
<a id="a49596eaf51c20ef7167ccce633a9a3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49596eaf51c20ef7167ccce633a9a3a1">&#9670;&nbsp;</a></span>collectGhostDOFIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::collectGhostDOFIndices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; libMesh::Elem * &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_elems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collect all ghost DOF indices for the specified collection of elements. </p>

</div>
</div>
<a id="a0950e57bc506aeec1e02dc4330785641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0950e57bc506aeec1e02dc4330785641">&#9670;&nbsp;</a></span>reinitializeIBGhostedDOFs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IBTK::FEDataManager::reinitializeIBGhostedDOFs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>system_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reinitialize IB ghosted DOF data structures for the specified system. </p>

</div>
</div>
<a id="a75398d9797ba12971b85761ca4eb370d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75398d9797ba12971b85761ca4eb370d">&#9670;&nbsp;</a></span>getFromRestart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IBTK::FEDataManager::getFromRestart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read object state from the restart file and initialize class data members. The database from which the restart data is read is determined by the object_name specified in the constructor.</p>
<p>Unrecoverable Errors:</p>
<ul>
<li>The database corresponding to object_name is not found in the restart file.</li>
<li>The class version number and restart version number do not match. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a46ad4df2258656ae6d77d14e0326bd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ad4df2258656ae6d77d14e0326bd04">&#9670;&nbsp;</a></span>d_fe_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classIBTK_1_1FEData.html">FEData</a>&gt; IBTK::FEDataManager::d_fe_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classIBTK_1_1FEData.html">FEData</a> object that contains the <a class="el" href="namespacelibMesh.html">libMesh</a> data structures.</p>
<dl class="section note"><dt>Note</dt><dd>multiple <a class="el" href="classIBTK_1_1FEDataManager.html" title="Class FEDataManager coordinates data required for Lagrangian-Eulerian interaction between a Lagrangia...">FEDataManager</a> objects may use the same <a class="el" href="classIBTK_1_1FEData.html">FEData</a> object, usually combined with different hierarchies. </dd></dl>

</div>
</div>
<a id="ad59687d321608e53ee79077b9f56102e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59687d321608e53ee79077b9f56102e">&#9670;&nbsp;</a></span>d_fe_projector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classIBTK_1_1FEProjector.html">FEProjector</a>&gt; IBTK::FEDataManager::d_fe_projector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classIBTK_1_1FEProjector.html" title="Class FEProjector coordinates data structures for projecting fields in FE models.">FEProjector</a> object that handles L2 projection functionality. </p>

</div>
</div>
<a id="af894887cefa006c2d9cb517867d18617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af894887cefa006c2d9cb517867d18617">&#9670;&nbsp;</a></span>d_L2_proj_matrix_diag_ghost</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::unique_ptr&lt;<a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; &gt; IBTK::FEDataManager::d_L2_proj_matrix_diag_ghost</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>IB ghosted diagonal mass matrix representations. </p>

</div>
</div>
<a id="a450f2ab850794758221e91baba82c9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450f2ab850794758221e91baba82c9a7">&#9670;&nbsp;</a></span>COORDINATES_SYSTEM_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; IBTK::FEDataManager::COORDINATES_SYSTEM_NAME</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The default value for this string is "coordinates system". </dd></dl>

</div>
</div>
<a id="ac4ee2a95496546d7d4812e34847c4680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ee2a95496546d7d4812e34847c4680">&#9670;&nbsp;</a></span>ZERO_DISPLACEMENT_X_BDRY_ID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const libMesh::boundary_id_type IBTK::FEDataManager::ZERO_DISPLACEMENT_X_BDRY_ID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e586810f0eeebff95ac938a5f24ed39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e586810f0eeebff95ac938a5f24ed39">&#9670;&nbsp;</a></span>ZERO_DISPLACEMENT_Y_BDRY_ID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const libMesh::boundary_id_type IBTK::FEDataManager::ZERO_DISPLACEMENT_Y_BDRY_ID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a245efaf42da4a5debdfd9fa5d77334ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245efaf42da4a5debdfd9fa5d77334ec">&#9670;&nbsp;</a></span>ZERO_DISPLACEMENT_Z_BDRY_ID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const libMesh::boundary_id_type IBTK::FEDataManager::ZERO_DISPLACEMENT_Z_BDRY_ID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80c7db6e07d8b71e0e66d3c6a7864b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c7db6e07d8b71e0e66d3c6a7864b8e">&#9670;&nbsp;</a></span>ZERO_DISPLACEMENT_XY_BDRY_ID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const libMesh::boundary_id_type IBTK::FEDataManager::ZERO_DISPLACEMENT_XY_BDRY_ID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac971b56547b458c33cf2450ee2a2c99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac971b56547b458c33cf2450ee2a2c99e">&#9670;&nbsp;</a></span>ZERO_DISPLACEMENT_XZ_BDRY_ID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const libMesh::boundary_id_type IBTK::FEDataManager::ZERO_DISPLACEMENT_XZ_BDRY_ID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a793eafb8efdc3de0b411ae8614e1084b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793eafb8efdc3de0b411ae8614e1084b">&#9670;&nbsp;</a></span>ZERO_DISPLACEMENT_YZ_BDRY_ID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const libMesh::boundary_id_type IBTK::FEDataManager::ZERO_DISPLACEMENT_YZ_BDRY_ID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb033bb232f10033d603c9d81c714acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb033bb232f10033d603c9d81c714acb">&#9670;&nbsp;</a></span>ZERO_DISPLACEMENT_XYZ_BDRY_ID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const libMesh::boundary_id_type IBTK::FEDataManager::ZERO_DISPLACEMENT_XYZ_BDRY_ID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adadb1d47428c3a4d58a1a1d57d5428b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adadb1d47428c3a4d58a1a1d57d5428b5">&#9670;&nbsp;</a></span>d_level_lookup</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIBTK_1_1SubdomainToPatchLevelTranslation.html">SubdomainToPatchLevelTranslation</a> IBTK::FEDataManager::d_level_lookup</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store the association between subdomain ids and patch levels. </p>

</div>
</div>
<a id="a7636c790a5718525b23180e916434579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7636c790a5718525b23180e916434579">&#9670;&nbsp;</a></span>s_data_manager_instances</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="classIBTK_1_1FEDataManager.html">FEDataManager</a>*&gt; IBTK::FEDataManager::s_data_manager_instances</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Static data members used to control access to and destruction of singleton data manager instance. </p>

</div>
</div>
<a id="ad55eeadf37c8e52b627c6704ae8fdee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55eeadf37c8e52b627c6704ae8fdee5">&#9670;&nbsp;</a></span>s_registered_callback</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::FEDataManager::s_registered_callback</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd28fa43b498507df4ffaf1c4f51dc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd28fa43b498507df4ffaf1c4f51dc51">&#9670;&nbsp;</a></span>s_shutdown_priority</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char IBTK::FEDataManager::s_shutdown_priority</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2381d39e94788aa41d0f90cf8558f187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2381d39e94788aa41d0f90cf8558f187">&#9670;&nbsp;</a></span>d_object_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string IBTK::FEDataManager::d_object_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object name is used as a handle to databases stored in restart files and for error reporting purposes. The boolean is used to control restart file writing operations. </p>

</div>
</div>
<a id="a82cb941f86e343dee24e2b78198e7a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cb941f86e343dee24e2b78198e7a0c">&#9670;&nbsp;</a></span>d_registered_for_restart</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::FEDataManager::d_registered_for_restart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad35c615c7b1eca329b08c8a59899da8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35c615c7b1eca329b08c8a59899da8b">&#9670;&nbsp;</a></span>d_enable_logging</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IBTK::FEDataManager::d_enable_logging = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether or not to log data to the screen: see <a class="el" href="classIBTK_1_1FEDataManager.html#ac3e5d4a3e7063e2e25890d6d4a44875e" title="Enable or disable logging.">FEDataManager::setLoggingEnabled()</a> and <a class="el" href="classIBTK_1_1FEDataManager.html#aae3ded192467edb5d1767057a0356d28" title="Determine whether logging is enabled or disabled.">FEDataManager::getLoggingEnabled()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This is usually set by IBFEMethod, which reads the relevant boolean from the database. </dd></dl>

</div>
</div>
<a id="a04f0e07478c4a2890f12cbd223fb50e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f0e07478c4a2890f12cbd223fb50e8">&#9670;&nbsp;</a></span>d_hierarchy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a>&lt;NDIM&gt; &gt; IBTK::FEDataManager::d_hierarchy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Grid hierarchy information. </p>

</div>
</div>
<a id="a18a9d16906880a8fac5f22d3814776ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a9d16906880a8fac5f22d3814776ee">&#9670;&nbsp;</a></span>d_max_level_number</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::FEDataManager::d_max_level_number = <a class="el" href="namespaceIBTK.html#a426852ad282d4bb75fa436e05150870d">IBTK::invalid_level_number</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum possible level number in the patch hierarchy. </p>

</div>
</div>
<a id="aaf901fddc8f1ff70875f0dc624901145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf901fddc8f1ff70875f0dc624901145">&#9670;&nbsp;</a></span>d_eulerian_data_cache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classIBTK_1_1SAMRAIDataCache.html">SAMRAIDataCache</a>&gt; IBTK::FEDataManager::d_eulerian_data_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cached Eulerian data to reduce the number of allocations/deallocations. </p>

</div>
</div>
<a id="af2855ef88a50e0d541cb2af01db20fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2855ef88a50e0d541cb2af01db20fb1">&#9670;&nbsp;</a></span>d_context</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">SAMRAI::hier::VariableContext</a>&gt; IBTK::FEDataManager::d_context</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">SAMRAI::hier::VariableContext</a> object used for data management. </p>

</div>
</div>
<a id="ac739b5015590b7883de7f5b50b446bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac739b5015590b7883de7f5b50b446bf8">&#9670;&nbsp;</a></span>d_qp_count_var</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">SAMRAI::tbox::Pointer</a>&lt;<a class="el" href="classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable</a>&lt;NDIM, <a class="el" href="classdouble.html">double</a>&gt; &gt; IBTK::FEDataManager::d_qp_count_var</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a> pointer and patch data descriptor indices for the cell variable used to keep track of the count of the quadrature points in each cell. </p>

</div>
</div>
<a id="a41d29ec75435f0de5203520c7ceb1fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d29ec75435f0de5203520c7ceb1fef">&#9670;&nbsp;</a></span>d_qp_count_idx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> IBTK::FEDataManager::d_qp_count_idx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afdee82e550c721afd1a45ef828cfe78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdee82e550c721afd1a45ef828cfe78a">&#9670;&nbsp;</a></span>d_default_workload_spec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structIBTK_1_1FEDataManager_1_1WorkloadSpec.html">WorkloadSpec</a> IBTK::FEDataManager::d_default_workload_spec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default parameters used during workload calculations. </p>

</div>
</div>
<a id="ab68d1a92b645f65b9f923fef22ed28a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68d1a92b645f65b9f923fef22ed28a1">&#9670;&nbsp;</a></span>d_default_interp_spec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structIBTK_1_1FEDataManager_1_1InterpSpec.html">InterpSpec</a> IBTK::FEDataManager::d_default_interp_spec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default kernel functions and quadrature rule used to mediate Lagrangian-Eulerian interaction. </p>

</div>
</div>
<a id="aaf9fbe4842dfc614049ce7e4a5201015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9fbe4842dfc614049ce7e4a5201015">&#9670;&nbsp;</a></span>d_default_spread_spec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structIBTK_1_1FEDataManager_1_1SpreadSpec.html">SpreadSpec</a> IBTK::FEDataManager::d_default_spread_spec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a714ce1ada783d89b4e974fc9786d0355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714ce1ada783d89b4e974fc9786d0355">&#9670;&nbsp;</a></span>d_node_patch_check</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIBTK.html#a4f11b6d5086d88dfb13c1518bf8b6afd">NodeOutsidePatchCheckType</a> IBTK::FEDataManager::d_node_patch_check = <a class="el" href="namespaceIBTK.html#a4f11b6d5086d88dfb13c1518bf8b6afda3ac623c23d3170654eb95589df58b3d3">NODE_OUTSIDE_ERROR</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>after reassociating patches with elements a node may still lie outside all patches on the finest level in unusual circumstances (like when the parent integrator class does not regrid sufficiently frequently and has more than one patch level). This enum controls what we do when this problem is detected. </p>

</div>
</div>
<a id="ac75d28d4330d6295bc0775443aa83915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75d28d4330d6295bc0775443aa83915">&#9670;&nbsp;</a></span>d_ghost_width</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt;NDIM&gt; IBTK::FEDataManager::d_ghost_width</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a> object which determines the required ghost cell width of this class. </p>

</div>
</div>
<a id="a5af61a3c3d1a47310488126a1bc2b822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af61a3c3d1a47310488126a1bc2b822">&#9670;&nbsp;</a></span>d_associated_elem_ghost_width</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt;NDIM&gt; IBTK::FEDataManager::d_associated_elem_ghost_width = <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a>&lt;NDIM&gt;(1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a> object which determines how many ghost cells we should enlarge a patch by when associating an element with a patch. An element is associated with a patch when its bounding box (defined as the bounding box of both its nodes and quadrature points) intersects the bounding box (including ghost cells) of that patch.</p>
<dl class="section note"><dt>Note</dt><dd>At the present time this is always 1, which matches the assumption made by <a class="el" href="classIBTK_1_1LEInteractor.html#acbfd13d715d5873f3042e3e4ff5f3b30" title="Returns the minimum ghost width size corresponding to the specified kernel function.">IBTK::LEInteractor::getMinimumGhostWidth()</a>. </dd></dl>

</div>
</div>
<a id="ab8a9a1ad285cc9c0ac2dec03fb9d7598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a9a1ad285cc9c0ac2dec03fb9d7598">&#9670;&nbsp;</a></span>d_active_patch_elem_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;libMesh::Elem*&gt; &gt; &gt; IBTK::FEDataManager::d_active_patch_elem_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Data to manage mappings between mesh elements and grid patches. </p>

</div>
</div>
<a id="a3e60ee2ea02f09ef44bb679c7eea90ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e60ee2ea02f09ef44bb679c7eea90ba">&#9670;&nbsp;</a></span>d_active_patch_node_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;libMesh::Node*&gt; &gt; &gt; IBTK::FEDataManager::d_active_patch_node_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ec1274a43f69195addbe38edaff0614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec1274a43f69195addbe38edaff0614">&#9670;&nbsp;</a></span>d_active_patch_ghost_dofs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; &gt; IBTK::FEDataManager::d_active_patch_ghost_dofs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d238fa770ff7b304a423d0f9c4e77bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d238fa770ff7b304a423d0f9c4e77bb">&#9670;&nbsp;</a></span>d_active_elems</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;libMesh::Elem*&gt; IBTK::FEDataManager::d_active_elems</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a13fb3d692d682d10fa81120cc3b5b4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fb3d692d682d10fa81120cc3b5b4c1">&#9670;&nbsp;</a></span>d_system_ghost_vec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::unique_ptr&lt;<a class="el" href="classlibMesh_1_1NumericVector.html">libMesh::NumericVector</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; &gt; IBTK::FEDataManager::d_system_ghost_vec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ghost vectors for the various equation systems. </p>

</div>
</div>
<a id="a91fbdf05a7919c9e691a8936fb106c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91fbdf05a7919c9e691a8936fb106c1e">&#9670;&nbsp;</a></span>d_system_ib_ghost_vec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::unique_ptr&lt;<a class="el" href="classlibMesh_1_1PetscVector.html">libMesh::PetscVector</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; &gt; IBTK::FEDataManager::d_system_ib_ghost_vec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exemplar relevant IB-ghosted vectors for the various equation systems. These vectors are cloned for fast initialization in buildIBGhostedVector. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ibtk/include/ibtk/<a class="el" href="FEDataManager_8h.html">FEDataManager.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aIBTK__CHKERRQ_8h_html_a82134efd79614179ddc74839a56497ef"><div class="ttname"><a href="IBTK__CHKERRQ_8h.html#a82134efd79614179ddc74839a56497ef">IBTK_CHKERRQ</a></div><div class="ttdeci">#define IBTK_CHKERRQ(ierr)</div><div class="ttdoc">Throw an error exception from within any C++ source code.</div><div class="ttdef"><b>Definition:</b> IBTK_CHKERRQ.h:39</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
