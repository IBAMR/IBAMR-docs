<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: SAMRAI::solv::FACOperatorStrategy&lt; DIM &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IBAMR
   &#160;<span id="projectnumber">IBAMR version 0.19.</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a></li><li class="navelem"><a class="el" href="namespaceSAMRAI_1_1solv.html">solv</a></li><li class="navelem"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">FACOperatorStrategy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSAMRAI_1_1solv_1_1FACOperatorStrategy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SAMRAI::solv::FACOperatorStrategy&lt; DIM &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines a Strategy pattern interface to problem-specific operations needed to implement the FAC preconditioner algorithm.  
 <a href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#details">More...</a></p>

<p><code>#include &lt;FACOperatorStrategy.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SAMRAI::solv::FACOperatorStrategy&lt; DIM &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSAMRAI_1_1solv_1_1FACOperatorStrategy__inherit__graph.png" border="0" usemap="#SAMRAI_1_1solv_1_1FACOperatorStrategy_3_01DIM_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="SAMRAI_1_1solv_1_1FACOperatorStrategy_3_01DIM_01_4_inherit__map" id="SAMRAI_1_1solv_1_1FACOperatorStrategy_3_01DIM_01_4_inherit__map">
<area shape="rect" title="Defines a Strategy pattern interface to problem&#45;specific operations needed to implement the FAC preco..." alt="" coords="5,5,203,47"/>
<area shape="rect" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html" title="FAC operator class to solve Poisson&#39;s equation on a SAMR grid, using cell&#45;centered,..." alt="" coords="9,95,199,136"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab88bafba001f88a851800a2234fc0e59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#ab88bafba001f88a851800a2234fc0e59">FACOperatorStrategy</a> ()</td></tr>
<tr class="memdesc:ab88bafba001f88a851800a2234fc0e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#ab88bafba001f88a851800a2234fc0e59">More...</a><br /></td></tr>
<tr class="separator:ab88bafba001f88a851800a2234fc0e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf468cae6b2daea32bc80de5903ce12f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#aaf468cae6b2daea32bc80de5903ce12f">~FACOperatorStrategy</a> ()</td></tr>
<tr class="memdesc:aaf468cae6b2daea32bc80de5903ce12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <a href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#aaf468cae6b2daea32bc80de5903ce12f">More...</a><br /></td></tr>
<tr class="separator:aaf468cae6b2daea32bc80de5903ce12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operator-dependent virtual methods</div></td></tr>
<tr class="memitem:a9a693926b14d3b588307493207aafb2c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a9a693926b14d3b588307493207aafb2c">restrictSolution</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;source, <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;dest, <a class="el" href="classint.html">int</a> dest_ln)=0</td></tr>
<tr class="memdesc:a9a693926b14d3b588307493207aafb2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restrict the solution quantity to the specified level from the next finer level.  <a href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a9a693926b14d3b588307493207aafb2c">More...</a><br /></td></tr>
<tr class="separator:a9a693926b14d3b588307493207aafb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3cd141b3ae50a4d284d3a4d930fd20"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#acb3cd141b3ae50a4d284d3a4d930fd20">restrictResidual</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;source, <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;dest, <a class="el" href="classint.html">int</a> dest_ln)=0</td></tr>
<tr class="memdesc:acb3cd141b3ae50a4d284d3a4d930fd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restrict the residual quantity to the specified level from the next finer level.  <a href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#acb3cd141b3ae50a4d284d3a4d930fd20">More...</a><br /></td></tr>
<tr class="separator:acb3cd141b3ae50a4d284d3a4d930fd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d21ae6ca7ddd5c3c6b513c03bf2649"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#af2d21ae6ca7ddd5c3c6b513c03bf2649">prolongErrorAndCorrect</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;source, <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;dest, <a class="el" href="classint.html">int</a> dest_ln)=0</td></tr>
<tr class="memdesc:af2d21ae6ca7ddd5c3c6b513c03bf2649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prolong the error quantity to the specified level from the next coarser level and apply the correction to the fine-level error.  <a href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#af2d21ae6ca7ddd5c3c6b513c03bf2649">More...</a><br /></td></tr>
<tr class="separator:af2d21ae6ca7ddd5c3c6b513c03bf2649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2fc412e2e37d99ae2b02e0f0bd20f9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a1e2fc412e2e37d99ae2b02e0f0bd20f9">smoothError</a> (<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;error, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;residual, <a class="el" href="classint.html">int</a> ln, <a class="el" href="classint.html">int</a> num_sweeps)=0</td></tr>
<tr class="memdesc:a1e2fc412e2e37d99ae2b02e0f0bd20f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a given number of relaxations on the error.  <a href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a1e2fc412e2e37d99ae2b02e0f0bd20f9">More...</a><br /></td></tr>
<tr class="separator:a1e2fc412e2e37d99ae2b02e0f0bd20f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac769cd5e362eaac6a4fe98e72014a260"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#ac769cd5e362eaac6a4fe98e72014a260">solveCoarsestLevel</a> (<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;error, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;residual, <a class="el" href="classint.html">int</a> coarsest_ln)=0</td></tr>
<tr class="memdesc:ac769cd5e362eaac6a4fe98e72014a260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the residual equation Ae=r on the coarsest level in the FAC iteration.  <a href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#ac769cd5e362eaac6a4fe98e72014a260">More...</a><br /></td></tr>
<tr class="separator:ac769cd5e362eaac6a4fe98e72014a260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615a2a68de28d7ae77ce709d7bf4b631"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a615a2a68de28d7ae77ce709d7bf4b631">computeCompositeResidualOnLevel</a> (<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;residual, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;solution, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs, <a class="el" href="classint.html">int</a> ln, <a class="el" href="classbool.html">bool</a> error_equation_indicator)=0</td></tr>
<tr class="memdesc:a615a2a68de28d7ae77ce709d7bf4b631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute composite grid residual on a single level.  <a href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a615a2a68de28d7ae77ce709d7bf4b631">More...</a><br /></td></tr>
<tr class="separator:a615a2a68de28d7ae77ce709d7bf4b631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a4bda677f0de9e0b9f7a6541a18e88"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#ad1a4bda677f0de9e0b9f7a6541a18e88">computeResidualNorm</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;residual, <a class="el" href="classint.html">int</a> fine_ln, <a class="el" href="classint.html">int</a> coarse_ln)=0</td></tr>
<tr class="memdesc:ad1a4bda677f0de9e0b9f7a6541a18e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the norm of the residual quantity.  <a href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#ad1a4bda677f0de9e0b9f7a6541a18e88">More...</a><br /></td></tr>
<tr class="separator:ad1a4bda677f0de9e0b9f7a6541a18e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c701e0e792532b6478f516142fe0d84"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a4c701e0e792532b6478f516142fe0d84">postprocessOneCycle</a> (<a class="el" href="classint.html">int</a> fac_cycle_num, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;current_soln, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;residual)</td></tr>
<tr class="memdesc:a4c701e0e792532b6478f516142fe0d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regular call back routine to be called after each FAC cycle.  <a href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a4c701e0e792532b6478f516142fe0d84">More...</a><br /></td></tr>
<tr class="separator:a4c701e0e792532b6478f516142fe0d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a46505460b62f3ae6d555faf7c376a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a7a46505460b62f3ae6d555faf7c376a3">initializeOperatorState</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;solution, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7a46505460b62f3ae6d555faf7c376a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute hierarchy-dependent data if any is required.  <a href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a7a46505460b62f3ae6d555faf7c376a3">More...</a><br /></td></tr>
<tr class="separator:a7a46505460b62f3ae6d555faf7c376a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6318f8ea1644306a066a7da60d70c42a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a6318f8ea1644306a066a7da60d70c42a">deallocateOperatorState</a> ()</td></tr>
<tr class="memdesc:a6318f8ea1644306a066a7da60d70c42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all hierarchy-dependent data.  <a href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a6318f8ea1644306a066a7da60d70c42a">More...</a><br /></td></tr>
<tr class="separator:a6318f8ea1644306a066a7da60d70c42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int DIM&gt;<br />
class SAMRAI::solv::FACOperatorStrategy&lt; DIM &gt;</h3>

<p>The FACPreconditioner&lt;DIM&gt; constructor accepts a concrete implementation of this interface and calls the concrete implementations of the virtual functions declared herein during the solution process.</p>
<p>All vector arguments in these interfaces are guaranteed to be either the vectors given to in <a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html#ae6cd7471f9b86e58d39142fdf30cf9df" title="Solve linear system Au=f using the FAC algorithm.">FACPreconditioner&lt;DIM&gt;::solveSystem()</a> or <a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html#a2a654bc79116bfc761280022084224f7" title="Compute hierarchy-dependent data required for solving.">FACPreconditioner&lt;DIM&gt;::initializeSolverState()</a> or vectors cloned from them.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html" title="Implements the FAC iterative solution procedure for a linear system of equations, Au=f,...">solv::FACPreconditioner</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab88bafba001f88a851800a2234fc0e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88bafba001f88a851800a2234fc0e59">&#9670;&nbsp;</a></span>FACOperatorStrategy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">SAMRAI::solv::FACOperatorStrategy</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">FACOperatorStrategy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf468cae6b2daea32bc80de5903ce12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf468cae6b2daea32bc80de5903ce12f">&#9670;&nbsp;</a></span>~FACOperatorStrategy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">SAMRAI::solv::FACOperatorStrategy</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">FACOperatorStrategy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9a693926b14d3b588307493207aafb2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a693926b14d3b588307493207aafb2c">&#9670;&nbsp;</a></span>restrictSolution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">SAMRAI::solv::FACOperatorStrategy</a>&lt; DIM &gt;::restrictSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dest_ln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Restrict the residual data to level dest_ln in the destination vector d, from level dest_ln+1 in the source vector s.</p>
<p>Can assume:</p><ol type="1">
<li>dest_ln is not the finest level in the range being solved.</li>
<li>corresponding solution has been computed on level dest_ln+1.</li>
<li>the source and destination residual vectors (s and d) may or may not be the same. (This function must work in either case.)</li>
</ol>
<p>Upon return from this function, the solution on the refined region of the coarse level will represent the coarsened version of the fine solution in a manner that is consistent with the linear system approximation on the composite grid. This function must not change the solution values anywhere except on level dest_ln of the destination vector.</p>
<p>The source and destination vectors may be the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>source solution </td></tr>
    <tr><td class="paramname">dest</td><td>destination solution </td></tr>
    <tr><td class="paramname">dest_ln</td><td>destination level number </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a265429acc287fc24a8135f7dd0076121">SAMRAI::solv::CellPoissonFACOps&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="acb3cd141b3ae50a4d284d3a4d930fd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3cd141b3ae50a4d284d3a4d930fd20">&#9670;&nbsp;</a></span>restrictResidual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">SAMRAI::solv::FACOperatorStrategy</a>&lt; DIM &gt;::restrictResidual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dest_ln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Restrict the residual data to level dest_ln in the destination vector d, from level dest_ln+1 in the source vector s.</p>
<p>Can assume:</p><ol type="1">
<li>dest_ln is not the finest level in the range being solved.</li>
<li>correspnding residual has been computed on level dest_ln+1.</li>
<li>the source and destination residual vectors (s and d) may or may not be the same. (This function must work in either case.)</li>
</ol>
<p>Upon return from this function, the residual on the refined region of the coarse level will represent the coarsened version of the fine residual in a manner that is consistent with the linear system approximation on the composite grid. This function must not change the residual values anywhere except on level dest_ln of the destination vector.</p>
<p>The source and destination vectors may be the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>source residual </td></tr>
    <tr><td class="paramname">dest</td><td>destination residual </td></tr>
    <tr><td class="paramname">dest_ln</td><td>destination level number </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a8fdd0853006f8c50c87dbdb73842579b">SAMRAI::solv::CellPoissonFACOps&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="af2d21ae6ca7ddd5c3c6b513c03bf2649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d21ae6ca7ddd5c3c6b513c03bf2649">&#9670;&nbsp;</a></span>prolongErrorAndCorrect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">SAMRAI::solv::FACOperatorStrategy</a>&lt; DIM &gt;::prolongErrorAndCorrect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dest_ln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>On the part of the coarse level that does <em>not</em> overlap the fine level, the error is the corection to Au=f.</p>
<p>On the part of the coarse level that <em>does</em> overlap the fine level, the error is the corection to Ae=r of the fine level.</p>
<p>This function should apply the coarse-level correction to the fine level, that is </p><p class="formulaDsp">
\[ e^{fine} \leftarrow e^{fine} + I^{fine}_{coarse} e^{coarse} \]
</p>
<p><b>Note:</b> You probably have to store the refined error in a temporary location before adding it to the current error.</p>
<p>The array of boundary information contains a description of the coarse-fine level boundary for each patch on the level; the boundary information for patch N is obtained as the N-th element in the array, coarse_fine_boundary[N].</p>
<p>Upon return from this function, the error on the fine level must represent the correction to the solution on that level. Also, this function must not change the error values on the coarse level.</p>
<p>The source and destination vectors may be the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>source error vector </td></tr>
    <tr><td class="paramname">dest</td><td>destination error vector </td></tr>
    <tr><td class="paramname">dest_ln</td><td>destination level number of data transfer </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#aba40028b1cd0926f97a445d46d534f90">SAMRAI::solv::CellPoissonFACOps&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="a1e2fc412e2e37d99ae2b02e0f0bd20f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2fc412e2e37d99ae2b02e0f0bd20f9">&#9670;&nbsp;</a></span>smoothError()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">SAMRAI::solv::FACOperatorStrategy</a>&lt; DIM &gt;::smoothError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_sweeps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Relax the residual equation Ae=r by applying the given number of smoothing sweeps on the specified level. The relaxation may ignore the possible existence of finer levels on a given level.</p>
<p>The array of boundary information contains a description of the coarse-fine level boundary for each patch on the level; the boundary information for patch N is obtained as the N-th element in the array, coarse_fine_boundary[N].</p>
<p>May assume:</p><ul>
<li>If intermediate data from level l+1 is needed (for example, to match flux at coarse-fine boundaries), that data is already computed and stored on level l+1.</li>
<li>The error in the next finer level has been computed and stored there.</li>
</ul>
<p>Steps for each iteration.</p><ol type="1">
<li>Fill ghost boundaries</li>
<li>Compute intermediate data (if needed) and coarsen intermediate data stored in level l+1 (if needed).</li>
<li>Perform relaxation step (update e toward a better approximation).</li>
</ol>
<p>Final step before leaving function.</p><ul>
<li>If needed, compute and store intermediate data for next coarser level l-1.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error vector </td></tr>
    <tr><td class="paramname">residual</td><td>residual vector </td></tr>
    <tr><td class="paramname">ln</td><td>level number </td></tr>
    <tr><td class="paramname">num_sweeps</td><td>number of sweeps </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a7f333444aef74da8c596d57f8901b4b4">SAMRAI::solv::CellPoissonFACOps&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="ac769cd5e362eaac6a4fe98e72014a260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac769cd5e362eaac6a4fe98e72014a260">&#9670;&nbsp;</a></span>solveCoarsestLevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classint.html">int</a> <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">SAMRAI::solv::FACOperatorStrategy</a>&lt; DIM &gt;::solveCoarsestLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarsest_ln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Here e is the given error quantity and r is the given residual quantity. The array of boundary information contains a description of the coarse-fine level boundary for each patch on the level; the boundary information for patch N is obtained as the N-th element in the array, coarse_fine_boundary[N].</p>
<p>This routine must fill boundary values for given solution quantity on all patches on the specified level before the solve is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error vector </td></tr>
    <tr><td class="paramname">residual</td><td>residual vector </td></tr>
    <tr><td class="paramname">coarsest_ln</td><td>coarsest level number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if solver converged to specified level, nonzero otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a6b224cec9c295a44c1ff2ca3a1866f29">SAMRAI::solv::CellPoissonFACOps&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="a615a2a68de28d7ae77ce709d7bf4b631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615a2a68de28d7ae77ce709d7bf4b631">&#9670;&nbsp;</a></span>computeCompositeResidualOnLevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">SAMRAI::solv::FACOperatorStrategy</a>&lt; DIM &gt;::computeCompositeResidualOnLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>error_equation_indicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For the specified level number ln, compute the <em>composite</em> residual r=f-Au, where f is the right hand side and u is the solution. Note that the composite residual is not a one-level residual. It must take into account the composite grid stencil around the coarse-fine grid interface.</p>
<p>May assume:</p><ul>
<li>Composite residual on next finer level l+1, has been computed already.</li>
<li>If any intermediately computed data is needed from level l+1, it has been done and stored on that level.</li>
<li>Residual computations for the original equation and the error equations will not be intermingled within one FAC cycle.</li>
</ul>
<p>Steps:</p><ol type="1">
<li>Fill boundary ghosts.</li>
<li>If needed, coarsen intermediate data from level l+1.</li>
<li>Compute residual \( r^l \leftarrow f - A u^l \).</li>
</ol>
<p>Final step before leaving function:</p><ul>
<li>If any intermediately computed data is needed in at level l-1, it must be computed and stored before leaving this function.</li>
</ul>
<p><b>Important:</b> Do not restrict residual from finer levels. (However, you must write the function <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#acb3cd141b3ae50a4d284d3a4d930fd20" title="Restrict the residual quantity to the specified level from the next finer level.">restrictResidual()</a> to do this.)</p>
<p><b>Important:</b> This function must also work when the right-hand-side and the residual are identical. In that case, it should effectively do \( r \leftarrow r - A u \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">residual</td><td>residual vector </td></tr>
    <tr><td class="paramname">solution</td><td>solution vector </td></tr>
    <tr><td class="paramname">rhs</td><td>source (right hand side) vector </td></tr>
    <tr><td class="paramname">ln</td><td>level number </td></tr>
    <tr><td class="paramname">error_equation_indicator</td><td>flag stating whether u is an error vector or a solution vector </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a09c3fb06ac1324187775f642fd3f9c63">SAMRAI::solv::CellPoissonFACOps&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="ad1a4bda677f0de9e0b9f7a6541a18e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a4bda677f0de9e0b9f7a6541a18e88">&#9670;&nbsp;</a></span>computeResidualNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">SAMRAI::solv::FACOperatorStrategy</a>&lt; DIM &gt;::computeResidualNorm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fine_ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarse_ln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute norm of the given residual on the given range of hierarchy levels. The residual vector is computed already and you should <b>not</b> change it. The only purpose of this function to allow you to choose how to define the norm.</p>
<p>The norm value is used during the FAC iteration to determine convergence of the composite grid linear system.</p>
<p>Residual values that lie under a finer level should not be counted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">residual</td><td>residual vector </td></tr>
    <tr><td class="paramname">fine_ln</td><td>finest level number </td></tr>
    <tr><td class="paramname">coarse_ln</td><td>coarsest level number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>norm value of residual vector, which should be non-negative </dd></dl>

<p>Implemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a3f35e8674ece1b10097455168ed0b19a">SAMRAI::solv::CellPoissonFACOps&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="a4c701e0e792532b6478f516142fe0d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c701e0e792532b6478f516142fe0d84">&#9670;&nbsp;</a></span>postprocessOneCycle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">SAMRAI::solv::FACOperatorStrategy</a>&lt; DIM &gt;::postprocessOneCycle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fac_cycle_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>current_soln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>residual</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is called after each FAC cycle. It allows you to monitor the progress and do other things. You should <em>not</em> modify the solution vector in the argument.</p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fac_cycle_num</td><td>FAC cycle number completed </td></tr>
    <tr><td class="paramname">current_soln</td><td>current solution </td></tr>
    <tr><td class="paramname">residual</td><td>residual based on the current solution </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a120a641cb4d0981a5c6a211d3b3f2155">SAMRAI::solv::CellPoissonFACOps&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="a7a46505460b62f3ae6d555faf7c376a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a46505460b62f3ae6d555faf7c376a3">&#9670;&nbsp;</a></span>initializeOperatorState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">SAMRAI::solv::FACOperatorStrategy</a>&lt; DIM &gt;::initializeOperatorState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is called when the hierarchy configuration changes. If you maintain any hierarchy-dependent data in your implementation (for example, caching communication schedules or computing coarse-fine boundaries), use this function to update that data.</p>
<p>If you do not maintain such data, this function may be empty.</p>
<p>Note that although the vector arguments given to other methods in this class may not necessarily be the same as those given to this method, there will be similarities, including:</p><ul>
<li>hierarchy configuration (hierarchy pointer and level range)</li>
<li>number, type and alignment of vector component data</li>
<li>ghost cell width of data in the solution (or solution-like) vector</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solution</td><td>solution vector u </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side vector f</td></tr>
  </table>
  </dd>
</dl>
<p>The default implementation does nothing. </p>

<p>Reimplemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#afc4d66aeb631bb797948bc2c8ec57f44">SAMRAI::solv::CellPoissonFACOps&lt; DIM &gt;</a>.</p>

</div>
</div>
<a id="a6318f8ea1644306a066a7da60d70c42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6318f8ea1644306a066a7da60d70c42a">&#9670;&nbsp;</a></span>deallocateOperatorState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">SAMRAI::solv::FACOperatorStrategy</a>&lt; DIM &gt;::deallocateOperatorState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove all hierarchy-dependent data set by <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a7a46505460b62f3ae6d555faf7c376a3" title="Compute hierarchy-dependent data if any is required.">initializeOperatorState()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a7a46505460b62f3ae6d555faf7c376a3" title="Compute hierarchy-dependent data if any is required.">initializeOperatorState</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a795ffc5da164c902a666c4bade66a163">SAMRAI::solv::CellPoissonFACOps&lt; DIM &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/samrai/include/<a class="el" href="FACOperatorStrategy_8h.html">FACOperatorStrategy.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
