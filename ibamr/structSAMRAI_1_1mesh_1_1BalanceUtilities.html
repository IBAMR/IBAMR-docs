<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IBAMR: SAMRAI::mesh::BalanceUtilities&lt; DIM &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IBAMR
   &#160;<span id="projectnumber">IBAMR version 0.19.</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a></li><li class="navelem"><a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a></li><li class="navelem"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">BalanceUtilities</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="structSAMRAI_1_1mesh_1_1BalanceUtilities-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SAMRAI::mesh::BalanceUtilities&lt; DIM &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utility class BalanceUtilities&lt;DIM&gt; provides several functions useful in various load balancing operations. These utilities include bin packing operations, box chopping by recursive bisection, and computation of effective processor layouts for boxes.  
</p>

<p><code>#include &lt;BalanceUtilities.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acd87a90095e02f80fd49c96a46056e90"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#acd87a90095e02f80fd49c96a46056e90">binPack</a> (<a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;mapping, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;weights, <a class="el" href="classint.html">int</a> nproc)</td></tr>
<tr class="separator:acd87a90095e02f80fd49c96a46056e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aafda5a7552b667afcee8afcc43e148"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#a3aafda5a7552b667afcee8afcc43e148">spatialBinPack</a> (<a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;mapping, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;weights, <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;boxes, const <a class="el" href="classint.html">int</a> nproc)</td></tr>
<tr class="separator:a3aafda5a7552b667afcee8afcc43e148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd21d94ac80f5cede4207d31c946e926"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#acd21d94ac80f5cede4207d31c946e926">recursiveBisectionUniform</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;out_boxes, <a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;out_workloads, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;in_boxes, <a class="el" href="classdouble.html">double</a> ideal_workload, const <a class="el" href="classdouble.html">double</a> workload_tolerance, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;cut_factor, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;bad_interval, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;physical_domain)</td></tr>
<tr class="separator:acd21d94ac80f5cede4207d31c946e926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96740b53dc8a710fe2f4b42bf5e231de"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#a96740b53dc8a710fe2f4b42bf5e231de">recursiveBisectionNonuniform</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;out_boxes, <a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;out_workloads, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; &amp;in_level, <a class="el" href="classint.html">int</a> work_id, <a class="el" href="classdouble.html">double</a> ideal_workload, const <a class="el" href="classdouble.html">double</a> workload_tolerance, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;cut_factor, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;bad_interval, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;physical_domain)</td></tr>
<tr class="separator:a96740b53dc8a710fe2f4b42bf5e231de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2157fbef149222719f5df9606ee0f6f0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#a2157fbef149222719f5df9606ee0f6f0">computeDomainDependentProcessorLayout</a> (<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;proc_dist, <a class="el" href="classint.html">int</a> num_procs, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box)</td></tr>
<tr class="separator:a2157fbef149222719f5df9606ee0f6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d06047689cdc4e9d38784ba114b7509"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#a5d06047689cdc4e9d38784ba114b7509">computeDomainIndependentProcessorLayout</a> (<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;proc_dist, <a class="el" href="classint.html">int</a> num_procs, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box)</td></tr>
<tr class="separator:a5d06047689cdc4e9d38784ba114b7509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca69ed1a7a421499edc2ecb3ce12ed9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#a2ca69ed1a7a421499edc2ecb3ce12ed9">sortDescendingBoxWorkloads</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;boxes, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;workload)</td></tr>
<tr class="separator:a2ca69ed1a7a421499edc2ecb3ce12ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36e104fc7e2fbeb113ff46c36e0a289"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#af36e104fc7e2fbeb113ff46c36e0a289">computeNonUniformWorkload</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &gt; patch, <a class="el" href="classint.html">int</a> wrk_indx, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box)</td></tr>
<tr class="separator:af36e104fc7e2fbeb113ff46c36e0a289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f75cdfafda16e28b1649936a9d5a43"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#ad5f75cdfafda16e28b1649936a9d5a43">computeLoadBalanceEfficiency</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; &amp;level, std::ostream &amp;os, <a class="el" href="classint.html">int</a> workload_data_id=-1)</td></tr>
<tr class="separator:ad5f75cdfafda16e28b1649936a9d5a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:af04a6cd6bdabb60df9b02f836b3ce2ab"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#af04a6cd6bdabb60df9b02f836b3ce2ab">privateHeapify</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;permutation, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;workload, const <a class="el" href="classint.html">int</a> index, const <a class="el" href="classint.html">int</a> heap_size)</td></tr>
<tr class="separator:af04a6cd6bdabb60df9b02f836b3ce2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6231874f9be8b55baa2ca4de011613d2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#a6231874f9be8b55baa2ca4de011613d2">privateHeapify</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;permutation, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1SpatialKey.html">SpatialKey</a> &gt; &amp;spatial_keys, const <a class="el" href="classint.html">int</a> index, const <a class="el" href="classint.html">int</a> heap_size)</td></tr>
<tr class="separator:a6231874f9be8b55baa2ca4de011613d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2577f09092e04651c3ba833a27cdb9b4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#a2577f09092e04651c3ba833a27cdb9b4">privateRecursiveProcAssign</a> (const <a class="el" href="classint.html">int</a> wt_index_lo, const <a class="el" href="classint.html">int</a> wt_index_hi, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;weights, const <a class="el" href="classint.html">int</a> proc_index_lo, const <a class="el" href="classint.html">int</a> proc_index_hi, <a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;mapping, const <a class="el" href="classdouble.html">double</a> avg_weight)</td></tr>
<tr class="separator:a2577f09092e04651c3ba833a27cdb9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddc5d41b41e3fba150189fa25cd2572"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#a4ddc5d41b41e3fba150189fa25cd2572">privatePrimeFactorization</a> (const <a class="el" href="classint.html">int</a> N, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;p)</td></tr>
<tr class="separator:a4ddc5d41b41e3fba150189fa25cd2572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cf7d9abba07a787faaccb86edaedb2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#ac1cf7d9abba07a787faaccb86edaedb2">privateResetPrimesArray</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;p)</td></tr>
<tr class="separator:ac1cf7d9abba07a787faaccb86edaedb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f57c5759b0de85fb56869c054bb6937"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#a1f57c5759b0de85fb56869c054bb6937">privateBadCutPointsExist</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;physical_domain)</td></tr>
<tr class="separator:a1f57c5759b0de85fb56869c054bb6937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd50d8dd3be68297ccdb897aefd694e7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#abd50d8dd3be68297ccdb897aefd694e7">privateInitializeBadCutPointsForBox</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;bad_cut_points, <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box, <a class="el" href="classbool.html">bool</a> bad_domain_boundaries_exist, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;bad_interval, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;physical_domain)</td></tr>
<tr class="separator:abd50d8dd3be68297ccdb897aefd694e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4919f8ea607fd644376deef9e70f095"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#ae4919f8ea607fd644376deef9e70f095">privateFindBestCutDimension</a> (<a class="el" href="classint.html">int</a> &amp;cut_dim_out, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;in_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;cut_factor, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;bad_cut_points)</td></tr>
<tr class="separator:ae4919f8ea607fd644376deef9e70f095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1630eeb3852395b0f85a9a5ebc7212"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#a0e1630eeb3852395b0f85a9a5ebc7212">privateFindCutPoint</a> (<a class="el" href="classdouble.html">double</a> total_work, <a class="el" href="classdouble.html">double</a> ideal_workload, <a class="el" href="classint.html">int</a> mincut, <a class="el" href="classint.html">int</a> numcells, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;work_in_slice, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;bad_cut_points)</td></tr>
<tr class="separator:a0e1630eeb3852395b0f85a9a5ebc7212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34a4c425a3fbbc5c9e51e4ae16138dc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#af34a4c425a3fbbc5c9e51e4ae16138dc">privateCutBoxesAndSetBadCutPoints</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box_lo, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;bad_cut_points_for_boxlo, <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;box_hi, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;bad_cut_points_for_boxhi, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;in_box, <a class="el" href="classint.html">int</a> cutdim, <a class="el" href="classint.html">int</a> cut_index, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;bad_cut_points)</td></tr>
<tr class="separator:af34a4c425a3fbbc5c9e51e4ae16138dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcc4de97d334637e665497b22168fe0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#aedcc4de97d334637e665497b22168fe0">privateRecursiveBisectionUniformSingleBox</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;out_boxes, <a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;out_workloads, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;in_box, <a class="el" href="classdouble.html">double</a> in_box_workload, <a class="el" href="classdouble.html">double</a> ideal_workload, const <a class="el" href="classdouble.html">double</a> workload_tolerance, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;cut_factor, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;bad_cut_points)</td></tr>
<tr class="separator:aedcc4de97d334637e665497b22168fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50a7deac5a0974d89dfd80b86c766b2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#ad50a7deac5a0974d89dfd80b86c766b2">privateRecursiveBisectionNonuniformSingleBox</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;out_boxes, <a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;out_workloads, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &gt; &amp;patch, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;in_box, <a class="el" href="classdouble.html">double</a> in_box_workload, <a class="el" href="classint.html">int</a> work_data_index, <a class="el" href="classdouble.html">double</a> ideal_workload, const <a class="el" href="classdouble.html">double</a> workload_tolerance, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;cut_factor, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;bad_cut_points)</td></tr>
<tr class="separator:ad50a7deac5a0974d89dfd80b86c766b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a6eddbdc4225a7d15c5700f33f5a5c821"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSAMRAI_1_1math_1_1PatchCellDataNormOpsReal.html">math::PatchCellDataNormOpsReal</a>&lt; DIM, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#a6eddbdc4225a7d15c5700f33f5a5c821">s_norm_ops</a></td></tr>
<tr class="separator:a6eddbdc4225a7d15c5700f33f5a5c821"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acd87a90095e02f80fd49c96a46056e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd87a90095e02f80fd49c96a46056e90">&#9670;&nbsp;</a></span>binPack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdouble.html">double</a> <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::binPack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>nproc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign workloads to processors using a greedy algorithm that attempts to distribute the sum of weights on each processor evenly across the given number of processors.</p>
<dl class="section return"><dt>Returns</dt><dd>double-valued estimate of the load balance efficiency (ranges from zero to one hundred percent)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapping</td><td>Output processor mapping. </td></tr>
    <tr><td class="paramname">weights</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of double-valued weights to distribute. </td></tr>
    <tr><td class="paramname">nproc</td><td>Integer number of processors, must be &gt; 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3aafda5a7552b667afcee8afcc43e148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aafda5a7552b667afcee8afcc43e148">&#9670;&nbsp;</a></span>spatialBinPack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdouble.html">double</a> <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::spatialBinPack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>nproc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign boxes to processors so that boxes spatially near each other are likely to be assigned to processors near each other (assuming that processor ordering is reflected in processor rank) and so that the workload is approximately evenly distributed among the processors. The routine uses a Morton space-filling curve algorithm.</p>
<p>Note that this routine potentially reorders the boxes passed in to achieve the first goal.</p>
<dl class="section return"><dt>Returns</dt><dd>Double-valued estimate of the load balance efficiency (ranges from zero to one hundred percent)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapping</td><td>Output processor mapping. </td></tr>
    <tr><td class="paramname">weights</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of double-valued box weights to distribute. </td></tr>
    <tr><td class="paramname">boxes</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of boxes to distribute to processors. </td></tr>
    <tr><td class="paramname">nproc</td><td>Integer number of processors, must be &gt; 0.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the wight and box arrrays must be the same size. </p>

</div>
</div>
<a id="acd21d94ac80f5cede4207d31c946e926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd21d94ac80f5cede4207d31c946e926">&#9670;&nbsp;</a></span>recursiveBisectionUniform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::recursiveBisectionUniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_workloads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>ideal_workload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>workload_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>bad_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>physical_domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursively chop chops boxes in input boxlist until each box has a workload less than the prescribed ideal workload or no more more chopping is allowed by the given constraints. A spatially-uniform workload is assumed; i.e., all cells are weighted equally. This routine attempts to create as many boxes as possible with loads equal to or slightly less than the ideal workload value so that they can be mapped to processors effectively. <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_boxes</td><td>Output box list. </td></tr>
    <tr><td class="paramname">out_workloads</td><td>Output list of box workloads. </td></tr>
    <tr><td class="paramname">in_boxes</td><td>Input boxlist for chopping. </td></tr>
    <tr><td class="paramname">ideal_workload</td><td>Input double ideal box workload, must be &gt; 0. </td></tr>
    <tr><td class="paramname">workload_tolerance</td><td>Input double workload tolerance, must be &gt;= 0 and &lt; 1.0 </td></tr>
    <tr><td class="paramname">min_size</td><td>Input integer vector of minimum dimensions for output boxes. All entries must be &gt; 0. </td></tr>
    <tr><td class="paramname">cut_factor</td><td>Input integer vector used to create boxes with correct dimensions. The length of each box dimension will be an integer multiple of the corresponding cut factor vector entry. All vector entries must be &gt; 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td class="paramname">bad_interval</td><td>Input integer vector used to create boxes near physical domain boundary with sufficient number of cells. No box face will be closer to the boundary than the corresponding interval of cells to the boundary (the corresponding value is given by the normal direction of the box face) unless the face coincides with the boundary itself. The point of this argument is to have no patch live within a certain ghost cell width of the boundary if its boundary does not coincide with that boundary . That is, all ghost cells along a face will be either in the domain interior or outside the domain. All entries must be &gt;= 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td class="paramname">physical_domain</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of boxes describing the physical extent of the index space associated with the in_boxes. This box array cannot be empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96740b53dc8a710fe2f4b42bf5e231de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96740b53dc8a710fe2f4b42bf5e231de">&#9670;&nbsp;</a></span>recursiveBisectionNonuniform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::recursiveBisectionNonuniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_workloads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>work_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>ideal_workload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>workload_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>bad_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>physical_domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursively chops boxes given by patches on input patch level until each box has a workload less than the prescribed ideal workload or no more more chopping is allowed by the given constraints. A spatially-nonuniform workload is assumed. Cell weights must be given bydata defined by the given patch data id on the given patch level. This routine attempts to create as many boxes as possible with loads equal to or slightly less than the ideal workload value so that they can be mapped to processors effectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_boxes</td><td>Output box list. </td></tr>
    <tr><td class="paramname">out_workloads</td><td>Output list of box workloads. </td></tr>
    <tr><td class="paramname">in_level</td><td>Input patch level whose patches describe input box regions and whose patch data contain workload estimate for each cell. </td></tr>
    <tr><td class="paramname">work_id</td><td>Input integer patch data id for cell-centered double work estimate for each cell. </td></tr>
    <tr><td class="paramname">ideal_workload</td><td>Input double ideal box workload, must be &gt; 0. </td></tr>
    <tr><td class="paramname">workload_tolerance</td><td>Input double workload tolerance, must be &gt;= 0 and &lt; 1.0 </td></tr>
    <tr><td class="paramname">min_size</td><td>Input integer vector of minimum dimensions for output boxes. All entries must be &gt; 0. </td></tr>
    <tr><td class="paramname">cut_factor</td><td>Input integer vector used to create boxes with correct dimensions. The length of each box dimension will be an integer multiple of the corresponding cut factor vector entry. All vector entries must be &gt; 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td class="paramname">bad_interval</td><td>Input integer vector used to create boxes near physical domain boundary with sufficient number of cells. No box face will be closer to the boundary than the corresponding interval of cells to the boundary (the corresponding value is given by the normal direction of the box face) unless the face coincides with the boundary itself. The point of this argument is to have no patch live within a certain ghost cell width of the boundary if its boundary does not coincide with that boundary . That is, all ghost cells along a face will be either in the domain interior or outside the domain. All entries must be &gt;= 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td class="paramname">physical_domain</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of boxes describing the physical extent of the index space associated with the in_boxes. This box array cannot be empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2157fbef149222719f5df9606ee0f6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2157fbef149222719f5df9606ee0f6f0">&#9670;&nbsp;</a></span>computeDomainDependentProcessorLayout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::computeDomainDependentProcessorLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>proc_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_procs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute factorization of processors corresponding to dimensions of given box.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc_dist</td><td>Output number of processors for each coordinate direction. </td></tr>
    <tr><td class="paramname">num_procs</td><td>Input integer number of processors, must be &gt; 0. </td></tr>
    <tr><td class="paramname">box</td><td>Input box to be distributed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d06047689cdc4e9d38784ba114b7509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d06047689cdc4e9d38784ba114b7509">&#9670;&nbsp;</a></span>computeDomainIndependentProcessorLayout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::computeDomainIndependentProcessorLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>proc_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_procs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute a factorization of processors that does NOT necessarily correspond to the dimensions of the supplied box. For example, the processor distribution in each direction may simply be a square root (cube root in 3D) of the number of processors. The box information is used simply to determine a maximum number of processors in each coordinate direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc_dist</td><td>Output number of processors for each coordinate direction. </td></tr>
    <tr><td class="paramname">num_procs</td><td>Input integer number of processors, must be &gt; 0. </td></tr>
    <tr><td class="paramname">box</td><td>Input box to be distributed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ca69ed1a7a421499edc2ecb3ce12ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca69ed1a7a421499edc2ecb3ce12ed9">&#9670;&nbsp;</a></span>sortDescendingBoxWorkloads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::sortDescendingBoxWorkloads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>workload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sort box array in descending order of workload according to the workload array. Both the box array and the work array will be sorted on return. <br  />
</p>
<p>Note that if you simply want to sort boxes based on their size, see <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxes</td><td>Boxes to be sorted based on workload array. </td></tr>
    <tr><td class="paramname">workload</td><td>Workloads to use for sorting boxes.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that both arrays must be the same size. </p>

</div>
</div>
<a id="af36e104fc7e2fbeb113ff46c36e0a289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36e104fc7e2fbeb113ff46c36e0a289">&#9670;&nbsp;</a></span>computeNonUniformWorkload()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdouble.html">double</a> <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::computeNonUniformWorkload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &gt;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>wrk_indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute total workload in region of argument box based on patch data defined by given integer index. The sum is computed on the intersection of argument box and box over which data associated with workload is defined.</p>
<dl class="section return"><dt>Returns</dt><dd>Double-valued sum of workload values in box region.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>Input patch on which workload data is defined. </td></tr>
    <tr><td class="paramname">wrk_indx</td><td>Input integer patch data identifier for work data. </td></tr>
    <tr><td class="paramname">box</td><td>Input box region</td></tr>
  </table>
  </dd>
</dl>
<p>Note that wrk_indx must refer to a valid cell-centered patch data entry. </p>

</div>
</div>
<a id="ad5f75cdfafda16e28b1649936a9d5a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f75cdfafda16e28b1649936a9d5a43">&#9670;&nbsp;</a></span>computeLoadBalanceEfficiency()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdouble.html">double</a> <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::computeLoadBalanceEfficiency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>workload_data_id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute and return load balance efficiency for a level. <br  />
</p>
<dl class="section return"><dt>Returns</dt><dd>Double-valued estimate of the load balance efficiency (ranges from zero to one hundred percent)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Input patch level to consider, can't be null. </td></tr>
    <tr><td class="paramname">os</td><td>Output stream for reporting load balance details. </td></tr>
    <tr><td class="paramname">workload_data_id</td><td>(Optional) Input integer id for workload data on level. If no value is given, the calculation assumes spatially-uniform load. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af04a6cd6bdabb60df9b02f836b3ce2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04a6cd6bdabb60df9b02f836b3ce2ab">&#9670;&nbsp;</a></span>privateHeapify() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::privateHeapify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>workload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>heap_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6231874f9be8b55baa2ca4de011613d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6231874f9be8b55baa2ca4de011613d2">&#9670;&nbsp;</a></span>privateHeapify() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::privateHeapify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1SpatialKey.html">SpatialKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>heap_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2577f09092e04651c3ba833a27cdb9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2577f09092e04651c3ba833a27cdb9b4">&#9670;&nbsp;</a></span>privateRecursiveProcAssign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::privateRecursiveProcAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>wt_index_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>wt_index_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>proc_index_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>proc_index_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>avg_weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ddc5d41b41e3fba150189fa25cd2572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddc5d41b41e3fba150189fa25cd2572">&#9670;&nbsp;</a></span>privatePrimeFactorization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::privatePrimeFactorization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1cf7d9abba07a787faaccb86edaedb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cf7d9abba07a787faaccb86edaedb2">&#9670;&nbsp;</a></span>privateResetPrimesArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::privateResetPrimesArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f57c5759b0de85fb56869c054bb6937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f57c5759b0de85fb56869c054bb6937">&#9670;&nbsp;</a></span>privateBadCutPointsExist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::privateBadCutPointsExist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>physical_domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd50d8dd3be68297ccdb897aefd694e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd50d8dd3be68297ccdb897aefd694e7">&#9670;&nbsp;</a></span>privateInitializeBadCutPointsForBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::privateInitializeBadCutPointsForBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bad_cut_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>bad_domain_boundaries_exist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>bad_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxArray.html">hier::BoxArray</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>physical_domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4919f8ea607fd644376deef9e70f095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4919f8ea607fd644376deef9e70f095">&#9670;&nbsp;</a></span>privateFindBestCutDimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::privateFindBestCutDimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>cut_dim_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bad_cut_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e1630eeb3852395b0f85a9a5ebc7212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1630eeb3852395b0f85a9a5ebc7212">&#9670;&nbsp;</a></span>privateFindCutPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classint.html">int</a> <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::privateFindCutPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>total_work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>ideal_workload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>mincut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>numcells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>work_in_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bad_cut_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af34a4c425a3fbbc5c9e51e4ae16138dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34a4c425a3fbbc5c9e51e4ae16138dc">&#9670;&nbsp;</a></span>privateCutBoxesAndSetBadCutPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::privateCutBoxesAndSetBadCutPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>box_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bad_cut_points_for_boxlo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>box_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bad_cut_points_for_boxhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cutdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cut_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bad_cut_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aedcc4de97d334637e665497b22168fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcc4de97d334637e665497b22168fe0">&#9670;&nbsp;</a></span>privateRecursiveBisectionUniformSingleBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::privateRecursiveBisectionUniformSingleBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_workloads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>in_box_workload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>ideal_workload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>workload_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bad_cut_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad50a7deac5a0974d89dfd80b86c766b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50a7deac5a0974d89dfd80b86c766b2">&#9670;&nbsp;</a></span>privateRecursiveBisectionNonuniformSingleBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::privateRecursiveBisectionNonuniformSingleBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxList.html">hier::BoxList</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_workloads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>in_box_workload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>work_data_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>ideal_workload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>workload_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bad_cut_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6eddbdc4225a7d15c5700f33f5a5c821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eddbdc4225a7d15c5700f33f5a5c821">&#9670;&nbsp;</a></span>s_norm_ops</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1math_1_1PatchCellDataNormOpsReal.html">math::PatchCellDataNormOpsReal</a>&lt;DIM,<a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a>&lt; DIM &gt;::s_norm_ops</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/samrai/include/<a class="el" href="BalanceUtilities_8h.html">BalanceUtilities.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
